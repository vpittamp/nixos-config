Directory structure:
└── cli/
    ├── _data.json
    ├── _prompt_select.ts
    ├── _run_length.ts
    ├── _run_length_test.ts
    ├── _types.ts
    ├── _unit.ts
    ├── deno.json
    ├── mod.ts
    ├── parse_args.ts
    ├── parse_args_test.ts
    ├── prompt_secret.ts
    ├── prompt_secret_test.ts
    ├── unicode_width.ts
    ├── unicode_width_test.ts
    ├── unstable_ansi.ts
    ├── unstable_progress_bar.ts
    ├── unstable_progress_bar_stream.ts
    ├── unstable_progress_bar_stream_test.ts
    ├── unstable_progress_bar_test.ts
    ├── unstable_prompt_multiple_select.ts
    ├── unstable_prompt_multiple_select_test.ts
    ├── unstable_prompt_select.ts
    ├── unstable_prompt_select_test.ts
    ├── unstable_spinner.ts
    ├── unstable_spinner_test.ts
    ├── _tools/
    │   ├── compare_with_rust.ts
    │   └── generate_data.ts
    └── testdata/
        └── unicode_width_crate/
            ├── Cargo.toml
            └── src/
                └── lib.rs

================================================
FILE: cli/_data.json
================================================
{
  "UNICODE_VERSION": "15.0.0",
  "tables": [
    {
      "d": "AAECAwQFBgcICQoLDA0OAw8DDwkQCRESERIA",
      "r": "AQEBAgEBAQEBAQEBAQEBBwEHAVABBwcBBwF4"
    },
    {
      "d": "AAECAwQFBgcGCAYJCgsMDQ4PEAYREhMUBhUWFxgZGhscHR4fICEiIyIkJSYnKCkqJSssLS4vMDEyMzQ1Njc4OToGOzwKBj0GPj9AQUIGQwZEBkVGR0hJSktMTQZOBgoGT1BRUlNUVVZXWFkGWgZbBlxdXl1fYGFiY2RlZmdoBmlqBmsGAQZsBm1uO29wcXI7czt0dXZ3OwY7eHkGent8Bn0Gfn+AgYKDhIWGBoc7iAZdO4kGiosGAXGMBo0GjgaPBpAGkQaSBpMGlJUGlpcGmJmam5ydnp+gLgahLKIGo6SlpganqKmqqwasBq0Grq8GsLGyswa0BrUGtre4Brm6uwZHvAa9vga/wME7wjvDxAbFO8bHO8gGyQbKywbMzQbOBs/Q0QbSBr8GvgbT1AbUBtUG1gbXBtjZ2tsG3N0G3t/g4eLjO+Tl5ufoO+k76gbrBuztOwbu7/AGO+XxCgYKCwZd8g==",
      "r": "AQEBAQEBAQEBAQEBAQEBAQEBAQMBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECBQEOAQEBAQEBAQEBAwEBAQEBAQEBAQIBAwEIAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBDQEBBQEBAQEBAgEBAwEBAQEBAQEBAQEBbQHaAQEFAQEBBAECAQEBAQEBAQEBAwGuASFkCAELAQEBAQEBAQEHAQMBAQEaAQIBCAEFAQEBAQEBAQEBAQEBAQEBAQEBAQECAQEBAQIBAQEBAQEBAwEDAQEBAQEBAQUBAQEBAQEBBAEBAVIBAdkBARABAQFfARMBAYoBBAEBBQEmAUkBAQcBAQIBHgEBARUBAQEBAQUBAQcBDwEBARoBAgEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQMBBAEBAgEBAQEUfwEBAQIDAXj/AQ=="
    },
    {
      "d": "AFUVAF3Xd3X/93//VXVVV9VX9V91f1/31X93XVXdVdVV9dVV/VVX1X9X/131VfXVVXV3V1VdVV1V1/1dV1X/3VUAVf3/3/9fVf3/3/9fVV1V/11VFQBQVQEAEEEQVQBQVQBAVFUVAFVUVQUAEAAUBFBVFVFVAEBVBQBUVRUAVVFVBRAAAVBVAVVQVQBVBQBAVUVUAQBUUQEAVQVVUVVUAVRVUVUFVUVBVVRBFRRQUVVQUVUBEFRRVQVVBQBRVRQBVFVRVUFVBVVFVVRVUVVUVQRUBQRQVUFVBVVFVVBVBVVQVRVUAVRVUVUFVVFVRVUFRFVRAEBVFQBAVVEAVFUAQFVQVRFRVQEAQAAEVQEAAQBUVUVVAQQAQVVQBVRVAVRVRUFVUVVRVaoAVQFVBVRVBVUFVQVVEABQVUUBAFVRVRUAVUFVUVVAFVRVRVUBVRUUVUUAQEQBAFQVABRVAEBVAFUEQFRFVRUAVVBVBVAQUFVFUBFQVQAFVUAABABUUVVUUFUVANd/X3//BUD3XdV1VQAEAFVXVdX9V1VXVQBUVdVdVdV1VX111VXVV9V//1X/X1VdVf9fVV9VdVdV1VX31dfVXXX9193/d1X/VV9VV3VVX//1VfVVXVVdVdVVdVWlVWlVqVaWVf/f/1X/Vf/1X1Xf/19V9VVf9df1X1X1X1XVVWlVfV31VVpVd1V3VapV33/fVZVVlVX1WVWlVelV+v/v//7/31Xv/6/77/tVWaVVVlVdVWaVmlX1/1WpVVZVlVWVVlVW+V9VFVBVAKqaqlWqWlWqVaoKoKpqqapqgapVqaqpqmqqVapqqv+qVqpqVRVAAFBVBVVQVUUVVUFVVFVQVQBQVRVVBQBQVRUAUFWqVkBVFQVQVVFVAUBBVRVVVFVUVQQUVAVRVVBVRVVRVFFVqlVFVQCqWlUAqmqqaqpVqlZVqmpVAV1VUVVUVQVAVQFBVQBVQBVVQVUAVRVUVQFVBQBUVQVQVVFVAEBVFFRVFVBVFUBBUUVVUVVAVRUAAQBUVRVVUFUFAEBVARRVFVAEVUVVFQBAVVRVBQBUAFRVAAVEVUVVFQBEFQRVBVBVEFRVUFUVAEARVFUVUQAQVQEFEABVFQBBVRVEFVUABVVUVQEAQFUVABRAVRVVAUABVQUAQFBVAEAAEFUFAAUABEFVAUBFEAAQVVARVRVUVVBVBUBVRFVUFQBQVQBUVQBAVRVVFUBVqlRVWlWqVapaVapWVaqpqmmqalVlVWpZVapVqlVBAFUAUABAVRVQVRUAQAEAVQVQVQVUVQBAFQBUVVFVVFUVAAEAVQBAABQAEARAVUVVAFUAQFUAQFVWVZVV/39V/1//X1X/76uq6v9XVWpVqlWqVlVaVapaVapWVamqmqqmqlWqapWqVapWqmqmqpaqWlWVaqpVZVVpVVZVlapVqlpVVmqpVapVlVZVqlZVqlVWVapqqpqqVapWqlZVqpqqWlWlqlWqVlWqVlVRVQD/Xw==",
      "r": "CBcBCAEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQMBAQECAQEBAQEBAQEBAQEBBAEBGAEDAQwBAwEIAQEBAQEBAQgcCAEDAQEBAQEDAQEBDQEDEAELAQEBEQEKAQEBDgEBAgIBAQoBBQQBCAEBAQEBAQEHAQEHBgEWAQIBDQECAgEFAQECAgEKAQ0BAQIKAQ0BDQEBAQEBAQEBAgEHAQ4BAQEBAQQBBgEBDgEBAQEBAQcBAQIBAQEBBAEFAQEBDgEBAQEBAQECAQcBDwECAQwCDQEBAQEBAQECAQgBAQEEAQcBDQEBAQEBAQQBBwERAQEBARYBAQECAQEBGAECAQIBARIBBgEBDQECAQEBAQECAQgBAQEZAQEBAgYBAQEDAQECAQEBAQMBCBgIBwEMAQEGAQcBBwEQAQEBAQEBAgIBCgEBDQEIAQ0BAQEBAQEBBgEBDgEBAQEBAQEBAgEMBwEMAQwBAQEBCQECAwEHAQEBAQ0BAQEBDgIBBgEDAQEBAQEBAQMBAQEBAgEBAQEBAQEBCAEBAgEBAQEBAQkBCAgBAwECAQEBAgEBAQkBAQEBAwECAQMBAQIBBwEFAQEDAQYBAQEBAgEBAQEBAQEBAQECAgEDAQECBAIDAgIBBQEEAQEBAwEPAQEBCyIBCAEJAwQBAQIBAQEBAgECAQEBAQMBAQEBAwEBAQEBAQEBAQgBAQMDAgEBAwEEAQIBAQEBBAEBAQEBAQECAQEBAQEBAQEBAQEHAQQBAwEBAQcBAgUBBgECAQYBAQwBAQEUAQELCAYBFgMFAQYDAQoBAQMBARQBAQkBAQoBBgEVAwsBCgIPAQ0BGQEBAgEHARQBAwIBBgEBAQUBBgQBAgEJAQEBBQECAQMHAQELAQECCQEQAQECAgECAQsBDAEBAQEBCgEBAQsBAQEECQ4BCAQCAQEECAEEAQEFCAEPAQEEAQEPAQgBFAEBAQEBAQEKAQEJAQ8BEAEBEwEBAQIBCwEBDgENAwEKAQEBAQELAQEBAQECAQwBCAEBAQEBDgEDAQwBAQECAQEXAQEBAQEHAgEBBQEIAQEBAQEQAgEBBQEUAQEBAQEbAQEBAQEGARQBAQEBARkBAQEBCQEBAQEQAQIBDwEBARQBAQEBBwEBAQkBAQEBAQECAQEBCwECAQEVAQEBAQQBBQEBAQEOAQEBAQEBEgEBFgEBAgEMAQEBAQ8BAQMBFgEBDgEBBQEPAQETAQECAQMOAgUBCgIBGQEBAQEIAQMBBwEBAwECEwgBAQcLAQUBFwEBAQEDAQEBBwEBBAEBDg0BAQwBAQEDAQQBAQEDBAEBBAEBAQEBEAEPAQgBAQsBAQ4BEQEMAgEBBwEOAQEHAQEBAQQBBAEDCwECAQEBAwEBBggBAgEBAREBBQMKAQEBAwQCEQEBHgEPAQIBAQYEAQYBAwEUAQUMAQEBAQEBAQECAQEBAgEIAwEBBgsBAgEODAMBAgEBCwEBAQEBAwECAQECAQEBBwgPAQ=="
    }
  ]
}



================================================
FILE: cli/_prompt_select.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import type { PromptEntry } from "./unstable_prompt_select.ts";

const SAFE_PADDING = 4;

const MORE_CONTENT_BEFORE_INDICATOR = "...";
const MORE_CONTENT_AFTER_INDICATOR = "...";

const encoder = new TextEncoder();
const decoder = new TextDecoder();

const CLEAR_ALL = encoder.encode("\x1b[J"); // Clear all lines after cursor
const HIDE_CURSOR = encoder.encode("\x1b[?25l");
const SHOW_CURSOR = encoder.encode("\x1b[?25h");

/**
 * @param message The prompt message to show to the user.
 * @param indicator The string to indicate the selected item.
 * @param values The values for the prompt.
 * @param clear Whether to clear the lines after the user's input.
 * @param visibleLinesInit The initial number of lines to be visible at once.
 * @param valueChange A function that is called when the value changes.
 * @param handleInput A function that handles the input from the user. If it returns false, the prompt will continue. If it returns true, the prompt will exit with clean ups of terminal state (Use this for finalizing the selection). If it returns "return", the prompt will exit immediately without clean ups of terminal state (Use this for exiting the program).
 */
export function handlePromptSelect<V>(
  message: string,
  indicator: string,
  values: PromptEntry<V>[],
  clear: boolean | undefined,
  visibleLinesInit: number | undefined,
  valueChange: (active: boolean, absoluteIndex: number) => string | void,
  handleInput: (str: string, absoluteIndex: number | undefined, actions: {
    etx(): "return";
    up(): void;
    down(): void;
    remove(): void;
    inputStr(): void;
  }) => boolean | "return",
) {
  const input = Deno.stdin;
  const output = Deno.stdout;
  const indexedValues = values.map((value, absoluteIndex) => ({
    value,
    absoluteIndex,
  }));
  let clearLength = indexedValues.length + 1;

  const PADDING = " ".repeat(indicator.length);
  const ARROW_PADDING = " ".repeat(indicator.length + 1);

  // Deno.consoleSize().rows - 3 because we need to output the message, the up arrow, the terminal line and the down arrow
  let visibleLines = visibleLinesInit ?? Math.min(
    Deno.consoleSize().rows - SAFE_PADDING,
    values.length,
  );

  let activeIndex = 0;
  let offset = 0;
  let searchBuffer = "";
  const buffer = new Uint8Array(4);

  input.setRaw(true);
  output.writeSync(HIDE_CURSOR);

  while (true) {
    output.writeSync(
      encoder.encode(
        `${message + (searchBuffer ? ` (filter: ${searchBuffer})` : "")}\r\n`,
      ),
    );
    const filteredChunks = indexedValues.filter((item) => {
      if (searchBuffer === "") {
        return true;
      } else {
        return (typeof item.value === "string" ? item.value : item.value.label)
          .toLowerCase().includes(searchBuffer.toLowerCase());
      }
    });
    const visibleChunks = filteredChunks.slice(offset, visibleLines + offset);
    const length = visibleChunks.length;

    const hasUpArrow = offset !== 0;
    const hasDownArrow = (length + offset) < filteredChunks.length;

    if (hasUpArrow) {
      output.writeSync(
        encoder.encode(`${ARROW_PADDING}${MORE_CONTENT_BEFORE_INDICATOR}\r\n`),
      );
    }

    for (
      const [
        index,
        {
          absoluteIndex,
          value,
        },
      ] of visibleChunks.entries()
    ) {
      const active = index === (activeIndex - offset);
      const start = active ? indicator : PADDING;
      const maybePrefix = valueChange(active, absoluteIndex);
      output.writeSync(
        encoder.encode(
          `${start}${maybePrefix ? ` ${maybePrefix}` : ""} ${
            typeof value === "string" ? value : value.label
          }\r\n`,
        ),
      );
    }

    if (hasDownArrow) {
      output.writeSync(
        encoder.encode(`${ARROW_PADDING}${MORE_CONTENT_AFTER_INDICATOR}\r\n`),
      );
    }
    const n = input.readSync(buffer);
    if (n === null || n === 0) break;
    const string = decoder.decode(buffer.slice(0, n));

    const processedInput = handleInput(
      string,
      filteredChunks[activeIndex]?.absoluteIndex,
      {
        etx: () => {
          output.writeSync(SHOW_CURSOR);
          Deno.exit(0);
          return "return";
        },
        up: () => {
          if (activeIndex === 0) {
            activeIndex = filteredChunks.length - 1;
            offset = Math.max(filteredChunks.length - visibleLines, 0);
          } else {
            activeIndex--;
            offset = Math.max(offset - 1, 0);
          }
        },
        down: () => {
          if (activeIndex === (filteredChunks.length - 1)) {
            activeIndex = 0;
            offset = 0;
          } else {
            activeIndex++;

            if (activeIndex >= visibleLines) {
              offset++;
            }
          }
        },
        remove: () => {
          activeIndex = 0;
          searchBuffer = searchBuffer.slice(0, -1);
        },
        inputStr: () => {
          activeIndex = 0;
          searchBuffer += string;
        },
      },
    );

    if (processedInput === "return") {
      return;
    } else if (processedInput) {
      break;
    }

    visibleLines = Math.min(
      Deno.consoleSize().rows - SAFE_PADDING,
      visibleLines,
    );

    clearLength = 1 + // message
      (hasUpArrow ? 1 : 0) +
      length +
      (hasDownArrow ? 1 : 0);

    output.writeSync(encoder.encode(`\x1b[${clearLength}A`));
    output.writeSync(CLEAR_ALL);
  }

  if (clear) {
    output.writeSync(encoder.encode(`\x1b[${clearLength}A`));
    output.writeSync(CLEAR_ALL);
  }

  output.writeSync(SHOW_CURSOR);
  input.setRaw(false);
}



================================================
FILE: cli/_run_length.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

export function runLengthEncode(arr: number[]) {
  const data: number[] = [];
  const runLengths: number[] = [];

  let prev: symbol | number = Symbol("none");

  for (const x of arr) {
    if (x === prev) {
      ++runLengths[runLengths.length - 1]!;
    } else {
      prev = x;
      data.push(x);
      runLengths.push(1);
    }
  }

  for (const r of runLengths) {
    if (r >= 0x100) {
      throw new Error(`Run length too long: ${r}`);
    }
  }

  return {
    d: btoa(String.fromCharCode(...data)),
    r: btoa(String.fromCharCode(...runLengths)),
  };
}

export function runLengthDecode({ d, r }: { d: string; r: string }) {
  const data = atob(d);
  const runLengths = atob(r);
  let out = "";

  for (const [i, ch] of [...runLengths].entries()) {
    out += data[i]!.repeat(ch.codePointAt(0)!);
  }

  return Uint8Array.from([...out].map((x) => x.codePointAt(0)!));
}



================================================
FILE: cli/_run_length_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { runLengthDecode, runLengthEncode } from "./_run_length.ts";
import { assertEquals, assertThrows } from "@std/assert";

const runLengthTestCases: {
  list: number[];
  compressed: { d: string; r: string };
  testName: string;
}[] = [
  {
    list: [1, 2, 3, 4, 5],
    compressed: { d: "AQIDBAU=", r: "AQEBAQE=" },
    testName: "return expected value if input is normal value",
  },
  {
    list: [1, 1, 1, 1],
    compressed: { d: "AQ==", r: "BA==" },
    testName: "return expected value if input includes an continuous value",
  },
  {
    list: [],
    compressed: { d: "", r: "" },
    testName: "return expected value if input is empty",
  },
];

Deno.test("runLengthEncode()", async (t) => {
  for (const { list, compressed, testName } of runLengthTestCases) {
    await t.step(`runLengthEncode() ${testName}`, () => {
      const encoded = runLengthEncode(list);
      assertEquals(encoded, compressed);
    });
  }

  await t.step(
    `runLengthEncode() throw an error if input is an array containing more than 256 numbers`,
    () => {
      assertThrows(() => runLengthEncode([1, 2, 3, 256]));
    },
  );

  await t.step(
    `runLengthEncode() throw an error if the input is an array longer than 256`,
    () => {
      assertThrows(() =>
        runLengthEncode([...Array.from({ length: 256 }, () => 0)])
      );
    },
  );
});

Deno.test("runLengthDecode()", async (t) => {
  for (const { list, compressed, testName } of runLengthTestCases) {
    await t.step(`runLengthDecode() ${testName}`, () => {
      const decoded = runLengthDecode(compressed);
      assertEquals(decoded, new Uint8Array(list));
    });
  }

  await t.step(`runLengthDecode() throw an error if input is wrong`, () => {
    assertThrows(() => runLengthDecode({ d: "wrong", r: "wrong" }));
  });
});



================================================
FILE: cli/_types.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

/**
 * Proxy type of {@code Uint8Array<ArrayBuffer>} or {@code Uint8Array} in TypeScript 5.7 or below respectively.
 *
 * This type is internal utility type and should not be used directly.
 *
 * @internal @private
 */

export type Uint8Array_ = ReturnType<Uint8Array["slice"]>;



================================================
FILE: cli/_unit.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

type Unit =
  | "KiB"
  | "MiB"
  | "GiB"
  | "TiB"
  | "PiB"
  | "EiB"
  | "ZiB"
  | "YiB";

const UNIT_RATE_MAP = new Map<Unit, number>([
  ["KiB", 2 ** 10],
  ["MiB", 2 ** 20],
  ["GiB", 2 ** 30],
  ["TiB", 2 ** 40],
  ["PiB", 2 ** 50],
  ["EiB", 2 ** 60],
  ["ZiB", 2 ** 70],
  ["YiB", 2 ** 80],
]);

function getUnitEntry(max: number): [Unit, number] {
  let result: [Unit, number] = ["KiB", 2 ** 10];
  for (const entry of UNIT_RATE_MAP) {
    if (entry[1] > max) break;
    result = entry;
  }
  return result;
}

export function formatUnitFraction(value: number, max: number) {
  const [unit, rate] = getUnitEntry(max);
  const currentValue = (value / rate).toFixed(2);
  const maxValue = (max / rate).toFixed(2);
  return `${currentValue}/${maxValue} ${unit}`;
}



================================================
FILE: cli/deno.json
================================================
{
  "name": "@std/cli",
  "version": "1.0.23",
  "exports": {
    ".": "./mod.ts",
    "./parse-args": "./parse_args.ts",
    "./prompt-secret": "./prompt_secret.ts",
    "./unstable-ansi": "./unstable_ansi.ts",
    "./unstable-progress-bar": "./unstable_progress_bar.ts",
    "./unstable-progress-bar-stream": "./unstable_progress_bar_stream.ts",
    "./unstable-prompt-select": "./unstable_prompt_select.ts",
    "./unstable-prompt-multiple-select": "./unstable_prompt_multiple_select.ts",
    "./unstable-spinner": "./unstable_spinner.ts",
    "./unicode-width": "./unicode_width.ts"
  }
}



================================================
FILE: cli/mod.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

/**
 * Tools for creating interactive command line tools.
 *
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert";
 *
 * // Same as running `deno run example.ts --foo --bar=baz ./quux.txt`
 * const args = parseArgs(["--foo", "--bar=baz", "./quux.txt"]);
 * assertEquals(args, { foo: true, bar: "baz", _: ["./quux.txt"] });
 * ```
 *
 * @module
 */

export * from "./parse_args.ts";
export * from "./prompt_secret.ts";
export * from "./unicode_width.ts";



================================================
FILE: cli/parse_args.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.
// This module is browser compatible.

/**
 * Command line arguments parser based on
 * {@link https://github.com/minimistjs/minimist | minimist}.
 *
 * See {@linkcode parseArgs} for more information.
 *
 * @example Usage
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * // For proper use, one should use `parseArgs(Deno.args)`
 * assertEquals(parseArgs(["--foo", "--bar=baz", "./quux.txt"]), {
 *   foo: true,
 *   bar: "baz",
 *   _: ["./quux.txt"],
 * });
 * ```
 *
 * @example `string` and `boolean` options
 *
 * Use `string` and `boolean` options to specify the type of the argument.
 *
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * const args = parseArgs(["--foo", "--bar", "baz"], {
 *   boolean: ["foo"],
 *   string: ["bar"],
 * });
 *
 * assertEquals(args, { foo: true, bar: "baz", _: [] });
 * ```
 *
 * @example `collect` option
 *
 * `collect` option tells the parser to treat the option as an array. All
 * values will be collected into one array. If a non-collectable option is used
 * multiple times, the last value is used.
 *
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * const args = parseArgs(["--foo", "bar", "--foo", "baz"], {
 *  collect: ["foo"],
 * });
 *
 * assertEquals(args, { foo: ["bar", "baz"], _: [] });
 * ```
 *
 * @example `negatable` option
 *
 * `negatable` option tells the parser to treat the option can be negated by
 * prefixing them with `--no-`, like `--no-config`.
 *
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * const args = parseArgs(["--no-foo"], {
 *   boolean: ["foo"],
 *   negatable: ["foo"],
 * });
 *
 * assertEquals(args, { foo: false, _: [] });
 * ```
 *
 * @module
 */

/** Combines recursively all intersection types and returns a new single type.
 * @internal
 */
type Id<TRecord> = TRecord extends Record<string, unknown>
  ? TRecord extends infer InferredRecord
    ? { [Key in keyof InferredRecord]: Id<InferredRecord[Key]> }
  : never
  : TRecord;

/** Converts a union type `A | B | C` into an intersection type `A & B & C`.
 * @internal
 */
type UnionToIntersection<TValue> =
  (TValue extends unknown ? (args: TValue) => unknown : never) extends
    (args: infer R) => unknown ? R extends Record<string, unknown> ? R : never
    : never;

/** @internal */
type BooleanType = boolean | string | undefined;
/** @internal */
type StringType = string | undefined;
/** @internal */
type ArgType = StringType | BooleanType;

/** @internal */
type Collectable = string | undefined;
/** @internal */
type Negatable = string | undefined;

type UseTypes<
  TBooleans extends BooleanType,
  TStrings extends StringType,
  TCollectable extends Collectable,
> = undefined extends (
  & (false extends TBooleans ? undefined : TBooleans)
  & TCollectable
  & TStrings
) ? false
  : true;

/**
 * Creates a record with all available flags with the corresponding type and
 * default type.
 * @internal
 */
type Values<
  TBooleans extends BooleanType,
  TStrings extends StringType,
  TCollectable extends Collectable,
  TNegatable extends Negatable,
  TDefault extends Record<string, unknown> | undefined,
  TAliases extends Aliases | undefined,
> = UseTypes<TBooleans, TStrings, TCollectable> extends true ?
    & Record<string, unknown>
    & AddAliases<
      SpreadDefaults<
        & CollectValues<TStrings, string, TCollectable, TNegatable>
        & RecursiveRequired<CollectValues<TBooleans, boolean, TCollectable>>
        & CollectUnknownValues<
          TBooleans,
          TStrings,
          TCollectable,
          TNegatable
        >,
        DedotRecord<TDefault>
      >,
      TAliases
    >
  // deno-lint-ignore no-explicit-any
  : Record<string, any>;

/** @internal */
type Aliases<TArgNames = string, TAliasNames extends string = string> = Partial<
  Record<Extract<TArgNames, string>, TAliasNames | ReadonlyArray<TAliasNames>>
>;

type AddAliases<
  TArgs,
  TAliases extends Aliases | undefined,
> = {
  [TArgName in keyof TArgs as AliasNames<TArgName, TAliases>]: TArgs[TArgName];
};

type AliasNames<
  TArgName,
  TAliases extends Aliases | undefined,
> = TArgName extends keyof TAliases
  ? string extends TAliases[TArgName] ? TArgName
  : TAliases[TArgName] extends string ? TArgName | TAliases[TArgName]
  : TAliases[TArgName] extends Array<string>
    ? TArgName | TAliases[TArgName][number]
  : TArgName
  : TArgName;

/**
 * Spreads all default values of Record `TDefaults` into Record `TArgs`
 * and makes default values required.
 *
 * **Example:**
 * `SpreadValues<{ foo?: boolean, bar?: number }, { foo: number }>`
 *
 * **Result:** `{ foo: boolean | number, bar?: number }`
 */
type SpreadDefaults<TArgs, TDefaults> = TDefaults extends undefined ? TArgs
  : TArgs extends Record<string, unknown> ?
      & Omit<TArgs, keyof TDefaults>
      & {
        [Default in keyof TDefaults]: Default extends keyof TArgs
          ? (TArgs[Default] & TDefaults[Default] | TDefaults[Default]) extends
            Record<string, unknown>
            ? NonNullable<SpreadDefaults<TArgs[Default], TDefaults[Default]>>
          : TDefaults[Default] | NonNullable<TArgs[Default]>
          : unknown;
      }
  : never;

/**
 * Defines the Record for the `default` option to add
 * auto-suggestion support for IDE's.
 * @internal
 */
type Defaults<TBooleans extends BooleanType, TStrings extends StringType> = Id<
  UnionToIntersection<
    & Record<string, unknown>
    // Dedotted auto suggestions: { foo: { bar: unknown } }
    & MapTypes<TStrings, unknown>
    & MapTypes<TBooleans, unknown>
    // Flat auto suggestions: { "foo.bar": unknown }
    & MapDefaults<TBooleans>
    & MapDefaults<TStrings>
  >
>;

type MapDefaults<TArgNames extends ArgType> = Partial<
  Record<TArgNames extends string ? TArgNames : string, unknown>
>;

type RecursiveRequired<TRecord> = TRecord extends Record<string, unknown> ? {
    [Key in keyof TRecord]-?: RecursiveRequired<TRecord[Key]>;
  }
  : TRecord;

/** Same as `MapTypes` but also supports collectable options. */
type CollectValues<
  TArgNames extends ArgType,
  TType,
  TCollectable extends Collectable,
  TNegatable extends Negatable = undefined,
> = UnionToIntersection<
  Extract<TArgNames, TCollectable> extends string ?
      & (Exclude<TArgNames, TCollectable> extends never ? Record<never, never>
        : MapTypes<Exclude<TArgNames, TCollectable>, TType, TNegatable>)
      & (Extract<TArgNames, TCollectable> extends never ? Record<never, never>
        : RecursiveRequired<
          MapTypes<Extract<TArgNames, TCollectable>, Array<TType>, TNegatable>
        >)
    : MapTypes<TArgNames, TType, TNegatable>
>;

/** Same as `Record` but also supports dotted and negatable options. */
type MapTypes<
  TArgNames extends ArgType,
  TType,
  TNegatable extends Negatable = undefined,
> = undefined extends TArgNames ? Record<never, never>
  : TArgNames extends `${infer Name}.${infer Rest}` ? {
      [Key in Name]?: MapTypes<
        Rest,
        TType,
        TNegatable extends `${Name}.${infer Negate}` ? Negate : undefined
      >;
    }
  : TArgNames extends string ? Partial<
      Record<TArgNames, TNegatable extends TArgNames ? TType | false : TType>
    >
  : Record<never, never>;

type CollectUnknownValues<
  TBooleans extends BooleanType,
  TStrings extends StringType,
  TCollectable extends Collectable,
  TNegatable extends Negatable,
> = UnionToIntersection<
  TCollectable extends TBooleans & TStrings ? Record<never, never>
    : DedotRecord<
      // Unknown collectable & non-negatable args.
      & Record<
        Exclude<
          Extract<Exclude<TCollectable, TNegatable>, string>,
          Extract<TStrings | TBooleans, string>
        >,
        Array<unknown>
      >
      // Unknown collectable & negatable args.
      & Record<
        Exclude<
          Extract<Extract<TCollectable, TNegatable>, string>,
          Extract<TStrings | TBooleans, string>
        >,
        Array<unknown> | false
      >
    >
>;

/** Converts `{ "foo.bar.baz": unknown }` into `{ foo: { bar: { baz: unknown } } }`. */
type DedotRecord<TRecord> = Record<string, unknown> extends TRecord ? TRecord
  : TRecord extends Record<string, unknown> ? UnionToIntersection<
      ValueOf<
        {
          [Key in keyof TRecord]: Key extends string ? Dedot<Key, TRecord[Key]>
            : never;
        }
      >
    >
  : TRecord;

type Dedot<TKey extends string, TValue> = TKey extends
  `${infer Name}.${infer Rest}` ? { [Key in Name]: Dedot<Rest, TValue> }
  : { [Key in TKey]: TValue };

type ValueOf<TValue> = TValue[keyof TValue];

/** The value returned from {@linkcode parseArgs}. */
export type Args<
  // deno-lint-ignore no-explicit-any
  TArgs extends Record<string, unknown> = Record<string, any>,
  TDoubleDash extends boolean | undefined = undefined,
> = Id<
  & TArgs
  & {
    /** Contains all the arguments that didn't have an option associated with
     * them. */
    _: Array<string | number>;
  }
  & (boolean extends TDoubleDash ? DoubleDash
    : true extends TDoubleDash ? Required<DoubleDash>
    : Record<never, never>)
>;

/** @internal */
type DoubleDash = {
  /** Contains all the arguments that appear after the double dash: "--". */
  "--"?: Array<string>;
};

/** Options for {@linkcode parseArgs}. */
export interface ParseOptions<
  TBooleans extends BooleanType = BooleanType,
  TStrings extends StringType = StringType,
  TCollectable extends Collectable = Collectable,
  TNegatable extends Negatable = Negatable,
  TDefault extends Record<string, unknown> | undefined =
    | Record<string, unknown>
    | undefined,
  TAliases extends Aliases | undefined = Aliases | undefined,
  TDoubleDash extends boolean | undefined = boolean | undefined,
> {
  /**
   * When `true`, populate the result `_` with everything before the `--` and
   * the result `['--']` with everything after the `--`.
   *
   * @default {false}
   *
   * @example Double dash option is false
   * ```ts
   * // $ deno run example.ts -- a arg1
   * import { parseArgs } from "@std/cli/parse-args";
   * const args = parseArgs(Deno.args, { "--": false }); // args equals { _: [ "a", "arg1" ] }
   * ```
   *
   * @example Double dash option is true
   * ```ts
   * // $ deno run example.ts -- a arg1
   * import { parseArgs } from "@std/cli/parse-args";
   * const args = parseArgs(Deno.args, { "--": true }); // args equals { _: [], --: [ "a", "arg1" ] }
   * ```
   */
  "--"?: TDoubleDash;

  /**
   * An object mapping string names to strings or arrays of string argument
   * names to use as aliases.
   *
   * @default {{}}
   */
  alias?: TAliases;

  /**
   * A boolean, string or array of strings to always treat as booleans. If
   * `true` will treat all double hyphenated arguments without equal signs as
   * `boolean` (e.g. affects `--foo`, not `-f` or `--foo=bar`).
   *  All `boolean` arguments will be set to `false` by default.
   *
   * @default {false}
   */
  boolean?: TBooleans | ReadonlyArray<Extract<TBooleans, string>>;

  /**
   * An object mapping string argument names to default values.
   *
   * @default {{}}
   */
  default?: TDefault & Defaults<TBooleans, TStrings>;

  /**
   * When `true`, populate the result `_` with everything after the first
   * non-option.
   *
   * @default {false}
   */
  stopEarly?: boolean;

  /**
   * A string or array of strings argument names to always treat as strings.
   *
   * @default {[]}
   */
  string?: TStrings | ReadonlyArray<Extract<TStrings, string>>;

  /**
   * A string or array of strings argument names to always treat as arrays.
   * Collectable options can be used multiple times. All values will be
   * collected into one array. If a non-collectable option is used multiple
   * times, the last value is used.
   *
   * @default {[]}
   */
  collect?: TCollectable | ReadonlyArray<Extract<TCollectable, string>>;

  /**
   * A string or array of strings argument names which can be negated
   * by prefixing them with `--no-`, like `--no-config`.
   *
   * @default {[]}
   */
  negatable?: TNegatable | ReadonlyArray<Extract<TNegatable, string>>;

  /**
   * A function which is invoked with a command line parameter not defined in
   * the `options` configuration object. If the function returns `false`, the
   * unknown option is not added to `parsedArgs`.
   *
   * @default {unknown}
   */
  unknown?: (arg: string, key?: string, value?: unknown) => unknown;
}

interface NestedMapping {
  [key: string]: NestedMapping | unknown;
}

const FLAG_REGEXP =
  /^(?:-(?:(?<doubleDash>-)(?<negated>no-)?)?)(?<key>.+?)(?:=(?<value>.+?))?$/s;
const LETTER_REGEXP = /[A-Za-z]/;
const NUMBER_REGEXP = /-?\d+(\.\d*)?(e-?\d+)?$/;
const HYPHEN_REGEXP = /^(-|--)[^-]/;
const VALUE_REGEXP = /=(?<value>.+)/;
const FLAG_NAME_REGEXP = /^--[^=]+$/;
const SPECIAL_CHAR_REGEXP = /\W/;

const NON_WHITESPACE_REGEXP = /\S/;

function isNumber(string: string): boolean {
  return NON_WHITESPACE_REGEXP.test(string) && Number.isFinite(Number(string));
}

function setNested(
  object: NestedMapping,
  keys: string[],
  value: unknown,
  collect = false,
) {
  keys = [...keys];
  const key = keys.pop()!;

  keys.forEach((key) => object = (object[key] ??= {}) as NestedMapping);

  if (collect) {
    const v = object[key];
    if (Array.isArray(v)) {
      v.push(value);
      return;
    }

    value = v ? [v, value] : [value];
  }

  object[key] = value;
}

function hasNested(object: NestedMapping, keys: string[]): boolean {
  for (const key of keys) {
    const value = object[key];
    if (!Object.hasOwn(object, key)) return false;
    object = value as NestedMapping;
  }
  return true;
}

function aliasIsBoolean(
  aliasMap: Map<string, Set<string>>,
  booleanSet: Set<string>,
  key: string,
): boolean {
  const set = aliasMap.get(key);
  if (set === undefined) return false;
  for (const alias of set) if (booleanSet.has(alias)) return true;
  return false;
}

function isBooleanString(value: string) {
  return value === "true" || value === "false";
}

function parseBooleanString(value: unknown) {
  return value !== "false";
}

/**
 * Take a set of command line arguments, optionally with a set of options, and
 * return an object representing the flags found in the passed arguments.
 *
 * By default, any arguments starting with `-` or `--` are considered boolean
 * flags. If the argument name is followed by an equal sign (`=`) it is
 * considered a key-value pair. Any arguments which could not be parsed are
 * available in the `_` property of the returned object.
 *
 * By default, this module tries to determine the type of all arguments
 * automatically and the return type of this function will have an index
 * signature with `any` as value (`{ [x: string]: any }`).
 *
 * If the `string`, `boolean` or `collect` option is set, the return value of
 * this function will be fully typed and the index signature of the return
 * type will change to `{ [x: string]: unknown }`.
 *
 * Any arguments after `'--'` will not be parsed and will end up in `parsedArgs._`.
 *
 * Numeric-looking arguments will be returned as numbers unless `options.string`
 * or `options.boolean` is set for that argument name.
 *
 * See {@linkcode ParseOptions} for more information.
 *
 * @param args An array of command line arguments.
 * @param options Options for the parse function.
 *
 * @typeParam TArgs Type of result.
 * @typeParam TDoubleDash Used by `TArgs` for the result.
 * @typeParam TBooleans Used by `TArgs` for the result.
 * @typeParam TStrings Used by `TArgs` for the result.
 * @typeParam TCollectable Used by `TArgs` for the result.
 * @typeParam TNegatable Used by `TArgs` for the result.
 * @typeParam TDefaults Used by `TArgs` for the result.
 * @typeParam TAliases Used by `TArgs` for the result.
 * @typeParam TAliasArgNames Used by `TArgs` for the result.
 * @typeParam TAliasNames Used by `TArgs` for the result.
 *
 * @return The parsed arguments.
 *
 * @example Usage
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * // For proper use, one should use `parseArgs(Deno.args)`
 * assertEquals(parseArgs(["--foo", "--bar=baz", "./quux.txt"]), {
 *   foo: true,
 *   bar: "baz",
 *   _: ["./quux.txt"],
 * });
 * ```
 *
 * @example `string` and `boolean` options
 *
 * Use `string` and `boolean` options to specify the type of the argument.
 *
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * const args = parseArgs(["--foo", "--bar", "baz"], {
 *   boolean: ["foo"],
 *   string: ["bar"],
 * });
 *
 * assertEquals(args, { foo: true, bar: "baz", _: [] });
 * ```
 *
 * @example `collect` option
 *
 * `collect` option tells the parser to treat the option as an array. All
 * values will be collected into one array. If a non-collectable option is used
 * multiple times, the last value is used.
 *
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * const args = parseArgs(["--foo", "bar", "--foo", "baz"], {
 *  collect: ["foo"],
 * });
 *
 * assertEquals(args, { foo: ["bar", "baz"], _: [] });
 * ```
 *
 * @example `negatable` option
 *
 * `negatable` option tells the parser to treat the option can be negated by
 * prefixing them with `--no-`, like `--no-config`.
 *
 * ```ts
 * import { parseArgs } from "@std/cli/parse-args";
 * import { assertEquals } from "@std/assert/equals";
 *
 * const args = parseArgs(["--no-foo"], {
 *   boolean: ["foo"],
 *   negatable: ["foo"],
 * });
 *
 * assertEquals(args, { foo: false, _: [] });
 * ```
 */
export function parseArgs<
  TArgs extends Values<
    TBooleans,
    TStrings,
    TCollectable,
    TNegatable,
    TDefaults,
    TAliases
  >,
  TDoubleDash extends boolean | undefined = undefined,
  TBooleans extends BooleanType = undefined,
  TStrings extends StringType = undefined,
  TCollectable extends Collectable = undefined,
  TNegatable extends Negatable = undefined,
  TDefaults extends Record<string, unknown> | undefined = undefined,
  TAliases extends Aliases<TAliasArgNames, TAliasNames> | undefined = undefined,
  TAliasArgNames extends string = string,
  TAliasNames extends string = string,
>(
  args: string[],
  options?: ParseOptions<
    TBooleans,
    TStrings,
    TCollectable,
    TNegatable,
    TDefaults,
    TAliases,
    TDoubleDash
  >,
): Args<TArgs, TDoubleDash> {
  const {
    "--": doubleDash = false,
    alias = {} as NonNullable<TAliases>,
    boolean = false,
    default: defaults = {} as TDefaults & Defaults<TBooleans, TStrings>,
    stopEarly = false,
    string = [],
    collect = [],
    negatable = [],
    unknown: unknownFn = (i: string): unknown => i,
  } = options ?? {};
  const aliasMap: Map<string, Set<string>> = new Map();
  const booleanSet = new Set<string>();
  const stringSet = new Set<string>();
  const collectSet = new Set<string>();
  const negatableSet = new Set<string>();

  let allBools = false;

  if (alias) {
    for (const [key, value] of Object.entries(alias)) {
      if (value === undefined) {
        throw new TypeError("Alias value must be defined");
      }
      const aliases = Array.isArray(value) ? value : [value];
      aliasMap.set(key, new Set(aliases));
      aliases.forEach((alias) =>
        aliasMap.set(
          alias,
          new Set([key, ...aliases.filter((it) => it !== alias)]),
        )
      );
    }
  }

  if (boolean) {
    if (typeof boolean === "boolean") {
      allBools = boolean;
    } else {
      const booleanArgs = Array.isArray(boolean) ? boolean : [boolean];
      for (const key of booleanArgs.filter(Boolean)) {
        booleanSet.add(key);
        aliasMap.get(key)?.forEach((al) => {
          booleanSet.add(al);
        });
      }
    }
  }

  if (string) {
    const stringArgs = Array.isArray(string) ? string : [string];
    for (const key of stringArgs.filter(Boolean)) {
      stringSet.add(key);
      aliasMap.get(key)?.forEach((al) => stringSet.add(al));
    }
  }

  if (collect) {
    const collectArgs = Array.isArray(collect) ? collect : [collect];
    for (const key of collectArgs.filter(Boolean)) {
      collectSet.add(key);
      aliasMap.get(key)?.forEach((al) => collectSet.add(al));
    }
  }

  if (negatable) {
    const negatableArgs = Array.isArray(negatable) ? negatable : [negatable];
    for (const key of negatableArgs.filter(Boolean)) {
      negatableSet.add(key);
      aliasMap.get(key)?.forEach((alias) => negatableSet.add(alias));
    }
  }

  const argv: Args = { _: [] };

  function setArgument(
    key: string,
    value: string | number | boolean,
    arg: string,
    collect: boolean,
  ) {
    if (
      !booleanSet.has(key) &&
      !stringSet.has(key) &&
      !aliasMap.has(key) &&
      !collectSet.has(key) &&
      !(allBools && FLAG_NAME_REGEXP.test(arg)) &&
      unknownFn?.(arg, key, value) === false
    ) {
      return;
    }

    if (typeof value === "string" && !stringSet.has(key)) {
      value = isNumber(value) ? Number(value) : value;
    }

    const collectable = collect && collectSet.has(key);
    setNested(argv, key.split("."), value, collectable);
    aliasMap.get(key)?.forEach((key) => {
      setNested(argv, key.split("."), value, collectable);
    });
  }

  let notFlags: string[] = [];

  // all args after "--" are not parsed
  const index = args.indexOf("--");
  if (index !== -1) {
    notFlags = args.slice(index + 1);
    args = args.slice(0, index);
  }

  argsLoop:
  for (let i = 0; i < args.length; i++) {
    const arg = args[i]!;

    const groups = arg.match(FLAG_REGEXP)?.groups;

    if (groups) {
      const { doubleDash, negated } = groups;
      let key = groups.key!;
      let value: string | number | boolean | undefined = groups.value;

      if (doubleDash) {
        if (value) {
          if (booleanSet.has(key)) value = parseBooleanString(value);
          setArgument(key, value, arg, true);
          continue;
        }

        if (negated) {
          if (negatableSet.has(key)) {
            setArgument(key, false, arg, false);
            continue;
          }
          key = `no-${key}`;
        }

        const next = args[i + 1];

        if (next) {
          if (
            !booleanSet.has(key) &&
            !allBools &&
            !next.startsWith("-") &&
            (!aliasMap.has(key) || !aliasIsBoolean(aliasMap, booleanSet, key))
          ) {
            value = next;
            i++;
            setArgument(key, value, arg, true);
            continue;
          }

          if (isBooleanString(next)) {
            value = parseBooleanString(next);
            i++;
            setArgument(key, value, arg, true);
            continue;
          }
        }

        value = stringSet.has(key) ? "" : true;
        setArgument(key, value, arg, true);
        continue;
      }
      const letters = arg.slice(1, -1).split("");

      for (const [j, letter] of letters.entries()) {
        const next = arg.slice(j + 2);

        if (next === "-") {
          setArgument(letter, next, arg, true);
          continue;
        }

        if (LETTER_REGEXP.test(letter)) {
          const groups = VALUE_REGEXP.exec(next)?.groups;
          if (groups) {
            setArgument(letter, groups.value!, arg, true);
            continue argsLoop;
          }
          if (NUMBER_REGEXP.test(next)) {
            setArgument(letter, next, arg, true);
            continue argsLoop;
          }
        }

        if (letters[j + 1]?.match(SPECIAL_CHAR_REGEXP)) {
          setArgument(letter, arg.slice(j + 2), arg, true);
          continue argsLoop;
        }
        setArgument(letter, stringSet.has(letter) ? "" : true, arg, true);
      }

      key = arg.slice(-1);
      if (key === "-") continue;

      const nextArg = args[i + 1];

      if (nextArg) {
        if (
          !HYPHEN_REGEXP.test(nextArg) &&
          !booleanSet.has(key) &&
          (!aliasMap.has(key) || !aliasIsBoolean(aliasMap, booleanSet, key))
        ) {
          setArgument(key, nextArg, arg, true);
          i++;
          continue;
        }
        if (isBooleanString(nextArg)) {
          const value = parseBooleanString(nextArg);
          setArgument(key, value, arg, true);
          i++;
          continue;
        }
      }
      setArgument(key, stringSet.has(key) ? "" : true, arg, true);
      continue;
    }

    if (unknownFn?.(arg) !== false) {
      argv._.push(
        stringSet.has("_") || !isNumber(arg) ? arg : Number(arg),
      );
    }

    if (stopEarly) {
      argv._.push(...args.slice(i + 1));
      break;
    }
  }

  for (const [key, value] of Object.entries(defaults)) {
    const keys = key.split(".");
    if (!hasNested(argv, keys)) {
      setNested(argv, keys, value);
      aliasMap.get(key)?.forEach((key) =>
        setNested(argv, key.split("."), value)
      );
    }
  }

  for (const key of booleanSet.keys()) {
    const keys = key.split(".");
    if (!hasNested(argv, keys)) {
      const value = collectSet.has(key) ? [] : false;
      setNested(argv, keys, value);
    }
  }

  for (const key of stringSet.keys()) {
    const keys = key.split(".");
    if (!hasNested(argv, keys) && collectSet.has(key)) {
      setNested(argv, keys, []);
    }
  }

  if (doubleDash) {
    argv["--"] = notFlags;
  } else {
    argv._.push(...notFlags);
  }

  return argv as Args<TArgs, TDoubleDash>;
}



================================================
FILE: cli/parse_args_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.
import { assertEquals, assertThrows } from "@std/assert";
import { type Args, parseArgs, type ParseOptions } from "./parse_args.ts";
import { assertType, type IsExact } from "@std/testing/types";

// flag boolean true (default all --args to boolean)
Deno.test("parseArgs() handles true boolean flag", function () {
  const argv = parseArgs(["moo", "--honk", "cow"], {
    boolean: true,
  });

  assertEquals(argv, {
    honk: true,
    _: ["moo", "cow"],
  });

  assertEquals(typeof argv.honk, "boolean");
});

// flag boolean true only affects double hyphen arguments without equals signs
Deno.test("parseArgs() handles boolean true flag if double dashed", function () {
  const argv = parseArgs(["moo", "--honk", "cow", "-p", "55", "--tacos=good"], {
    boolean: true,
  });

  assertEquals(argv, {
    honk: true,
    tacos: "good",
    p: 55,
    _: ["moo", "cow"],
  });

  assertEquals(typeof argv.honk, "boolean");
});

Deno.test("parseArgs() handles boolean flag default value", function () {
  const argv = parseArgs(["moo"], {
    boolean: ["t", "verbose"],
    default: { verbose: false, t: false },
  });

  assertEquals(argv, {
    verbose: false,
    t: false,
    _: ["moo"],
  });

  assertEquals(typeof argv.verbose, "boolean");
  assertEquals(typeof argv.t, "boolean");
});

Deno.test("parseArgs() handles boolean group", function () {
  const argv = parseArgs(["-x", "-z", "one", "two", "three"], {
    boolean: ["x", "y", "z"],
  });

  assertEquals(argv, {
    x: true,
    y: false,
    z: true,
    _: ["one", "two", "three"],
  });

  assertEquals(typeof argv.x, "boolean");
  assertEquals(typeof argv.y, "boolean");
  assertEquals(typeof argv.z, "boolean");
});

Deno.test("parseArgs() handles boolean and alias default values", function (): void {
  const argv = parseArgs([], {
    string: ["foo"],
    boolean: ["bar"],
    alias: {
      bar: "b",
    },
  });

  assertEquals(argv, {
    bar: false,
    b: false,
    _: [],
  });
});

Deno.test("parseArgs() handles boolean and alias with chainable api", function () {
  const aliased = ["-h", "derp"];
  const regular = ["--herp", "derp"];
  const aliasedArgv = parseArgs(aliased, {
    boolean: "herp",
    alias: { h: "herp" },
  });
  const propertyArgv = parseArgs(regular, {
    boolean: "herp",
    alias: { h: "herp" },
  });
  const expected = {
    herp: true,
    h: true,
    _: ["derp"],
  };

  assertEquals(aliasedArgv, expected);
  assertEquals(propertyArgv, expected);
});

Deno.test("parseArgs() handles boolean and alias with options hash", function () {
  const aliased = ["-h", "derp"];
  const regular = ["--herp", "derp"];
  const opts = {
    alias: { h: "herp" },
    boolean: "herp",
  } as const;
  const aliasedArgv = parseArgs(aliased, opts);
  const propertyArgv = parseArgs(regular, opts);
  const expected = {
    herp: true,
    h: true,
    _: ["derp"],
  };
  assertEquals(aliasedArgv, expected);
  assertEquals(propertyArgv, expected);
});

Deno.test("parseArgs() handles boolean and alias array with options hash", function () {
  const aliased = ["-h", "derp"];
  const regular = ["--herp", "derp"];
  const alt = ["--harp", "derp"];
  const opts = {
    alias: { h: ["herp", "harp"] },
    boolean: "h",
  } as const;
  const aliasedArgv = parseArgs(aliased, opts);
  const propertyArgv = parseArgs(regular, opts);
  const altPropertyArgv = parseArgs(alt, opts);
  const expected = {
    harp: true,
    herp: true,
    h: true,
    _: ["derp"],
  };
  assertEquals(aliasedArgv, expected);
  assertEquals(propertyArgv, expected);
  assertEquals(altPropertyArgv, expected);
});

Deno.test("parseArgs() handles boolean and alias using explicit true", function () {
  const aliased = ["-h", "true"];
  const regular = ["--herp", "true"];
  const opts = {
    alias: { h: "herp" },
    boolean: "h",
  } as const;
  const aliasedArgv = parseArgs(aliased, opts);
  const propertyArgv = parseArgs(regular, opts);
  const expected = {
    herp: true,
    h: true,
    _: [],
  };

  assertEquals(aliasedArgv, expected);
  assertEquals(propertyArgv, expected);
});

// regression, see https://github.com/substack/node-optimist/issues/71
// boolean and --x=true
Deno.test("parseArgs() handles boolean and non-boolean", function () {
  const parsed = parseArgs(["--boool", "--other=true"], {
    boolean: "boool",
  });

  assertEquals(parsed.boool, true);
  assertEquals(parsed.other, "true");

  const parsed2 = parseArgs(["--boool", "--other=false"], {
    boolean: "boool",
  });

  assertEquals(parsed2.boool, true);
  assertEquals(parsed2.other, "false");
});

Deno.test("parseArgs() handles boolean true parsing", function () {
  const parsed = parseArgs(["--boool=true"], {
    default: {
      boool: false,
    },
    boolean: ["boool"],
  });

  assertEquals(parsed.boool, true);
});

Deno.test("parseArgs() handles boolean false parsing", function () {
  const parsed = parseArgs(["--boool=false"], {
    default: {
      boool: true,
    },
    boolean: ["boool"],
  });

  assertEquals(parsed.boool, false);
});

Deno.test("parseArgs() handles boolean true-like parsing", function () {
  const parsed = parseArgs(["-t", "true123"], { boolean: ["t"] });
  assertEquals(parsed.t, true);

  const parsed2 = parseArgs(["-t", "123"], { boolean: ["t"] });
  assertEquals(parsed2.t, true);

  const parsed3 = parseArgs(["-t", "false123"], { boolean: ["t"] });
  assertEquals(parsed3.t, true);
});

Deno.test("parseArgs() handles boolean after boolean negation", function () {
  const parsed = parseArgs(["--foo", "--no-foo"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed.foo, false);

  const parsed2 = parseArgs(["--foo", "--no-foo", "123"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed2.foo, false);
});

Deno.test("parseArgs() handles boolean after boolean negation", function () {
  const parsed = parseArgs(["--no-foo", "--foo"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed.foo, true);

  const parsed2 = parseArgs(["--no-foo", "--foo", "123"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed2.foo, true);
});

Deno.test("parseArgs() handles latest flag boolean negation", function () {
  const parsed = parseArgs(["--no-foo", "--foo", "--no-foo"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed.foo, false);

  const parsed2 = parseArgs(["--no-foo", "--foo", "--no-foo", "123"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed2.foo, false);
});

Deno.test("parseArgs() handles latest flag boolean", function () {
  const parsed = parseArgs(["--foo", "--no-foo", "--foo"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed.foo, true);

  const parsed2 = parseArgs(["--foo", "--no-foo", "--foo", "123"], {
    boolean: ["foo"],
    negatable: ["foo"],
  });
  assertEquals(parsed2.foo, true);
});

Deno.test("parseArgs() handles string negatable option", function () {
  const parsed = parseArgs(["--no-foo"], {
    boolean: ["foo"],
    negatable: "foo",
  });
  assertEquals(parsed.foo, false);
});

Deno.test("parseArgs() handles hyphen", function () {
  assertEquals(parseArgs(["-n", "-"]), { n: "-", _: [] });
  assertEquals(parseArgs(["-"]), { _: ["-"] });
  assertEquals(parseArgs(["-f-"]), { f: "-", _: [] });
  assertEquals(parseArgs(["-b", "-"], { boolean: "b" }), { b: true, _: ["-"] });
  assertEquals(parseArgs(["-s", "-"], { string: "s" }), { s: "-", _: [] });
});

Deno.test("parseArgs() handles double dash", function () {
  assertEquals(parseArgs(["-a", "--", "b"]), { a: true, _: ["b"] });
  assertEquals(parseArgs(["--a", "--", "b"]), { a: true, _: ["b"] });
  assertEquals(parseArgs(["--a", "--", "b"]), { a: true, _: ["b"] });
});

Deno.test("parseArgs() moves args after double dash into own array", function () {
  assertEquals(
    parseArgs(["--name", "John", "before", "--", "after"], { "--": true }),
    {
      name: "John",
      _: ["before"],
      "--": ["after"],
    },
  );
});

Deno.test("parseArgs() handles default true boolean value", function () {
  const argv = parseArgs([], {
    boolean: "sometrue",
    default: { sometrue: true },
  });
  assertEquals(argv.sometrue, true);
});

Deno.test("parseArgs() handles default true boolean value", function () {
  const argv = parseArgs([], {
    boolean: "somefalse",
    default: { somefalse: false },
  });
  assertEquals(argv.somefalse, false);
});

Deno.test("parseArgs() handles default null boolean value", function () {
  const argv = parseArgs([], {
    boolean: "maybe",
    default: { maybe: null },
  });
  assertEquals(argv.maybe, null);
  const argv2 = parseArgs(["--maybe"], {
    boolean: "maybe",
    default: { maybe: null },
  });
  assertEquals(argv2.maybe, true);
});

Deno.test("parseArgs() handles dotted alias", function () {
  const argv = parseArgs(["--a.b", "22"], {
    default: { "a.b": 11 },
    alias: { "a.b": "aa.bb" },
  });
  assertEquals(argv.a.b, 22);
  assertEquals(argv.aa.bb, 22);
});

Deno.test("parseArgs() handles dotted default value", function () {
  const argv = parseArgs([], {
    default: { "a.b": 11 },
    alias: { "a.b": "aa.bb" },
  });
  assertEquals(argv.a.b, 11);
  assertEquals(argv.aa.bb, 11);
});

Deno.test("parseArgs() handles dotted default with no alias", function () {
  const argv = parseArgs([], { default: { "a.b": 11 } });
  assertEquals(argv.a.b, 11);
});

Deno.test("parseArgs() handles short", function () {
  const argv = parseArgs(["-b=123"]);
  assertEquals(argv, { b: 123, _: [] });
});

Deno.test("parseArgs() handles multi short", function () {
  const argv = parseArgs(["-a=whatever", "-b=robots"]);
  assertEquals(argv, { a: "whatever", b: "robots", _: [] });
});

Deno.test("parseArgs() handles long opts", function () {
  assertEquals(parseArgs(["--bool"]), { bool: true, _: [] });
  assertEquals(parseArgs(["--pow", "xixxle"]), { pow: "xixxle", _: [] });
  assertEquals(parseArgs(["--pow=xixxle"]), { pow: "xixxle", _: [] });
  assertEquals(parseArgs(["--host", "localhost", "--port", "555"]), {
    host: "localhost",
    port: 555,
    _: [],
  });
  assertEquals(parseArgs(["--host=localhost", "--port=555"]), {
    host: "localhost",
    port: 555,
    _: [],
  });
});

Deno.test("parseArgs() handles numbers", function () {
  const argv = parseArgs([
    "-x",
    "1234",
    "-y",
    "5.67",
    "-z",
    "1e7",
    "-w",
    "10f",
    "--hex",
    "0xdeadbeef",
    "789",
  ]);
  assertEquals(argv, {
    x: 1234,
    y: 5.67,
    z: 1e7,
    w: "10f",
    hex: 0xdeadbeef,
    _: [789],
  });
  assertEquals(typeof argv.x, "number");
  assertEquals(typeof argv.y, "number");
  assertEquals(typeof argv.z, "number");
  assertEquals(typeof argv.w, "string");
  assertEquals(typeof argv.hex, "number");
  assertEquals(typeof argv._[0], "number");
});

Deno.test("parseArgs() handles already number", function () {
  const argv = parseArgs(["-x", "1234", "789"]);
  assertEquals(argv, { x: 1234, _: [789] });
  assertEquals(typeof argv.x, "number");
  assertEquals(typeof argv._[0], "number");
});

Deno.test("parseArgs() parses args", function () {
  assertEquals(parseArgs(["--no-moo"]), { "no-moo": true, _: [] });
  assertEquals(parseArgs(["-v", "a", "-v", "b", "-v", "c"]), {
    v: "c",
    _: [],
  });
});

Deno.test("parseArgs() handles comprehensive", function () {
  assertEquals(
    parseArgs([
      "--name=meowmers",
      "bare",
      "-cats",
      "woo",
      "-h",
      "awesome",
      "--multi=quux",
      "--key",
      "value",
      "-b",
      "--bool",
      "--no-meep",
      "--multi=baz",
      "-f=abc=def",
      "--foo=---=\\n--+34-=/=",
      "-e==",
      "--",
      "--not-a-flag",
      "eek",
    ]),
    {
      c: true,
      a: true,
      t: true,
      e: "=",
      f: "abc=def",
      foo: "---=\\n--+34-=/=",
      s: "woo",
      h: "awesome",
      b: true,
      bool: true,
      key: "value",
      multi: "baz",
      "no-meep": true,
      name: "meowmers",
      _: ["bare", "--not-a-flag", "eek"],
    },
  );
});

Deno.test("parseArgs() handles flag boolean", function () {
  const argv = parseArgs(["-t", "moo"], { boolean: "t" });
  assertEquals(argv, { t: true, _: ["moo"] });
  assertEquals(typeof argv.t, "boolean");
});

Deno.test("parseArgs() handles flag boolean value", function () {
  const argv = parseArgs(["--verbose", "false", "moo", "-t", "true"], {
    boolean: ["t", "verbose"],
    default: { verbose: true },
  });

  assertEquals(argv, {
    verbose: false,
    t: true,
    _: ["moo"],
  });

  assertEquals(typeof argv.verbose, "boolean");
  assertEquals(typeof argv.t, "boolean");
});

Deno.test("parseArgs() handles newlines in params", function () {
  const args = parseArgs(["-s", "X\nX"]);
  assertEquals(args, { _: [], s: "X\nX" });

  // reproduce in bash:
  // VALUE="new
  // line"
  // deno program.js --s="$VALUE"
  const args2 = parseArgs(["--s=X\nX"]);
  assertEquals(args2, { _: [], s: "X\nX" });
});

Deno.test("parseArgs() handles strings", function () {
  const s = parseArgs(["-s", "0001234"], { string: "s" }).s;
  assertEquals(s, "0001234");
  assertEquals(typeof s, "string");

  const x = parseArgs(["-x", "56"], { string: "x" }).x;
  assertEquals(x, "56");
  assertEquals(typeof x, "string");
});

Deno.test("parseArgs() handles string args", function () {
  const s = parseArgs(["  ", "  "], { string: "_" })._;
  assertEquals(s.length, 2);
  assertEquals(typeof s[0], "string");
  assertEquals(s[0], "  ");
  assertEquals(typeof s[1], "string");
  assertEquals(s[1], "  ");
});

Deno.test("parseArgs() handles empty strings", function () {
  const s = parseArgs(["-s"], { string: "s" }).s;
  assertEquals(s, "");
  assertEquals(typeof s, "string");

  const str = parseArgs(["--str"], { string: "str" }).str;
  assertEquals(str, "");
  assertEquals(typeof str, "string");

  const letters = parseArgs(["-art"], {
    string: ["a", "t"],
  });

  assertEquals(letters.a, "");
  assertEquals(letters.r, true);
  assertEquals(letters.t, "");
});

Deno.test("parseArgs() handles string and alias", function () {
  const x = parseArgs(["--str", "000123"], {
    string: "s",
    alias: { s: "str" },
  });

  assertEquals(x.str, "000123");
  assertEquals(typeof x.str, "string");
  assertEquals(x.s, "000123");
  assertEquals(typeof x.s, "string");

  const y = parseArgs(["-s", "000123"], {
    string: "str",
    alias: { str: "s" },
  });

  assertEquals(y.str, "000123");
  assertEquals(typeof y.str, "string");
  assertEquals(y.s, "000123");
  assertEquals(typeof y.s, "string");
});

Deno.test("parseArgs() handles slash break", function () {
  assertEquals(parseArgs(["-I/foo/bar/baz"]), { I: "/foo/bar/baz", _: [] });
  assertEquals(parseArgs(["-xyz/foo/bar/baz"]), {
    x: true,
    y: true,
    z: "/foo/bar/baz",
    _: [],
  });
});

Deno.test("parseArgs() handles alias", function () {
  const argv = parseArgs(["-f", "11", "--zoom", "55"], {
    alias: { z: "zoom" },
  });
  assertEquals(argv.zoom, 55);
  assertEquals(argv.z, argv.zoom);
  assertEquals(argv.f, 11);
});

Deno.test("parseArgs() handles multi alias", function () {
  const argv = parseArgs(["-f", "11", "--zoom", "55"], {
    alias: { z: ["zm", "zoom"] },
  });
  assertEquals(argv.zoom, 55);
  assertEquals(argv.z, argv.zoom);
  assertEquals(argv.z, argv.zm);
  assertEquals(argv.f, 11);
});

Deno.test("parseArgs() handles nested dotted objects", function () {
  const argv = parseArgs([
    "--foo.bar",
    "3",
    "--foo.baz",
    "4",
    "--foo.quux.quibble",
    "5",
    "--foo.quux.oO",
    "--beep.boop",
  ]);

  assertEquals(argv.foo, {
    bar: 3,
    baz: 4,
    quux: {
      quibble: 5,
      oO: true,
    },
  });
  assertEquals(argv.beep, { boop: true });
});

Deno.test("parseArgs() handles flag builtin property", function () {
  const argv = parseArgs(["--toString", "--valueOf", "foo"]);
  assertEquals(argv, { toString: true, valueOf: "foo", _: [] });
  assertEquals(typeof argv.toString, "boolean");
  assertEquals(typeof argv.valueOf, "string");
});

Deno.test("parseArgs() handles numeric short args", function () {
  assertEquals(parseArgs(["-n123"]), { n: 123, _: [] });
  assertEquals(parseArgs(["-123", "456"]), { 1: true, 2: true, 3: 456, _: [] });
});

Deno.test("parseArgs() handles short", function () {
  assertEquals(parseArgs(["-b"]), { b: true, _: [] });
  assertEquals(parseArgs(["foo", "bar", "baz"]), { _: ["foo", "bar", "baz"] });
  assertEquals(parseArgs(["-cats"]), {
    c: true,
    a: true,
    t: true,
    s: true,
    _: [],
  });
  assertEquals(parseArgs(["-cats", "meow"]), {
    c: true,
    a: true,
    t: true,
    s: "meow",
    _: [],
  });
  assertEquals(parseArgs(["-h", "localhost"]), { h: "localhost", _: [] });
  assertEquals(parseArgs(["-h", "localhost", "-p", "555"]), {
    h: "localhost",
    p: 555,
    _: [],
  });
});

Deno.test("parseArgs() handles mixed short bool and capture", function () {
  assertEquals(parseArgs(["-h", "localhost", "-fp", "555", "script.js"]), {
    f: true,
    p: 555,
    h: "localhost",
    _: ["script.js"],
  });
});

Deno.test("parseArgs() handles short and long", function () {
  assertEquals(parseArgs(["-h", "localhost", "-fp", "555", "script.js"]), {
    f: true,
    p: 555,
    h: "localhost",
    _: ["script.js"],
  });
});

// stops parsing on the first non-option when stopEarly is set
Deno.test("parseArgs() handles stopEarly option", function () {
  const argv = parseArgs(["--aaa", "bbb", "ccc", "--ddd"], {
    stopEarly: true,
  });

  assertEquals(argv, {
    aaa: "bbb",
    _: ["ccc", "--ddd"],
  });
});

Deno.test("parseArgs() handles boolean and alias that are not unknown", function () {
  const unknown: unknown[] = [];
  function unknownFn(arg: string, k?: string, v?: unknown): boolean {
    unknown.push({ arg, k, v });
    return false;
  }
  const aliased = ["-h", "true", "--derp", "true"];
  const regular = ["--herp", "true", "-d", "false"];
  const opts = {
    alias: { h: "herp" },
    boolean: "h",
    unknown: unknownFn,
  };
  parseArgs(aliased, opts);
  parseArgs(regular, opts);

  assertEquals(unknown, [
    { arg: "--derp", k: "derp", v: "true" },
    { arg: "-d", k: "d", v: "false" },
  ]);
});

Deno.test(
  "parseArgs() handles flag boolean true any double hyphen argument is not unknown",
  function () {
    const unknown: unknown[] = [];
    function unknownFn(arg: string, k?: string, v?: unknown): boolean {
      unknown.push({ arg, k, v });
      return false;
    }
    const argv = parseArgs(["--honk", "--tacos=good", "cow", "-p", "55"], {
      boolean: true,
      unknown: unknownFn,
    });
    assertEquals(unknown, [
      { arg: "--tacos=good", k: "tacos", v: "good" },
      { arg: "cow", k: undefined, v: undefined },
      { arg: "-p", k: "p", v: "55" },
    ]);
    assertEquals(argv, {
      honk: true,
      _: [],
    });
  },
);

Deno.test("parseArgs() handles string and alias is not unknown", function () {
  const unknown: unknown[] = [];
  function unknownFn(arg: string, k?: string, v?: unknown): boolean {
    unknown.push({ arg, k, v });
    return false;
  }
  const aliased = ["-h", "hello", "--derp", "goodbye"];
  const regular = ["--herp", "hello", "-d", "moon"];
  const opts = {
    alias: { h: "herp" },
    string: "h",
    unknown: unknownFn,
  };
  parseArgs(aliased, opts);
  parseArgs(regular, opts);

  assertEquals(unknown, [
    { arg: "--derp", k: "derp", v: "goodbye" },
    { arg: "-d", k: "d", v: "moon" },
  ]);
});

Deno.test("parseArgs() handles default and alias is not unknown", function () {
  const unknown: unknown[] = [];
  function unknownFn(arg: string, k?: string, v?: unknown): boolean {
    unknown.push({ arg, k, v });
    return false;
  }
  const aliased = ["-h", "hello"];
  const regular = ["--herp", "hello"];
  const opts = {
    default: { h: "bar" },
    alias: { h: "herp" },
    unknown: unknownFn,
  };
  parseArgs(aliased, opts);
  parseArgs(regular, opts);

  assertEquals(unknown, []);
});

Deno.test("parseArgs() handles value following double hyphen", function () {
  const unknown: unknown[] = [];
  function unknownFn(arg: string, k?: string, v?: unknown): boolean {
    unknown.push({ arg, k, v });
    return false;
  }
  const aliased = ["--bad", "--", "good", "arg"];
  const opts = {
    "--": true,
    unknown: unknownFn,
  };
  const argv = parseArgs(aliased, opts);

  assertEquals(unknown, [{ arg: "--bad", k: "bad", v: true }]);
  assertEquals(argv, {
    "--": ["good", "arg"],
    _: [],
  });
});

Deno.test("parseArgs() handles whitespace", function () {
  assertEquals(parseArgs(["-x", "\t"]).x, "\t");
});

Deno.test("parseArgs() handles collect args default behaviour", function () {
  const argv = parseArgs([
    "--foo",
    "bar",
    "--foo",
    "baz",
    "--beep",
    "boop",
    "--bool",
    "--bool",
  ]);

  assertEquals(argv, {
    foo: "baz",
    beep: "boop",
    bool: true,
    _: [],
  });
});

Deno.test("parseArgs() handles collect args with default behaviour", function () {
  const argv = parseArgs([], {
    collect: ["foo"],
    default: {
      foo: ["bar", "baz"],
    },
  });

  assertEquals(argv, {
    foo: ["bar", "baz"],
    _: [],
  });
});

Deno.test("parseArgs() handles collect unknown args", function () {
  const argv = parseArgs([
    "--foo",
    "bar",
    "--foo",
    "baz",
    "--beep",
    "boop",
    "--bib",
    "--bib",
    "--bab",
    "--bab",
  ], {
    collect: ["beep", "bib"],
  });

  assertEquals(argv, {
    foo: "baz",
    beep: ["boop"],
    bib: [true, true],
    bab: true,
    _: [],
  });
});

Deno.test("parseArgs() handles collect args", function () {
  const argv = parseArgs([
    "--bool",
    "--bool",
    "--boolArr",
    "--str",
    "foo",
    "--strArr",
    "beep",
    "--unknown",
    "--unknownArr",
  ], {
    boolean: ["bool", "boolArr"],
    string: ["str", "strArr"],
    collect: ["boolArr", "strArr", "unknownArr"],
    alias: {
      bool: "b",
      strArr: "S",
      boolArr: "B",
    },
  });

  assertEquals(argv, {
    bool: true,
    b: true,
    boolArr: [true],
    B: [true],
    str: "foo",
    strArr: ["beep"],
    S: ["beep"],
    unknown: true,
    unknownArr: [true],
    _: [],
  });
});

Deno.test("parseArgs() handles collect negateable args", function () {
  const argv = parseArgs([
    "--foo",
    "123",
    "-f",
    "456",
    "--no-foo",
  ], {
    string: ["foo"],
    collect: ["foo"],
    negatable: ["foo"],
    alias: {
      foo: "f",
    },
  });

  assertEquals(argv, {
    foo: false,
    f: false,
    _: [],
  });
});

Deno.test("parseArgs() handles string collect option", function () {
  const argv = parseArgs([
    "--foo",
    "123",
    "--foo",
    "345",
  ], {
    collect: "foo",
  });

  assertEquals(argv, {
    foo: [123, 345],
    _: [],
  });
});

/** ---------------------- TYPE TESTS ---------------------- */

Deno.test("parseArgs() handles types of default options", function () {
  const argv = parseArgs([]);
  assertType<
    IsExact<
      typeof argv,
      // deno-lint-ignore no-explicit-any
      & { [x: string]: any }
      & {
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean disabled", function () {
  const argv = parseArgs([], {
    boolean: false,
  });
  assertType<
    IsExact<
      typeof argv,
      // deno-lint-ignore no-explicit-any
      & { [x: string]: any }
      & {
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean disabled with defaults", function () {
  const argv = parseArgs([], {
    boolean: false,
    default: {
      bar: 123,
    },
  });
  assertType<
    IsExact<
      typeof argv,
      // deno-lint-ignore no-explicit-any
      & { [x: string]: any }
      & {
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean disabled and string args", function () {
  const argv = parseArgs([], {
    boolean: false,
    string: ["foo"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo?: string;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean disabled and string args with defaults", function () {
  const argv = parseArgs([], {
    boolean: false,
    string: ["foo"],
    default: {
      foo: 123,
      bar: false,
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: string | number;
        bar: unknown;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean", function () {
  const argv = parseArgs([], {
    boolean: true,
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean with defaults", function () {
  const argv = parseArgs([], {
    boolean: true,
    default: {
      foo: "123",
      bar: 123,
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: unknown;
        bar: unknown;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean and string args", function () {
  const argv = parseArgs([], {
    boolean: true,
    string: ["foo", "bar", "foo-bar"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo?: string;
        bar?: string;
        "foo-bar"?: string;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of all boolean and string args with defaults", function () {
  const argv = parseArgs([], {
    boolean: true,
    string: ["foo", "bar", "foo-bar"],
    default: {
      bar: 123,
      baz: new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo?: string;
        bar: string | number;
        baz: unknown;
        "foo-bar"?: string;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of boolean args", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "bar", "foo-bar"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: boolean;
        bar: boolean;
        "foo-bar": boolean;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of boolean args with defaults", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "bar", "foo-bar"],
    default: {
      bar: 123,
      baz: "123",
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: boolean;
        bar: number | boolean;
        baz: unknown;
        "foo-bar": boolean;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of string args", function () {
  const argv = parseArgs([], {
    string: ["foo", "bar", "foo-bar"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo?: string;
        bar?: string;
        "foo-bar"?: string;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of string args with defaults", function () {
  const argv = parseArgs([], {
    string: ["foo", "bar", "foo-bar"],
    default: {
      bar: true,
      baz: 123,
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo?: string;
        bar: string | boolean;
        baz: unknown;
        "foo-bar"?: string;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of boolean and string args", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "bar", "foo-bar"],
    string: ["beep", "boop", "beep-boop"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        beep?: string;
        boop?: string;
        "beep-boop"?: string;
        foo: boolean;
        bar: boolean;
        "foo-bar": boolean;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of boolean and string args with defaults", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "bar", "foo-bar"],
    string: ["beep", "boop", "beep-boop"],
    default: {
      bar: 123,
      baz: new Error(),
      beep: new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: boolean;
        boop?: string;
        "beep-boop"?: string;
        bar: number | boolean;
        baz: unknown;
        beep: string | Date;
        "foo-bar": boolean;
        _: Array<string | number>;
      }
    >
  >(true);
});

/** ------------------------ DOTTED OPTIONS ------------------------ */

Deno.test("parseArgs() handles types of dotted boolean args", function () {
  const argv = parseArgs([], {
    boolean: ["blubb", "foo.bar", "foo.baz.biz", "foo.baz.buz"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        blubb: boolean;
        foo: {
          bar: boolean;
          baz: {
            biz: boolean;
            buz: boolean;
          };
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted boolean args with defaults", function () {
  const argv = parseArgs([], {
    boolean: ["blubb", "foo.bar", "foo.baz.biz", "foo.baz.buz"],
    default: {
      blubb: "123",
      foo: {
        bar: 123,
        baz: {
          biz: new Date(),
        },
      },
      bla: new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        blubb: boolean | string;
        foo: {
          bar: boolean | number;
          baz: {
            biz: boolean | Date;
            buz: boolean;
          };
        };
        bla: unknown;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted string args", function () {
  const argv = parseArgs([], {
    string: ["blubb", "foo.bar", "foo.baz.biz", "foo.baz.buz"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        blubb?: string;
        foo?: {
          bar?: string;
          baz?: {
            biz?: string;
            buz?: string;
          };
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted string args with defaults", function () {
  const argv = parseArgs([], {
    string: ["blubb", "foo.bar", "foo.baz.biz", "foo.baz.buz"],
    default: {
      blubb: true,
      foo: {
        bar: 123,
        baz: {
          biz: new Date(),
        },
      },
      bla: new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        blubb: string | boolean;
        foo: {
          bar: string | number;
          baz: {
            biz: string | Date;
            buz?: string;
          };
        };
        bla: unknown;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted string and boolean args", function () {
  const argv = parseArgs([], {
    boolean: ["blubb", "foo.bar", "foo.baz.biz", "beep.bib.bub"],
    string: ["bla", "beep.boop", "beep.bib.bab", "foo.baz.buz"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        blubb: boolean;
        foo: {
          bar: boolean;
          baz: {
            biz: boolean;
            buz?: string;
          };
        };
        bla?: string;
        beep: {
          boop?: string;
          bib: {
            bab?: string;
            bub: boolean;
          };
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted string and boolean args with defaults", function () {
  const argv = parseArgs([], {
    boolean: ["blubb", "foo.bar", "foo.baz.biz", "beep.bib.bub"],
    string: ["beep.boop", "beep.bib.bab", "foo.baz.buz"],
    default: {
      blubb: true,
      foo: {
        bar: 123,
        baz: {
          biz: new Date(),
        },
      },
      beep: {
        boop: true,
        bib: {
          bab: new Date(),
        },
      },
      bla: new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        bla: unknown;
        blubb: boolean;
        foo: {
          bar: boolean | number;
          baz: {
            biz: boolean | Date;
            buz?: string;
          };
        };
        beep: {
          boop: string | boolean;
          bib: {
            bab: string | Date;
            bub: boolean;
          };
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted string and boolean args with flatted defaults", function () {
  const argv = parseArgs([], {
    boolean: ["blubb", "foo.bar", "foo.baz.biz", "beep.bib.bub"],
    string: ["beep.boop", "beep.bib.bab", "foo.baz.buz"],
    default: {
      bla: new Date(),
      blubb: true,
      "foo.bar": 123,
      "foo.baz.biz": new Date(),
      "beep.boop": true,
      "beep.bib.bab": new Date(),
      "mee.moo": true,
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        bla: unknown;
        blubb: boolean;
        mee: unknown;
        foo: {
          bar: boolean | number;
          baz: {
            biz: boolean | Date;
            buz?: string;
          };
        };
        beep: {
          boop: string | boolean;
          bib: {
            bab: string | Date;
            bub: boolean;
          };
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted args with union defaults", function () {
  const argv = parseArgs([], {
    string: ["foo.bar.baz"],
    boolean: ["beep.boop.bab"],
    default: {
      "foo": 1,
      "beep": new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: number | {
          bar?: {
            baz?: string;
          };
        };
        beep: Date | {
          boop: {
            bab: boolean;
          };
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of dotted args with nested union defaults", function () {
  const argv = parseArgs([], {
    string: ["foo.bar.baz"],
    boolean: ["beep.boop.bab"],
    default: {
      "foo.bar": 1,
      "beep.boop": new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: {
          bar: number | {
            baz?: string;
          };
        };
        beep: {
          boop: Date | {
            bab: boolean;
          };
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of args with dotted defaults", function () {
  const argv = parseArgs([], {
    string: ["foo"],
    default: {
      "foo.bar": 1,
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: string | {
          bar: number;
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

/** ------------------------ COLLECT OPTION -------------------------- */

Deno.test("parseArgs() handles types of collect unknown args", function () {
  const argv = parseArgs([], {
    collect: ["foo", "bar.baz"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: Array<unknown>;
        bar: {
          baz: Array<unknown>;
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of collect args", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "dotted.beep"],
    string: ["bar", "dotted.boop"],
    collect: ["foo", "dotted.boop"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        bar?: string;
        dotted: {
          boop: Array<string>;
          beep: boolean;
        };
        foo: Array<boolean>;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of collect args with defaults", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "dotted.beep"],
    string: ["bar", "dotted.boop"],
    collect: ["foo", "dotted.boop"],
    default: {
      bar: 123,
      dotted: {
        beep: new Date(),
        boop: /.*/,
      },
      foo: new TextDecoder(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        bar: number | string;
        foo: TextDecoder | Array<boolean>;
        dotted: {
          beep: boolean | Date;
          boop: RegExp | Array<string>;
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of collect args with single args", function () {
  const argv = parseArgs([], {
    boolean: ["foo"],
    collect: ["foo"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: Array<boolean>;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of collect args with empty type array", function () {
  const argv = parseArgs([], {
    boolean: [],
    collect: ["foo"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: Array<unknown>;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of collect args with unknown args", function () {
  const argv = parseArgs([], {
    boolean: ["bar"],
    collect: ["foo"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        bar: boolean;
        foo: Array<unknown>;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of collect args with known and unknown args", function () {
  const argv = parseArgs([], {
    boolean: ["foo"],
    collect: ["foo", "bar"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: Array<boolean>;
        bar: Array<unknown>;
        _: Array<string | number>;
      }
    >
  >(true);
});

// https://github.com/denoland/std/issues/6773
Deno.test("parseArgs() does not call unknown() when collecting known args", () => {
  let called = 0;

  parseArgs(["--foo=bar"], {
    collect: ["foo"],
    unknown: () => called++,
  });

  assertEquals(called, 0);
});

Deno.test("parseArgs() calls unknown() for uncollected args", () => {
  let called = 0;

  parseArgs(["--foo=bar", "--qux=baz"], {
    collect: ["baz", "bar"],
    unknown: () => called++,
  });

  assertEquals(called, 2);
});

/** -------------------------- NEGATABLE OPTIONS --------------------------- */

Deno.test("parseArgs() handles types of negatable args", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "bar", "dotted.tick", "dotted.tock"],
    string: ["beep", "boop", "dotted.zig", "dotted.zag"],
    negatable: ["bar", "boop", "dotted.tick", "dotted.zig"],
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        beep?: string;
        boop?: string | false;
        dotted: {
          zig?: string | false;
          zag?: string;
          tick: boolean;
          tock: boolean;
        };
        foo: boolean;
        bar: boolean;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of collect all args with defaults", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "bar", "dotted.tick", "dotted.tock"],
    string: ["beep", "boop", "dotted.zig", "dotted.zag"],
    negatable: ["bar", "boop", "dotted.tick", "dotted.zig"],
    default: {
      bar: 123,
      boop: new TextDecoder(),
      dotted: {
        tick: new Date(),
        zig: /.*/,
      },
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo: boolean;
        beep?: string;
        bar: number | boolean;
        boop: string | false | TextDecoder;
        dotted: {
          zag?: string;
          tock: boolean;
          tick: boolean | Date;
          zig: string | false | RegExp;
        };
        _: Array<string | number>;
      }
    >
  >(true);
});

/** ----------------------------- ALIAS OPTION ----------------------------- */

Deno.test("parseArgs() handles types of alias args", function () {
  const argv = parseArgs([], {
    boolean: ["foo"],
    string: ["beep"],
    alias: {
      foo: ["bar", "baz"],
      beep: "boop",
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        beep?: string;
        boop?: string;
        foo: boolean;
        bar: boolean;
        baz: boolean;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of alias args with options", function () {
  const argv = parseArgs([], {
    boolean: ["foo", "biz"],
    string: ["beep", "bib"],
    negatable: ["foo", "beep"],
    alias: {
      foo: "bar",
      beep: "boop",
      biz: "baz",
    },
    default: {
      foo: 1,
      beep: new Date(),
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        baz: boolean;
        biz: boolean;
        bib?: string;
        foo: number | boolean;
        bar: number | boolean;
        beep: string | false | Date;
        boop: string | false | Date;
        _: Array<string | number>;
      }
    >
  >(true);
});

/** ----------------------- OTHER TYPE TESTS ------------------------ */

Deno.test("parseArgs() handles types of double dash option", function () {
  const argv = parseArgs([], {
    boolean: true,
    string: ["foo"],
    "--": true,
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo?: string;
        _: Array<string | number>;
        "--": Array<string>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of nullish defaults", function () {
  const argv = parseArgs([], {
    boolean: true,
    string: ["foo", "bar", "baz"],
    default: {
      bar: undefined,
      baz: null,
    },
  });
  assertType<
    IsExact<
      typeof argv,
      & { [x: string]: unknown }
      & {
        foo?: string;
        bar: string | undefined;
        baz: string | null;
        _: Array<string | number>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of parse generics", function () {
  const argv = parseArgs<{ foo?: number } & { bar: string }, true>([]);
  assertType<
    IsExact<
      typeof argv,
      {
        foo?: number;
        bar: string;
        _: Array<string | number>;
        "--": Array<string>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of args generics", function () {
  type ArgsResult = Args<{ foo?: number } & { bar: string }, true>;
  assertType<
    IsExact<
      ArgsResult,
      {
        foo?: number;
        bar: string;
        _: Array<string | number>;
        "--": Array<string>;
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of parse options generics", function () {
  type Opts = ParseOptions<"foo", "bar" | "baz">;
  assertType<
    IsExact<
      Pick<Opts, "string">,
      { string?: "bar" | "baz" | ReadonlyArray<"bar" | "baz"> }
    >
  >(true);

  assertType<
    IsExact<
      Pick<Opts, "boolean">,
      { boolean?: "foo" | ReadonlyArray<"foo"> }
    >
  >(true);

  assertType<
    IsExact<
      Pick<Opts, "default">,
      {
        default?: {
          [x: string]: unknown;
          bar?: unknown;
          baz?: unknown;
          foo?: unknown;
        };
      }
    >
  >(true);
});

Deno.test("parseArgs() handles types of parse options generic defaults", function () {
  const opts: ParseOptions = {
    boolean: ["foo"],
    string: ["bar"],
  };

  const args = parseArgs([], opts);

  assertType<
    IsExact<
      typeof args,
      {
        // deno-lint-ignore no-explicit-any
        [x: string]: any;
        _: (string | number)[];
        "--"?: string[];
      }
    >
  >(true);
});

Deno.test("parseArgs() handles collect with alias", () => {
  const args = ["--header", "abc", "--header", "def"];
  const parsed = parseArgs(args, {
    collect: ["header"],
    alias: {
      H: "header",
    },
  });
  assertEquals(parsed.header, ["abc", "def"]);
});

Deno.test("parseArgs() throws if the alias value is undefined", () => {
  assertThrows(
    () => {
      parseArgs([], {
        alias: {
          h: undefined,
        },
      });
    },
    Error,
    "Alias value must be defined",
  );
});



================================================
FILE: cli/prompt_secret.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { isWindows } from "@std/internal/os";
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const LF = "\n".charCodeAt(0); // ^J - Enter on Linux
const CR = "\r".charCodeAt(0); // ^M - Enter on macOS and Windows (CRLF)
const BS = "\b".charCodeAt(0); // ^H - Backspace on Linux and Windows
const DEL = 0x7f; // ^? - Backspace on macOS
const CLR = encoder.encode("\r\u001b[K"); // Clear the current line
const MOVE_LINE_UP = encoder.encode("\r\u001b[1F"); // Move to previous line

// The `cbreak` option is not supported on Windows
const setRawOptions = isWindows ? undefined : { cbreak: true };

/** Options for {@linkcode promptSecret}. */
export type PromptSecretOptions = {
  /** A character to print instead of the user's input. */
  mask?: string;
  /** Clear the current line after the user's input. */
  clear?: boolean;
};

/**
 * Shows the given message and waits for the user's input. Returns the user's input as string.
 * This is similar to `prompt()` but it print user's input as `*` to prevent password from being shown.
 * Use an empty `mask` if you don't want to show any character.
 *
 * @param message The prompt message to show to the user.
 * @param options The options for the prompt.
 * @returns The string that was entered or `null` if stdin is not a TTY.
 *
 * @example Usage
 * ```ts ignore
 * import { promptSecret } from "@std/cli/prompt-secret";
 *
 * const password = promptSecret("Please provide the password:");
 * if (password !== "some-password") {
 *   throw new Error("Access denied");
 * }
 * ```
 */
export function promptSecret(
  message = "Secret",
  options?: PromptSecretOptions,
): string | null {
  const input = Deno.stdin;
  const output = Deno.stdout;
  const { mask = "*", clear } = options ?? {};

  if (!input.isTerminal()) {
    return null;
  }

  const { columns } = Deno.consoleSize();
  let previousLength = 0;
  // Make the output consistent with the built-in prompt()
  message += " ";
  const callback = !mask ? undefined : (n: number) => {
    let line = `${message}${mask.repeat(n)}`;
    const currentLength = line.length;
    const charsPastLineLength = line.length % columns;

    if (line.length > columns) {
      line = line.slice(
        -1 * (charsPastLineLength === 0 ? columns : charsPastLineLength),
      );
    }

    // If the user has deleted a character
    if (currentLength < previousLength) {
      // Then clear the current line.
      output.writeSync(CLR);
      if (charsPastLineLength === 0) {
        // And if there's no characters on the current line, return to previous line.
        output.writeSync(MOVE_LINE_UP);
      }
    } else {
      // Always jump the cursor back to the beginning of the line unless it's the first character.
      if (charsPastLineLength !== 1) {
        output.writeSync(CLR);
      }
    }

    output.writeSync(encoder.encode(line));

    previousLength = currentLength;
  };

  output.writeSync(encoder.encode(message));

  input.setRaw(true, setRawOptions);
  try {
    return readLineFromStdinSync(callback);
  } finally {
    if (clear) {
      output.writeSync(CLR);
    } else {
      output.writeSync(encoder.encode("\n"));
    }
    input.setRaw(false);
  }
}

// Slightly modified from Deno's runtime/js/41_prompt.js
// This implementation immediately break on CR or LF and accept callback.
// The original version waits LF when CR is received.
// https://github.com/denoland/deno/blob/e4593873a9c791238685dfbb45e64b4485884174/runtime/js/41_prompt.js#L52-L77
function readLineFromStdinSync(callback?: (n: number) => void): string {
  const c = new Uint8Array(1);
  const buf = [];

  while (true) {
    const n = Deno.stdin.readSync(c);
    if (n === null || n === 0) {
      break;
    }
    if (c[0] === CR || c[0] === LF) {
      break;
    }
    if (c[0] === BS || c[0] === DEL) {
      buf.pop();
    } else {
      buf.push(c[0]!);
    }
    if (callback) callback(buf.length);
  }
  return decoder.decode(new Uint8Array(buf));
}



================================================
FILE: cli/prompt_secret_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { assertEquals } from "@std/assert/equals";
import { promptSecret } from "./prompt_secret.ts";
import { restore, stub } from "@std/testing/mock";

const encoder = new TextEncoder();
const decoder = new TextDecoder();

Deno.test("promptSecret() handles CR", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:");
  assertEquals(password, "");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles LF", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\n",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:");
  assertEquals(password, "");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles input", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\r\x1b[K",
    "Please provide the password: *",
    "\r\x1b[K",
    "Please provide the password: **",
    "\r\x1b[K",
    "Please provide the password: ***",
    "\r\x1b[K",
    "Please provide the password: ****",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "d",
    "e",
    "n",
    "o",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:");

  assertEquals(password, "deno");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles DEL", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\r\x1b[K",
    "Please provide the password: *",
    "\r\x1b[K",
    "Please provide the password: ",
    "\r\x1b[K",
    "Please provide the password: *",
    "\r\x1b[K",
    "Please provide the password: **",
    "\r\x1b[K",
    "Please provide the password: ***",
    "\r\x1b[K",
    "Please provide the password: ****",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "n",
    "\x7f",
    "d",
    "e",
    "n",
    "o",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:");

  assertEquals(password, "deno");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles BS", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\r\x1b[K",
    "Please provide the password: *",
    "\r\x1b[K",
    "Please provide the password: ",
    "\r\x1b[K",
    "Please provide the password: *",
    "\r\x1b[K",
    "Please provide the password: **",
    "\r\x1b[K",
    "Please provide the password: ***",
    "\r\x1b[K",
    "Please provide the password: ****",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "n",
    "\b",
    "d",
    "e",
    "n",
    "o",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:");

  assertEquals(password, "deno");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles clear option", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\r\x1b[K",
    "Please provide the password: *",
    "\r\x1b[K",
    "Please provide the password: **",
    "\r\x1b[K",
    "Please provide the password: ***",
    "\r\x1b[K",
    "Please provide the password: ****",
    "\r\x1b[K",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "d",
    "e",
    "n",
    "o",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:", {
    clear: true,
  });

  assertEquals(password, "deno");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles mask option", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\r\x1b[K",
    "Please provide the password: $",
    "\r\x1b[K",
    "Please provide the password: $$",
    "\r\x1b[K",
    "Please provide the password: $$$",
    "\r\x1b[K",
    "Please provide the password: $$$$",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "d",
    "e",
    "n",
    "o",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:", { mask: "$" });

  assertEquals(password, "deno");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles empty mask option", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "d",
    "e",
    "n",
    "o",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("Please provide the password:", { mask: "" });

  assertEquals(password, "deno");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() returns null if Deno.stdin.isTerminal() is false", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => false);

  const expectedOutput: string[] = [];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  const password = promptSecret("Please provide the password:");
  assertEquals(password, null);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles null readSync", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  stub(Deno.stdin, "readSync", () => null);

  const password = promptSecret("Please provide the password:");

  assertEquals(password, "");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() handles empty readSync", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 80, rows: 20 };
  });

  const expectedOutput = [
    "Please provide the password: ",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  stub(Deno.stdin, "readSync", () => 0);

  const password = promptSecret("Please provide the password:");

  assertEquals(password, "");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() wraps characters wider than console columns", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 5, rows: 20 };
  });

  const expectedOutput = [
    "? ",
    "\r\x1b[K",
    "? *",
    "\r\x1b[K",
    "? **",
    "\r\x1b[K",
    "? ***",
    "*",
    "\r\x1b[K",
    "**",
    "\r\x1b[K",
    "***",
    "\r\x1b[K",
    "****",
    "\r\x1b[K",
    "*****",
    "*",
    "\r\x1b[K",
    "**",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "d",
    "e",
    "n",
    "o",
    " ",
    "r",
    "u",
    "l",
    "e",
    "s",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("?");

  assertEquals(password, "deno rules");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSecret() returns to previous line when deleting characters", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => {
    return { columns: 6, rows: 20 };
  });

  const expectedOutput = [
    "? ",
    "\r\u001b[K",
    "? *",
    "\r\u001b[K",
    "? **",
    "\r\u001b[K",
    "? ***",
    "\r\u001b[K",
    "? ****",
    "*",
    "\r\u001b[K",
    "**",
    "\r\u001b[K",
    "***",
    "\r\u001b[K",
    "****",
    "\r\u001b[K",
    "*****",
    "\r\u001b[K",
    "******",
    "*",
    "\r\u001b[K",
    "**",
    "\r\u001b[K",
    "***",
    "\r\u001b[K",
    "**",
    "\r\u001b[K",
    "*",
    "\r\u001b[K",
    "\r\u001b[1F",
    "******",
    "\r\u001b[K",
    "*****",
    "\r\u001b[K",
    "****",
    "\r\u001b[K",
    "***",
    "\r\u001b[K",
    "**",
    "\r\u001b[K",
    "*",
    "\r\u001b[K",
    "\r\u001b[1F",
    "? ****",
    "\n",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "d",
    "e",
    "n",
    "o",
    " ",
    "r",
    "u",
    "l",
    "e",
    "s",
    "!",
    "!",
    "!",
    "\x7f",
    "\x7f",
    "\x7f",
    "\x7f",
    "\x7f",
    "\x7f",
    "\x7f",
    "\x7f",
    "\x7f",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const password = promptSecret("?");

  assertEquals(password, "deno");
  assertEquals(expectedOutput, actualOutput);
  restore();
});



================================================
FILE: cli/unicode_width.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.
// This module is browser compatible.
// Ported from unicode_width rust crate, Copyright (c) 2015 The Rust Project Developers. MIT license.

import data from "./_data.json" with { type: "json" };
import { runLengthDecode } from "./_run_length.ts";

let tables: Uint8Array[] | null = null;
function lookupWidth(cp: number) {
  if (!tables) tables = data.tables.map(runLengthDecode);
  const t1Offset = tables[0]![(cp >> 13) & 0xff]!;
  const t2Offset = tables[1]![128 * t1Offset + ((cp >> 6) & 0x7f)]!;
  const packedWidths = tables[2]![16 * t2Offset + ((cp >> 2) & 0xf)]!;

  const width = (packedWidths >> (2 * (cp & 0b11))) & 0b11;

  return width === 3 ? 1 : width;
}

const cache = new Map<string, number | null>();
function charWidth(char: string) {
  if (cache.has(char)) return cache.get(char)!;

  const codePoint = char.codePointAt(0)!;
  let width: number | null = null;

  if (codePoint < 0x7f) {
    width = codePoint >= 0x20 ? 1 : codePoint === 0 ? 0 : null;
  } else if (codePoint >= 0xa0) {
    width = lookupWidth(codePoint);
  } else {
    width = null;
  }

  cache.set(char, width);
  return width;
}

/**
 * Calculate the physical width of a string in a TTY-like environment. This is
 * useful for cases such as calculating where a line-wrap will occur and
 * underlining strings.
 *
 * The physical width is given by the number of columns required to display
 * the string. The number of columns a given unicode character occupies can
 * vary depending on the character itself.
 *
 * @param str The string to measure.
 * @returns The unicode width of the string.
 *
 * @example Calculating the unicode width of a string
 * ```ts
 * import { unicodeWidth } from "@std/cli/unicode-width";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(unicodeWidth("hello world"), 11);
 * assertEquals(unicodeWidth("天地玄黃宇宙洪荒"), 16);
 * assertEquals(unicodeWidth("ｆｕｌｌｗｉｄｔｈ"), 18);
 * ```
 *
 * @example Calculating the unicode width of a color-encoded string
 * ```ts
 * import { unicodeWidth } from "@std/cli/unicode-width";
 * import { stripAnsiCode } from "@std/fmt/colors";
 * import { assertEquals } from "@std/assert";
 *
 * assertEquals(unicodeWidth(stripAnsiCode("\x1b[36mголубой\x1b[39m")), 7);
 * assertEquals(unicodeWidth(stripAnsiCode("\x1b[31m紅色\x1b[39m")), 4);
 * assertEquals(unicodeWidth(stripAnsiCode("\x1B]8;;https://deno.land\x07🦕\x1B]8;;\x07")), 2);
 * ```
 *
 * Use
 * {@linkcode https://jsr.io/@std/fmt/doc/colors/~/stripAnsiCode | stripAnsiCode}
 * to remove ANSI escape codes from a string before passing it to
 * {@linkcode unicodeWidth}.
 */
export function unicodeWidth(str: string): number {
  return [...str].map((ch) => charWidth(ch) ?? 0).reduce((a, b) => a + b, 0);
}



================================================
FILE: cli/unicode_width_test.ts
================================================
[Binary file]


================================================
FILE: cli/unstable_ansi.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

/**
 * Ansi is a module that offers export function s and variables that returns
 * various Ansi Escape Sequences. This class is not an exhaustive list of what
 * is possible with Ansi Escape Sequences, nor does it guarantee that every
 * code will work in every terminal. The only way to guarantee that only one
 * code will work in a particular terminal, is to check for yourself. Calling
 * these export function s and variables does not automatically change the
 * terminal settings. Only once they are passed to stdout or stderr will they
 * take effect.
 *
 * These codes were based off the
 * [xterm reference](https://invisible-island.net/xterm/ctlseqs/ctlseqs.html).
 *
 * @example Basic Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.DOUBLE_HEIGHT_TOP + "Hello World!");
 * console.log(Ansi.DOUBLE_HEIGHT_BOTTOM + "Hello World!");
 * ```
 *
 * @module
 */

/**
 * Causes content on the current line to enlarge, showing only the top half
 * of characters with each character taking up two columns. Can be used in
 * combination with {@linkcode DOUBLE_HEIGHT_BOTTOM} on the next line to
 * make text appear twice as big.
 *
 * @returns The ANSI escape code for double-height top.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.DOUBLE_HEIGHT_TOP + "Hello World!");
 * console.log(Ansi.DOUBLE_HEIGHT_BOTTOM + "Hello World!");
 * ```
 */
export const DOUBLE_HEIGHT_TOP = "\x1b#3";

/**
 * Causes content on the current line to enlarge, showing only the bottom
 * half of the characters with each character taking up two columns. Can be
 * used in combination with {@linkcode DOUBLE_HEIGHT_TOP} on the previous
 * line to make text appear twice as big.
 *
 * @returns The ANSI escape code for double-height bottom.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.DOUBLE_HEIGHT_TOP + "Hello World!");
 * console.log(Ansi.DOUBLE_HEIGHT_BOTTOM + "Hello World!");
 * ```
 */
export const DOUBLE_HEIGHT_BOTTOM = "\x1b#4";

/**
 * Causes content on the current line to shrink down to a single column,
 * essentially reverting the effects of {@linkcode DOUBLE_HEIGHT_TOP},
 * {@linkcode DOUBLE_HEIGHT_BOTTOM}, or {@linkcode DOUBLE_WIDTH}.
 *
 * @returns The ANSI escape code for single-width.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.DOUBLE_HEIGHT_TOP + "Hello World!");
 * console.log(Ansi.DOUBLE_HEIGHT_BOTTOM + "Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUpStart(2) +
 *     Ansi.deleteLines(1) +
 *     Ansi.SINGLE_WIDTH,
 * );
 * ```
 */
export const SINGLE_WIDTH = "\x1b#5";

/**
 * Causes content on the current line to stretch out, with each character
 * taking up two columns. Can be reverted with {@linkcode SINGLE_WIDTH}.
 *
 * @returns The ANSI escape code for double-width.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.DOUBLE_WIDTH + "Hello World!");
 * ```
 */
export const DOUBLE_WIDTH = "\x1b#6";

/**
 * Saves:
 * - cursor position
 * - graphic rendition
 * - character set shift state
 * - state of wrap flag {@linkcode ENABLE_AUTO_WRAP}
 * - state of origin mode {@linkcode ENABLE_ORIGIN_MODE}
 * - selective eraser
 *
 * Can be restored with {@linkcode RESTORE_CURSOR}.
 *
 * @returns The ANSI escape code for saving cursor.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.SAVE_CURSOR +
 *     Ansi.setCursorPosition(Deno.consoleSize().rows, 1) +
 *     Ansi.ERASE_LINE +
 *     "Hello World!" +
 *     Ansi.RESTORE_CURSOR,
 * );
 * ```
 */
export const SAVE_CURSOR = "\x1b7";

/**
 * Restores:
 * - cursor position
 * - graphic rendition
 * - character set shift state
 * - state of wrap flag {@linkcode ENABLE_AUTO_WRAP}
 * - state of origin mode {@linkcode ENABLE_ORIGIN_MODE}
 * - selective eraser
 *
 * Can be saved with {@linkcode SAVE_CURSOR}.
 *
 * @returns The ANSI escape code for restoring cursor.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.SAVE_CURSOR +
 *     Ansi.setCursorPosition(Deno.consoleSize().rows) +
 *     Ansi.ERASE_LINE +
 *     "Hello World!" +
 *     Ansi.RESTORE_CURSOR,
 * );
 * ```
 */
export const RESTORE_CURSOR = "\x1b8";

/**
 * This is a full reset of the terminal, reverting it back to its original
 * default settings, clearing the screen, resetting modes, colors, character
 * sets and more. Essentially making the terminal behave as if it were just
 * started by the user. This command is very disruptive to the user. Also see
 * {@linkcode SOFT_RESET}.
 *
 * @returns The ANSI escape code for hard resetting the terminal.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.HIDE_CURSOR);
 * await delay(5000);
 * console.log(Ansi.HARD_RESET);
 * ```
 */
export const HARD_RESET = "\x1bc";

/**
 * This command resets many settings to their initial state without fully
 * reinitializing the terminal like {@linkcode HARD_RESET}. It preserves
 * things like cursor position and display content, but clears modes,
 * character sets, etc. Should probably be called when exiting the program.
 *
 * @returns The ANSI escape code for soft resetting the terminal.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.HIDE_CURSOR);
 * await delay(5000);
 * console.log(Ansi.SOFT_RESET);
 * ```
 */
export const SOFT_RESET = "\x1b[!p";

/**
 * Inserts `x` spaces at the cursor position. Shifting existing line content
 * to the right. Cursor position does not change. Characters that exit the
 * display are discarded.
 *
 * @param x The number of spaces to insert.
 * @returns The ANSI escape code for inserting spaces.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(6) +
 *     Ansi.insertSpace(10),
 * );
 * ```
 */
export function insertSpace(x = 1): string {
  return `\x1b[${x}@`;
}

/**
 * Deletes `x` characters at cursor position and to the right. Shifting line
 * content left.
 *
 * @param x The number of characters to delete.
 * @returns The ANSI escape code for deleting characters.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUpStart() +
 *     Ansi.deleteCharacters(5) +
 *     "Bye",
 * );
 * ```
 */
export function deleteCharacters(x = 1): string {
  return `\x1b[${x}P`;
}

/**
 * Erases `x` characters at cursor position and to the right.
 *
 * @param x The number of characters to erase.
 * @returns The ANSI escape code for erasing characters.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     Ansi.eraseCharacters(6) +
 *     "Bob!",
 * );
 * ```
 */
export function eraseCharacters(x = 1): string {
  return `\x1b[${x}X`;
}

/**
 * Inserts `x` lines at cursor position. Shifting current line and below
 * down. Cursor position does not change. Characters that exit the display
 * are discarded.
 *
 * @param x The number of lines to insert.
 * @returns The ANSI escape code for inserting lines.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello\nWorld!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUpStart() +
 *     Ansi.insertLines() +
 *     "and Goodbye",
 * );
 * ```
 */
export function insertLines(x = 1): string {
  return `\x1b[${x}L`;
}

/**
 * Deletes `x` lines at cursor position. Shifting below lines up.
 *
 * @param x The number of lines to delete.
 * @returns The ANSI escape code for deleting lines.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello\nWorld!");
 * await delay(1000);
 * console.log(Ansi.moveCursorUpStart() + Ansi.deleteLines());
 * await delay(1000);
 * console.log("and Goodbye!");
 * ```
 */
export function deleteLines(x = 1): string {
  return `\x1b[${x}M`;
}

/**
 * Moves cursor position up `x` lines or up to the top margin.
 *
 * @param x The number of lines to move up.
 * @returns The ANSI escape code for moving the cursor up.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello\nWorld!");
 * await delay(1000);
 * console.log(Ansi.moveCursorUp(2) + "Goodbye");
 * ```
 */
export function moveCursorUp(x = 1): string {
  return `\x1b[${x}A`;
}

/**
 * Moves cursor position `x` lines up or up to the top of the margin, and to
 * the beginning of that line.
 *
 * @param x The number of lines to move up.
 * @returns The ANSI escape code for moving the cursor up and to the
 * beginning of the line.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello\nWorld!");
 * await delay(1000);
 * console.log(Ansi.moveCursorUpStart(2) + "Goodbye");
 * ```
 */
export function moveCursorUpStart(x = 1): string {
  return `\x1b[${x}F`;
}

/**
 * Moves cursor position down `x` lines or up to the bottom margin.
 *
 * @param x The number of lines to move down.
 * @returns The ANSI escape code for moving the cursor down.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello\nWorld!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUpStart(2) +
 *     "Goodbye" +
 *     Ansi.moveCursorDown() +
 *     Ansi.setCursorColumn() +
 *     Ansi.ERASE_LINE +
 *     "Bob!",
 * );
 * ```
 */
export function moveCursorDown(x = 1): string {
  return `\x1b[${x}B`;
}

/**
 * Moves cursor position `x` lines down or up to the bottom margin, and to
 * the beginning of that line.
 *
 * @param x The number of lines to move down.
 * @returns The ANSI escape code for moving the cursor down and to the
 * beginning of the line.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello\nWorld!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUpStart(2) +
 *     "Goodbye" +
 *     Ansi.moveCursorDownStart() +
 *     Ansi.ERASE_LINE +
 *     "Bob!",
 * );
 * ```
 */
export function moveCursorDownStart(x = 1): string {
  return `\x1b[${x}E`;
}

/**
 * Moves cursor position `x` columns right or up to the right margin.
 *
 * @param x The number of columns to move right.
 * @returns The ANSI escape code for moving the cursor right.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.moveCursorRight(2) + "Hello World!");
 * ```
 */
export function moveCursorRight(x = 1): string {
  return `\x1b[${x}C`;
}

/**
 * Moves cursor position `x` tab stops right or up to the right margin.
 *
 * @param x The number of tab stops to move right.
 * @returns The ANSI escape code for moving the cursor right every tab
 * stop.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.moveCursorRightTab() + "Hello World!");
 * ```
 */
export function moveCursorRightTab(x = 1): string {
  return `\x1b[${x}I`;
}

/**
 * Moves cursor position `x` columns left or up to the left margin.
 *
 * @param x The number of columns to move left.
 * @returns The ANSI escape code for moving the cursor left.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.moveCursorRight(4) +
 *     Ansi.moveCursorLeft(2) +
 *     "Hello World!",
 * );
 * ```
 */
export function moveCursorLeft(x = 1): string {
  return `\x1b[${x}D`;
}

/**
 * Moves cursor position `x` tab stops left or up to the left margin.
 *
 * @param x The number of tab stops to move left.
 * @returns The ANSI escape code for moving the cursor left every tab
 * stop.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.moveCursorRightTab(2) +
 *     Ansi.moveCursorLeftTab() +
 *     "Hello World!",
 * );
 * ```
 */
export function moveCursorLeftTab(x = 1): string {
  return `\x1b[${x}Z`;
}

/**
 * Sets cursor position to column `x` or up to the sides of the margins.
 * Columns begin at `1` not `0`.
 *
 * @param x The column to move to.
 * @returns The ANSI escape code for setting the cursor column.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     "and Goodbye!",
 * );
 * ```
 */
export function setCursorColumn(x = 1): string {
  return `\x1b[${x}G`;
}

/**
 * Sets cursor position to line `x` or down to the bottom of the margin.
 * Lines begin at `1` not `0`.
 *
 * @param x The line to move to.
 * @returns The ANSI escape code for setting the cursor line.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.setCursorLine() + Ansi.ERASE_LINE + "Hello World!");
 * ```
 */
export function setCursorLine(x = 1): string {
  return `\x1b[${x}d`;
}

/**
 * Sets cursor position to `x` line and `y` column or up to the margin. Lines
 * and columns begin at `1` not `0`.
 *
 * @param x The line to move to.
 * @param y The column to move to.
 * @returns The ANSI escape code for setting the cursor position.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.setCursorPosition(5, 2) +
 *   Ansi.ERASE_LINE +
 *   "Hello World!",
 * );
 * ```
 */
export function setCursorPosition(x = 1, y = 1): string {
  return `\x1b[${x};${y}H`;
}

/**
 * Erases line content to the right of cursor position.
 *
 * @returns The ANSI escape code for erasing the line content to the
 * right of the cursor.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     Ansi.ERASE_LINE_AFTER_CURSOR,
 * );
 * ```
 */
export const ERASE_LINE_AFTER_CURSOR = "\x1b[0K";

/**
 * Erases line content to the left of cursor position.
 *
 * @returns The ANSI escape code for erasing the line content to the
 * left of the cursor.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     Ansi.ERASE_LINE_BEFORE_CURSOR,
 * );
 * ```
 */
export const ERASE_LINE_BEFORE_CURSOR = "\x1b[1K";

/**
 * Erases entire line content.
 *
 * @returns The ANSI escape code for erasing the entire line content.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(Ansi.moveCursorUp() + Ansi.ERASE_LINE);
 * ```
 */
export const ERASE_LINE = "\x1b[2K";

/**
 * Erases content of lines below cursor position and content to the right on
 * the same line as cursor.
 *
 * @returns The ANSI escape code for erasing the content after the
 * cursor.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     Ansi.ERASE_DISPLAY_AFTER_CURSOR,
 * );
 * ```
 */
export const ERASE_DISPLAY_AFTER_CURSOR = "\x1b[0J";

/**
 * Erases content of lines above cursor position and content to the left on
 * the same line as cursor.
 *
 * @returns The ANSI escape code for erasing the content before the
 * cursor.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     Ansi.ERASE_DISPLAY_BEFORE_CURSOR,
 * );
 * ```
 */
export const ERASE_DISPLAY_BEFORE_CURSOR = "\x1b[1J";

/**
 * Erases all content.
 *
 * @returns The ANSI escape code for erasing the entire display.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(Ansi.ERASE_DISPLAY);
 * ```
 */
export const ERASE_DISPLAY = "\x1b[2J";

/**
 * Shifts content within the scrollable region up `x` lines, inserting blank
 * lines at the bottom of the scrollable region.
 *
 * @param x The number of lines content should be shifted up.
 * @returns The ANSI escape code for shifting content up.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.shiftUpAndInsert());
 * ```
 */
export function shiftUpAndInsert(x = 1): string {
  return `\x1b[${x}S`;
}

/**
 * Shifts content within the scrollable region down `x` lines, inserting
 * blank lines at the top of the scrollable region.
 *
 * @param x The number of lines content should be shifted down.
 * @returns The ANSI escape code for shifting content down.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.shiftDownAndInsert(3));
 * ```
 */
export function shiftDownAndInsert(x = 1): string {
  return `\x1b[${x}T`;
}

/**
 * Repeats last graphic character printed `x` times at cursor position.
 *
 * @param x The number of times the last character printed should be repeated.
 * @returns The ANSI escape code for repeating the last printed
 * character.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!" + Ansi.repeatLastCharacter(4));
 * ```
 */
export function repeatLastCharacter(x = 1): string {
  return `\x1b[${x}b`;
}

/**
 * Causes existing characters to the right of the cursor position to shift
 * right as new characters are written. Opposite of
 * {@linkcode REPLACE_MODE}.
 *
 * @returns The ANSI escape code for entering insert mode.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.INSERT_MODE +
 *     Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     "and Goodbye " +
 *     Ansi.REPLACE_MODE,
 * );
 * ```
 */
export const INSERT_MODE = "\x1b[4h";

/**
 * Causes existing characters to be overwritten at the cursor position by new
 * characters. See also {@linkcode INSERT_MODE}.
 *
 * @returns The ANSI escape code for entering replace mode.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log("Hello World!");
 * await delay(1000);
 * console.log(
 *   Ansi.INSERT_MODE +
 *     Ansi.moveCursorUp() +
 *     Ansi.setCursorColumn(7) +
 *     "and Goodbye " +
 *     Ansi.REPLACE_MODE,
 * );
 * ```
 */
export const REPLACE_MODE = "\x1b[4l";

/**
 * Causes top and bottom margins to shrink to scrollable region (See
 * {@linkcode setScrollableRegion}) preventing the cursor from moving
 * to the lines outside it.
 *
 * @returns The ANSI escape code for enabling origin mode.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.ERASE_DISPLAY +
 *     Ansi.setCursorPosition() +
 *     "Hello World" +
 *     Ansi.setScrollableRegion(2) +
 *     Ansi.ENABLE_ORIGIN_MODE,
 * );
 * await delay(1000);
 * console.log(Ansi.setCursorPosition() + "Bye World!");
 * ```
 */
export const ENABLE_ORIGIN_MODE = "\x1b[?6h";

/**
 * Causes the top and bottom margins to enlarge to the user's display. See
 * {@linkcode ENABLE_ORIGIN_MODE}.
 *
 * @returns The ANSI escape code for disabling origin mode.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.ERASE_DISPLAY +
 *     Ansi.setCursorPosition() +
 *     "Hello World" +
 *     Ansi.setScrollableRegion(2) +
 *     Ansi.ENABLE_ORIGIN_MODE,
 * );
 * await delay(1000);
 * console.log(Ansi.setCursorPosition() + "Bye World!");
 * await delay(1000);
 * console.log(
 *   Ansi.DISABLE_ORIGIN_MODE +
 *     Ansi.setCursorPosition() +
 *     Ansi.ERASE_LINE +
 *     "Hi World!",
 * );
 * ```
 */
export const DISABLE_ORIGIN_MODE = "\x1b[?6l";

/**
 * Causes cursor to automatically move to the next line when it hits the
 * end of the current line to continue writing. See also
 * {@linkcode DISABLE_AUTO_WRAP}.
 *
 * @returns The ANSI escape code to enable auto-wrap.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.ENABLE_AUTO_WRAP + "A" + "h".repeat(500));
 * ```
 */
export const ENABLE_AUTO_WRAP = "\x1b[?7h";

/**
 * Causes cursor to remain on the same line when it hits the end of the
 * current line. See also {@linkcode ENABLE_AUTO_WRAP}.
 *
 * @returns The ANSI escape code to disable auto-wrap.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.DISABLE_AUTO_WRAP + "A" + "h".repeat(500));
 * ```
 */
export const DISABLE_AUTO_WRAP = "\x1b[?7l";

/**
 * Sets the cursor animation style.
 *
 * @param x The cursor style to set.
 * @returns The ANSI escape code to set the cursor style.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.setCursorStyle(Ansi.CursorStyle.BlinkingUnderline));
 * ```
 */
export function setCursorStyle(x: CursorStyle): string {
  return `\x1b[${x} q`;
}

/**
 * Causes cursor position to be visible to the user. See also
 * {@linkcode HIDE_CURSOR}.
 *
 * @returns The ANSI escape code to show the cursor.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.HIDE_CURSOR);
 * await delay(5000);
 * console.log(Ansi.SHOW_CURSOR);
 * ```
 */
export const SHOW_CURSOR = "\x1b[?25h";

/**
 * Causes cursor position to be hidden from the user. See also
 * {@linkcode SHOW_CURSOR}.
 *
 * @returns The ANSI escape code to hide the cursor.
 *
 * @example Usage
 * ```ts ignore
 * import { delay } from "@std/async/delay";
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.HIDE_CURSOR);
 * await delay(5000);
 * console.log(Ansi.SHOW_CURSOR);
 * ```
 */
export const HIDE_CURSOR = "\x1b[?25l";

/**
 * Sets the scrollable region of the display. Allowing either or both the top
 * and bottom lines to not have their content moved when the scrolling region
 * is updated. `x` is the top line of the scrollable region. `y` is the
 * bottom line of the scrollable region.
 *
 * @param x The top line of the scrollable region.
 * @param y The bottom line of the scrollable region.
 * @returns The ANSI escape code to set the scrollable region.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(
 *   Ansi.ERASE_DISPLAY +
 *     Ansi.setScrollableRegion(3, 10),
 * );
 * setInterval(() => console.log(Math.random()), 1000);
 * ```
 */
export function setScrollableRegion(x = 1, y?: number): string {
  return `\x1b[${x}${y == undefined ? "" : `;${y}`}r`;
}

/**
 * CursorStyle is a export const enum used to set the value in
 * {@linkcode setCursorStyle}.
 *
 * @example Usage
 * ```ts ignore
 * import * as Ansi from "@std/cli/unstable-ansi";
 *
 * console.log(Ansi.setCursorStyle(Ansi.CursorStyle.BlinkingUnderline));
 * ```
 */
export const enum CursorStyle {
  Default = 0,
  BlinkingBlock = 1,
  SteadyBlock = 2,
  BlinkingUnderline = 3,
  SteadyUnderline = 4,
  BlinkingBar = 5,
  SteadyBar = 6,
}



================================================
FILE: cli/unstable_progress_bar.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { formatUnitFraction } from "./_unit.ts";

/**
 * The properties provided to the fmt function upon every visual update.
 */
export interface ProgressBarFormatter {
  /**
   * A formatted version of the duration.
   * `mm:ss`
   */
  styledTime: string;
  /**
   * A function that returns a formatted version of the data received.
   * `0.40/97.66 KiB`
   * @param fractions The number of decimal places the values should have.
   */
  styledData: (fractions?: number) => string;
  /**
   * The progress bar string.
   * Default Style: `###-------`
   */
  progressBar: string;
  /**
   * The duration of the progress bar.
   */
  time: number;
  /**
   * The duration passed to the last call.
   */
  previousTime: number;
  /**
   * The current value the progress bar is sitting at.
   */
  value: number;
  /**
   * The value passed to the last call.
   */
  previousValue: number;
  /**
   * The max value expected to receive.
   */
  max: number;
}

/**
 * The options that are provided to a {@link createProgressBar} or
 * {@link ProgressBarStream}.
 */
export interface ProgressBarOptions {
  /**
   * The {@link WritableStream} that will receive the progress bar reports.
   * @default {Deno.stderr.writable}
   */
  writable?: WritableStream<Uint8Array>;
  /**
   * The offset size of the input if progress is resuming part way through.
   * @default {0}
   */
  value?: number;
  /**
   * The total size expected to receive.
   */
  max: number;
  /**
   * The length that the progress bar should be, in characters.
   * @default {50}
   */
  barLength?: number;
  /**
   * The character to fill the progress bar up with as it makes progress.
   * @default {'#'}
   */
  fillChar?: string;
  /**
   * The character the progress bar starts out with.
   * @default {'-'}
   */
  emptyChar?: string;
  /**
   * Whether the progress bar should be removed after completion.
   * @default {false}
   */
  clear?: boolean;
  /**
   * A function that creates the style of the progress bar.
   * Default Style: `[mm:ss] [###-------] [0.24/97.6 KiB]`.
   */
  formatter?: (formatter: ProgressBarFormatter) => string;
  /**
   * Whether the writable should be kept open when progress bar stops.
   * @default {true}
   */
  keepOpen?: boolean;
}

const LINE_CLEAR = "\r\u001b[K";

function defaultFormatter(formatter: ProgressBarFormatter) {
  return `[${formatter.styledTime}] [${formatter.progressBar}] [${formatter.styledData()}]`;
}

function clamp(value: number, min: number, max: number) {
  return Math.min(Math.max(value, min), max);
}

/**
 * `ProgressBar` is a customisable class that reports updates to a
 * {@link WritableStream} on a 1s interval. Progress is communicated by using
 * the `ProgressBar.value` property.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Basic Usage
 * ```ts ignore
 * import { delay } from "@std/async";
 * import { ProgressBar } from "@std/cli/unstable-progress-bar";
 *
 * const gen = async function* () {
 *   for (let i = 0; i < 100; ++i) {
 *     yield new Uint8Array(1000).fill(97);
 *     await delay(Math.random() * 200 | 0);
 *   }
 * }();
 * const writer = (await Deno.create("./_tmp/output.txt")).writable.getWriter();
 *
 * const bar = new ProgressBar({ max: 100_000 });
 *
 * for await (const buffer of gen) {
 *   bar.value += buffer.length;
 *   await writer.write(buffer);
 * }
 *
 * await bar.stop();
 * await writer.close();
 * ```
 *
 * @example Custom Formatting
 * ```ts ignore
 * import { delay } from "@std/async";
 * import { ProgressBar } from "@std/cli/unstable-progress-bar";
 *
 * const bar = new ProgressBar({
 *   max: 100,
 *   formatter(formatter) {
 *     return `[${formatter.styledTime}] [${formatter.progressBar}] [${formatter.value}/${formatter.max} files]`;
 *   },
 * });
 *
 * for (const x of Array(100)) {
 *   bar.value += 1;
 *   await delay(Math.random() * 500);
 * }
 *
 * await bar.stop();
 */
export class ProgressBar {
  /**
   * The current progress that has been completed.
   * @example Usage
   * ```ts no-assert
   * import { ProgressBar } from "@std/cli/unstable-progress-bar";
   *
   * const progressBar = new ProgressBar({ max : 10 });
   * progressBar.value += 1;
   *
   * // do stuff
   *
   * await progressBar.stop();
   * ```
   */
  value: number;
  /**
   * The maximum progress that is expected.
   * @example Usage
   * ```ts no-assert
   * import { ProgressBar } from "@std/cli/unstable-progress-bar";
   *
   * const progressBar = new ProgressBar({ max : 1 });
   * progressBar.max = 100;
   *
   * // do stuff
   *
   * await progressBar.stop();
   * ```
   */
  max: number;

  #writer: WritableStreamDefaultWriter;
  #id: number;
  #startTime: number;
  #previousTime: number;
  #previousValue: number;
  #barLength: number;
  #fillChar: string;
  #emptyChar: string;
  #clear: boolean;
  #formatter: (formatter: ProgressBarFormatter) => string;
  #keepOpen: boolean;
  #pipePromise: Promise<void>;
  /**
   * Constructs a new instance.
   *
   * @param options The options to configure various settings of the progress bar.
   */
  constructor(
    options: ProgressBarOptions,
  ) {
    const {
      writable = Deno.stderr.writable,
      value = 0,
      max,
      barLength = 50,
      fillChar = "#",
      emptyChar = "-",
      clear = false,
      formatter = defaultFormatter,
      keepOpen = true,
    } = options;
    this.value = value;
    this.max = max;
    this.#barLength = barLength;
    this.#fillChar = fillChar;
    this.#emptyChar = emptyChar;
    this.#clear = clear;
    this.#formatter = formatter;
    this.#keepOpen = keepOpen;

    const stream = new TextEncoderStream();
    this.#pipePromise = stream.readable
      .pipeTo(writable, { preventClose: this.#keepOpen })
      .catch(() => clearInterval(this.#id));
    this.#writer = stream.writable.getWriter();
    this.#startTime = Date.now();
    this.#previousTime = 0;
    this.#previousValue = this.value;

    this.#id = setInterval(() => this.#print(), 1000);
    this.#print();
  }
  #createFormatterObject() {
    const time = Date.now() - this.#startTime;

    const ratio = clamp(this.value / this.max, 0, 1);
    const size = Math.trunc(ratio * this.#barLength);
    const fillChars = this.#fillChar.repeat(size);
    const emptyChars = this.#emptyChar.repeat(this.#barLength - size);

    return {
      get styledTime() {
        const minutes = (this.time / 1000 / 60 | 0).toString().padStart(2, "0");
        const seconds = (this.time / 1000 % 60 | 0).toString().padStart(2, "0");
        return `${minutes}:${seconds}`;
      },
      styledData() {
        return formatUnitFraction(this.value, this.max);
      },
      progressBar: `${fillChars}${emptyChars}`,
      time,
      previousTime: this.#previousTime,
      value: this.value,
      previousValue: this.#previousValue,
      max: this.max,
    };
  }
  async #print(): Promise<void> {
    const formatter = this.#createFormatterObject();
    const output = this.#formatter(formatter);
    try {
      await this.#writer.write(LINE_CLEAR + output);
    } catch {
      // ignore
    }
    this.#previousTime = formatter.time;
    this.#previousValue = formatter.value;
  }

  /**
   * Ends the progress bar and cleans up any lose ends.
   *
   * @example Usage
   * ```ts ignore
   * import { ProgressBar } from "@std/cli/unstable-progress-bar";
   *
   * const progressBar = new ProgressBar({ max: 100 });
   * await progressBar.stop()
   * ```
   */
  async stop(): Promise<void> {
    clearInterval(this.#id);
    try {
      if (this.#clear) {
        await this.#writer.write(LINE_CLEAR);
      } else {
        await this.#print();
        await this.#writer.write("\n");
      }
      await this.#writer.close();
      await this.#pipePromise;
    } catch {
      // ignore
    }
  }
}



================================================
FILE: cli/unstable_progress_bar_stream.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import {
  ProgressBar,
  type ProgressBarOptions,
} from "./unstable_progress_bar.ts";

import type { Uint8Array_ } from "./_types.ts";

export type { Uint8Array_ };

/**
 * `ProgressBarStream` is a {@link TransformStream} class that reports updates
 * to a separate {@link WritableStream} on a 1s interval.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Basic Usage
 * ```ts no-assert
 * import { ProgressBarStream } from "@std/cli/unstable-progress-bar-stream";
 *
 * const response = await fetch("https://example.com/");
 * const max = Number(response.headers.get("content-length"));
 * let readable = response.body
 * if (max) {
 *   readable = readable
 *     ?.pipeThrough(new ProgressBarStream({ max })) ?? null;
 * }
 * await readable?.pipeTo((await Deno.create("./_tmp/example.com.html")).writable);
 * ```
 */
export class ProgressBarStream
  extends TransformStream<Uint8Array_, Uint8Array_> {
  /**
   * Constructs a new instance.
   *
   * @example Basic Usage
   * ```ts no-assert
   * import { ProgressBarStream } from "@std/cli/unstable-progress-bar-stream";
   *
   * const response = await fetch("https://example.com/");
   * const max = Number(response.headers.get("content-length"));
   * let readable = response.body
   * if (max) {
   *   readable = readable
   *     ?.pipeThrough(new ProgressBarStream({ max })) ?? null;
   * }
   * await readable?.pipeTo((await Deno.create("./_tmp/example.com.html")).writable);
   * ```
   * @param options The options to configure various settings of the progress bar.
   */
  constructor(
    options: ProgressBarOptions,
  ) {
    let bar: ProgressBar | undefined;
    super({
      start(_controller) {
        bar = new ProgressBar(options);
      },
      transform(chunk, controller) {
        if (bar) bar.value += chunk.length;
        controller.enqueue(chunk);
      },
      flush(_controller) {
        bar?.stop();
      },
      cancel() {
        bar?.stop();
      },
    });
  }
}



================================================
FILE: cli/unstable_progress_bar_stream_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { assertEquals } from "@std/assert";
import { ProgressBarStream } from "./unstable_progress_bar_stream.ts";

async function* getData(
  loops: number,
  bufferSize: number,
): AsyncGenerator<Uint8Array> {
  for (let i = 0; i < loops; ++i) {
    yield new Uint8Array(bufferSize);
    await new Promise((a) => setTimeout(a, Math.random() * 500 + 500));
  }
}

Deno.test("ProgressBarStream() flushes", async () => {
  const { readable, writable } = new TransformStream();

  for await (
    const _ of ReadableStream
      .from(getData(10, 1000))
      .pipeThrough(
        new ProgressBarStream({ writable, max: 10 * 1000, keepOpen: false }),
      )
    // deno-lint-ignore no-empty
  ) {}

  assertEquals((await new Response(readable).bytes()).subarray(-1)[0], 10);
});

Deno.test("ProgressBarStream() cancels", async () => {
  const { readable, writable } = new TransformStream();

  await ReadableStream
    .from(getData(10, 1000))
    .pipeThrough(
      new ProgressBarStream({ writable, max: 10 * 1000, keepOpen: false }),
    )
    .cancel();

  assertEquals((await new Response(readable).bytes()).subarray(-1)[0], 10);
});



================================================
FILE: cli/unstable_progress_bar_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { assertEquals } from "@std/assert";
import { ProgressBar } from "./unstable_progress_bar.ts";
import { FakeTime } from "@std/testing/time";

const decoder = new TextDecoder();

Deno.test("ProgressBar() outputs default result", async () => {
  using fakeTime = new FakeTime();

  const { readable, writable } = new TransformStream();
  const bar = new ProgressBar({ writable, max: 10 * 1000 });
  for (let index = 0; index < 10; index++) {
    bar.value += 1000;
    fakeTime.tick(1000);
  }
  bar.stop().then(() => writable.close());

  const expected = [
    "\r\x1b[K[00:00] [--------------------------------------------------] [0.00/9.77 KiB]",
    "\r\x1b[K[00:01] [#####---------------------------------------------] [0.98/9.77 KiB]",
    "\r\x1b[K[00:02] [##########----------------------------------------] [1.95/9.77 KiB]",
    "\r\x1b[K[00:03] [###############-----------------------------------] [2.93/9.77 KiB]",
    "\r\x1b[K[00:04] [####################------------------------------] [3.91/9.77 KiB]",
    "\r\x1b[K[00:05] [#########################-------------------------] [4.88/9.77 KiB]",
    "\r\x1b[K[00:06] [##############################--------------------] [5.86/9.77 KiB]",
    "\r\x1b[K[00:07] [###################################---------------] [6.84/9.77 KiB]",
    "\r\x1b[K[00:08] [########################################----------] [7.81/9.77 KiB]",
    "\r\x1b[K[00:09] [#############################################-----] [8.79/9.77 KiB]",
    "\r\x1b[K[00:10] [##################################################] [9.77/9.77 KiB]",
    "\r\x1b[K[00:10] [##################################################] [9.77/9.77 KiB]",
    "\n",
  ];

  const actual: string[] = [];
  for await (const buffer of readable) {
    actual.push(decoder.decode(buffer));
  }
  assertEquals(actual, expected);
});

Deno.test("ProgressBar() prints every second", async () => {
  using fakeTime = new FakeTime();
  const { readable, writable } = new TransformStream();
  const bar = new ProgressBar({ writable, max: 10 * 1000 });
  fakeTime.tick(3000);
  bar.stop().then(() => writable.close());

  const expected = [
    "\r\x1b[K[00:00] [--------------------------------------------------] [0.00/9.77 KiB]",
    "\r\x1b[K[00:01] [--------------------------------------------------] [0.00/9.77 KiB]",
    "\r\x1b[K[00:02] [--------------------------------------------------] [0.00/9.77 KiB]",
    "\r\x1b[K[00:03] [--------------------------------------------------] [0.00/9.77 KiB]",
    "\r\x1b[K[00:03] [--------------------------------------------------] [0.00/9.77 KiB]",
    "\n",
  ];

  const actual: string[] = [];
  for await (const buffer of readable) {
    actual.push(decoder.decode(buffer));
  }
  assertEquals(actual, expected);
});

Deno.test("ProgressBar() can handle a readable.cancel() correctly", async () => {
  using _fakeTime = new FakeTime();
  const { readable, writable } = new TransformStream();
  const bar = new ProgressBar({ writable, max: 10 * 1000 });
  bar.stop();
  await readable.cancel();
});

Deno.test("ProgressBar() can remove itself when finished", async () => {
  using _fakeTime = new FakeTime();
  const { readable, writable } = new TransformStream();
  const bar = new ProgressBar({ writable, max: 10 * 1000, clear: true });
  bar.stop().then(() => writable.close());

  const expected = [
    "\r\x1b[K[00:00] [--------------------------------------------------] [0.00/9.77 KiB]",
    "\r\x1b[K",
  ];

  const actual: string[] = [];
  for await (const buffer of readable) {
    actual.push(decoder.decode(buffer));
  }
  assertEquals(actual, expected);
});

Deno.test("ProgressBar() passes correct values to formatter", async () => {
  using _fakeTime = new FakeTime();
  const { readable, writable } = new TransformStream();
  let lastTime: undefined | number = undefined;
  let lastValue: undefined | number = undefined;
  let called = false;
  const bar = new ProgressBar({
    writable,
    max: 10 * 1000,
    keepOpen: false,
    formatter(x) {
      called = true;
      if (lastTime != undefined) assertEquals(x.previousTime, lastTime);
      if (lastValue != undefined) assertEquals(x.previousValue, lastValue);
      lastTime = x.time;
      lastValue = x.value;
      return "";
    },
  });

  bar.value += 1000;
  bar.stop();
  assertEquals(called, true);
  await new Response(readable).bytes();
});

Deno.test("ProgressBar() uses correct unit type", async () => {
  const units = ["KiB", "MiB", "GiB", "TiB", "PiB"];
  let i = 0;
  for (const unit of units) {
    const { readable, writable } = new TransformStream();
    const bar = new ProgressBar({
      writable,
      max: 2 ** (10 * ++i),
      keepOpen: false,
    });

    const decoder = new TextDecoder();
    for await (const buffer of readable) {
      assertEquals(decoder.decode(buffer.subarray(-4, -1)), unit);
      break;
    }
    bar.stop();
  }
});

Deno.test("ProgressBar() does not leak resources when immediately stopped", async () => {
  const progressBar = new ProgressBar({ max: 10 });
  await progressBar.stop();
});

Deno.test("ProgressBar() handles value < 0", async () => {
  using _fakeTime = new FakeTime();
  const { readable, writable } = new TransformStream();
  const bar = new ProgressBar({ writable, max: 2 ** 10, value: -1 });
  bar.stop().then(() => writable.close());

  const expected = [
    "\r\x1b[K[00:00] [--------------------------------------------------] [-0.00/1.00 KiB]",
    "\r\x1b[K[00:00] [--------------------------------------------------] [-0.00/1.00 KiB]",
    "\n",
  ];

  const actual: string[] = [];
  for await (const buffer of readable) {
    actual.push(decoder.decode(buffer));
  }
  assertEquals(actual, expected);
});

Deno.test("ProgressBar() handles max < 0", async () => {
  using _fakeTime = new FakeTime();
  const { readable, writable } = new TransformStream();
  const bar = new ProgressBar({ writable, max: -1 });
  bar.stop().then(() => writable.close());

  const expected = [
    "\r\x1b[K[00:00] [--------------------------------------------------] [0.00/-0.00 KiB]",
    "\r\x1b[K[00:00] [--------------------------------------------------] [0.00/-0.00 KiB]",
    "\n",
  ];

  const actual: string[] = [];
  for await (const buffer of readable) {
    actual.push(decoder.decode(buffer));
  }
  assertEquals(actual, expected);
});

Deno.test("ProgressBar() handles value > max", async () => {
  using _fakeTime = new FakeTime();
  const { readable, writable } = new TransformStream();
  const bar = new ProgressBar({ writable, max: 2 ** 10, value: 2 ** 10 + 1 });
  bar.stop().then(() => writable.close());

  const expected = [
    "\r\x1b[K[00:00] [##################################################] [1.00/1.00 KiB]",
    "\r\x1b[K[00:00] [##################################################] [1.00/1.00 KiB]",
    "\n",
  ];

  const actual: string[] = [];
  for await (const buffer of readable) {
    actual.push(decoder.decode(buffer));
  }
  assertEquals(actual, expected);
});



================================================
FILE: cli/unstable_prompt_multiple_select.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { handlePromptSelect } from "./_prompt_select.ts";

/** Options for {@linkcode promptMultipleSelect}. */
export interface PromptMultipleSelectOptions {
  /** Clear the lines after the user's input. */
  clear?: boolean;

  /** The number of lines to be visible at once */
  visibleLines?: number;

  /** The string to indicate the selected item */
  indicator?: string;
}

/**
 * Value for {@linkcode promptMultipleSelect}.
 * If an object, it must have a title and a value, else it can just be a string.
 *
 * @typeParam V The value of the underlying Entry, if any.
 */
export type PromptEntry<V = undefined> = V extends undefined ? string
  : PromptEntryWithValue<V>;

/**
 * A {@linkcode PromptEntry} with an underlying value.
 *
 * @typeParam V The value of the underlying Entry.
 */
export interface PromptEntryWithValue<V> {
  /** The label for this entry. */
  label: string;
  /** The underlying value representing this entry. */
  value: V;
}

const ETX = "\x03";
const ARROW_UP = "\u001B[A";
const ARROW_DOWN = "\u001B[B";
const CR = "\r";

const DELETE = "\u007F";

const CHECKED = "◉";
const UNCHECKED = "◯";

/**
 * Shows the given message and waits for the user's input. Returns the user's selected value as string.
 *
 * Also supports filtering of the options by typing.
 *
 * @typeParam V The value of the underlying Entry, if any.
 * @param message The prompt message to show to the user.
 * @param values The values for the prompt.
 * @param options The options for the prompt.
 * @returns The selected values as an array of strings or `null` if stdin is not a TTY.
 *
 * @example Usage
 * ```ts ignore
 * import { promptMultipleSelect } from "@std/cli/unstable-prompt-multiple-select";
 *
 * const browsers = promptMultipleSelect(
 *   "Please select browsers:",
 *   ["safari", "chrome", "firefox"],
 *   { clear: true },
 * );
 * ```
 *
 * @example With title and value
 * ```ts ignore
 * import { promptMultipleSelect } from "@std/cli/unstable-prompt-multiple-select";
 *
 * const browsers = promptMultipleSelect(
 *   "Please select browsers:",
 *   [{
 *     label: "safari",
 *     value: 1,
 *   }, {
 *     label: "chrome",
 *     value: 2,
 *   }, {
 *     label: "firefox",
 *     value: 3,
 *   }],
 *   { clear: true },
 * );
 * ```
 *
 * @example With multiple options
 * ```ts ignore
 * import { promptMultipleSelect } from "@std/cli/unstable-prompt-multiple-select";
 *
 * const browsers = promptMultipleSelect(
 *   "Select your favorite numbers below 100:",
 *   [...Array(100).keys()].map(String),
 *   { clear: true, visibleLines: 5, indicator: "→" },
 * );
 * ```
 */
export function promptMultipleSelect<V = undefined>(
  message: string,
  values: PromptEntry<V>[],
  options: PromptMultipleSelectOptions = {},
): PromptEntry<V>[] | null {
  if (!Deno.stdin.isTerminal()) return null;

  const selectedAbsoluteIndexes = new Set<number>();

  handlePromptSelect(
    message,
    options.indicator ?? "❯",
    values,
    options.clear,
    options.visibleLines,
    (_active, absoluteIndex) => {
      const checked = selectedAbsoluteIndexes.has(absoluteIndex);
      return checked ? CHECKED : UNCHECKED;
    },
    (str, absoluteIndex, {
      etx,
      up,
      down,
      remove,
      inputStr,
    }) => {
      switch (str) {
        case ETX:
          return etx();
        case ARROW_UP:
          up();
          break;
        case ARROW_DOWN:
          down();
          break;
        case CR:
          return true;
        case " ": {
          if (absoluteIndex !== undefined) {
            if (selectedAbsoluteIndexes.has(absoluteIndex)) {
              selectedAbsoluteIndexes.delete(absoluteIndex);
            } else {
              selectedAbsoluteIndexes.add(absoluteIndex);
            }
          }
          break;
        }
        case DELETE:
          remove();
          break;
        default:
          inputStr();
          break;
      }

      return false;
    },
  );

  return [...selectedAbsoluteIndexes].map((it) => values[it]!);
}



================================================
FILE: cli/unstable_prompt_multiple_select_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { assertEquals } from "@std/assert/equals";
import { promptMultipleSelect } from "./unstable_prompt_multiple_select.ts";
import { restore, stub } from "@std/testing/mock";

const encoder = new TextEncoder();
const decoder = new TextDecoder();

Deno.test("promptMultipleSelect() handles enter", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",

    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browsers, []);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles selection", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◉ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",

    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    { label: "safari", value: 1 },
    { label: "chrome", value: 2 },
    { label: "firefox", value: 3 },
  ]);

  assertEquals(browsers, [{ label: "safari", value: 1 }]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles multiple selection", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◉ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◉ safari\r\n",
    "❯ ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◉ safari\r\n",
    "❯ ◉ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◉ safari\r\n",
    "  ◉ chrome\r\n",
    "❯ ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",

    "Please select browsers:\r\n",
    "  ◉ safari\r\n",
    "  ◉ chrome\r\n",
    "❯ ◉ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    " ",
    "\u001B[B",
    " ",
    "\u001B[B",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    { label: "safari", value: 1 },
    { label: "chrome", value: 2 },
    { label: "firefox", value: 3 },
  ]);

  assertEquals(browsers, [
    { label: "safari", value: 1 },
    { label: "chrome", value: 2 },
    { label: "firefox", value: 3 },
  ]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles arrow down", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "❯ ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "❯ ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",

    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "❯ ◉ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    { label: "safari", value: 1 },
    { label: "chrome", value: 2 },
    { label: "firefox", value: 3 },
  ]);

  assertEquals(browsers, [{ label: "firefox", value: 3 }]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles arrow up", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "❯ ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◉ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",

    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[A",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browsers, ["safari"]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles up index overflow", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "❯ ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "❯ ◉ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[A",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browsers, ["firefox"]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles down index overflow", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "❯ ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "❯ ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",

    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◉ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",

    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browsers, ["safari"]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() scrolls down and display lines correctly", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "❯ ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "❯ ◯ firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "  ...\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "❯ ◯ brave\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◉ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "  ...\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
    "brave",
  ], { visibleLines: 3 });

  assertEquals(browser, ["safari"]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles clear option", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◉ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ], { clear: true });

  assertEquals(browsers, ["safari"]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles ETX", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  let called = false;
  stub(
    Deno,
    "exit",
    (() => {
      called = true;
    }) as never,
  );

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\x03",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const _browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(called, true);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() supports search by typing", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers: (filter: f)\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select browsers: (filter: f)\r\n",
    "  ◯ safari\r\n",
    "❯ ◯ firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select browsers: (filter: f)\r\n",
    "  ◯ safari\r\n",
    "❯ ◉ firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select browsers: (filter: fa)\r\n",
    "❯ ◯ safari\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select browsers: (filter: f)\r\n",
    "❯ ◯ safari\r\n",
    "  ◉ firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◉ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers: (filter: z)\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "f",
    "\u001B[B", // Arrow down
    " ",
    "a",
    "\u007F", // Backspace
    "\u007F", // Backspace
    "z",
    "\r", // Enter
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(expectedOutput, actualOutput);
  assertEquals(browsers, ["firefox"]);
  restore();
});

Deno.test("promptMultipleSelect() handles search", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers: (filter: c)\r\n",
    "❯ ◯ chrome\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select browsers: (filter: ch)\r\n",
    "❯ ◯ chrome\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select browsers: (filter: ch)\r\n",
    "❯ ◉ chrome\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "c",
    "h",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browsers, ["chrome"]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles search backspace", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers: (filter: f)\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◉ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "f",
    "\x7f",
    " ",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browsers, ["safari"]);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() handles search no matches", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select browsers: (filter: x)\r\n",
    "❯ ◯ firefox\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select browsers: (filter: xy)\r\n",
    "\x1b[1A",
    "\x1b[J",
    "Please select browsers: (filter: xyz)\r\n",
    "\x1b[1A",
    "\x1b[J",
    "Please select browsers: (filter: xy)\r\n",
    "\x1b[1A",
    "\x1b[J",
    "Please select browsers: (filter: x)\r\n",
    "❯ ◯ firefox\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select browsers:\r\n",
    "❯ ◯ safari\r\n",
    "  ◯ chrome\r\n",
    "  ◯ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "x",
    "y",
    "z",
    "\x7f",
    "\x7f",
    "\x7f",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browsers, []);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptMultipleSelect() returns null if Deno.stdin.isTerminal() is false", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => false);

  const expectedOutput: string[] = [];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  const browsers = promptMultipleSelect("Please select browsers:", [
    "safari",
    "chrome",
    "firefox",
  ]);
  assertEquals(browsers, null);
  assertEquals(expectedOutput, actualOutput);
  restore();
});



================================================
FILE: cli/unstable_prompt_select.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { handlePromptSelect } from "./_prompt_select.ts";

/** Options for {@linkcode promptSelect}. */
export interface PromptSelectOptions {
  /** Clear the lines after the user's input. */
  clear?: boolean;

  /** The number of lines to be visible at once */
  visibleLines?: number;

  /** The string to indicate the selected item */
  indicator?: string;
}

/**
 * Value for {@linkcode promptSelect}.
 * If an object, it must have a title and a value, else it can just be a string.
 *
 * @typeParam V The value of the underlying Entry, if any.
 */
export type PromptEntry<V = undefined> = V extends undefined ? string
  : PromptEntryWithValue<V>;

/**
 * A {@linkcode PromptEntry} with an underlying value.
 *
 * @typeParam V The value of the underlying Entry.
 */
export interface PromptEntryWithValue<V> {
  /** The label for this entry. */
  label: string;
  /** The underlying value representing this entry. */
  value: V;
}

const ETX = "\x03";
const ARROW_UP = "\u001B[A";
const ARROW_DOWN = "\u001B[B";
const CR = "\r";
const DELETE = "\u007F";

/**
 * Shows the given message and waits for the user's input. Returns the user's selected value as string.
 *
 * Also supports filtering of the options by typing.
 *
 * @typeParam V The value of the underlying Entry, if any.
 * @param message The prompt message to show to the user.
 * @param values The values for the prompt.
 * @param options The options for the prompt.
 * @returns The string that was entered or `null` if stdin is not a TTY.
 *
 * @example Basic usage
 * ```ts ignore
 * import { promptSelect } from "@std/cli/unstable-prompt-select";
 *
 * const browser = promptSelect("Please select browser", [
 *   "Chrome",
 *   "Firefox",
 *   "Safari",
 * ], { clear: true });
 * ```
 *
 * @example With title and value
 * ```ts ignore
 * import { promptSelect } from "@std/cli/unstable-prompt-select";
 *
 * const browsers = promptSelect(
 *   "Please select browsers:",
 *   [{
 *     label: "safari",
 *     value: 1,
 *   }, {
 *     label: "chrome",
 *     value: 2,
 *   }, {
 *     label: "firefox",
 *     value: 3,
 *   }],
 *   { clear: true },
 * );
 * ```
 *
 * @example With multiple options
 * ```ts ignore
 * import { promptSelect } from "@std/cli/unstable-prompt-select";
 *
 * const browser = promptSelect("What country are you from?", [
 *   "Brazil",
 *   "United States",
 *   "Japan",
 *   "China",
 *   "Canada",
 *   "Spain",
 * ], { clear: true, visibleLines: 3, indicator: "*" });
 * ```
 */
export function promptSelect<V = undefined>(
  message: string,
  values: PromptEntry<V>[],
  options: PromptSelectOptions = {},
): PromptEntry<V> | null {
  if (!Deno.stdin.isTerminal()) return null;

  let selectedIndex = 0;

  handlePromptSelect(
    message,
    options.indicator ?? "❯",
    values,
    options.clear,
    options.visibleLines,
    (active, absoluteIndex) => {
      if (active) {
        selectedIndex = absoluteIndex;
      }
    },
    (str, _absoluteIndex, {
      etx,
      up,
      down,
      remove,
      inputStr,
    }) => {
      switch (str) {
        case ETX:
          return etx();
        case ARROW_UP:
          up();
          break;
        case ARROW_DOWN:
          down();
          break;
        case CR:
        case " ":
          return true;
        case DELETE:
          remove();
          break;
        default:
          inputStr();
          break;
      }

      return false;
    },
  );

  return values[selectedIndex] ?? null;
}



================================================
FILE: cli/unstable_prompt_select_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

import { assertEquals } from "@std/assert/equals";
import { promptSelect } from "./unstable_prompt_select.ts";
import { restore, stub } from "@std/testing/mock";

const encoder = new TextEncoder();
const decoder = new TextDecoder();
Deno.test("promptSelect() handles CR", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    { label: "safari", value: 1 },
    { label: "chrome", value: 2 },
    { label: "firefox", value: 3 },
  ]);

  assertEquals(browser, { label: "safari", value: 1 });
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles arrow down", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "❯ chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "  chrome\r\n",
    "❯ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, "firefox");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles arrow up", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "❯ chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[A",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, "safari");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles index underflow", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "  chrome\r\n",
    "❯ firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[A",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, "firefox");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles index overflow", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "❯ chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "  chrome\r\n",
    "❯ firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, "safari");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() scrolls down and display lines correctly", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "❯ chrome\r\n",
    "  firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "  chrome\r\n",
    "❯ firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  ...\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "❯ brave\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "  ...\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
    "brave",
  ], { visibleLines: 3 });

  assertEquals(browser, "safari");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() uses Deno.consoleSize().rows", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a Country:\r\n",
    "❯ Brazil\r\n",
    "  Spain\r\n",
    "  Japan\r\n",
    "  USA\r\n",
    "  Mexico\r\n",
    "  Canada\r\n",
    "  Portugal\r\n",
    "  India\r\n",
    "\x1b[9A",
    "\x1b[J",
    "Please select a Country:\r\n",
    "  Brazil\r\n",
    "❯ Spain\r\n",
    "  Japan\r\n",
    "  USA\r\n",
    "  Mexico\r\n",
    "  Canada\r\n",
    "  Portugal\r\n",
    "  India\r\n",
    "\x1b[9A",
    "\x1b[J",
    "Please select a Country:\r\n",
    "  Brazil\r\n",
    "  Spain\r\n",
    "❯ Japan\r\n",
    "  USA\r\n",
    "  Mexico\r\n",
    "  Canada\r\n",
    "  Portugal\r\n",
    "  India\r\n",
    "\x1b[9A",
    "\x1b[J",
    "Please select a Country:\r\n",
    "  Brazil\r\n",
    "  Spain\r\n",
    "  Japan\r\n",
    "❯ USA\r\n",
    "  Mexico\r\n",
    "  Canada\r\n",
    "  Portugal\r\n",
    "  India\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a Country:", [
    "Brazil",
    "Spain",
    "Japan",
    "USA",
    "Mexico",
    "Canada",
    "Portugal",
    "India",
  ]);

  assertEquals(browser, "USA");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() display certain number of visibleLines", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  ...\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  safari\r\n",
    "❯ chrome\r\n",
    "  ...\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  ...\r\n",
    "  chrome\r\n",
    "❯ firefox\r\n",
    "  ...\r\n",
    "\x1b[5A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "  ...\r\n",
    "  firefox\r\n",
    "❯ brave\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  ...\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    "\u001B[B",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
    "brave",
  ], { visibleLines: 2 });

  assertEquals(browser, "safari");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() changes the indicator", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "-> safari\r\n",
    "   chrome\r\n",
    "   firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "   safari\r\n",
    "-> chrome\r\n",
    "   firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "   safari\r\n",
    "   chrome\r\n",
    "-> firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\u001B[B",
    "\u001B[B",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ], { indicator: "->" });

  assertEquals(browser, "firefox");
  assertEquals(expectedOutput, actualOutput);
  restore();
});
Deno.test("promptSelect() handles clear option", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ], { clear: true });

  assertEquals(browser, "safari");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() returns null if Deno.stdin.isTerminal() is false", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => false);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput: string[] = [];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, null);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles search", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser: (filter: c)\r\n",
    "❯ chrome\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select a browser: (filter: ch)\r\n",
    "❯ chrome\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "c",
    "h",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, "chrome");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles search backspace", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser: (filter: f)\r\n",
    "❯ safari\r\n",
    "  firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "f",
    "\x7f",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, "safari");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles search no matches", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser: (filter: x)\r\n",
    "❯ firefox\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select a browser: (filter: xy)\r\n",
    "\x1b[1A",
    "\x1b[J",
    "Please select a browser: (filter: xyz)\r\n",
    "\x1b[1A",
    "\x1b[J",
    "Please select a browser: (filter: xy)\r\n",
    "\x1b[1A",
    "\x1b[J",
    "Please select a browser: (filter: x)\r\n",
    "❯ firefox\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "x",
    "y",
    "z",
    "\x7f",
    "\x7f",
    "\x7f",
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(browser, "safari");
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() handles ETX", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  let called = false;
  stub(
    Deno,
    "exit",
    (() => {
      called = true;
    }) as never,
  );

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "\x03",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const _browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(called, true);
  assertEquals(expectedOutput, actualOutput);
  restore();
});

Deno.test("promptSelect() supports search by typing", () => {
  stub(Deno.stdin, "setRaw");
  stub(Deno.stdin, "isTerminal", () => true);
  stub(Deno, "consoleSize", () => ({ columns: 80, rows: 24 }));

  const expectedOutput = [
    "\x1b[?25l",
    "Please select a browser:\r\n",
    "❯ safari\r\n",
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[4A",
    "\x1b[J",
    "Please select a browser: (filter: e)\r\n",
    "❯ chrome\r\n",
    "  firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select a browser: (filter: ef)\r\n",
    "❯ firefox\r\n",
    "\x1b[2A",
    "\x1b[J",
    "Please select a browser: (filter: e)\r\n",
    "❯ chrome\r\n",
    "  firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select a browser: (filter: e)\r\n",
    "  chrome\r\n",
    "❯ firefox\r\n",
    "\x1b[3A",
    "\x1b[J",
    "Please select a browser:\r\n",
    "❯ safari\r\n", // the selection is reset when the search is changed
    "  chrome\r\n",
    "  firefox\r\n",
    "\x1b[?25h",
  ];

  const actualOutput: string[] = [];

  stub(
    Deno.stdout,
    "writeSync",
    (data: Uint8Array) => {
      const output = decoder.decode(data);
      actualOutput.push(output);
      return data.length;
    },
  );

  let readIndex = 0;

  const inputs = [
    "e",
    "f",
    "\u007F", // Backspace
    "\u001B[B", // Arrow down
    "\u007F", // Backspace
    "\r",
  ];

  stub(
    Deno.stdin,
    "readSync",
    (data: Uint8Array) => {
      const input = inputs[readIndex++];
      const bytes = encoder.encode(input);
      data.set(bytes);
      return bytes.length;
    },
  );

  const browser = promptSelect("Please select a browser:", [
    "safari",
    "chrome",
    "firefox",
  ]);

  assertEquals(expectedOutput, actualOutput);
  assertEquals(browser, "safari");
  restore();
});



================================================
FILE: cli/unstable_spinner.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

const encoder = new TextEncoder();

const LINE_CLEAR = encoder.encode("\r\u001b[K"); // From cli/prompt_secret.ts
const COLOR_RESET = "\u001b[0m";
const DEFAULT_INTERVAL = 75;
const DEFAULT_SPINNER = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"];

/**
 * This is a hack to allow us to use the same type for both the color name and
 * an ANSI escape code.
 *
 * @see {@link https://github.com/microsoft/TypeScript/issues/29729#issuecomment-460346421}
 *
 * @internal
 */
// deno-lint-ignore ban-types
export type Ansi = string & {};

/**
 * Color options for {@linkcode SpinnerOptions.color}.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 */
export type Color =
  | "black"
  | "red"
  | "green"
  | "yellow"
  | "blue"
  | "magenta"
  | "cyan"
  | "white"
  | "gray"
  | Ansi;

const COLORS: Record<Color, string> = {
  black: "\u001b[30m",
  red: "\u001b[31m",
  green: "\u001b[32m",
  yellow: "\u001b[33m",
  blue: "\u001b[34m",
  magenta: "\u001b[35m",
  cyan: "\u001b[36m",
  white: "\u001b[37m",
  gray: "\u001b[90m",
};

/**
 * Options for {@linkcode Spinner}.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 */
export interface SpinnerOptions {
  /**
   * The sequence of characters to be iterated through for animation.
   *
   * @default {["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]}
   */
  spinner?: string[];
  /**
   * The message to display next to the spinner. This can be changed while the
   * spinner is active.
   */
  message?: string;
  /**
   * The time between each frame of the spinner in milliseconds.
   *
   * @default {75}
   */
  interval?: number;
  /**
   * The color of the spinner. Defaults to the default terminal color.
   * This can be changed while the spinner is active.
   */
  color?: Color;
  /**
   * The stream to write the spinner to.
   *
   * @default {Deno.stdout}
   */
  output?: typeof Deno.stderr | typeof Deno.stdout;
}

/**
 * A spinner that can be used to indicate that something is loading.
 *
 * @experimental **UNSTABLE**: New API, yet to be vetted.
 *
 * @example Usage
 * ```ts ignore
 * import { Spinner } from "@std/cli/unstable-spinner";
 *
 * const spinner = new Spinner({ message: "Loading...", color: "yellow" });
 * spinner.start();
 *
 * setTimeout(() => {
 *  spinner.stop();
 *  console.log("Finished loading!");
 * }, 3_000);
 *
 * // You can also use the spinner with `Deno.stderr`
 * const spinner2 = new Spinner({ message: "Loading...", color: "yellow", output: Deno.stderr });
 * spinner2.start();
 *
 * setTimeout(() => {
 *  spinner2.stop();
 *  console.error("Finished loading!");
 * }, 3_000);
 * ```
 */
export class Spinner {
  #spinner: string[];

  /**
   * The message to display next to the spinner.
   * This can be changed while the spinner is active.
   *
   * @example Usage
   * ```ts ignore
   * import { Spinner } from "@std/cli/unstable-spinner";
   *
   * const spinner = new Spinner({ message: "Working..." });
   * spinner.start();
   *
   * for (let step = 0; step < 5; step++) {
   *   // do some work
   *   await new Promise((resolve) => setTimeout(resolve, 1000));
   *
   *   spinner.message = `Finished Step #${step}`;
   * }
   *
   * spinner.stop();
   * console.log("Done!");
   * ```
   */
  message: string;

  #interval: number;
  #color: Color | undefined;
  #intervalId: number | null = null;
  #output: typeof Deno.stdout | typeof Deno.stderr;

  /**
   * Creates a new spinner.
   *
   * @param options Options for the spinner.
   */
  constructor(options?: SpinnerOptions) {
    const {
      spinner = DEFAULT_SPINNER,
      message = "",
      interval = DEFAULT_INTERVAL,
      color,
    } = options ?? {};
    this.#spinner = spinner;
    this.message = message;
    this.#interval = interval;
    this.#output = options?.output ?? Deno.stdout;
    this.color = color;
  }

  /**
   * Set the color of the spinner. This defaults to the default terminal color.
   * This can be changed while the spinner is active.
   *
   * Providing `undefined` will use the default terminal color.
   *
   * @param value Color to set.
   *
   * @example Usage
   * ```ts ignore
   * import { Spinner } from "@std/cli/unstable-spinner";
   *
   * const spinner = new Spinner({ message: "Loading...", color: "yellow" });
   * spinner.start();
   *
   * // do some work
   * await new Promise((resolve) => setTimeout(resolve, 1000));
   *
   * spinner.color = "magenta";
   * ```
   */
  set color(value: Color | undefined) {
    this.#color = value ? COLORS[value] : undefined;
  }

  /**
   * Get the current color of the spinner.
   *
   * @example Usage
   * ```ts no-assert
   * import { Spinner } from "@std/cli/unstable-spinner";
   *
   * const spinner = new Spinner({ message: "Loading", color: "blue" });
   *
   * spinner.color; // Blue ANSI escape sequence
   * ```
   * @returns The color of the spinner or `undefined` if it's using the terminal default.
   */
  get color(): Color | undefined {
    return this.#color;
  }

  /**
   * Starts the spinner.
   *
   * @example Usage
   * ```ts ignore
   * import { Spinner } from "@std/cli/unstable-spinner";
   *
   * const spinner = new Spinner({ message: "Loading..." });
   * spinner.start();
   * ```
   */
  start() {
    if (this.#intervalId !== null || this.#output.writable.locked) {
      return;
    }

    let i = 0;
    const noColor = Deno.noColor;

    // Updates the spinner after the given interval.
    const updateFrame = () => {
      const color = this.#color ?? "";
      const frame = encoder.encode(
        noColor
          ? this.#spinner[i] + " " + this.message
          : color + this.#spinner[i] + COLOR_RESET + " " + this.message,
      );
      // call writeSync once to reduce flickering
      const writeData = new Uint8Array(LINE_CLEAR.length + frame.length);
      writeData.set(LINE_CLEAR);
      writeData.set(frame, LINE_CLEAR.length);
      this.#output.writeSync(writeData);
      i = (i + 1) % this.#spinner.length;
    };

    this.#intervalId = setInterval(updateFrame, this.#interval);
    updateFrame();
  }

  /**
   * Stops the spinner.
   *
   * @example Usage
   * ```ts ignore
   * import { Spinner } from "@std/cli/unstable-spinner";
   *
   * const spinner = new Spinner({ message: "Loading..." });
   * spinner.start();
   *
   * setTimeout(() => {
   *  spinner.stop();
   *  console.log("Finished loading!");
   * }, 3_000);
   * ```
   */
  stop() {
    if (this.#intervalId === null) return;
    clearInterval(this.#intervalId);
    this.#intervalId = null;
    this.#output.writeSync(LINE_CLEAR); // Clear the current line
  }
}



================================================
FILE: cli/unstable_spinner_test.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.
import { assertEquals } from "@std/assert";
import { Spinner } from "./unstable_spinner.ts";
import { restore, stub } from "@std/testing/mock";
import { FakeTime } from "@std/testing/time";

const decoder = new TextDecoder();

Deno.test("Spinner can start and stop", async () => {
  try {
    const expectedOutput = [
      "\r\x1b[K⠋\x1b[0m Loading...",
      "\r\x1b[K⠙\x1b[0m Loading...",
      "\r\x1b[K⠹\x1b[0m Loading...",
      "\r\x1b[K⠸\x1b[0m Loading...",
      "\r\x1b[K⠼\x1b[0m Loading...",
      "\r\x1b[K⠴\x1b[0m Loading...",
      "\r\x1b[K⠦\x1b[0m Loading...",
      "\r\x1b[K⠧\x1b[0m Loading...",
      "\r\x1b[K⠇\x1b[0m Loading...",
      "\r\x1b[K⠏\x1b[0m Loading...",
      "\r\x1b[K",
    ];

    const actualOutput: string[] = [];

    let resolvePromise: (value: void | PromiseLike<void>) => void;
    const promise = new Promise<void>((resolve) => resolvePromise = resolve);

    stub(
      Deno.stdout,
      "writeSync",
      (data: Uint8Array) => {
        const output = decoder.decode(data);
        actualOutput.push(output);
        if (actualOutput.length === expectedOutput.length - 1) resolvePromise();
        return data.length;
      },
    );

    const spinner = new Spinner({ message: "Loading..." });
    spinner.start();
    await promise;
    spinner.stop();
    assertEquals(actualOutput, expectedOutput);
  } finally {
    restore();
  }
});

Deno.test("Spinner constructor accepts spinner", async () => {
  try {
    const expectedOutput = [
      "\r\x1b[K0\x1b[0m ",
      "\r\x1b[K1\x1b[0m ",
      "\r\x1b[K2\x1b[0m ",
      "\r\x1b[K3\x1b[0m ",
      "\r\x1b[K4\x1b[0m ",
      "\r\x1b[K5\x1b[0m ",
      "\r\x1b[K6\x1b[0m ",
      "\r\x1b[K7\x1b[0m ",
      "\r\x1b[K8\x1b[0m ",
      "\r\x1b[K9\x1b[0m ",
      "\r\x1b[K",
    ];

    const actualOutput: string[] = [];

    let resolvePromise: (value: void | PromiseLike<void>) => void;
    const promise = new Promise<void>((resolve) => resolvePromise = resolve);

    stub(
      Deno.stdout,
      "writeSync",
      (data: Uint8Array) => {
        const output = decoder.decode(data);
        actualOutput.push(output);
        if (actualOutput.length === expectedOutput.length - 1) resolvePromise();
        return data.length;
      },
    );

    const spinner = new Spinner({
      spinner: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    });
    spinner.start();
    await promise;
    spinner.stop();
    assertEquals(actualOutput, expectedOutput);
  } finally {
    restore();
  }
});

Deno.test("Spinner constructor accepts message", async () => {
  try {
    const expectedOutput = [
      "\r\x1b[K⠋\x1b[0m Spinning with Deno 🦕",
      "\r\x1b[K⠙\x1b[0m Spinning with Deno 🦕",
      "\r\x1b[K⠹\x1b[0m Spinning with Deno 🦕",
      "\r\x1b[K",
    ];

    const actualOutput: string[] = [];

    let resolvePromise: (value: void | PromiseLike<void>) => void;
    const promise = new Promise<void>((resolve) => resolvePromise = resolve);

    stub(
      Deno.stdout,
      "writeSync",
      (data: Uint8Array) => {
        const output = decoder.decode(data);
        actualOutput.push(output);
        if (actualOutput.length === expectedOutput.length - 1) resolvePromise();
        return data.length;
      },
    );

    const spinner = new Spinner({ message: "Spinning with Deno 🦕" });
    spinner.start();
    await promise;
    spinner.stop();
    assertEquals(actualOutput, expectedOutput);
  } finally {
    restore();
  }
});

Deno.test("Spinner constructor accepts interval", async () => {
  try {
    using time = new FakeTime();
    const expectedOutput = [
      "\r\x1b[K⠋\x1b[0m ",
      "\r\x1b[K⠙\x1b[0m ",
      "\r\x1b[K⠹\x1b[0m ",
      "\r\x1b[K⠸\x1b[0m ",
      "\r\x1b[K",
    ];

    const actualOutput: string[] = [];

    stub(
      Deno.stdout,
      "writeSync",
      (data: Uint8Array) => {
        const output = decoder.decode(data);
        actualOutput.push(output);
        return data.length;
      },
    );

    const spinner = new Spinner({ interval: 300 });
    spinner.start();
    await time.tick(1000);
    spinner.stop();
    assertEquals(actualOutput, expectedOutput);
  } finally {
    restore();
  }
});

Deno.test("Spinner constructor accepts output", async () => {
  try {
    const expectedOutput = [
      "\r\x1b[K⠋\x1b[0m ",
      "\r\x1b[K⠙\x1b[0m ",
      "\r\x1b[K⠹\x1b[0m ",
      "\r\x1b[K⠸\x1b[0m ",
      "\r\x1b[K⠼\x1b[0m ",
      "\r\x1b[K⠴\x1b[0m ",
      "\r\x1b[K⠦\x1b[0m ",
      "\r\x1b[K⠧\x1b[0m ",
      "\r\x1b[K⠇\x1b[0m ",
      "\r\x1b[K⠏\x1b[0m ",
      "\r\x1b[K",
    ];

    const actualOutput: string[] = [];

    let resolvePromise: (value: void | PromiseLike<void>) => void;
    const promise = new Promise<void>((resolve) => resolvePromise = resolve);

    stub(
      Deno.stderr,
      "writeSync",
      (data: Uint8Array) => {
        const output = decoder.decode(data);
        actualOutput.push(output);
        if (actualOutput.length === expectedOutput.length - 1) resolvePromise();
        return data.length;
      },
    );

    const spinner = new Spinner({ output: Deno.stderr });
    spinner.start();
    await promise;
    spinner.stop();
    assertEquals(actualOutput, expectedOutput);
  } finally {
    restore();
  }
});

Deno.test("Spinner constructor accepts each color", async (t) => {
  await t.step("black", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[30m⠋\x1b[0m ",
        "\r\x1b[K\x1b[30m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "black" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("red", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[31m⠋\x1b[0m ",
        "\r\x1b[K\x1b[31m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "red" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("green", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[32m⠋\x1b[0m ",
        "\r\x1b[K\x1b[32m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "green" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("yellow", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[33m⠋\x1b[0m ",
        "\r\x1b[K\x1b[33m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "yellow" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("blue", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[34m⠋\x1b[0m ",
        "\r\x1b[K\x1b[34m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "blue" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("magenta", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[35m⠋\x1b[0m ",
        "\r\x1b[K\x1b[35m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "magenta" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("cyan", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[36m⠋\x1b[0m ",
        "\r\x1b[K\x1b[36m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "cyan" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("white", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[37m⠋\x1b[0m ",
        "\r\x1b[K\x1b[37m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "white" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
  await t.step("gray", async () => {
    try {
      const expectedOutput = [
        "\r\x1b[K\x1b[90m⠋\x1b[0m ",
        "\r\x1b[K\x1b[90m⠙\x1b[0m ",
        "\r\x1b[K",
      ];

      const actualOutput: string[] = [];

      let resolvePromise: (value: void | PromiseLike<void>) => void;
      const promise = new Promise<void>((resolve) => resolvePromise = resolve);

      stub(
        Deno.stdout,
        "writeSync",
        (data: Uint8Array) => {
          const output = decoder.decode(data);
          actualOutput.push(output);
          if (actualOutput.length === expectedOutput.length - 1) {
            resolvePromise();
          }
          return data.length;
        },
      );

      const spinner = new Spinner({ color: "gray" });
      spinner.start();
      await promise;
      spinner.stop();
      assertEquals(actualOutput, expectedOutput);
    } finally {
      restore();
    }
  });
});

Deno.test("Spinner.color can set each color", async () => {
  try {
    const expectedOutput = [
      "\r\x1b[K⠋\x1b[0m ",
      "\r\x1b[K\x1b[30m⠙\x1b[0m ",
      "\r\x1b[K",
    ];

    const actualOutput: string[] = [];

    let resolvePromise: (value: void | PromiseLike<void>) => void;
    const promise = new Promise<void>((resolve) => resolvePromise = resolve);

    const spinner = new Spinner();

    stub(
      Deno.stdout,
      "writeSync",
      (data: Uint8Array) => {
        const output = decoder.decode(data);
        actualOutput.push(output);
        spinner.color = "black";
        if (actualOutput.length === expectedOutput.length - 1) resolvePromise();
        return data.length;
      },
    );

    spinner.start();
    await promise;
    spinner.stop();
    assertEquals(actualOutput, expectedOutput);
  } finally {
    restore();
  }
});

Deno.test("Spinner.color can get each color", () => {
  const spinner = new Spinner();

  spinner.color = "black";
  assertEquals(spinner.color, "\u001b[30m");

  spinner.color = "red";
  assertEquals(spinner.color, "\u001b[31m");

  spinner.color = "green";
  assertEquals(spinner.color, "\u001b[32m");

  spinner.color = "yellow";
  assertEquals(spinner.color, "\u001b[33m");

  spinner.color = "blue";
  assertEquals(spinner.color, "\u001b[34m");

  spinner.color = "magenta";
  assertEquals(spinner.color, "\u001b[35m");

  spinner.color = "cyan";
  assertEquals(spinner.color, "\u001b[36m");

  spinner.color = "white";
  assertEquals(spinner.color, "\u001b[37m");

  spinner.color = "gray";
  assertEquals(spinner.color, "\u001b[90m");
});

Deno.test("Spinner.message can be updated", async () => {
  try {
    const expectedOutput = [
      "\r\x1b[K⠋\x1b[0m One dino 🦕",
      "\r\x1b[K⠙\x1b[0m Two dinos 🦕🦕",
      "\r\x1b[K",
    ];

    const actualOutput: string[] = [];

    let resolvePromise: (value: void | PromiseLike<void>) => void;
    const promise = new Promise<void>((resolve) => resolvePromise = resolve);

    const spinner = new Spinner({ message: "One dino 🦕" });

    stub(
      Deno.stdout,
      "writeSync",
      (data: Uint8Array) => {
        const output = decoder.decode(data);
        actualOutput.push(output);
        spinner.message = "Two dinos 🦕🦕";
        if (actualOutput.length === expectedOutput.length - 1) resolvePromise();
        return data.length;
      },
    );

    spinner.start();
    await promise;
    spinner.stop();
    assertEquals(actualOutput, expectedOutput);
  } finally {
    restore();
  }
});

Deno.test("Spinner handles multiple start() calls", () => {
  const spinner = new Spinner();

  spinner.start();
  spinner.start();
  spinner.stop();
});

Deno.test("Spinner handles multiple stop() calls", () => {
  const spinner = new Spinner();

  spinner.start();
  spinner.stop();
  spinner.stop();
});



================================================
FILE: cli/_tools/compare_with_rust.ts
================================================
// Copyright 2018-2025 the Deno authors. MIT license.
// Run this test with `deno test --unstable-ffi -A compare_with_rust.ts`

import { unicodeWidth } from "../unicode_width.ts";
import { fromFileUrl } from "../../path/mod.ts";
import fc from "npm:fast-check@3.8.0";

// Note: This test is optional. It requires the Rust code to be compiled locally
Deno.test("fast-check equality with unicode_width Rust crate", async (t) => {
  const libName = ({
    darwin: "libunicode_width_crate.dylib",
    linux: "libunicode_width_crate.so",
    windows: "libunicode_width_crate.dll",
    // deno-lint-ignore no-explicit-any
  } as any)[Deno.build.os];
  const libPath = fromFileUrl(
    import.meta.resolve(
      `../testdata/unicode_width_crate/target/debug/${libName}`,
    ),
  );

  const toCString = (str: string) => new TextEncoder().encode(str + "\0");

  // @ts-ignore type-check errors if unavailable due to lack of --unstable-ffi flag
  let dylib: Deno.DynamicLibrary<{
    unicode_width: { parameters: ["buffer"]; result: "usize" };
  }>;

  try {
    dylib = Deno.dlopen(libPath, {
      unicode_width: { parameters: ["buffer"], result: "usize" },
    });

    for (
      const arbitrary of [
        "string",
        "unicodeString",
        "fullUnicodeString",
      ] as const
    ) {
      await t.step({
        name: `fc.${arbitrary}()`,
        fn() {
          // To avoid esm.sh statically analyzed
          fc.assert(
            fc.property(
              fc[arbitrary](),
              // JSON stringify to allow "\0" chars to cross FFI boundary in a null-terminated string
              // deno-lint-ignore no-explicit-any
              (str: any) =>
                unicodeWidth(str) ===
                  Number(
                    dylib.symbols.unicode_width(toCString(JSON.stringify(str))),
                  ),
            ),
          );
        },
      });
    }
  } finally {
    // deno-lint-ignore no-extra-non-null-assertion
    dylib!?.close();
  }
});



================================================
FILE: cli/_tools/generate_data.ts
================================================
#!/usr/bin/env -S deno run --allow-net --allow-read --allow-write
// Copyright 2018-2025 the Deno authors. MIT license.
// Ported from unicode_width rust crate, Copyright (c) 2015 The Rust Project Developers. MIT license.

import { assert } from "../../assert/assert.ts";
import { runLengthEncode } from "../_run_length.ts";

// change this line and re-run the script to update for new Unicode versions
const UNICODE_VERSION = "15.0.0";

const NUM_CODEPOINTS = 0x110000;
const MAX_CODEPOINT_BITS = Math.ceil(Math.log2(NUM_CODEPOINTS - 1));

const OffsetType = {
  U2: 2,
  U4: 4,
  U8: 8,
} as const;

type OffsetType = typeof OffsetType[keyof typeof OffsetType];

type CodePoint = number;
type BitPos = number;

const TABLE_CFGS: [BitPos, BitPos, OffsetType][] = [
  [13, MAX_CODEPOINT_BITS, OffsetType.U8],
  [6, 13, OffsetType.U8],
  [0, 6, OffsetType.U2],
];

async function fetchUnicodeData(filename: string, version: string) {
  const res = await fetch(
    `https://www.unicode.org/Public/${version}/ucd/${filename}`,
  );

  if (!res.ok) {
    throw new Error(`Failed to fetch ${filename}: status ${res.status}`);
  }

  return await res.text();
}

const EffectiveWidth = {
  Zero: 0,
  Narrow: 1,
  Wide: 2,
  Ambiguous: 3,
} as const;

type EffectiveWidth = typeof EffectiveWidth[keyof typeof EffectiveWidth];

const widthCodes = {
  N: EffectiveWidth.Narrow,
  Na: EffectiveWidth.Narrow,
  H: EffectiveWidth.Narrow,
  W: EffectiveWidth.Wide,
  F: EffectiveWidth.Wide,
  A: EffectiveWidth.Ambiguous,
};

async function loadEastAsianWidths(version: string) {
  const eaw = await fetchUnicodeData("EastAsianWidth.txt", version);

  const single = /^([0-9A-F]+);(\w+)/;
  const multiple = /^([0-9A-F]+)\.\.([0-9A-F]+);(\w+)/;

  const widthMap: EffectiveWidth[] = [];
  let current = 0;

  for (const line of eaw.split("\n")) {
    let rawData: [string, string, string] | null = null;

    let match: RegExpMatchArray | null = null;
    // deno-lint-ignore no-cond-assign
    if (match = line.match(single)) {
      rawData = [match[1]!, match[1]!, match[2]!];
      // deno-lint-ignore no-cond-assign
    } else if (match = line.match(multiple)) {
      rawData = [match[1]!, match[2]!, match[3]!];
    } else {
      continue;
    }

    const low = parseInt(rawData[0], 16);
    const high = parseInt(rawData[1], 16);
    const width = widthCodes[rawData[2] as keyof typeof widthCodes];

    assert(current <= high);

    while (current <= high) {
      widthMap.push(current < low ? EffectiveWidth.Narrow : width);
      ++current;
    }
  }

  while (widthMap.length < NUM_CODEPOINTS) {
    widthMap.push(EffectiveWidth.Narrow);
  }

  return widthMap;
}

async function loadZeroWidths(version: string) {
  const categories = await fetchUnicodeData("UnicodeData.txt", version);

  const zwMap: boolean[] = [];
  let current = 0;

  for (const line of categories.split("\n")) {
    const rawData = line.split(";");

    if (rawData.length !== 15) {
      continue;
    }
    const [codepoint, name, catCode] = [
      parseInt(rawData[0]!, 16),
      rawData[1],
      rawData[2],
    ];

    const zeroWidth = ["Cc", "Cf", "Mn", "Me"].includes(catCode!);

    assert(current <= codepoint);

    while (current <= codepoint) {
      if (name!.endsWith(", Last>") || (current === codepoint)) {
        zwMap.push(zeroWidth);
      } else {
        zwMap.push(false);
      }
      ++current;
    }
  }
  while (zwMap.length < NUM_CODEPOINTS) {
    zwMap.push(false);
  }

  return zwMap;
}

class Bucket {
  entrySet: Set<string>;
  widths: EffectiveWidth[];

  constructor() {
    this.entrySet = new Set();
    this.widths = [];
  }

  append(codepoint: CodePoint, width: EffectiveWidth) {
    this.entrySet.add(JSON.stringify([codepoint, width]));
    this.widths.push(width);
  }

  tryExtend(attempt: Bucket) {
    const [less, more] = [this.widths, attempt.widths].sort((a, b) =>
      a.length - b.length
    );

    if (!more!.slice(0, less!.length).every((v, i) => v === less![i])) {
      return false;
    }

    for (const x of attempt.entrySet.values()) {
      this.entrySet.add(x);
    }

    this.widths = more!;

    return true;
  }

  entries() {
    const result = [...this.entrySet]
      .map((x) => JSON.parse(x) as [CodePoint, EffectiveWidth]);

    return result.sort((a, b) => a[0] - b[0]);
  }

  width() {
    return new Set(this.widths).size === 1 ? this.widths[0] : null;
  }
}

function makeBuckets(
  entries: [CodePoint, EffectiveWidth][],
  lowBit: BitPos,
  capBit: BitPos,
) {
  const numBits = capBit - lowBit;
  assert(numBits > 0);
  const buckets = Array.from({ length: 2 ** numBits }, () => new Bucket());

  const mask = (1 << numBits) - 1;

  for (const [codepoint, width] of entries) {
    buckets[(codepoint >> lowBit) & mask]!.append(codepoint, width);
  }

  return buckets;
}

class Table {
  lowBit: BitPos;
  capBit: BitPos;
  offsetType: OffsetType;
  entries: number[];
  indexed: Bucket[];

  constructor(
    entryGroups: [CodePoint, EffectiveWidth][][],
    lowBit: BitPos,
    capBit: BitPos,
    offsetType: OffsetType,
  ) {
    this.lowBit = lowBit;
    this.capBit = capBit;
    this.offsetType = offsetType;
    this.entries = [];
    this.indexed = [];

    const buckets = entryGroups.flatMap((entries) =>
      makeBuckets(entries, this.lowBit, this.capBit)
    );

    for (const bucket of buckets) {
      let extended = false;
      for (const [i, existing] of this.indexed.entries()) {
        if (existing.tryExtend(bucket)) {
          this.entries.push(i);
          extended = true;
          break;
        }
      }
      if (!extended) {
        this.entries.push(this.indexed.length);
        this.indexed.push(bucket);
      }
    }

    for (const index of this.entries) {
      assert(index < (1 << this.offsetType));
    }
  }

  indicesToWidths() {
    if (!this.indexed) {
      throw new Error(`Cannot call indicesToWidths twice on the same table`);
    }

    this.entries = this.entries.map((i) => {
      const width = this.indexed[i]!.width();
      if (width === null) throw new TypeError("'width' cannot be null");
      return width!;
    });

    this.indexed = null as unknown as Bucket[];
  }

  get buckets() {
    if (!this.indexed) {
      throw new Error(`Cannot access buckets after calling indicesToWidths`);
    }

    return this.indexed;
  }

  toBytes() {
    const entriesPerByte = Math.trunc(8 / this.offsetType);
    const byteArray: number[] = [];
    for (let i = 0; i < this.entries.length; i += entriesPerByte) {
      let byte = 0;
      for (let j = 0; j < entriesPerByte; ++j) {
        byte |= this.entries[i + j]! << (j * this.offsetType);
      }
      byteArray.push(byte);
    }

    return byteArray;
  }
}

function makeTables(
  tableCfgs: [BitPos, BitPos, OffsetType][],
  entries: [CodePoint, EffectiveWidth][],
) {
  const tables: Table[] = [];
  let entryGroups = [entries];

  for (const [lowBit, capBit, offsetType] of tableCfgs) {
    const table = new Table(entryGroups, lowBit, capBit, offsetType);
    entryGroups = table.buckets.map((bucket) => bucket.entries());

    tables.push(table);
  }

  return tables;
}

export async function tables(version: string) {
  // deno-lint-ignore no-console
  console.info(`Generating tables for Unicode ${version}`);

  const eawMap = await loadEastAsianWidths(version);
  const zwMap = await loadZeroWidths(version);

  const widthMap = eawMap.map((x, i) => zwMap[i] ? EffectiveWidth.Zero : x);

  widthMap[0x00AD] = EffectiveWidth.Narrow;

  for (let i = 0x1160; i < 0x11FF + 1; ++i) {
    widthMap[i] = EffectiveWidth.Zero;
  }

  const tables = makeTables(TABLE_CFGS, [...widthMap.entries()]);

  tables[tables.length - 1]!.indicesToWidths();

  return tables;
}

const data = {
  UNICODE_VERSION,
  tables: (await tables(UNICODE_VERSION)).map((table) =>
    runLengthEncode(table.toBytes())
  ),
};

assert(data.UNICODE_VERSION.split(".").length === 3);
assert(data.tables.length === 3);

await Deno.writeTextFile("../_data.json", JSON.stringify(data, null, 2) + "\n");



================================================
FILE: cli/testdata/unicode_width_crate/Cargo.toml
================================================
[package]
name = "unicode_width_crate"
version = "0.1.0"
edition = "2021"

[dependencies]
libc = "0.2.140"
serde_json = "1.0.95"
unicode-width = "0.1.10"

[lib]
crate-type = ["cdylib"]



================================================
FILE: cli/testdata/unicode_width_crate/src/lib.rs
================================================
// Copyright 2018-2025 the Deno authors. MIT license.

use libc::c_char;
use std::ffi::CStr;
use serde_json;
use unicode_width::UnicodeWidthStr;

fn from_c_char(ptr: *const c_char) -> &'static str {
    let c_str = unsafe {
        assert!(!ptr.is_null());

        CStr::from_ptr(ptr)
    };
    return c_str.to_str().unwrap();
}

#[no_mangle]
pub extern "C" fn unicode_width(json_str: *const c_char) -> usize {
    let json_str = from_c_char(json_str);

    serde_json::from_str::<String>(json_str).unwrap().width()
}


