#!/usr/bin/env bash
# Example: Automated build testing with LLM-assisted debugging
# This demonstrates how to integrate the build status system into
# automated testing and debugging workflows

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"
readonly LOG_DIR="${LOG_DIR:-/var/log/nixos-builds}"
readonly FLAKE_PATH="${FLAKE_PATH:-/etc/nixos}"

# Color codes
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'
readonly BOLD='\033[1m'

# Test results
declare -a TEST_RESULTS=()
declare -i TESTS_PASSED=0
declare -i TESTS_FAILED=0

# Source build status library
# shellcheck disable=SC1091
source "$LIB_DIR/build-status.sh"

# Test framework helpers
test_header() {
  printf '%b\n' "${CYAN}${BOLD}╔════════════════════════════════════════════════╗${NC}"
  printf '%b\n' "${CYAN}${BOLD}║  NixOS Build Automation Test Suite            ║${NC}"
  printf '%b\n' "${CYAN}${BOLD}╚════════════════════════════════════════════════╝${NC}"
  printf '\n'
}

test_section() {
  printf '%b\n' "${BLUE}${BOLD}=== $1 ===${NC}"
}

run_test() {
  local test_name="$1"
  local test_description="$2"
  shift 2
  local test_cmd=("$@")

  printf '%b' "  ▸ ${test_name}: "

  local output
  if output=$("${test_cmd[@]}" 2>&1); then
    printf '%b\n' "${GREEN}✓ PASS${NC}"
    TEST_RESULTS+=("PASS: $test_name")
    ((TESTS_PASSED++))
    return 0
  else
    printf '%b\n' "${RED}✗ FAIL${NC}"
    printf '%b\n' "${RED}    Error: $output${NC}"
    TEST_RESULTS+=("FAIL: $test_name - $output")
    ((TESTS_FAILED++))
    return 1
  fi
}

# Collect debug context for LLM
collect_debug_context() {
  local context_file="$1"

  cat > "$context_file" <<'EOF'
# NixOS Build Failure Debug Context
# Generated by automated test suite for LLM analysis

EOF

  {
    echo "## System Information"
    echo "\`\`\`"
    uname -a
    hostname
    date -Iseconds
    echo "\`\`\`"
    echo ""

    echo "## Build Status"
    echo "\`\`\`json"
    nixos-build-status --json 2>/dev/null || echo "{}"
    echo "\`\`\`"
    echo ""

    echo "## Generation Information"
    echo "\`\`\`"
    nixos-generation-info 2>/dev/null || echo "Not available"
    echo "\`\`\`"
    echo ""

    echo "## Last Build Log"
    echo "\`\`\`json"
    get_last_build_status
    echo "\`\`\`"
    echo ""

    if [[ -f "$LOG_DIR/last-build.log" ]]; then
      echo "## Build Output (last 100 lines)"
      echo "\`\`\`"
      tail -100 "$LOG_DIR/last-build.log"
      echo "\`\`\`"
      echo ""

      echo "## Extracted Errors"
      echo "\`\`\`json"
      extract_nix_errors "$LOG_DIR/last-build.log"
      echo "\`\`\`"
      echo ""
    fi

    echo "## Failed Systemd Units"
    echo "\`\`\`json"
    check_failed_units
    echo "\`\`\`"
    echo ""

    echo "## Recent Journal Errors (last hour)"
    echo "\`\`\`"
    journalctl -p err --since "1 hour ago" --no-pager -n 50 2>/dev/null || echo "Not available"
    echo "\`\`\`"
    echo ""

    echo "## Flake Metadata"
    echo "\`\`\`"
    nix flake metadata "$FLAKE_PATH" --no-write-lock-file 2>&1 || echo "Flake metadata unavailable"
    echo "\`\`\`"
    echo ""

    echo "## Current Configuration Commit"
    echo "\`\`\`"
    echo "Commit: $(get_current_commit)"
    echo "Nixpkgs: $(get_current_nixpkgs_rev)"
    echo "\`\`\`"

  } >> "$context_file"

  printf '%b\n' "${CYAN}Debug context saved to: $context_file${NC}"
}

# Send to LLM for analysis (example - customize for your LLM tool)
analyze_with_llm() {
  local context_file="$1"

  printf '%b\n' "${YELLOW}Sending debug context to LLM for analysis...${NC}"

  # Example: Using Claude Code (customize as needed)
  if command -v claude &>/dev/null; then
    printf '%b\n' "${BLUE}Requesting LLM analysis via Claude...${NC}"

    cat <<EOF | claude code
I have a NixOS build failure. Please analyze the debug context below and:
1. Identify the root cause of the failure
2. Provide specific steps to fix it
3. Suggest any preventive measures

Debug Context:
$(cat "$context_file")

Please provide:
- Root cause analysis
- Specific fix commands
- Explanation of why this happened
EOF
  else
    printf '%b\n' "${YELLOW}LLM tool not available. Debug context saved for manual review.${NC}"
    printf '%b\n' "${CYAN}Review at: $context_file${NC}"
  fi
}

# Main test suite
main() {
  test_header

  # Phase 1: Pre-Build Checks
  test_section "Phase 1: Pre-Build Validation"

  run_test "Flake Evaluation" \
    "Check if flake can be evaluated" \
    nix flake show "$FLAKE_PATH" --no-write-lock-file

  run_test "Flake Metadata" \
    "Check if flake metadata is accessible" \
    nix flake metadata "$FLAKE_PATH" --no-write-lock-file

  run_test "No Failed Units" \
    "Verify no systemd units have failed" \
    bash -c '[[ $(check_failed_units | jq "length") -eq 0 ]]'

  printf '\n'

  # Phase 2: Build Test
  test_section "Phase 2: Build Execution"

  printf '%b\n' "  ▸ Building NixOS configuration (dry-run)..."
  if nixos-build-wrapper os dry-build --json > "$LOG_DIR/test-build.json" 2>&1; then
    printf '%b\n' "${GREEN}  ✓ Dry build succeeded${NC}"
    TEST_RESULTS+=("PASS: NixOS dry-build")
    ((TESTS_PASSED++))
  else
    local exit_code=$?
    printf '%b\n' "${RED}  ✗ Dry build failed (exit code: $exit_code)${NC}"
    TEST_RESULTS+=("FAIL: NixOS dry-build - exit code $exit_code")
    ((TESTS_FAILED++))

    # Collect debug context
    local context_file="$LOG_DIR/debug-context-$(date +%s).md"
    printf '%b\n' "${YELLOW}  ⚠ Collecting debug context...${NC}"
    collect_debug_context "$context_file"

    # Optionally analyze with LLM
    if [[ "${AUTO_DEBUG:-0}" == "1" ]]; then
      analyze_with_llm "$context_file"
    fi
  fi

  printf '\n'

  # Phase 3: Post-Build Validation
  test_section "Phase 3: Post-Build Validation"

  run_test "Generation In Sync" \
    "Check if current generation matches latest" \
    is_generation_in_sync

  run_test "Last Build Successful" \
    "Verify last build completed successfully" \
    was_last_build_successful

  run_test "No Build Errors" \
    "Check for errors in last build" \
    bash -c '[[ $(nixos-build-status --json | jq -r ".buildErrors.errorCount") -eq 0 ]]'

  printf '\n'

  # Phase 4: System Health Checks
  test_section "Phase 4: System Health"

  run_test "System Status" \
    "Overall system health check" \
    bash -c 'nixos-build-status --json | jq -e ".overallStatus == \"success\""'

  run_test "Home Manager Status" \
    "Check Home Manager generation status" \
    bash -c 'nixos-generation-info --json | jq -e ".homeManagerStatus == \"in-sync\""'

  run_test "Journal Clean" \
    "Check for recent journal errors" \
    bash -c '[[ $(check_journal_errors "1 hour ago") -lt 10 ]]'

  printf '\n'

  # Results Summary
  test_section "Test Results Summary"

  printf '\n'
  for result in "${TEST_RESULTS[@]}"; do
    if [[ "$result" =~ ^PASS ]]; then
      printf '%b\n' "${GREEN}  ✓ $result${NC}"
    else
      printf '%b\n' "${RED}  ✗ $result${NC}"
    fi
  done

  printf '\n'
  printf '%b\n' "${BOLD}Total Tests: $((TESTS_PASSED + TESTS_FAILED))${NC}"
  printf '%b\n' "${GREEN}Passed: $TESTS_PASSED${NC}"
  printf '%b\n' "${RED}Failed: $TESTS_FAILED${NC}"

  if [[ $TESTS_FAILED -eq 0 ]]; then
    printf '\n'
    printf '%b\n' "${GREEN}${BOLD}╔════════════════════════════════════════════════╗${NC}"
    printf '%b\n' "${GREEN}${BOLD}║  ALL TESTS PASSED ✓                            ║${NC}"
    printf '%b\n' "${GREEN}${BOLD}╚════════════════════════════════════════════════╝${NC}"
    exit 0
  else
    printf '\n'
    printf '%b\n' "${RED}${BOLD}╔════════════════════════════════════════════════╗${NC}"
    printf '%b\n' "${RED}${BOLD}║  SOME TESTS FAILED ✗                           ║${NC}"
    printf '%b\n' "${RED}${BOLD}╚════════════════════════════════════════════════╝${NC}"
    printf '\n'
    printf '%b\n' "${YELLOW}Review logs at: $LOG_DIR${NC}"
    printf '%b\n' "${YELLOW}Run 'nixos-build-status --verbose' for details${NC}"
    exit 1
  fi
}

# Run main if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
