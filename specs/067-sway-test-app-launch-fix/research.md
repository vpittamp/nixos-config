# Research: Sway Test Framework Enhancement

**Feature**: 067-sway-test-app-launch-fix
**Date**: 2025-11-08
**Phase**: 0 - Technology Research

## Research Questions

This document consolidates research for all "NEEDS CLARIFICATION" items from Technical Context and design decisions required for implementation.

## 1. Sway IPC Event Subscription Mechanism

### Decision
Use `swaymsg -t subscribe -m '[event-types]'` subprocess with JSON line parsing for event-driven wait_event implementation.

### Rationale
- **Native Sway Support**: Sway provides built-in IPC subscription via `swaymsg -t subscribe`
- **JSON Streaming**: Events arrive as JSON lines on stdout, easily parseable in TypeScript
- **Multiple Event Types**: Can subscribe to multiple event types simultaneously: `window`, `workspace`, `binding`, `shutdown`, `tick`
- **Deno Subprocess API**: `Deno.Command` provides streaming stdout access with `readable` property
- **No Additional Dependencies**: Uses standard Sway tooling, no third-party libraries needed

### Implementation Pattern
```typescript
// Subprocess approach for event subscription
const command = new Deno.Command("swaymsg", {
  args: ["-t", "subscribe", "-m", JSON.stringify(["window", "workspace"])],
  stdout: "piped",
  stderr: "piped",
});

const process = command.spawn();

// Read events as JSON lines
const decoder = new TextDecoder();
for await (const chunk of process.stdout) {
  const lines = decoder.decode(chunk).split("\n");
  for (const line of lines) {
    if (line.trim()) {
      const event = JSON.parse(line);
      // Process event
    }
  }
}
```

### Alternatives Considered
1. **Direct Unix Socket Communication**: Would require implementing Sway IPC protocol (socket framing, message types, binary protocol). Rejected because `swaymsg` already handles this complexity.
2. **Third-Party Library** (e.g., swayipc for Rust/Node.js): No mature TypeScript/Deno library exists. Rejected to avoid adding dependencies.
3. **Polling `swaymsg -t get_tree`**: Would require polling at intervals (high CPU, race conditions). Rejected because event subscription is real-time and efficient.

### Related Requirements
- FR-004: wait_event action with event subscription
- FR-005: Respect timeout up to 60 seconds
- FR-006: Filter events by type (window::new vs window::close)

---

## 2. App Registry JSON Structure and Location

### Decision
Read application registry from `~/.config/i3/application-registry.json` using Deno file I/O with JSON parsing and Zod validation.

### Rationale
- **Known Location**: Application registry is generated by Nix home-manager at `~/.config/i3/application-registry.json`
- **JSON Format**: Already JSON, no parsing complexity
- **Schema Validation**: Use Zod to validate registry structure and app entries
- **Read-Only**: Tests only read registry, never modify it
- **Existing Structure**: Registry contains:
  - `app_name`: Unique identifier (e.g., "firefox", "vscode")
  - `command`: Launch command
  - `preferred_workspace`: Target workspace number
  - `scope`: "global" or "scoped"
  - `expected_class`: Expected Wayland app_id or X11 class

### Implementation Pattern
```typescript
import { z } from "zod";

const AppEntrySchema = z.object({
  app_name: z.string(),
  command: z.string(),
  preferred_workspace: z.number().optional(),
  scope: z.enum(["global", "scoped"]),
  expected_class: z.string().optional(),
  pwas: z.array(z.object({
    id: z.string(),
    expected_class: z.string(),
  })).optional(),
});

const AppRegistrySchema = z.record(z.string(), AppEntrySchema);

export async function loadAppRegistry(): Promise<Map<string, AppEntry>> {
  const registryPath = `${Deno.env.get("HOME")}/.config/i3/application-registry.json`;
  const content = await Deno.readTextFile(registryPath);
  const data = AppRegistrySchema.parse(JSON.parse(content));
  return new Map(Object.entries(data));
}
```

### Alternatives Considered
1. **Hardcode App Paths**: Would break when apps change. Rejected for maintainability.
2. **Query Daemon**: Daemon doesn't expose registry API. Rejected as unnecessary complexity.
3. **Environment Variables**: Registry not exposed as env vars. Rejected as infeasible.

### Related Requirements
- FR-002: launch_app_via_wrapper action with app name lookup
- FR-011: validate_workspace_assignment helper
- FR-020: Validate test syntax for invalid app names

---

## 3. RPC Method Introspection Approach

### Decision
Use JSON-RPC 2.0 `system.listMethods` introspection call to detect available methods, with memoization to avoid repeated checks.

### Rationale
- **Standard JSON-RPC**: Most JSON-RPC implementations support `system.listMethods` for reflection
- **Session-Level Caching**: Check once per framework initialization, cache result
- **Graceful Degradation**: If introspection fails, assume methods unavailable and disable features
- **Minimal Overhead**: Single RPC call at startup, no per-test overhead
- **Fallback Strategy**: When method unavailable, fall back to timeout-based synchronization

### Implementation Pattern
```typescript
export class TreeMonitorClient {
  private availableMethods: Set<string> | null = null;

  async checkMethodAvailability(methodName: string): Promise<boolean> {
    // Lazy load available methods on first call
    if (this.availableMethods === null) {
      try {
        const methods = await this.sendRequest("system.listMethods", {}) as string[];
        this.availableMethods = new Set(methods);
      } catch (error) {
        console.warn("RPC introspection unavailable, disabling auto-sync features");
        this.availableMethods = new Set(); // Empty set = no methods available
      }
    }

    return this.availableMethods.has(methodName);
  }

  async sendSyncMarker(): Promise<string> {
    // Check if method available before calling
    if (!(await this.checkMethodAvailability("sendSyncMarker"))) {
      throw new Error("sendSyncMarker not available - daemon does not support sync markers");
    }

    return await this.sendRequest("sendSyncMarker", {}) as string;
  }
}
```

### Alternatives Considered
1. **Try-Catch on Every Call**: Would spam "Method not found" errors. Rejected per FR-010.
2. **Hardcoded Method List**: Would break when daemon updates. Rejected for maintainability.
3. **Version Detection**: Daemon doesn't expose version in predictable way. Rejected as unreliable.

### Related Requirements
- FR-008: Detect missing RPC methods via introspection
- FR-009: Fall back to timeout-based sync when daemon unavailable
- FR-010: Suppress repeated "Method not found" errors

---

## 4. Environment Variable Validation Approach

### Decision
Read `/proc/<pid>/environ` file for process environment, parse null-separated key-value pairs, validate I3PM_* variables exist.

### Rationale
- **Linux Procfs**: Standard Linux feature, available on all NixOS systems
- **No External Tools**: Can be read directly via Deno.readTextFile
- **I3PM Convention**: All I3PM environment variables start with `I3PM_` prefix
- **Validation Assertions**: Tests can assert specific variables exist and have expected values
- **Alternative to window-env**: No need to shell out to external utility

### Implementation Pattern
```typescript
export interface WindowEnvironment {
  I3PM_APP_NAME?: string;
  I3PM_APP_ID?: string;
  I3PM_TARGET_WORKSPACE?: string;
  I3PM_PROJECT_NAME?: string;
  I3PM_SCOPE?: string;
  [key: string]: string | undefined;
}

export async function readWindowEnvironment(pid: number): Promise<WindowEnvironment> {
  const environPath = `/proc/${pid}/environ`;

  try {
    const content = await Deno.readTextFile(environPath);

    // Parse null-separated key=value pairs
    const env: WindowEnvironment = {};
    const pairs = content.split("\0");

    for (const pair of pairs) {
      const [key, ...valueParts] = pair.split("=");
      if (key) {
        env[key] = valueParts.join("="); // Handle values with = in them
      }
    }

    return env;
  } catch (error) {
    throw new Error(`Failed to read environment for PID ${pid}: ${error.message}`);
  }
}

export function validateI3pmEnvironment(env: WindowEnvironment): { valid: boolean; missing: string[] } {
  const required = ["I3PM_APP_NAME", "I3PM_APP_ID", "I3PM_TARGET_WORKSPACE"];
  const missing = required.filter(key => !env[key]);

  return {
    valid: missing.length === 0,
    missing,
  };
}
```

### Alternatives Considered
1. **window-env Utility**: External shell script, adds subprocess overhead. Rejected for simplicity.
2. **Daemon Query**: Daemon doesn't expose process environments. Rejected as infeasible.
3. **Parse swaymsg Output**: Sway doesn't include env vars in tree output. Rejected as unavailable.

### Related Requirements
- FR-003: Validate I3PM environment variables in launched processes
- FR-012: Extract window PID from Sway tree and query /proc
- FR-016: Log diagnostic information when wrapper launch fails

---

## 5. Wait Event Timeout Handling

### Decision
Use `Promise.race()` with timeout promise and event arrival promise to implement configurable timeout with immediate return on event.

### Rationale
- **Immediate Return**: Promise.race resolves as soon as first promise resolves (event or timeout)
- **Clean Cancellation**: AbortController can cancel event subscription on timeout
- **TypeScript Pattern**: Standard pattern for cancelable async operations
- **Configurable**: Timeout value from test definition or action parameter
- **No Busy-Wait**: Event-driven, no polling

### Implementation Pattern
```typescript
export async function waitForEvent(
  eventType: string,
  criteria: Record<string, unknown>,
  timeoutMs: number
): Promise<SwayEvent> {
  // Create abort controller for cleanup
  const abortController = new AbortController();

  // Promise that resolves when event arrives
  const eventPromise = new Promise<SwayEvent>((resolve) => {
    const subscription = subscribeToEvents([eventType], (event) => {
      // Check if event matches criteria
      if (matchesEventCriteria(event, criteria)) {
        resolve(event);
        abortController.abort(); // Cancel subscription
      }
    });

    // Cleanup on abort
    abortController.signal.addEventListener("abort", () => {
      subscription.unsubscribe();
    });
  });

  // Promise that rejects after timeout
  const timeoutPromise = new Promise<SwayEvent>((_, reject) => {
    setTimeout(() => {
      reject(new Error(`wait_event timed out after ${timeoutMs}ms waiting for ${eventType}`));
      abortController.abort();
    }, timeoutMs);
  });

  // Race between event arrival and timeout
  return Promise.race([eventPromise, timeoutPromise]);
}
```

### Alternatives Considered
1. **Fixed Delay**: Current implementation (max 1 second). Rejected as too limiting.
2. **Polling get_tree**: Would miss events between polls. Rejected for reliability.
3. **No Timeout**: Could hang forever. Rejected for poor UX.

### Related Requirements
- FR-005: wait_event MUST respect timeout parameter up to 60 seconds
- FR-006: Filter events by type to avoid false matches
- SC-002: 0% false timeouts proving event-driven synchronization

---

## 6. Optimal launch_app Implementation

### Decision
Replace launch_app action to ALWAYS use app-launcher-wrapper.sh. Remove direct execution support entirely. Command parameter is always interpreted as app name from registry.

### Rationale
- **Principle XII**: Forward-only development - no legacy support
- **Production Realism**: All tests use production launch flow (wrapper)
- **I3PM Integration**: Ensures environment variables always injected correctly
- **Simpler Code**: Single code path, no conditional logic
- **Clear Intent**: No ambiguity about how apps launch
- **Optimal Solution**: Testing the actual user experience, not a simplified version

### Implementation Pattern
```typescript
// Optimal test definition
{
  "type": "launch_app",
  "params": {
    "app_name": "firefox",  // ALWAYS app name from registry
    "args": [],             // Optional additional args
    "project": "nixos"      // Optional project context
  }
}

// Action executor (single path)
private async executeLaunchApp(action: Action): Promise<void> {
  const appName = action.params.app_name as string;

  // Validate app exists in registry
  const app = await this.appRegistry.lookupApp(appName);

  // Launch via wrapper (only path)
  await this.launchViaWrapper(appName, {
    args: action.params.args || [],
    project: action.params.project,
    workspace: action.params.workspace,
  });
}
```

### Breaking Changes
- **Old**: `{ "type": "launch_app", "params": { "command": "firefox" } }`
- **New**: `{ "type": "launch_app", "params": { "app_name": "firefox" } }`
- **Impact**: ALL existing tests must update to use `app_name` and ensure apps are in registry
- **Justification**: Optimal solution, tests now validate production flow

### Alternatives Rejected
1. **Keep Direct Launch**: Would preserve suboptimal test pattern. Rejected per Principle XII.
2. **Optional via_wrapper Parameter**: Would preserve dual code paths. Rejected for complexity.
3. **Automatic Detection**: Would add implicit behavior. Rejected for clarity.

### Related Requirements
- FR-002: launch_app uses wrapper (not optional)
- FR-013: launch_app with app_name parameter (not via_wrapper flag)
- FR-018: Handle wrapper launching apps via swaymsg exec

---

## 7. Test Framework Integration Points

### Decision Summary

| Integration Point | Approach | Rationale |
|------------------|----------|-----------|
| **Event Subscription** | swaymsg subprocess | Native Sway support, no dependencies |
| **App Registry** | JSON file read with Zod | Standard location, schema validation |
| **RPC Introspection** | system.listMethods with memoization | Standard JSON-RPC, single overhead |
| **Environment Validation** | /proc/<pid>/environ read | Direct, no external tools |
| **Wait Timeout** | Promise.race with AbortController | Immediate return, clean cancellation |
| **Launch Compatibility** | Optional via_wrapper parameter | Zero breaking changes |

---

## Technology Stack Confirmation

### Core Technologies (Unchanged)
- **Runtime**: Deno 1.40+
- **Language**: TypeScript with strict mode
- **CLI Parsing**: @std/cli parseArgs()
- **File I/O**: @std/fs, Deno.readTextFile
- **Subprocess**: Deno.Command API
- **Validation**: Zod for JSON schemas

### New Dependencies (None Required)
All functionality achievable with existing dependencies and Deno standard library.

### External Tools Required
- `swaymsg`: Sway IPC command-line tool (already available on system)
- `app-launcher-wrapper.sh`: Existing script at `~/.local/bin/` (read-only dependency)

---

## Performance Considerations

### Event Subscription Overhead
- **Startup Cost**: Single subprocess spawn (<10ms)
- **Memory**: JSON line buffering (~1KB per event)
- **CPU**: Negligible (event-driven, no polling)
- **Cleanup**: Subprocess terminated on test completion

### RPC Introspection
- **Startup Cost**: Single RPC call (~5ms)
- **Memory**: Set of method names (<1KB)
- **Caching**: Session-level, no per-test overhead

### Environment Variable Validation
- **Per-Window Cost**: File read + parse (~1ms)
- **Memory**: Environment object (~2-5KB per process)
- **Frequency**: Only when test explicitly validates

### Timeout Handling
- **Overhead**: Promise.race + setTimeout (~0.1ms)
- **Cleanup**: AbortController ensures proper resource cleanup
- **No Busy-Wait**: Event-driven, CPU idle while waiting

---

## Risk Analysis

### High Confidence Areas âœ…
- Sway IPC event subscription (well-documented, mature)
- JSON file reading (standard Deno API)
- Process environment reading (standard Linux feature)
- Timeout with Promise.race (TypeScript best practice)

### Medium Confidence Areas âš ï¸
- RPC method introspection (assumes daemon supports system.listMethods)
  - **Mitigation**: Fallback to empty method set on introspection failure
- Event filtering accuracy (depends on Sway event payload structure)
  - **Mitigation**: Validate against real Sway events, adjust criteria matching

### Low Risk Areas ðŸŸ¢
- Breaking changes (opt-in via_wrapper parameter prevents)
- Performance degradation (event-driven, minimal overhead)
- Dependency bloat (zero new dependencies)

---

## Next Steps

Phase 1 (Design):
1. Define data models (Event, AppRegistryEntry, WindowEnvironment)
2. Document API contracts (waitForEvent, launchViaWrapper, validateEnvironment)
3. Create integration test scenarios
4. Write quickstart guide with examples
