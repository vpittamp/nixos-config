Directory structure:
└── lbonn-i3-quickterm/
    ├── README.md
    ├── LICENSE.txt
    ├── requirements-dev.txt
    ├── ruff.toml
    ├── setup.cfg
    ├── setup.py
    ├── i3-quickterm -> main.py
    ├── i3_quickterm/
    │   ├── __init__.py
    │   └── main.py
    ├── tests/
    │   ├── conftest.py
    │   ├── test_args_and_conf.py
    │   ├── test_quickterm.py
    │   └── test_run_logic.py
    ├── typings/
    │   └── i3ipc/
    │       ├── __init__.pyi
    │       ├── __version__.pyi
    │       ├── con.pyi
    │       ├── connection.pyi
    │       ├── events.pyi
    │       ├── model.pyi
    │       ├── replies.pyi
    │       ├── _private/
    │       │   ├── __init__.pyi
    │       │   ├── pubsub.pyi
    │       │   ├── sync.pyi
    │       │   └── types.pyi
    │       └── aio/
    │           ├── __init__.pyi
    │           └── connection.pyi
    └── .github/
        ├── actions/
        │   └── test/
        │       └── action.yml
        └── workflows/
            └── check.yml

================================================
FILE: README.md
================================================
# i3-quickterm

[![Packaging status](https://repology.org/badge/vertical-allrepos/python:i3-quickterm.svg)](https://repology.org/project/python:i3-quickterm/versions)

A small drop-down terminal for [i3wm](https://i3wm.org/) and [sway](https://swaywm.org/)

## Features

* use your favourite terminal emulator
* can select a shell with [dmenu](http://tools.suckless.org/dmenu/) / [rofi](https://github.com/DaveDavenport/rofi)
* adapt to screen width
* multi-monitor aware

## Installation

Via pip:

```
pip install i3-quickterm
```

Or check the the repology badge above to see if it is packaged by your distribution.

## Usage

When launched, it will minimize the quickterm on the current screen if there is one.  Otherwise, it will either prompt the user for the shell to open or use the one supplied in argument.

If the requested shell is already opened on another screen, it will be moved on the current screen.

It is recommended to map it to an i3 binding:

```
# with prompt
bindsym $mod+p exec i3-quickterm
# always bring up standard shell, without the menu
bindsym $mod+b exec i3-quickterm shell
```

## Configuration

The configuration is read from `~/.config/i3-quickterm/config.json` or `~/.config/i3/i3-quickterm.json`.

* `menu`: the dmenu-compatible application used to select the shell
* `term`: the terminal emulator of choice
* `history`: a file to save the last-used shells order, last-used ordering is disabled if set to null
* `width`: the percentage of the screen width to use
* `height`: the percentage of the screen height to use
* `pos`: where to pop the terminal (`top` or `bottom`)
* `shells`: registered shells (`{ name: command }`)

`term` can be either:
- the name of a terminal from the [supported list](#supported-terminals).
- `auto` to select the first existing terminal of the list above (only to provide friendler defaults, not recommended otherwise)
- a format string, like this one: `urxvt -t {title} -e {expanded}` with the correct arguments format of your terminal. Some terminals, like xfce4-terminal need the command argument to be passed as a string. In this case, replace `{expanded}` by `{string}`

`menu`, `term`, `history` and `shell` can contain placeholders for environment variables: `{$var}`.

Unspecified keys are inherited from the defaults:

```
{
    "menu": "rofi -dmenu -p 'quickterm: ' -no-custom -auto-select",
    "term": "auto",
    "history": "{$HOME}/.cache/i3-quickterm/shells.order",
    "width": 1.0,
    "height": 0.25,
    "pos": "top",
    "shells": {
        "js": "node",
        "python": "ipython3 --no-banner",
        "shell": "{$SHELL}"
    }
}
```

## Supported terminals

* alacritty
* foot
* gnome-terminal
* kitty
* roxterm
* st
* terminator
* termite
* urxvt
* urxvtc
* xfce4-terminal
* xterm

If you'd like to add another terminal (or correct an error), please open a pull request.

## Requirements

* python >= 3.8
* i3 >= v3.11 or sway >= 1.2
* [i3ipc-python](https://i3ipc-python.readthedocs.io/en/latest/) >= v2.0.1
* dmenu or rofi (optional)



================================================
FILE: LICENSE.txt
================================================
MIT License

Copyright (c) 2016-2020 lbonn

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: requirements-dev.txt
================================================
coverage==7.4.1
iniconfig==2.0.0
mypy==1.8.0
mypy-extensions==1.0.0
packaging==23.2
pluggy==1.4.0
pytest==8.0.1
ruff==0.2.2
typing_extensions==4.9.0



================================================
FILE: ruff.toml
================================================
[lint]
select = ["E4", "E7", "E9", "F", "A", "B", "PIE", "RET", "RUF"]



================================================
FILE: setup.cfg
================================================
[metadata]
license_files = LICENSE.txt

[bdist_wheel]
universal=0

[tool:pytest]
testpaths = tests

[coverage:run]
omit = /usr/*

[mypy]
mypy_path = $MYPY_CONFIG_FILE_DIR/typings/



================================================
FILE: setup.py
================================================
import codecs
from os import path
import re

from setuptools import setup, find_packages

# from https://packaging.python.org/guides/single-sourcing-package-version/
here = path.abspath(path.dirname(__file__))


def read(*parts):
    with codecs.open(path.join(here, *parts), "r") as fp:
        return fp.read()


def find_version(*file_paths):
    version_file = read(*file_paths)
    version_match = re.search(r"^__version__ = ['\"]([^'\"]*)['\"]", version_file, re.M)
    if version_match:
        return version_match.group(1)
    raise RuntimeError("Unable to find version string.")


with open(path.join(here, "README.md"), encoding="utf-8") as f:
    long_description = f.read()


setup(
    name="i3-quickterm",
    version=find_version("i3_quickterm", "main.py"),
    description="A small drop-down terminal for i3 and sway",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/lbonn/i3-quickterm",
    author="lbonn",
    author_email="github@lbonnans.net",
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: End Users/Desktop",
        "Topic :: Desktop Environment",
        "Topic :: Terminals :: Terminal Emulators/X Terminals",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
    ],
    keywords="i3 i3wm extensions add-ons",
    packages=find_packages(where="."),
    python_requires=">=3.8",
    install_requires=["i3ipc>=2.0.1"],
    extras_require={
        "dev": ["coverage", "mypy", "pytest", "ruff"],
    },
    entry_points={
        "console_scripts": [
            "i3-quickterm=i3_quickterm:run_main",
        ],
    },
    project_urls={
        "Bug Reports": "https://github.com/lbonn/i3-quickterm/issues",
        "Source": "https://github.com/lbonn/i3-quickterm",
    },
)



================================================
SYMLINK: i3-quickterm -> main.py
================================================



================================================
FILE: i3_quickterm/__init__.py
================================================
from .main import main as run_main

__all__ = ["run_main"]



================================================
FILE: i3_quickterm/main.py
================================================
#!/usr/bin/env python3

import argparse
import copy
import fcntl
import json
import os
import shlex
import shutil
import subprocess
import sys
import traceback

from typing import cast, Any, Dict, Generator, Literal, Optional, TextIO

from contextlib import contextmanager, suppress
from pathlib import Path

import i3ipc


__version__ = "1.2"


# fmt: off
DEFAULT_CONF = {
    "menu": "rofi -dmenu -p 'quickterm: ' -no-custom -auto-select",
    "term": "auto",
    "history": "{$HOME}/.cache/i3-quickterm/shells.order",
    "height": 0.25,
    "width": 1.0,
    "pos": "top",
    "shells": {
        "js": "node",
        "python": "ipython3 --no-banner",
        "shell": "{$SHELL}"
    }
}
# fmt: on


MARK_QT_PATTERN = "quickterm_.*"
MARK_QT = "quickterm_{}"

# types
ExecFmtMode = Literal["expanded", "string"]
Conf = Dict[str, Any]


def TERM(
    executable: str,
    execopt: str = "-e",
    execfmt: ExecFmtMode = "expanded",
    titleopt: Optional[str] = "-T",
):
    """Helper to declare a terminal in the hardcoded list"""
    if execfmt not in ("expanded", "string"):
        raise RuntimeError("Invalid execfmt")

    fmt = executable

    if titleopt is not None:
        fmt += " " + titleopt + " {title}"

    fmt += f" {execopt} {{{execfmt}}}"

    return fmt


TERMS = {
    "alacritty": TERM("alacritty", titleopt="-t"),
    "foot": TERM("foot", titleopt="-T", execopt="", execfmt="expanded"),
    "gnome-terminal": TERM("gnome-terminal", execopt="--", titleopt=None),
    "kitty": TERM("kitty", titleopt="-T"),
    "roxterm": TERM("roxterm"),
    "st": TERM("st"),
    "terminator": TERM("terminator", execopt="-x", titleopt="-T"),
    "termite": TERM("termite", execfmt="string", titleopt="-t"),
    "urxvt": TERM("urxvt"),
    "urxvtc": TERM("urxvtc"),
    "xfce4-terminal": TERM("xfce4-terminal", execfmt="string"),
    "xterm": TERM("xterm"),
}


def quoted(s: str) -> str:
    return "'" + s + "'"


def expand_command(cmd: str, **rplc_map):
    d = {"$" + k: v for k, v in os.environ.items()}
    d.update(rplc_map)

    return shlex.split(cmd.format(**d))


def term_title(shell: str) -> str:
    return f"{shell} - i3-quickterm"


def conf_path() -> Optional[str]:
    locations = [
        "i3-quickterm/config.json",
        "i3/i3-quickterm.json",  # legacy location
    ]
    home_dir = os.environ["HOME"]
    xdg_dir = os.environ.get("XDG_CONFIG_DIR", f"{home_dir}/.config")

    for loc in locations:
        full_loc = f"{xdg_dir}/{loc}"
        if os.path.exists(full_loc):
            return full_loc

    return None


def read_conf(fn) -> Conf:
    if fn is None:
        print("no config file! using defaults", file=sys.stderr)
        return {}

    try:
        with open(fn, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"invalid config file: {e}", file=sys.stderr)
        return {}


@contextmanager
def read_history_file(conf: Conf) -> Generator[Optional[TextIO], None, None]:
    if conf["history"] is None:
        yield None
        return

    p = Path(expand_command(conf["history"])[0])

    os.makedirs(str(p.parent), exist_ok=True)

    f = open(str(p), "a+")
    fcntl.lockf(f, fcntl.LOCK_EX)

    try:
        f.seek(0)
        yield f
    finally:
        fcntl.lockf(f, fcntl.LOCK_UN)
        f.close()


def select_terminal(term_fmt: str) -> str:
    if term_fmt == "auto":
        for t, fmt in sorted(TERMS.items()):
            if shutil.which(t) is not None:
                return fmt
        raise RuntimeError(
            f"Could not find a suitable terminal "
            f"in the predefined list: {sorted(TERMS.keys())}"
        )

    if term_fmt in TERMS:
        # one of the pre-configured terminals
        return cast(str, TERMS.get(term_fmt))

    return term_fmt


def select_shell(conf: Conf) -> Optional[str]:
    """Select shell to use using menu application"""
    with read_history_file(conf) as hist:
        # compute the list from conf + (maybe) history
        hist_list = None
        if hist is not None:
            with suppress(Exception):
                hist_list = json.load(hist)

                # invalidate if different set from the configured shells
                if set(hist_list) != set(conf["shells"].keys()):
                    hist_list = None

        shells = hist_list or sorted(conf["shells"].keys())

        proc = subprocess.Popen(
            expand_command(conf["menu"]), stdin=subprocess.PIPE, stdout=subprocess.PIPE
        )

        assert proc.stdin is not None

        for r in shells:
            proc.stdin.write((r + "\n").encode())
        stdout, _ = proc.communicate()

        shell = stdout.decode().strip()

        if len(shell) == 0:
            return None

        if shell not in conf["shells"]:
            raise RuntimeError(f"Unknown shell: {shell}")

        if hist is not None:
            # put the selected shell on top
            shells = [shell] + [s for s in shells if s != shell]
            hist.truncate(0)
            json.dump(shells, hist)

        return shell


def move_to_scratchpad(conn: i3ipc.Connection, con: i3ipc.Con):
    conn.command(f"[con_id={con.id}] floating enable, move scratchpad")


def get_current_workspace(conn: i3ipc.Connection):
    focused = conn.get_tree().find_focused()
    if not focused:
        return None
    return focused.workspace()


class VerboseConnection(i3ipc.Connection):
    def __init__(self):
        super().__init__()

    def command(self, payload: str, *kargs, **kwargs):
        print(f"command: {payload}")
        return super().command(payload, *kargs, **kwargs)


class Quickterm:
    def __init__(self, conf: Conf, shell: Optional[str]):
        self.conf = conf
        self.shell = shell
        self._ws: Optional[i3ipc.Con] = None
        self._ws_fetched = False
        self._conn: Optional[i3ipc.Connection] = None
        self._con: Optional[i3ipc.Con] = None
        self._con_fetched = False
        self._verbose = self.conf.get("_verbose", False)

    @property
    def conn(self) -> i3ipc.Connection:
        if self._conn is None:
            if self._verbose:
                self._conn = VerboseConnection()
            else:
                self._conn = i3ipc.Connection()
        return self._conn

    @property
    def ws(self) -> Optional[i3ipc.Con]:
        if not self._ws_fetched and self._ws is None:
            self._ws = get_current_workspace(self.conn)
            self._ws_fetched = True
        return self._ws

    @property
    def mark(self) -> str:
        if self.shell is None:
            raise RuntimeError("No shell defined")
        return MARK_QT.format(self.shell)

    @property
    def con(self) -> Optional[i3ipc.Con]:
        """Find container in complete tree"""
        if not self._con_fetched and self._con is None:
            node = self.conn.get_tree().find_marked(self.mark)
            if len(node) == 0:
                self._con = None
            else:
                self._con = node[0]
            self._con_fetched = True
        return self._con

    def con_in_workspace(self, mark: str) -> Optional[i3ipc.Con]:
        """Find container in workspace"""
        if self.ws is None:
            return None
        c = self.ws.find_marked(mark)
        if len(c) == 0:
            return None
        return c[0]

    def execvp(self, cmd):
        if self._verbose:
            print(f"execvp: {cmd}")
        os.execvp(cmd[0], cmd)

    """Operations"""

    def launch_inplace(self):
        """Quickterm is called by itself

        Mark current window, move back and focus again, then run shell in current
        process
        """

        self.conn.command(f"mark {self.mark}")

        self.focus_on_current_ws()

        prog_cmd = expand_command(self.conf["shells"][self.shell])
        self.execvp(prog_cmd)

    def toggle_on_current_ws(self):
        """If on another workspace: hide, otherwise show on current"""
        assert self.con is not None
        move_to_scratchpad(self.conn, self.con)

        qt_ws = self.con.workspace()
        if self.ws is not None and (qt_ws is None or qt_ws.name != self.ws.name):
            self.focus_on_current_ws()

    def focus_on_current_ws(self):
        """Focus existing qt on current workspace"""
        ws = self.ws
        assert ws is not None
        pos = self.conf["pos"]

        wx, wy = ws.rect.x, ws.rect.y
        wwidth, wheight = ws.rect.width, ws.rect.height

        height = int(wheight * self.conf["height"])
        width = int(wwidth * self.conf["width"])
        posx = int(wx + (wwidth - width) / 2)

        if pos == "bottom":
            margin = 6
            posy = wy + wheight - height - margin
        else:  # pos == 'top'
            posy = wy

        self.conn.command(
            f"[con_mark={self.mark}] "
            f"move scratchpad, "
            f"scratchpad show, "
            f"resize set {width} {height} px, "
            f"move absolute position {posx} {posy} px"
        )

    def execute_term(self):
        """Launch i3-quickterm in a new terminal"""
        assert self.shell is not None

        term = select_terminal(self.conf["term"])
        qt_cmd = f"{sys.argv[0]} -i {self.shell}"
        if self._verbose:
            qt_cmd += " -v"
        if "_config" in self.conf:
            qt_cmd += f" -c {self.conf['_config']}"

        term_cmd = expand_command(
            term,
            title=quoted(term_title(self.shell)),
            expanded=qt_cmd,
            string=quoted(qt_cmd),
        )
        self.execvp(term_cmd)


def run_qt(qt: Quickterm, in_place: bool = False):
    """Main logic"""
    shell = qt.shell

    if in_place:
        if shell is None:
            raise RuntimeError("shell should be provided when running in place")

        # we are launched by ourselves: start a shell
        qt.launch_inplace()
        return

    if shell is None:
        c = qt.con_in_workspace(MARK_QT_PATTERN)
        if c is not None:
            # undefined shell and visible on workspace: hide
            move_to_scratchpad(qt.conn, c)
            return

        # undefined shell and nothing on workspace: ask for shell selection
        shell = select_shell(qt.conf)
        if shell is None:
            return
        qt.shell = shell

    # show logic
    # if it does not exist: create
    # else: toggle on current workspace
    if qt.con is None:
        qt.execute_term()
        return

    qt.toggle_on_current_ws()


def main(argv=None):
    parser = argparse.ArgumentParser(prog="i3-quickterm")
    parser.add_argument("-i", "--in-place", dest="in_place", action="store_true")
    parser.add_argument("-v", "--verbose", dest="verbose", action="store_true")
    parser.add_argument(
        "-c",
        "--config",
        dest="config",
        type=str,
        help="read config from specified file",
    )
    parser.add_argument("shell", metavar="SHELL", nargs="?")
    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {__version__}"
    )
    args = parser.parse_args(argv)

    conf = copy.deepcopy(DEFAULT_CONF)
    if args.config:
        conf.update(read_conf(args.config))
        conf["_config"] = args.config
    else:
        conf.update(read_conf(conf_path()))

    conf["_verbose"] = args.verbose

    if args.shell is not None and args.shell not in conf["shells"]:
        print(f"unknown shell: {args.shell}", file=sys.stderr)
        return 1

    qt = Quickterm(conf, args.shell)

    run_qt(qt, args.in_place)

    return 0


if __name__ == "__main__":
    try:
        sys.exit(main(sys.argv[1:]))
    except Exception:
        print(traceback.format_exc(), file=sys.stderr)
        sys.exit(1)



================================================
FILE: tests/conftest.py
================================================
from i3_quickterm.main import Quickterm, DEFAULT_CONF

import i3ipc

import copy
import json

import pytest
import unittest.mock


@pytest.fixture
def conf(tmp_path):
    c = copy.deepcopy(DEFAULT_CONF)
    c.update(
        {
            "menu": "/bin/true",
            "term": "xterm",
            "shells": {"shell": "bash"},
            "history": str(tmp_path / "shells.order"),
        }
    )
    return c


@pytest.fixture
def conf_file_factory(tmp_path):
    fname = tmp_path / "i3-quickterm.conf"

    class Fact:
        def __init__(self, fname):
            self.fname = fname

        def write(self, conf):
            with open(self.fname, "w") as f:
                json.dump(conf, f)

    return Fact(fname)


@pytest.fixture
def i3ipc_workspace():
    ws = unittest.mock.MagicMock()
    ws.name = "ws"
    ws.rect = i3ipc.Rect({"x": 0, "y": 0, "height": 0, "width": 0})
    return ws


@pytest.fixture
def i3ipc_con(i3ipc_workspace):
    con = unittest.mock.Mock(i3ipc.Con)
    con.find_marked.return_value = [con]
    con.find_focused.return_value = con
    con.id = "0"
    con.workspace.return_value = i3ipc_workspace
    i3ipc_workspace.find_marked.return_value = [con]
    return con


@pytest.fixture
def i3ipc_connection(i3ipc_con):
    conn = unittest.mock.Mock(i3ipc.Connection)
    conn.get_tree.return_value = i3ipc_con
    with unittest.mock.patch("i3ipc.Connection") as cm:
        cm.return_value = conn
        yield conn


@pytest.fixture
def quickterm_mock(i3ipc_connection, conf):
    qt = unittest.mock.Mock(Quickterm)
    qt.shell = None
    qt.con = None
    qt.conf = conf
    qt.conn = i3ipc_connection

    return qt



================================================
FILE: tests/test_args_and_conf.py
================================================
from i3_quickterm.main import main, DEFAULT_CONF

import os
import os.path

import pytest
import unittest.mock
from unittest.mock import ANY

DEFAULT_WITH_VERBOSE: dict[str, object] = {"_verbose": False}
DEFAULT_WITH_VERBOSE.update(DEFAULT_CONF)


@pytest.fixture
def run_qt_patched():
    with unittest.mock.patch("i3_quickterm.main.run_qt") as mock_qt:
        yield mock_qt


def is_config_path(path):
    if os.path.realpath(path).endswith("/i3-quickterm/config.json"):
        return True
    if os.path.realpath(path).endswith("/i3/i3-quickterm.json"):
        return True
    return False


@pytest.fixture
def system_conf():
    exists_ = os.path.exists

    def fake_exists(path):
        if is_config_path(path):
            return True
        return exists_(path)

    m = unittest.mock.MagicMock()
    m.side_effect = fake_exists
    exist_mock = unittest.mock.patch("os.path.exists", new=m)

    open_mock = unittest.mock.patch("i3_quickterm.main.open", unittest.mock.mock_open())

    jsonm = unittest.mock.MagicMock()
    json_load_mock = unittest.mock.patch("json.load", new=jsonm)

    with exist_mock, open_mock, json_load_mock:
        yield jsonm


@pytest.fixture
def system_conf_none():
    exists_ = os.path.exists

    def fake_exists(path):
        nonlocal exists_
        if is_config_path(path):
            return False
        return exists_(path)

    m = unittest.mock.MagicMock()
    m.side_effect = fake_exists
    exist_mock = unittest.mock.patch("os.path.exists", new=m)

    with exist_mock:
        yield


def test_args_version_help(capsys):
    with pytest.raises(SystemExit):
        main(["--version"])

    out, _ = capsys.readouterr()
    assert out.startswith("i3-quickterm")

    with pytest.raises(SystemExit):
        main(["--help"])

    out, _ = capsys.readouterr()
    assert out.startswith("usage: i3-quickterm")


def test_args_simple(conf, conf_file_factory, run_qt_patched):
    conf_file_factory.write(conf)

    assert main(["-c", f"{conf_file_factory.fname}"]) == 0

    run_qt_patched.assert_called_once_with(ANY, False)

    qt, _ = run_qt_patched.call_args.args
    assert not qt.conf["_verbose"]
    assert qt.conf["menu"] == "/bin/true"
    assert qt.conf["term"] == "xterm"
    assert qt.conf["shells"] == {"shell": "bash"}
    # from the defaults
    assert qt.conf["pos"] == "top"


def test_args_inplace(conf, conf_file_factory, run_qt_patched):
    conf_file_factory.write(conf)

    assert main(["-i", "-c", f"{conf_file_factory.fname}"]) == 0

    run_qt_patched.assert_called_once_with(ANY, True)


def test_args_verbose(conf, conf_file_factory, run_qt_patched):
    conf_file_factory.write(conf)

    assert main(["-v", "-c", f"{conf_file_factory.fname}"]) == 0

    run_qt_patched.assert_called_once_with(ANY, False)

    qt, _ = run_qt_patched.call_args.args
    assert qt.conf["_verbose"]


def test_args_wrong_shell(conf, conf_file_factory, run_qt_patched):
    conf_file_factory.write(conf)

    assert main(["-c", f"{conf_file_factory.fname}", "noshell"]) == 1

    assert run_qt_patched.call_count == 0


def test_args_system_conf_none(system_conf_none, run_qt_patched, capsys):
    assert main([]) == 0

    run_qt_patched.assert_called_once_with(ANY, False)

    _, err = capsys.readouterr()
    assert err.find("using defaults") != -1

    qt, _ = run_qt_patched.call_args.args
    assert qt.conf == DEFAULT_WITH_VERBOSE


def test_args_system_conf_term(system_conf, run_qt_patched):
    system_conf.return_value = {"term": "myterm"}

    assert main([]) == 0

    run_qt_patched.assert_called_once_with(ANY, False)

    qt, _ = run_qt_patched.call_args.args
    assert qt.conf["term"] == "myterm"


def test_args_system_conf_empty(system_conf, run_qt_patched):
    system_conf.return_value = {}

    assert main([]) == 0

    run_qt_patched.assert_called_once_with(ANY, False)

    qt, _ = run_qt_patched.call_args.args
    assert qt.conf == DEFAULT_WITH_VERBOSE


def test_args_system_conf_invalid(system_conf, run_qt_patched, capsys):
    system_conf.side_effect = RuntimeError("Invalid configuration")

    assert main([]) == 0

    run_qt_patched.assert_called_once_with(ANY, False)

    _, err = capsys.readouterr()
    assert err.find("invalid config") != -1

    qt, _ = run_qt_patched.call_args.args
    assert qt.conf == DEFAULT_WITH_VERBOSE



================================================
FILE: tests/test_quickterm.py
================================================
from i3_quickterm.main import Quickterm

import i3ipc

import pytest
import unittest.mock
from unittest.mock import call, ANY


@pytest.fixture
def execvp():
    with unittest.mock.patch("os.execvp") as mock_execvp:
        yield mock_execvp


@pytest.fixture
def shutil_roxterm_only():
    def roxterm_which(p):
        if p == "roxterm":
            return "/usr/bin/roxterm"
        return None

    with unittest.mock.patch("shutil.which", wraps=roxterm_which) as mock_execvp:
        yield mock_execvp


"""Test quickterm operations"""


def test_launch_inplace(i3ipc_connection, conf, execvp):
    """In place: just call the shell"""
    qt = Quickterm(conf, "shell")

    qt.launch_inplace()

    i3ipc_connection.command.assert_has_calls(
        [
            call("mark quickterm_shell"),
            call(
                "[con_mark=quickterm_shell] move scratchpad, scratchpad show, "
                "resize set 0 0 px, move absolute position 0 0 px"
            ),
        ]
    )
    execvp.assert_called_once_with("bash", ["bash"])


def test_execute_term(i3ipc_connection, i3ipc_con, conf, execvp):
    """Create term"""
    i3ipc_con.find_marked.return_value = []

    qt = Quickterm(conf, "shell")

    qt.execute_term()

    execvp.assert_has_calls([call("xterm", ANY)])


def test_execute_term_auto(
    i3ipc_connection, i3ipc_con, conf, execvp, shutil_roxterm_only
):
    """Auto-detect and execute term"""
    conf["term"] = "auto"
    i3ipc_con.find_marked.return_value = []

    qt = Quickterm(conf, "shell")

    qt.execute_term()

    execvp.assert_has_calls([call("roxterm", ANY)])


def test_execute_term_custom_format(
    i3ipc_connection, i3ipc_con, conf, execvp, shutil_roxterm_only
):
    """Auto-detect and execute term"""
    conf["term"] = "roxterm -t {title} -e {expanded}"
    i3ipc_con.find_marked.return_value = []

    qt = Quickterm(conf, "shell")

    qt.execute_term()

    execvp.assert_has_calls([call("roxterm", ANY)])


def test_execute_term_config(
    i3ipc_connection, i3ipc_con, conf, execvp, shutil_roxterm_only
):
    """Auto-detect and execute term"""
    conf["term"] = "auto"
    conf["_config"] = "dummy"
    i3ipc_con.find_marked.return_value = []

    qt = Quickterm(conf, "shell")

    qt.execute_term()

    execvp.assert_has_calls([call("roxterm", ANY)])


def test_toggle_hide(i3ipc_connection, conf, execvp):
    """Toggle with visible term: hide"""
    qt = Quickterm(conf, "shell")

    qt.toggle_on_current_ws()

    i3ipc_connection.command.assert_called_once_with(
        "[con_id=0] floating enable, move scratchpad"
    )
    assert execvp.call_count == 0


def test_con_in_workspace(i3ipc_connection, i3ipc_con, i3ipc_workspace, conf):
    qt = Quickterm(conf, None)

    assert qt.con_in_workspace("") is not None

    i3ipc_workspace.find_marked.return_value = []

    assert qt.con_in_workspace("") is None


def test_toggle_from_other_workspace(i3ipc_connection, i3ipc_con, conf, execvp):
    """Toggle with visible term on another workspace: hide and show on current"""
    qt = Quickterm(conf, "shell")

    k = 0

    def new_workspace():
        nonlocal k
        ws = unittest.mock.MagicMock()
        ws.name = f"ws{k}"
        ws.rect = i3ipc.Rect({"x": 0, "y": 0, "height": 0, "width": 0})
        k += 1
        return ws

    i3ipc_con.workspace.side_effect = new_workspace

    qt.toggle_on_current_ws()

    i3ipc_connection.command.assert_has_calls(
        [
            call("[con_id=0] floating enable, move scratchpad"),
            call(
                "[con_mark=quickterm_shell] move scratchpad, scratchpad show, "
                "resize set 0 0 px, move absolute position 0 0 px"
            ),
        ]
    )
    assert execvp.call_count == 0



================================================
FILE: tests/test_run_logic.py
================================================
from i3_quickterm.main import run_qt

import pytest


"""Test run logic"""


def test_run_qt_inplace_no_shell(quickterm_mock):
    with pytest.raises(RuntimeError):
        run_qt(quickterm_mock, in_place=True)


def test_run_qt_inplace(quickterm_mock):
    qt = quickterm_mock
    qt.shell = "bash"
    run_qt(qt, in_place=True)
    qt.launch_inplace.assert_called_once()


def test_run_qt_noshell_hide(quickterm_mock, i3ipc_connection, i3ipc_con):
    qt = quickterm_mock
    qt.con_in_workspace.return_value = i3ipc_con

    run_qt(qt)

    i3ipc_connection.command.assert_called_once_with(
        "[con_id=0] floating enable, move scratchpad"
    )


def test_run_qt_noshell_select_none(quickterm_mock):
    qt = quickterm_mock
    qt.con_in_workspace.return_value = None

    run_qt(qt)

    assert qt.shell is None


def test_run_qt_noshell_select_one(quickterm_mock):
    qt = quickterm_mock
    qt.con_in_workspace.return_value = None
    qt.conf["menu"] = "echo shell"

    run_qt(qt)

    assert qt.shell == "shell"


def test_run_qt_execute_shell(quickterm_mock):
    qt = quickterm_mock
    qt.shell = "bash"
    run_qt(qt)
    qt.execute_term.assert_called_once()


def test_run_qt_toggle_on_current_ws(i3ipc_con, quickterm_mock):
    qt = quickterm_mock
    qt.shell = "bash"
    qt.con = i3ipc_con
    run_qt(qt)
    qt.toggle_on_current_ws.assert_called_once()



================================================
FILE: typings/i3ipc/__init__.pyi
================================================
from .__version__ import __author_email__ as __author_email__, __description__ as __description__, __url__ as __url__, __version__ as __version__
from .con import Con as Con
from .connection import Connection as Connection
from .events import BarconfigUpdateEvent as BarconfigUpdateEvent, BindingEvent as BindingEvent, BindingInfo as BindingInfo, Event as Event, InputEvent as InputEvent, ModeEvent as ModeEvent, OutputEvent as OutputEvent, ShutdownEvent as ShutdownEvent, TickEvent as TickEvent, WindowEvent as WindowEvent, WorkspaceEvent as WorkspaceEvent
from .model import Gaps as Gaps, Rect as Rect
from .replies import BarConfigReply as BarConfigReply, CommandReply as CommandReply, ConfigReply as ConfigReply, InputReply as InputReply, OutputReply as OutputReply, SeatReply as SeatReply, TickReply as TickReply, VersionReply as VersionReply, WorkspaceReply as WorkspaceReply



================================================
FILE: typings/i3ipc/__version__.pyi
================================================
__description__: str
__url__: str
__version__: str
__author_email__: str



================================================
FILE: typings/i3ipc/con.pyi
================================================
from . import replies as replies
from .model import Gaps as Gaps, Rect as Rect
from _typeshed import Incomplete
from typing import List, Optional

class Con:
    ipc_data: Incomplete
    parent: Incomplete
    marks: Incomplete
    type: str
    nodes: Incomplete
    floating_nodes: Incomplete
    window_class: Incomplete
    window_instance: Incomplete
    window_role: Incomplete
    window_title: Incomplete
    rect: Incomplete
    window_rect: Incomplete
    deco_rect: Incomplete
    geometry: Incomplete
    gaps: Incomplete
    # ipc properties
    border: Incomplete
    current_border_width: Incomplete
    floating: Incomplete
    focus: Incomplete
    focused: Incomplete
    fullscreen_mode: Incomplete
    id: Incomplete
    layout: Incomplete
    name: Incomplete
    num: Incomplete
    orientation: Incomplete
    percent: Incomplete
    scratchpad_state: Incomplete
    sticky: Incomplete
    urgent: Incomplete
    window: Incomplete
    pid: Incomplete
    app_id: Incomplete
    representation: Incomplete

    def __init__(self, data, parent, conn) -> None: ...
    def __iter__(self): ...
    def root(self) -> Con: ...
    def descendants(self) -> List['Con']: ...
    def descendents(self) -> List['Con']: ...
    def leaves(self) -> List['Con']: ...
    def command(self, command: str) -> List[replies.CommandReply]: ...
    def command_children(self, command: str) -> List[replies.CommandReply]: ...
    def workspaces(self) -> List['Con']: ...
    def find_focused(self) -> Optional['Con']: ...
    def find_by_id(self, id: int) -> Optional['Con']: ...
    def find_by_pid(self, pid: int) -> List['Con']: ...
    def find_by_window(self, window: int) -> Optional['Con']: ...
    def find_by_role(self, pattern: str) -> List['Con']: ...
    def find_named(self, pattern: str) -> List['Con']: ...
    def find_titled(self, pattern: str) -> List['Con']: ...
    def find_classed(self, pattern: str) -> List['Con']: ...
    def find_instanced(self, pattern: str) -> List['Con']: ...
    def find_marked(self, pattern: str = '.*') -> List['Con']: ...
    def find_fullscreen(self) -> List['Con']: ...
    def workspace(self) -> Optional['Con']: ...
    def scratchpad(self) -> Con: ...



================================================
FILE: typings/i3ipc/connection.pyi
================================================
from ._private import EventType as EventType, MessageType as MessageType, PubSub as PubSub, Synchronizer as Synchronizer
from .con import Con as Con
from .events import BarconfigUpdateEvent as BarconfigUpdateEvent, BindingEvent as BindingEvent, Event as Event, InputEvent as InputEvent, IpcBaseEvent as IpcBaseEvent, ModeEvent as ModeEvent, OutputEvent as OutputEvent, ShutdownEvent as ShutdownEvent, TickEvent as TickEvent, WindowEvent as WindowEvent, WorkspaceEvent as WorkspaceEvent
from .replies import BarConfigReply as BarConfigReply, CommandReply as CommandReply, ConfigReply as ConfigReply, InputReply as InputReply, OutputReply as OutputReply, SeatReply as SeatReply, TickReply as TickReply, VersionReply as VersionReply, WorkspaceReply as WorkspaceReply
from _typeshed import Incomplete
from typing import Callable, List, Optional, Union

class Connection:
    subscriptions: int
    def __init__(self, socket_path: Incomplete | None = None, auto_reconnect: bool = False) -> None: ...
    @property
    def socket_path(self) -> str: ...
    @property
    def auto_reconnect(self) -> bool: ...
    def command(self, payload: str) -> List[CommandReply]: ...
    def get_version(self) -> VersionReply: ...
    def get_bar_config(self, bar_id: Optional[str] = None) -> Optional[BarConfigReply]: ...
    def get_bar_config_list(self) -> List[str]: ...
    def get_outputs(self) -> List[OutputReply]: ...
    def get_inputs(self) -> List[InputReply]: ...
    def get_seats(self) -> List[SeatReply]: ...
    def get_workspaces(self) -> List[WorkspaceReply]: ...
    def get_tree(self) -> Con: ...
    def get_marks(self) -> List[str]: ...
    def get_binding_modes(self) -> List[str]: ...
    def get_config(self) -> ConfigReply: ...
    def send_tick(self, payload: str = '') -> TickReply: ...
    def off(self, handler: Callable[[Connection, IpcBaseEvent], None]): ...
    def on(self, event: Union[Event, str], handler: Callable[[Connection, IpcBaseEvent], None]): ...
    def main(self, timeout: float = 0.0): ...
    def main_quit(self) -> None: ...



================================================
FILE: typings/i3ipc/events.pyi
================================================
from . import con as con
from .replies import BarConfigReply as BarConfigReply, InputReply as InputReply
from _typeshed import Incomplete
from enum import Enum

class IpcBaseEvent: ...

class Event(Enum):
    WORKSPACE: str
    OUTPUT: str
    MODE: str
    WINDOW: str
    BARCONFIG_UPDATE: str
    BINDING: str
    SHUTDOWN: str
    TICK: str
    INPUT: str
    WORKSPACE_FOCUS: str
    WORKSPACE_INIT: str
    WORKSPACE_EMPTY: str
    WORKSPACE_URGENT: str
    WORKSPACE_RELOAD: str
    WORKSPACE_RENAME: str
    WORKSPACE_RESTORED: str
    WORKSPACE_MOVE: str
    WINDOW_NEW: str
    WINDOW_CLOSE: str
    WINDOW_FOCUS: str
    WINDOW_TITLE: str
    WINDOW_FULLSCREEN_MODE: str
    WINDOW_MOVE: str
    WINDOW_FLOATING: str
    WINDOW_URGENT: str
    WINDOW_MARK: str
    SHUTDOWN_RESTART: str
    SHUTDOWN_EXIT: str
    INPUT_ADDED: str
    INPUT_REMOVED: str

class WorkspaceEvent(IpcBaseEvent):
    ipc_data: Incomplete
    change: Incomplete
    current: Incomplete
    old: Incomplete
    def __init__(self, data, conn, _Con=...) -> None: ...

class OutputEvent(IpcBaseEvent):
    ipc_data: Incomplete
    change: Incomplete
    def __init__(self, data) -> None: ...

class ModeEvent(IpcBaseEvent):
    ipc_data: Incomplete
    change: Incomplete
    pango_markup: Incomplete
    def __init__(self, data) -> None: ...

class WindowEvent(IpcBaseEvent):
    ipc_data: Incomplete
    change: Incomplete
    container: Incomplete
    def __init__(self, data, conn, _Con=...) -> None: ...

class BarconfigUpdateEvent(IpcBaseEvent, BarConfigReply): ...

class BindingInfo:
    ipc_data: Incomplete
    command: Incomplete
    event_state_mask: Incomplete
    input_code: Incomplete
    symbol: Incomplete
    input_type: Incomplete
    symbols: Incomplete
    mods: Incomplete
    def __init__(self, data) -> None: ...

class BindingEvent(IpcBaseEvent):
    ipc_data: Incomplete
    change: Incomplete
    binding: Incomplete
    def __init__(self, data) -> None: ...

class ShutdownEvent(IpcBaseEvent):
    ipc_data: Incomplete
    change: Incomplete
    def __init__(self, data) -> None: ...

class TickEvent(IpcBaseEvent):
    ipc_data: Incomplete
    first: Incomplete
    payload: Incomplete
    def __init__(self, data) -> None: ...

class InputEvent(IpcBaseEvent):
    ipc_data: Incomplete
    change: Incomplete
    input: Incomplete
    def __init__(self, data) -> None: ...



================================================
FILE: typings/i3ipc/model.pyi
================================================
from _typeshed import Incomplete

class Rect:
    x: Incomplete
    y: Incomplete
    height: Incomplete
    width: Incomplete
    def __init__(self, data) -> None: ...

class OutputMode:
    width: Incomplete
    height: Incomplete
    refresh: Incomplete
    def __init__(self, data) -> None: ...
    def __getitem__(self, item): ...

class Gaps:
    inner: Incomplete
    outer: Incomplete
    left: Incomplete
    right: Incomplete
    top: Incomplete
    bottom: Incomplete
    def __init__(self, data) -> None: ...



================================================
FILE: typings/i3ipc/replies.pyi
================================================
from .model import OutputMode as OutputMode, Rect as Rect
from _typeshed import Incomplete

class _BaseReply:
    ipc_data: Incomplete
    def __init__(self, data) -> None: ...

class CommandReply(_BaseReply): ...
class WorkspaceReply(_BaseReply): ...
class OutputReply(_BaseReply): ...

class BarConfigGaps:
    left: Incomplete
    right: Incomplete
    top: Incomplete
    bottom: Incomplete
    def __init__(self, data) -> None: ...

class BarConfigReply(_BaseReply): ...
class VersionReply(_BaseReply): ...
class ConfigReply(_BaseReply): ...
class TickReply(_BaseReply): ...
class InputReply(_BaseReply): ...
class SeatReply(_BaseReply): ...



================================================
FILE: typings/i3ipc/_private/__init__.pyi
================================================
from .pubsub import PubSub as PubSub
from .sync import Synchronizer as Synchronizer
from .types import EventType as EventType, MessageType as MessageType, ReplyType as ReplyType



================================================
FILE: typings/i3ipc/_private/pubsub.pyi
================================================
from _typeshed import Incomplete

class PubSub:
    conn: Incomplete
    def __init__(self, conn) -> None: ...
    def subscribe(self, detailed_event, handler) -> None: ...
    def unsubscribe(self, handler): ...
    def emit(self, event, data) -> None: ...



================================================
FILE: typings/i3ipc/_private/sync.pyi
================================================
from _typeshed import Incomplete

class Synchronizer:
    display: Incomplete
    screen: Incomplete
    root: Incomplete
    sync_atom: Incomplete
    send_window: Incomplete
    def __init__(self) -> None: ...
    def sync(self) -> None: ...



================================================
FILE: typings/i3ipc/_private/types.pyi
================================================
from _typeshed import Incomplete
from enum import Enum

class MessageType(Enum):
    COMMAND: int
    GET_WORKSPACES: int
    SUBSCRIBE: int
    GET_OUTPUTS: int
    GET_TREE: int
    GET_MARKS: int
    GET_BAR_CONFIG: int
    GET_VERSION: int
    GET_BINDING_MODES: int
    GET_CONFIG: int
    SEND_TICK: int
    GET_INPUTS: int
    GET_SEATS: int

class ReplyType(Enum):
    COMMAND: int
    WORKSPACES: int
    SUBSCRIBE: int
    OUTPUTS: int
    TREE: int
    MARKS: int
    BAR_CONFIG: int
    VERSION: int
    BINDING_MODES: int
    GET_CONFIG: int
    TICK: int

class EventType(Enum):
    WORKSPACE: Incomplete
    OUTPUT: Incomplete
    MODE: Incomplete
    WINDOW: Incomplete
    BARCONFIG_UPDATE: Incomplete
    BINDING: Incomplete
    SHUTDOWN: Incomplete
    TICK: Incomplete
    INPUT: Incomplete
    def to_string(self): ...
    @staticmethod
    def from_string(val): ...
    def to_list(self): ...



================================================
FILE: typings/i3ipc/aio/__init__.pyi
================================================
from .connection import Con as Con, Connection as Connection



================================================
FILE: typings/i3ipc/aio/connection.pyi
================================================
from .. import con as con
from .._private import EventType as EventType, MessageType as MessageType, PubSub as PubSub, Synchronizer as Synchronizer
from ..events import BarconfigUpdateEvent as BarconfigUpdateEvent, BindingEvent as BindingEvent, Event as Event, InputEvent as InputEvent, IpcBaseEvent as IpcBaseEvent, ModeEvent as ModeEvent, OutputEvent as OutputEvent, ShutdownEvent as ShutdownEvent, TickEvent as TickEvent, WindowEvent as WindowEvent, WorkspaceEvent as WorkspaceEvent
from ..replies import BarConfigReply as BarConfigReply, CommandReply as CommandReply, ConfigReply as ConfigReply, InputReply as InputReply, OutputReply as OutputReply, SeatReply as SeatReply, TickReply as TickReply, VersionReply as VersionReply, WorkspaceReply as WorkspaceReply
from _typeshed import Incomplete
from typing import Callable, List, Optional, Union

class _AIOPubSub(PubSub):
    def queue_handler(self, handler, data: Incomplete | None = None) -> None: ...
    def emit(self, event, data) -> None: ...

class Con(con.Con):
    async def command(self, command: str) -> List[CommandReply]: ...
    async def command_children(self, command: str) -> List[CommandReply]: ...

class Connection:
    def __init__(self, socket_path: Optional[str] = None, auto_reconnect: bool = False) -> None: ...
    @property
    def socket_path(self) -> str: ...
    @property
    def auto_reconect(self) -> bool: ...
    async def connect(self) -> Connection: ...
    async def subscribe(self, events: Union[List[Event], List[str]], force: bool = False): ...
    def on(self, event: Union[Event, str], handler: Callable[[Connection, IpcBaseEvent], None]): ...
    def off(self, handler: Callable[[Connection, IpcBaseEvent], None]): ...
    async def command(self, cmd: str) -> List[CommandReply]: ...
    async def get_version(self) -> VersionReply: ...
    async def get_bar_config_list(self) -> List[str]: ...
    async def get_bar_config(self, bar_id: Incomplete | None = None) -> Optional[BarConfigReply]: ...
    async def get_outputs(self) -> List[OutputReply]: ...
    async def get_workspaces(self) -> List[WorkspaceReply]: ...
    async def get_tree(self) -> Con: ...
    async def get_marks(self) -> List[str]: ...
    async def get_binding_modes(self) -> List[str]: ...
    async def get_config(self) -> ConfigReply: ...
    async def send_tick(self, payload: str = '') -> TickReply: ...
    async def get_inputs(self) -> List[InputReply]: ...
    async def get_seats(self) -> List[SeatReply]: ...
    def main_quit(self, _error: Incomplete | None = None) -> None: ...
    async def main(self) -> None: ...



================================================
FILE: .github/actions/test/action.yml
================================================
name: Test
description: Formatting, static analysis and tests

runs:
  using: composite
  steps:
    - id: pip
      shell: bash
      run: |
        pip install -r requirements-dev.txt
        pip install -e .
    - id: format-check
      shell: bash
      run: ruff format --check --diff i3_quickterm tests setup.py
    - id: lint
      shell: bash
      run: ruff check i3_quickterm tests
    - id: typing
      shell: bash
      run: mypy i3_quickterm tests
    - id: unit-tests
      shell: bash
      run: |
        coverage run -m pytest -vv
        coverage report -m



================================================
FILE: .github/workflows/check.yml
================================================
name: Check

on:
  push:
    branches:
      - master
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: ./.github/actions/test


