Directory structure:
└── ultrabug-py3status/
    ├── README.md
    ├── CHANGELOG
    ├── LICENSE
    ├── Makefile
    ├── MANIFEST.in
    ├── mkdocs.yml
    ├── pyproject.toml
    ├── setup.py
    ├── contrib/
    │   └── py3status.html
    ├── docs/
    │   ├── getting-started.md
    │   ├── index.md
    │   ├── dev-guide/
    │   │   ├── contributing.md
    │   │   ├── the-py3-helper.md
    │   │   └── writing-modules.md
    │   └── user-guide/
    │       ├── configuration.md
    │       ├── installation.md
    │       ├── remote-control.md
    │       └── user-contributed-conf-examples.md
    ├── py3status/
    │   ├── __init__.py
    │   ├── argparsers.py
    │   ├── autodoc.py
    │   ├── command.py
    │   ├── composite.py
    │   ├── constants.py
    │   ├── core.py
    │   ├── docstrings.py
    │   ├── events.py
    │   ├── exceptions.py
    │   ├── formatter.py
    │   ├── helpers.py
    │   ├── i3status.py
    │   ├── module.py
    │   ├── module_test.py
    │   ├── output.py
    │   ├── parse_config.py
    │   ├── private.py
    │   ├── profiling.py
    │   ├── py3.py
    │   ├── request.py
    │   ├── screenshots.py
    │   ├── storage.py
    │   ├── udev_monitor.py
    │   ├── util.py
    │   ├── version.py
    │   └── modules/
    │       ├── README.md
    │       ├── __init__.py
    │       ├── air_quality.py
    │       ├── apt_updates.py
    │       ├── arch_updates.py
    │       ├── async_script.py
    │       ├── audiosink.py
    │       ├── aws_bill.py
    │       ├── backlight.py
    │       ├── battery_level.py
    │       ├── bluetooth.py
    │       ├── check_tcp.py
    │       ├── clock.py
    │       ├── cmus.py
    │       ├── coin_balance.py
    │       ├── coin_market.py
    │       ├── conky.py
    │       ├── deadbeef.py
    │       ├── dexcom.py
    │       ├── diskdata.py
    │       ├── do_not_disturb.py
    │       ├── dpms.py
    │       ├── dropboxd_status.py
    │       ├── emerge_status.py
    │       ├── exchange_rate.py
    │       ├── external_script.py
    │       ├── fedora_updates.py
    │       ├── file_status.py
    │       ├── frame.py
    │       ├── getjson.py
    │       ├── github.py
    │       ├── gitlab.py
    │       ├── glpi.py
    │       ├── google_calendar.py
    │       ├── graphite.py
    │       ├── group.py
    │       ├── hamster.py
    │       ├── hddtemp.py
    │       ├── hueshift.py
    │       ├── i3block.py
    │       ├── i3pystatus.py
    │       ├── icinga2.py
    │       ├── imap.py
    │       ├── insync.py
    │       ├── kdeconnector.py
    │       ├── keyboard_layout.py
    │       ├── keyboard_locks.py
    │       ├── khal_calendar.py
    │       ├── lm_sensors.py
    │       ├── loadavg.py
    │       ├── mail.py
    │       ├── mega_sync.py
    │       ├── moc.py
    │       ├── mpd_status.py
    │       ├── mpris.py
    │       ├── net_iplist.py
    │       ├── net_rate.py
    │       ├── netdata.py
    │       ├── networkmanager.py
    │       ├── ns_checker.py
    │       ├── nvidia_smi.py
    │       ├── online_status.py
    │       ├── pingdom.py
    │       ├── playerctl.py
    │       ├── pomodoro.py
    │       ├── process_status.py
    │       ├── prometheus.py
    │       ├── rainbow.py
    │       ├── rate_counter.py
    │       ├── rss_aggregator.py
    │       ├── rt.py
    │       ├── scratchpad.py
    │       ├── screenshot.py
    │       ├── scroll.py
    │       ├── selinux.py
    │       ├── spaceapi.py
    │       ├── speedtest.py
    │       ├── spotify.py
    │       ├── sql.py
    │       ├── static_string.py
    │       ├── sway_idle.py
    │       ├── sysdata.py
    │       ├── systemd.py
    │       ├── systemd_suspend_inhibitor.py
    │       ├── taskwarrior.py
    │       ├── thunderbird_todos.py
    │       ├── timer.py
    │       ├── timewarrior.py
    │       ├── tor_rate.py
    │       ├── transmission.py
    │       ├── twitch.py
    │       ├── uname.py
    │       ├── uptime.py
    │       ├── usbguard.py
    │       ├── vnstat.py
    │       ├── volume_status.py
    │       ├── vpn_status.py
    │       ├── wanda_the_fish.py
    │       ├── watson.py
    │       ├── weather_owm.py
    │       ├── whatismyip.py
    │       ├── whoami.py
    │       ├── wifi.py
    │       ├── window.py
    │       ├── wwan.py
    │       ├── wwan_status.py
    │       ├── xkb_input.py
    │       ├── xrandr.py
    │       ├── xrandr_rotate.py
    │       ├── xscreensaver.py
    │       ├── xsel.py
    │       ├── yandexdisk_status.py
    │       ├── yubikey.py
    │       └── zypper_updates.py
    ├── requirements/
    │   └── project.txt
    ├── tests/
    │   ├── test_composite.py
    │   ├── test_consistency.py
    │   ├── test_formatter.py
    │   ├── test_module_doc.py
    │   ├── test_module_load.py
    │   ├── test_py3.py
    │   └── test_user_modules.py
    ├── .git-hooks/
    │   └── pre-push
    └── .github/
        ├── FUNDING.yml
        ├── ISSUE_TEMPLATE/
        │   ├── ask-a-question.md
        │   ├── feature_request.md
        │   └── report-a-bug-or-a-problem.md
        └── workflows/
            ├── ci.yml
            ├── codeql.yml
            └── deploy-docs.yml

================================================
FILE: README.md
================================================
![image](https://github.com/ultrabug/py3status/blob/master/logo/logotype-horizontal.png)

# py3status

![CI](https://github.com/ultrabug/py3status/workflows/CI/badge.svg)

**py3status** is an extensible i3status wrapper written in Python.

Using py3status, you can take control of your i3bar easily by:

-   using one of the available
    [modules](https://ultrabug.github.io/py3status/user-guide/modules/)
    shipped with py3status
-   grouping multiple modules and automatically or manually cycle their
    display
-   writing your own modules and have their output displayed on your bar
-   handling click events on your i3bar and play with them in no time
-   seeing your clock tick every second whatever your i3status interval

**No extra configuration file needed**, just install & enjoy!

## About

You will love py3status if you're using [i3wm](https://i3wm.org)
(or [sway](https://swaywm.org)) and are frustrated by the i3status
[limitations](https://faq.i3wm.org/question/459/external-scriptsprograms-in-i3status-without-loosing-colors/) on your i3bar such as:

-   you cannot hack into it easily
-   you want more than the built-in modules and their limited configuration
-   you cannot pipe the result of one of more scripts or commands in your bar easily

## Philosophy

-   **no added configuration file, use the standard i3status.conf**
-   **rely on i3status**' strengths and its **existing configuration** as much as possible
-   **be extensible**, it must be easy for users to add their own
    stuff/output by writing a simple python class which will be loaded
    and executed dynamically
-   **easily allow interactivity** with the i3bar
-   add some **built-in enhancement/transformation** of basic i3status modules output

We apply the [Zen of py3status](https://ultrabug.github.io/py3status/dev-guide/contributing/#zen-of-py3status) to improve this project and encourage everyone to read it!

## Documentation

Up-to-date [documentation](https://ultrabug.github.io/py3status/):

-   [Installation](https://ultrabug.github.io/py3status/user-guide/installation/)
-   [Getting started](https://ultrabug.github.io/py3status/getting-started/)
-   [Using Modules](https://ultrabug.github.io/py3status/user-guide/configuration/#loading-and-ordering-py3status-modules)
-   [Custom click events](https://ultrabug.github.io/py3status/user-guide/configuration/#custom-click-events)
-   [The py3-cmd command line](https://ultrabug.github.io/py3status/user-guide/remote-control/)
-   [Writing custom modules](https://ultrabug.github.io/py3status/dev-guide/writing-modules/)
-   [Contributing](https://ultrabug.github.io/py3status/dev-guide/contributing/)

Get help or share your ideas on IRC:

-   channel **\#py3status** on **OFTC**

## Installation

See the up to date and complete [installation instructions](https://ultrabug.github.io/py3status/user-guide/installation/) for your favorite distribution.

## Usage

In your i3 config file, simply switch from *i3status* to *py3status* in
your *status_command*:

    status_command py3status

Usually you have your own i3status configuration, just point to it:

    status_command py3status -c ~/.i3/i3status.conf

## Options

You can see the help of py3status by issuing \`py3status -h\`:

    usage: py3status [-h] [-b] [-c FILE] [-d] [-g] [-i PATH] [-l FILE] [-s]
                     [-t INT] [-m] [-u PATH] [-v] [--wm WINDOW_MANAGER]

    The agile, python-powered, i3status wrapper

    optional arguments:
      -h, --help            show this help message and exit
      -b, --dbus-notify     send notifications via dbus instead of i3-nagbar
                            (default: False)
      -c, --config FILE     load config (default: /home/alexys/.i3/i3status.conf)
      -d, --debug           enable debug logging in syslog and --log-file
                            (default: False)
      -i, --include PATH    append additional user-defined module paths (default:
                            None)
      -l, --log-file FILE   enable logging to FILE (default: None)
      -s, --standalone      run py3status without i3status (default: False)
      -t, --timeout INT     default module cache timeout in seconds (default: 60)
      -m, --disable-click-events
                            disable all click events (default: False)
      -u, --i3status PATH   specify i3status path (default: /usr/bin/i3status)
      -v, --version         show py3status version and exit (default: False)
      --wm WINDOW_MANAGER   specify window manager i3 or sway (default: i3)

## Available modules

[All modules](https://ultrabug.github.io/py3status/user-guide/modules/)
shipped with py3status are [configurable directly from your current i3status.conf](https://ultrabug.github.io/py3status/user-guide/configuration/#loading-and-ordering-py3status-modules)!

[Check them out](https://ultrabug.github.io/py3status/user-guide/modules/)
to see all the configuration options.

## Control from CLI

Just like i3status, you can force an update of your i3bar by sending a
SIGUSR1 signal to py3status. Note that this will also send a SIGUSR1
signal to i3status:

    killall -USR1 py3status

To refresh individual modules, the
[py3-cmd](https://ultrabug.github.io/py3status/user-guide/remote-control/)
utility can be used, e.g:

    py3-cmd refresh wifi



================================================
FILE: CHANGELOG
================================================
version 3.62 (2025-05-24)
* core: fix usage of deprecated pkg_resources to the @sdelafond (#2286)
* py3: add new helper: get_replacements_list (#2242), by lasers
* conky module: add fallback delete parameter for py3.11 or less (#2275), by lasers
* external_script module: adjust how urgent is specified (#2283), by Kevin Pulo
* external_script module: allow scripts to specify urgent (#2282), by Kevin Pulo
* getjson module: fix examples (#2278), by lasers
* mpris module: implement track number support (#2280), by James Walker
* mpris module: use new helper: get_replacements_list introduced with (#2242) (#2284), by Valdur Kana
* tests: stop warning py3status/tests/test_module_load.py:5 (#2276), by lasers
* whatismyip module: add an example with more url_geo choices (#2277), by lasers
* xsel module: fix TypeError (#2279), by Eduardo Suarez-Santana

version 3.61 (2024-12-05)
* argparsers: pgrep i3 with shmlog (#2272), by lasers
* modules: fix SyntaxWarning for python 3.12+ thx to @sdelafond (#2274)
* conky module: fix tempfile and ignore new output (#2273), by ntorresalberto
* mpris module: hide all non can_play players (#2267), by Valdur Kana
* playerctl module: gi.require_version notification fix (#2270), by Valdur Kana

version 3.60 (2024-10-24)
* THANKS to Valdur Kana and @lasers for their long and continued efforts in improving py3status!
* core: drop EOL python 3.8 and add new 3.13 to CI (#2266)
* external_script module: add composite placeholder (#2263), by lasers
* hddtemp module: remove deprecated telnetlib dependency (fixes #2261) (#2262), by Valdur Kana
* kdeconnector module: replace pydbus with dbus-python (#2264), by Valdur Kana
* mpris module: improve documentation (#2257), by Valdur Kana
* playerctl module: hide non-can-play players and use chrome and chromium as default value. (#2256), by Valdur Kana
* playerctl module: list python-gobject as dependency (#2258), by Joey Holtzman
* wwan module: replace pydbus with dbus-python (#2265), by Valdur Kana

version 3.59 (2024-08-02)
* core: strip whitespaces from OUTPUT, OUTPUT_PART events (#2245), by lasers
* ci(ruff): use new ruff check path command (#2253)
* external_script module: fix clicking on parts of message thx to @lasers (#2254)
* mpris module: kdeconnect mpris interface will skip identity cache, because mobile device can run different media players (#2251), by Valdur Kana

version 3.58 (2024-05-31)
* conky module: skip invalid conky errors (#2248), by lasers
* weather_owm module: switch to 3.0 API endpoint as 2.5 is deprecated (#2249)

version 3.57 (2024-03-26)
* docs: explain how to serve mkdocs locally (#2239), by Lujeni
* add CodeQL workflow for GitHub code scanning (#2159), by lgtm-com[bot]
* fmt: fix newer black
* backlight module: add brightnessctl support (#2233), by Gabriele Fioco
* conky module: workaround upstream issues/1479 (#2238), by ntorresalberto
* volume_status module: fix for default source with pamixer (#2240), by oceyral

version 3.56 (2024-01-28)
* remove audio modules in favor of playerctl (#2231), by lasers
* new module dexcom:  display glucose readings from your Dexcom CGM system (#2229), by lasers
* arch_updates module: hourly cache_timeout, add a note about alpm-hooks (#2219), by lasers
* volume_status module: pamixer fix command if device is 0 (#2230), by Václav Kubernát
* volume_status module: pamixer: Use default device if none specified (#2228), by Václav Kubernát

version 3.55 (2024-01-12)
* pkg: add dbus tag to pull dependencies 'pip install py3status[dbus]'
* pkg: drop eol python 3.7 support, add python 3.12
* pkg: pull setuptools for 3.12
* docs(build): move away from readthedocs and switch to automatic github pages (#2216)
* docs(config): add favicon and rename the site
* readme: drop readthedocs build status
* docs: fix broken 404 urls (#2223), by lasers
* arch_updates module: update auracle from sync to outdated (#2220), by mlmatlock
* bluetooth module: reinitialize dbus to fix after sleep behavior (#2221), by lasers
* lm_sensors module: fix invalid json if specified more than one chip (#2226), by lasers
* nvidia_smi module: fix --list-properties (#2225), by lasers
* vpn_status module: add formatters for displaying IP addresses of VPNs (#2227), by Joey Holtzman

version 3.54 (2023-10-13)
* arch_updates module: handle yay return code better when there are no updates (#2214), by Geoff Liu
* arch_updates module: make it more responsive to system updates (#2215), by Geoff Liu
* battery_level module: fix code style

version 3.53 (2023-09-10)
* argparser: remove deprecated interval option (#2210), by lasers
* new module playerctl: control players supported by playerctl (#2211), by Joey Holtzman

version 3.52 (2023-07-29)
* IMPORTANT: the project has moved from setuptools to pyproject.toml and hatch
* IMPORTANT: gevent support is now deprecated and removed
* core: drop gevent support

version 3.51 (2023-06-27)
* NEW: thanks to Andreas Grapentin, py3status can now run in lots of other containers (tmux, term, dzen2, lemonbar...)
* IMPORTANT: modules are moving away from the obsolete pydbus library
* core: implement handling of output_format in py3status for i3bar, dzen2, xmobar, lemonbar, tmux, term, none (#2104), by Andreas Grapentin
* core: autodetect output_format (#2202), by lasers
* fix(module): report module post_config_hook errors thx to @lasers (#2208)
* docs(user): add a section to specify that modules dependencies are up to the users
* docs(mkdocs): drop mkdocs-simple-hooks closes #2195
* docs: fix two DeprecationWarning (#2191), by lasers
* docs(audiosink): fix screenshots (#2194), by lasers
* docs(autodoc): remove dead code thx to @lasers, closes #2183 (#2193)
* arch_updates module: add support for pikaur (#2182), by vim
* arch_updates module: remove cower support (gone) (#2190), by lasers
* backlight module: drop pydbus, switch to dbus-python
* bluetooth module: report battery percentage if available (#2185), by Alex Tsitsimpis
* clock module: added timezone information to times implicitly using local system timezone (#2197), by Andreas Grapentin
* clock module: minor patch to get the local timezone. (#2189), by Josh Sixsmith
* diskdata module: fix variable init type
* diskdata module: make module work on FreeBSD (#2200), by Björn Busse
* mpd_status module: fix UnboundLocalError (#2199), by Björn Busse
* ns_checker module: replace query() with resolve() (#2207), by Björn Busse
* systemd module: drop pydbus, switch to dbus-python
* vpn_status module: drop pydbus, switch to dbus-python

version 3.50 (2023-04-17)
* update alpine install doc (#2176), by raspbeguy
* battery_level module: fix invalid indexing, skip batteries with unavailable info (#2180), by lasers
* vpn_status module: add wireguard support (#2181), by javiertury

version 3.49 (2023-02-17)
* do_not_disturb module: use 'makoctl mode' to check current mode. (#2172), by Valdur Kana
* google_calendar module: add support to configure which google calendar will be used (#2174), by Alex Thomae

version 3.48 (2023-01-14)
* IMPORTANT: bluetooth module has been replaced by the bluetooth2 code, please migrate
* python: drop py 3.6 from CI and bump 3.11 (#2166)
* battery_level module: allow icon to not use charging_character (#2158), by Kevin Pulo
* bluetooth module: replaced by bluetooth2 as announced on 2022-10
* check_tcp module: add IPv6 support (#2167), by Björn Busse
* clock module: migrate to standard zoneinfo with 3.7, 3.8 support. (#2155), by Valdur Kana
* events: change the reading timeout to infinity (#2153), by Austin Lund
* kdeconnector module: Active notifications were always 1. (#2170), by Valdur Kana
* kdeconnector module: refactor to use dbus signals to update module (#2168), by Valdur Kana
* kdeconnector module: show cell network type and strength. (#2162) (#2163), by Valdur Kana
* mpris module: fix error self.parent on Py3status module not found. (#2169), by Valdur Kana
* timewarrior module: remove dependency on dateutil (#2161), by Rasmus Rendal
* volume_status module: amixer scontrols uses device and card parameter. (#2152), by Valdur Kana
* volume_status module: deprecate start_delay parameter
* volume_status module: smarter initialization logic with retry, remove start_delay setting (#2165), by Joan Bruguera
* window module: window without title will not produce error on i3msg mode, by Valdur Kana* core: add inhibition timer on misbehaving signals

version 3.47 (2022-10-02)
* INFORMATION: the upcoming bluetooth module has been merged as bluetooth2, users are encouraged to switch
* core: simpler logic to inhibit out of order signaling (#2147)
* formatter: add escape command to escape html, thx to lasers
* new module from scratch: bluetooth2 (#2114), by lasers
* mpris module: different players can use chromium busname, skip cache, by Valdur Kana
* taskwarrior module: add report parameter (#2141), by Evan Chen
* volume_status module: autoselect channel on amixer backend (#2143), by lasers

version 3.46 (2022-08-25)
* INFORMATION: we plan to replace the bluetooth module with a more flexible one in coming releases (see #2114)
* core: use git package for logging git commit information if available (#2138), by Austin Lund
* docs: add Alpine Linux installation instructions (#2129), by raspbeguy
* new audiosink module: switch between pulseaudio sinks from your bar (#2137), by Jens Brandt
* sysdata module: ignore ZFS ARC cache in memory usage (#2131), by anarcat
* volume_status module: add start_delay to address issue #2136 (#2139)

version 3.45 (2022-06-16)
* official python3.6 support removed
* mail module: fix pathlib adoption (#2125), by Hunter Blanks
* twitch module: migrate to new Twitch API, fix #2123 (#2124), by Julian Picht
* volume_status module: use mapped volume with amixer backend. (#2128), by Jose Riha

version 3.44 (2022-04-22)
* IMPORTANT: python3.6 support will be removed on next release
* core: handle SIGTSTP/SIGCONT better for after sleep freezes
* formatter: stop escaping html characters on pango markup (#2122), by lasers
* module_test: add clear_timeout_due (#2119), by lasers
* udev monitor: implement udev events throttling with warnings
* google_calendar module: escape html on event summary for pango
* mpris module: add player_shortname placeholder for displaying player busname (#2120), by Valdur Kana
* xrandr module: fix missing " at the end of documentation line. (#2121), by Valdur Kana

version 3.43 (2022-04-01)
* core: rework SIGSTP inhibition to support both #2068 and #2107
* formatter: pango markup should escape all html character
* py3.safe_format: add information about invalid format
* py3.safe_format: implement a generic max_width parameter
* requirements: fix click dependency with black
* udev monitor: don't trigger actions when i3bar refresh is stopped
* weather_owm module: dont use onecall for better current day forecast (#2112)

version 3.42 (2022-03-14)
* core: fix root cause of negative update_due (#2109), by Valdur Kana
* external_script module: add option 'convert_numbers' to preserve number formatting (#2101), by Nicolas Kuttler
* khal_calendar module: add option to limit the number of returned calendar entries (#2103), by Andreas Grapentin
* mpris module: total rework with bug fixes (#2077), by Valdur Kana
* weather_own module: fix onecall when city is specified thx to @mlmatlock

version 3.41 (2022-02-27)
* core: drop and log negative new_update_due which causes high cpu load and endless loop (closses #2085) (#2092), by Valdur Kana
* core: switch from time.perf_counter to time.monotonic (#2099)
* core: timeout due to return something >= 0 instead of None
* new option py3status.stop_signal to disable i3bar stop/resume (#2095)
* arch_updates module: paru exits with a non-zero status if there are no updates (#2098), by Stefan G
* battery_level module: fallback to power_now if no current_now
* events: fix pydevd.debugger first click caused "JSONDecodeError: Expecting value: line 1 column 2 (char 1)". (closes #2090) (#2091), by Valdur Kana
* net_iplist module: support parsing iface name with "@" symbol (#2083), by Yikai Zhao
* pomodoro module: pyglet and pygame are no longer needed after the merge of #1770 (#2094), by Stefan G
* scratchpad module: workaround for i3ipc 2.2.1 not finding leaves() in sway (#2088), by Valdur Kana
* sysdata module: add tctl sensor (#2082), by lasers
* velib_metropole module: drop obsolete module
* weather_owm module: fix forecast by using new onecall api endpoint (#2097)
* window module: i3ipc backend uses incoming event data and relies less on get_tree.focused() data. (#2087), by Valdur Kana

version 3.40 (2021-11-08)
* README: update readthedocs links to new documentation thx to @oceyral
* i3 contrib page: update readthedocs links to new documentation
* i3 contrib page: update to sync with i3.github.io
* core: inhibit conflicting SIGCONT SIGTSTP that can be received too fast (#2068)
* core: fix i3/sway detection thx to @steinex
* formatter: support pango special & character
* bump mkdocs from 1.2.1 to 1.2.3 in /requirements (#2073), by dependabot[bot]
* battery_level module: add configurable status strings (#2065), by oghm2
* do_not_disturb module: handle mako using makoctl (#2075) thx to @steinex
* vpn_status module: fix changed dbus signal handler signature (#2074) thx to @oceyral
* whoami module: add {hostname} placeholder to output (#2069), by oghm2

version 3.39 (2021-08-30)
* documentation was refactored to use MkDocs, lots of work has been done
* add a makefile to ease tasks
* create and split project, documentation and tests requirements
* tests: update tox and module tests to match mkdocs md format
* new sway_idle module: to display the idle state of sway wm (#2058), by Valentin Weber
* clock module: compatible with tzlocal 3.0, thx to @flyingapfopenguin
* speedtest module: fix error when clicking too fast, closes #2060
* weather_owm module: _format_sunrise and _format_sunset as aware datetime (#2055), by msk

version 3.38 (2021-06-29)
* update IRC doc to OFTC
* arch_updates module: add paru support (#2052), by Andreas Schleifer
* spotify module: work around play/pause bug in spotifyd (#2053), by Benjamin van der Burgh
* weather_owm module: added support for displaying wind speeds in knots (#2050), by Tarjei Knapstad

version 3.37 (2021-05-26)
* require setuptools: py3status/core.py and tests/test_user_modules.py import pkg_resources (#2043), by Tomáš Hrnčiar
* help: clarify connection between --debug and --log-file options (#2044), by Ilia Kurenkov
* tox: exit on first error
* bitcoin_price module: remove module due to unmaintained APIs (#2047), by lasers
* exchange_rate module: update code to require an api key fix #2048
* kdeconnector module: add support for version 20.12.3 (#2037), by Danilo Treffiletti
* lm_sensors module: replace raw with json output (#2049), by lasers
* timewarrior module: remove timezone info from end date (#2039), by Glenn Feunteun
* weather_owm module: avoid customized formats in module_test (#2034), by lasers
* weather_owm module: remove hardcoded rounded numbers (#2033), by lasers

version 3.36 (2021-04-02)
* new zypper_updates module: to watch for OpenSuse updates (#2026), by Yiannis
* clock module: switch back to time.time

version 3.35 (2021-03-22)
* fix time modules synchronization bug thanks to @ya-isakov
* core: fix detection of instances of user provided modules fix #2020 (#2023)
* docs: fix NixOS instructions to address #2018 (#2024), by Thiago Kenji Okada
* add github issue templates
* bluetooth module: add missing requirement
* sysdata module: rename temp_unit to cpu_temp_unit and drop zone config to support intel, amd, RPi (#2029), by lasers
* weather_owm module: add wind direction placeholder (#2021), by leroyz84

version 3.34 (2021-03-04)
* storage: fix Path generation in storage fixes #2004 (#2007), by Miroslav Šedivý
* battery_level module: fix converting seconds to H:M:S format (#2010), by David Herman
* google_calendar module: add options to personalize behavior (#2013), by ben75020
* kdeconnector module: fix for battery unavailable (#2015), by Zack Didcott
* lm_sensors module: fix an issue when sensors disconnect and are not detected again  (#2006), by Jack Doan
* net_iplist module: show only non deprecated ipv6 addresses (#2011), by Christian Struck
* networkmanager module: make format_device less confusing in docstring
* volume_status module: log available devices only on change
* volume_status module: run with either pulseaudio or pipewire installed (#2009), by Yaroslav Dronskii

version 3.33 (2021-02-07)
* HOTFIX: this hotfix release fixes py3-cmd
* IMPORTANT: since we touched a lot of stuff in 3.32, we might have broken stuff.
* command: fix py3-cmd refresh error thx to @btmcg fixes #2003

version 3.32 (2021-02-03)
* IMPORTANT: a lot of python3 and code normalization happened thanks to Miroslav Šedivý
* core: upgrade to python 3.6 syntax using pyupgrade, by Miroslav Šedivý
* core: modernize python3 code (#1993), by Miroslav Šedivý
* py3status code uses f-strings (#1981), by Miroslav Šedivý
* use list/generator/dict comprehensions where appropriate (#1982), by Miroslav Šedivý
* use pathlib everywhere to manipulate paths and files (#1978), by Miroslav Šedivý
* use shutil.which() instead of external which binary (#1997), by Jonas Witschel
* use time.perf_counter to measure short time periods (#1996), by Miroslav Šedivý
* add github project sponsoring
* argparsers: add missing path on default value
* argparsers: make sure FILE and PATH options are Path objects
* battery_level module: fix float formatting with f-strings
* better usage of timedelta/time modules (#1985), by Miroslav Šedivý
* ci: switch to GitHub Actions CI (#1980), by Miroslav Šedivý
* command: fix binding on PosixPath instead of a bytes-like object
* core: honor the "colors" general directive thx to @infabo fixes #1999
* docs: fix building of html docs
* drop travis-ci
* fix sys.path manipulation in setup.py as reported by @X-dark (#1983), by Miroslav Šedivý
* i3status module: use datetime.timezone for a custom tz (#1984), by Miroslav Šedivý
* i3status module: add markup support for time,tztime modules, by lasers
* mpd_status module: fixes extra space in the state when there's no artist (#1998), by Nicolás Sirolli
* mpris module: fixes mpris for Chrome, too. (#1989), by Klaus Umbach
* remove obsolete numeric relics from Python 2 (#1991), by Miroslav Šedivý
* spotify module: fix QA black format* Drop Python 3.5 support, by Miroslav Šedivý
* taskwarrior module: replace pytz with datetime.timezone (#1992), by Miroslav Šedivý
* volume_status module: stop spamming logs fixes #2002
* window module: change i3ipc to required dependency thx to @ssiyad

version 3.31 (2020-11-19)
* core: new "on_error" parameter to control module error behavior (#1972)
* doc: add CorruptCommit 's configuration examples (#1965), by CorruptCommit
* doc: create a user contributed conf example section thx to @CorruptCommit #1959
* update python version compatibility, 3.5 is gone, 3.9 is out
* parse_config: report missing file command fixes #1961 thx to @Bouni
* add poweron architecture ppc64le to travis build (#1963), by asellappen
* clock module: handle timezone changes, thx to @sTiKyt fix #1962
* coin_market module: broken module rewrite fixes #1913 (#1970), by lasers
* diskdata module: ignore df -k errors (#1969), by lasers
* do_not_disturb module: enhance dunst support using 1.5.0 dunstctl
* hueshift module: fix initialization incrementing cached value by delta (#1967), by Eugène Nélou
* i3status: add support for '%+' time format (#1975), by Parakleta
* mpris module: don't join the artist fields in BrokenDBusMpris (#1954), by Moritz Lüdecke
* spotify module: add spotifyd support (#1974), by Jean-Philippe Evrard
* sysdata module: increasing meminfo readable lines count to support Raspberry Pi4 (fix #1958) (#1960), by Valdur Kana

version 3.30 (2020-09-14)
* battery_level module: fix filter in /sys thanks to @naclander and @armandg (#1951), by Marc Poulhiès
* battery_level module: fix logic to skip batteries and charged state detection (#1949), by Danilo Treffiletti
* volume_status module: device parameter can be used as a regex
* volume_status module: log available devices on default mode

version 3.29 (2020-09-07)
* fix flake8 code linting and black code formatting to pass tests (#1940), by lasers
* py3.requests: return empty json on remote server problem fix #1401
* battery_level module: add power consumption placeholder (#1939), by vmoyankov
* battery_level module: support more battery paths detection  (#1946), by Marc Poulhiès
* core modules: remove deprectated function, fix type annotation support (#1942), by Markus Sommer
* do_not_disturb module: change pause default from False to True
* google_calendar module: fix imports for newer google-python-client-api versions (#1948), by raphaunix
* mpris module: implement broken chromium mpris interface workaround (#1943), by Jacotsu
* new module prometheus: display prometheus query results on your bar (#1947), by Wilmer van der Gaast
* new module watson: to use the watson time-tracking tool (#1944), by Markus Sommer
* sysdata module: add {mem,swap}_free, {mem,swap}_free_unit, {mem,swap}_free_percent, by Ricardo Pérez
* sysdata module: try to use default intel/amd sensors first, by Yaroslav Dronskii
* tox CI: force version of black to avoid reformatting failure
* volume_status module: document commands to print possible devices (#1932), by lasers

version 3.28 (2020-04-13)
* IMPORTANT: drop support for EOL Python 2.6-3.4 (#1896), by Hugo van Kemenade
* clock module: add "locale" config parameter to change time representation (#1910), by inemajo
* docs: update debian instructions fix #1916
* mpd_status module: use currentsong command if possible (#1924), by girst
* networkmanager module: allow using the currently active AP in formats (#1921), by Benoît Dardenne
* volume_status module: change amixer flag ordering fix #1914 (#1920)

version 3.27 (2020-03-01)
* i3status: support read_file module (#1909), by @lasers thx to @dohseven

version 3.26 (2020-02-23)
* IMPORTANT: drop support for EOL Python 2.6-3.4 (#1904), by Hugo van Kemenade

version 3.25 (2020-02-09)
* core: fix collections.abc imports for Python 3.9 (#1889), by Hugo van Kemenade
* qa: fix black formatting
* fix documentation build
* do_not_disturb module: add Mako support for wayland environment. (#1898), by Cyrinux
* frame module: expose output of submodules for use in format (#1900), by Akim Sadaoui
* imap module: fix idle for courier (#1899), by Alexander Görtz
* imap module: handle OAuth TransportError (#1886), by Justyn Butler
* imap module: implement degraded_when_stale (#1885), by girst
* imap module: implement retry logic (works around badly configured mail servers) (#1881), by girst
* mpd_status module: use idle feature (major cpu savings) (#1884), by girst
* mpd_status module: clean up idle code (#1890), by girst
* mpd_status module: properly terminate idling thread (#1895), by girst
* mpd_status: fix color output (#1893), by L0ric0
* net_iplist module: fix iface regex wrt #1892 thx to @segaja
* spotify module: document dep on python-dbus fix #1888
* xrandr module: fix force_on_change logic when udev is not available #1873 (#1874), by Andrwe Lord Weber

version 3.24 (2020-01-10)
* core: some commands expectedly return non 0 output, dont log them, thanks to steinex
* fix tests and update setup for python 3.8 (#1880), by Maxim Baz
* imap module: add OAuth2 support (#1879), by Justyn Butler

version 3.23 (2020-01-04)
* core: report CommandError on logs
* xkb_input: new module from scratch to support sway too (#1869), by lasers
* backlight module: use logind as a fallback (#1870), by Boucman
* spaceapi module: fix offline attributeerror exception (#1872), by lasers
* getjson module: support basic auth via username/password fix #1875 (#1876)
* speedtest module: document how to run the test wrt #1878

version 3.22 (2019-12-10)
* doc/configuration.rst: fix unexpected unindents (#1867), by lasers
* imap module: fix black code formatting to pass tests (#1857), by lasers
* module_test: support config cli arguments (#1859), by lasers
* mpris module: add vlc nowplaying field (#1855), by Cedric Girard
* new module systemd_suspend_inhibitor, to be able to inhibit suspend managed by systemd logind (#1861), by Cyrinux
* ns_checker module: use post_config_hook (#1850), by lasers
* remove nvidia_temp in favor of nvidia_smi (#1853), by lasers
* remove scratchpad_{async,counter} in favor of scratchpad (#1852), by lasers
* remove window_title{,_async} in favor of window (#1854), by lasers
* treewide: fix typos, grammar improvements (#1858), by Torstein Husebø
* usbguard module: update for versioned dbus in 0.7.5 (#1856), by Maxim Baz
* volume_status module: simplify code (#1851), by lasers
* window: get name instead of window_title, get nodes or empty lists (#1860), by lasers

version 3.21 (2019-10-13)
* implement global request_retry_times and request_retry_wait options (#1847)
* arch_updates module: checkupdates throws exit code on zero updates (#1848), by Daniel Jenssen
* bitcoin_price module: change api request to http (#1836), by dosera
* coin_market module: skip empty datas (#1849), by lasers
* fix `long_description_content_type` missing
* fix entry_point typo in docstring (#1830), by Oliver Bestwalter
* fix project's long_description has invalid markup which will not be rendered on PyPI
* i3status: support memory module, remove valid_config_param (#1833), by lasers
* new module networkmanager: display network status (#1766), by Kevin Pulo
* module testing: fix testmode fails because it uses is_gevent property. (#1832), by Valdur Kana
* mpris module: fix KeyError exception closes #1827 (#1831), by lasers
* nvidia_temp module: add safeformat for separator, rename separator (#1846), by lasers
* spotify module: add playback placeholder (#1829), by Bazyli Cyran
* sysdata module: prevent a divide by zero on empty swap (#1838), by Pierre GINDRAUD
* weather_owm module: add safeformat for separator, rename separator (#1845), by lasers
* weather_own module: add thresholds for humidity (#1844), by lasers
* wifi module: fix bug introduced in PR #1834 (#1835), by ownaginatious
* wifi module: specify device by name or MAC address (#1834), by ownaginatious

version 3.20 (2019-08-06)
* IMPORTANT: py3status now supports importing modules from pypi packages, see 'writing modules' section on docs!
* introduce entry point based discovery of packaged custom modules (#1823), by Oliver Bestwalter
* core, module: add an ability to import resources (#1673), by lasers
* fix logo url in README (#1814), by Daniel Peukert
* formatter: add expand_color() (#1787), by lasers
* formatter: fix colors in composites after expand_color addition (#1821), by lasers
* tox is always lowercase (#1824), by Oliver Bestwalter
* new module xkb_layouts: to display keyboard layouts and variants (#1817), by lasers
* add 100ms delay before refreshing modules on udev trigger #1805
* arch_updates module: add trizen support (#1813), by Daniel Peukert
* arch_updates module: auracle throws exit code on zero updates (#1809), by Piotr Miller
* arch_updates module: change trizen command to track exit code (#1815), by Daniel Peukert
* backlight module: round brightness percentage instead of truncating (#1803), by Piotr Miller
* bluetooth module: switch to pydbus (#1804), by Maxim Baz
* clementine module: upgrade to MPRIS2 support (#1797), by Rodrigo Leite
* sysdata module: add cpus, format_cpu, format_cpu_separator, etc (#1798), by lasers
* uptime module: specify strftime characters to display system up since (#1810), by lasers
* volume_status module: pactl improvements (#1765), by Kevin Pulo
* volume_status module: support icon blocks to reflect volume (#1812), by Daniel Peukert
* volume_status: pamixer cleanups/improvs (#1806), by lasers
* weather_owm module: switch from timezoneapi to our own api (Fix #1818) (#1819)
* wifi module: split up unit placeholders, remove round_bitrate (#1791), by lasers
* wwan module: add missing curly brackets to examples (#1820), by luto
* xrandr module: allow users to use an icon instead of OUTPUT text (#1801), by lasers

version 3.19 (2019-04-30)
* NEWS: py3status now has a logo thanks to @tobaloidee!
* constants: QA uppercase hex color codes (#1786), by lasers
* core: log loaded i3status modules on startup (#1772), by lasers
* group: calculate remaining times to cycle more accurately (#1785), by lasers
* logo upload & readme update  (#1768), by tobaloidee
* module: fix pango markup for non-composite modules (#1784), by lasers
* py3: move py3.get_color_names helper to formatter (#1778), by lasers
* py3: support multiple matches on get_placeholders_list (#1773), by lasers
* py3: support converting bits to bytes on format_units() (#1793), by lasers
* new module khal: display your khal calendar (#1741), by xenrox
* diskdata module: explicitly request kb from df (#1763), by Kevin Pulo
* diskdata module: optimize formatting composites, units, etc  (#1774), by lasers
* i3pystatus module: check python first before telling python2 users to install (#1760), by lasers
* i3pystatus module: support universal/py3status module options (#1758), by lasers
* i3pystatus module: remove composites and keys to make dicts more comparable (#1762), by lasers
* keyboard_layout module: use xkblayout-state to switch layout (#1780), by Pipat Saengow
* keyboard_layout module: xkblayout-state should prefer variant if available (#1795), by ecks
* mpris module: detect and report error when used with gevent (#1771)
* mpris module: make new default and click buttons changes (#1761), by lasers
* net_rate module: call functions once instead of twice (#1792), by lasers
* nvidia_smi module: add memory units placeholders (#1790), by lasers
* pomodoro module: use py3.play_sound helper (#1770), by lasers

version 3.18 (2019-03-30)
* bugfix release: regresion on group cycling
* group: don't cycle on zero (#1757), by lasers
* updated configuration and modules paths detection using XDG_CONFIG_HOME (#1694), by lasers
* reorder docs index
* update i3wm.github.io py3status page with newer links and doc fix #1010 (#1745)
* docs: make unordered list, update docs, fix typos (#1754), by lasers
* parse_config: raise errors when using modules in containers in the order directive (#1747), by lasers
* frame module: add safeformat for the separator (#1746), by lasers
* mpris module: handle disconnected players gracefully on clicks (#1759), by lasers

version 3.17 (2019-03-24)
* IMPORTANT: py3status is now compatible with sway on wayland
* add sway support with --wm option (#1718), by lasers
* argparsers: add slash on paths (#1710), by lasers
* broken frame modules when pango markup is used fix #1736
* cli, core: refactor cli stuff from core to cli (#1667), by lasers
* events: remove unused if statement for \$OUTPUT{,_PART} (#1752), by lasers
* formatter, py3: use color hidden to hide blocks (#1726), by lasers
* py3status: transform modules and docstring commands (#1677), by lasers
* module cleanups and tweaks #2 (#1701), by lasers
* module cleanups and tweaks (#1691), by lasers
* module: add pango markup conversion (#1723), by lasers
* module: add pango markup conversion (py2+module_options) (#1729), by lasers
* module: fix indexerror exception (#1749), by lasers
* move list and docstring from py3status to py3-cmd (#1713), by lasers
* rename cli.py to argparsers.py (#1696), by lasers
* simplify include_paths early to valid paths (#1695), by lasers
* tests: add consistency tests for modules (#1690), by lasers
* new module: scroll (#1748), by lasers
* air_quality module: expose and optimize thresholds (#1684), by lasers
* arch_updates module: add auracle support (#1674), by Yaroslav Dronskii
* arch_updates module: fix SPEC VIOLATION: full_text is NULL! (#1735), by lasers
* arch_updates module: remove include_aur in favor of auto, refactoring (#1727), by lasers
* arch_updates module: remove obsolete cower from docs (#1720), by lasers
* arch_updates module: use py3.command_output helper (#1721), by lasers
* async_script module: fix typo (#1702), by Cody Hiar
* battery_level: fix case when an invalid battery is detected (#1751), by Thiago Kenji Okada
* coin_market module: optimize thresholds (#1682), by lasers
* graphite module: use func mapping instead of eval('func') (#1700), by lasers
* group module: stop cycling on urgent module closes #890 (#1753)
* hddtemp module: optimize thresholds (#1683), by lasers
* imap module: fix flake8 F999 errors (#1671), by lasers
* mail module: raise invalid filters, add log option to print folders (#1708), by lasers
* mpris module: remove min_width pixels in favor of spaces (#1738), by lasers
* netdata module: normalize speed rate (#1730), by Ajeet D'Souza
* netdata module: optimize thresholds (#1679), by lasers
* screenshot module: catch up with the standards (#1714), by lasers
* sysdata module: add used units (#1715), by lasers
* sysdata module: optimize cpu_freqs (#1685), by lasers
* sysdata module: optimize meminfo parsing (#1697), by lasers
* sysdata module: optimize thresholds (#1678), by lasers
* thunderbird_todos module: optimize thresholds (#1680), by lasers
* tor_rate module: allow users to hide socket errors (#1666), by cyrinux
* transmission module: optimize thresholds (#1681), by lasers
* twitch module: clean up some code (#1698), by lasers
* twitch module: use self.py3.request helper (#1699), by lasers
* usbguard module: simpler implementation (#1707), by Maxim Baz
* vnstat module: replace coloring with optimized thresholds (#1686), by lasers
* weather_owm module: flip coordinates to (lat, lon) (#1732), by lasers
* weather_owm module: print error message and status code (#1672), by lasers
* wifi module: add optimized thresholds (#1688), by lasers
* wifi module: code cleanup (#1689), by lasers
* wifi module: remove use_sudo in favor of auto (#1703), by lasers
* wifi module: switch to wifi device auto detection by default (#1706), by lasers

version 3.16 (2019-01-20)
* @maximbaz has become the third collaborator of the py3status project !
* add -u, --i3status to specify or override i3status path (#1649), by lasers
* add more module and global options, see documentation (#1620), by lasers
* added zen of py3status
* notify users of obsolete module and their alternatives (#1618)
* module_test: add urgent support in --term (#1626), by lasers
* modules: deprecate timeout parameter and honor request_timeout everywhere
* modules: don't set module options on disabled modules (#1637), by lasers
* modules: normalize main methods and add tests (#1641), by lasers
* doc: Update NixOS docs (#1639), by Thiago Kenji Okada
* doc: write documentation about request_timeout, by lasers
* doc: fix doc generation warnings (#1636), by lasers
* py3: adjust cache_timeout intervals to the right second (#1650), by lasers
* py3: get_color_names_list to return an empty list on false value (#1631), by lasers
* py3: threshold_get_color to set color=None on exception (#1634), by lasers
* fix i3status path detection and setting on startup (#1662), by lasers
* fixed typo in naming ('gradiant' -> 'gradient') (#1658), by Thomas F. Duellmann
* remove obsolete cli interval argument (#1661)
* git-hooks: add black tests to run first before pushing (#1653), by lasers
* update arch installation instructions (#1622), by Maxim Baz
* update contribution guidelines (#1623), by Maxim Baz
* update screenshots (#1616), by lasers
* new conky module: display conky system monitoring (#1664), by lasers
* diskdata module: call functions once instead of twice (#1640), by lasers
* diskdata module: optimize thresholds (#1629), by lasers
* diskdata: Added used_percent threshold (#1628), by Thiago Kenji Okada
* do_not_disturb module: dunst with state=None is invalid (#1625), by lasers
* do_not_disturb module: fix pause logic hiding startup notifications (#1624)
* do_not_disturb: simplify dunst logic (#1654), by Maxim Baz
* do_not_disturb: use pkill instead of killall to support NixOS (#1638), by Thiago Kenji Okada
* exchange_rate module: change feed to exchangeratesapi.io (#1655), by lasers
* file_status module: optimize thresholds (#1632), by lasers
* i3block module: normalize docstrings (#1635), by lasers
* mpd_status module: max_width was not working because of composite fixes #1613 (#1615)
* mpris module: fix clementine attributeerror exception (#1648), by lasers
* net_rate module: optimize thresholds (#1630), by lasers
* net_rate module: prevent errors after resuming from sleep (#1659), by cyrinux
* pingdom module: add author ultrabug (#1651), by lasers
* sysdata module: added cpu frequency placeholders (#1609), by Jack Doan
* sysdata module: support sysfs paths to temp sensors (#1614), by Jack Doan
* systemd module: support user systemd units (#1657), by cyrinux
* taskwarrior module: add tasks placeholder (#1647), by ecks
* velib_metropole module: fix format thresholds (#1633), by lasers
* weather_yahoo module: removed due to full API change by Yahoo/Oath
* xrandr module: add dynamic primary configuration (#1665), by lasers

version 3.15 (2018-12-30)
* CI now checks for black format on modules
* add support for background and border (i3-gaps) colors (#1486), by lasers
* py3-cmd: allow sending click events with modifiers (#1589), by lasers
* dont log every udev event per default
* fix check for modifiers at click events (#1601), by L0ric0
* formatter: avoid duplicate soft blocks (#1595), by @lasers, by lasers
* log signals for easier debugging
* arch_updates module: alternatively use yay for AUR check (#1545), by Simon Legner
* backlight module: added "hide_when_unavailable" option (#1607), by Thiago Kenji Okada
* battery_level module: refresh with udev, increase default cache_timeout (#1573), by Maxim Baz
* deadbeef module: return deadbeef data without error codes (#1581), by lasers
* do_not_disturb module: major refactoring (#1471), by lasers
* dropbox_status module: add support for unicode character output from dropbox-cli (#1578), by Keith Hughitt
* dropboxd_status module: add documentation about dropbox-cli (#1598), by sridhars
* external_script module: allow display full output as notification on click (#1585), by Maxim Baz
* gitlab module: use py3.get_color_names_list helper (#1522), by lasers
* google_calendar module: fix url indexerror exception (#1603), by lasers
* i3pystatus module: add sample output, fix docstrings (#1587), by lasers
* keyboard_layout module: add variant placeholder (#1492), by lasers
* mail module: report account name collision with folder names (#1544), by L0ric0
* mail module: add imap subscriptions to filter mailbox folders (#1606), by lasers
* mail module: validate mailboxes, names to avoid collisions (#1593), by lasers
* new module async_script: allow for background scripts output to update the bar themselves (#1265), by girst
* new module emerge_status: display information about running gentoo emerge (#1275), by AnwariasEu
* new module hueshift: change your screen color temperature (#1142), by lasers
* new module mega_sync: to check for MEGA service synchronization (#1458), by Maxim Baz
* new module speedtest: to check your internet bandwidth (#1435), by cyrinux
* new module usbguard: control usbguard from your bar (#1376), by cyrinux
* new module velib_metropole: display velib metropole stations and (e)bikes (#1515), by cyrinux
* screenshots module: don't use f-strings (#1590), by lasers
* screenshots module: fix parsing missing last screenshots (#1586), by lasers
* systemd module:  add option to suppress output if unit is in default state (#1382), by flyingapfopenguin
* systemd module: add config parameter to hide service extension (#1381), by flyingapfopenguin
* transmission module: use --list when no aditional arguments are given (#1604), by L0ric0
* vnstat module: replace deprecated --exportdb with --oneline (#1570), by lasers
* volume_status module: use human-scale volume percentages like alsamixer (#1579), by justin j lin
* vpn_status module: handle multiple vpns (#1596), by @oceyral, by oceyral
* wifi module: add mhz and ghz frequency placeholders (#1574), by Till Backhaus
* xrandr module: new force_on_change feature to follow screens automatically (#1597)

version 3.14 (2018-11-10)
* IMPORTANT: this version adds an optional dependency with pyudev that is recommended to use
* core & modules: add helpers to allow modules to react to udev events (#1546)
* black: py3status core uses black formatter
* fix default i3status.conf detection
* add ~/.config/i3 as a default config directory, closes #1548
* add .config/i3/py3status in default user modules include directories
* add markup (pango) support for modules (#1408), by @MikaYuoadas
* add missing documentation on gevent option
* setup.py, travis.yml: add python 3.7 support, by lasers
* module_test: print modules in terminal, by lasers
* clean and improve screenshots generation (#1535), by @tobes
* py3: add threshold string support (#1480), by @lasers
* py3: notify_user module name in the title (#1556), by @lasers, by lasers
* parse_config: raise error on invalid modules (fixes #1523), by @lasers
* fix flake8 W605 errors in core and disable test for modules (#1560), by @tobes
* module: rename min_width,align to min_length,position (#1551), by @lasers
* allow test_modules to use udev_monitor (#1558), by @lasers
* refactor and document extra requirements
* print module information to sdtout instead of stderr (#1565), by @robertnf
* battery_level: Default to using sys instead of acpi (#1562), by @eddie-dunn
* enhanced help message thx to @lasers #1555
* reduce flake8 checks on errors to concentrate on functional errors
* fix errors on empty module error message, fixes #1567
* imap module: fix output formatting issue (#1559), by @girst
* xrandr module: now only updates on a "drm" udev event if pyudev is installed


version 3.13 (2018-09-28)
* WARNING: after this release, py3status coding style CI will enforce the 'black' formatter: https://pypi.org/project/black/
* @lasers has become the second collaborator of the py3status project !
* README: update Arch Linux installation instructions, by Alexis Horgix Chotard
* config functions base64() and hide(), by @tobes
* config parser: add explicit exceptions, by @tobes
* config parser: cleaner functions, by @tobes
* config parser: improve unicode support, by @tobes
* config parser: unify quote removal, by @tobes
* documentation: module docstring fixes to remove sphinx errors plus formatting, by @tobes
* documentation: update formater and configuration docs, by @L0ric0
* fix BOM related documentation breakage, by @tobes
* fix empty seeming composite block issue, by @tobes
* fix LANGUAGE environment variable for english output, by @wojtex
* flake8: resolve several warnings and errors, by @lasers
* formatter: add {:ceil} to return x or x+1, by @lasers
* formatter: catch both lonely braces, by @tobes
* formatter: don't strip whitespace, by @lasers
* formatter: hide block on 'None' string too, by @lasers
* formatter: return falsey properly, by @lasers
* formatter: show values instead of faking nonexistent keys, by @lasers
* lexer fix small glitchs, by @tobes
* module: align modules with py3status instead of i3bar, by @lasers
* module: fix universal module options for python2, by @lasers
* parse_config: fix lookuperror exception, by @lasers
* parse_config: print file name too in config error messages, by @lasers
* prevent creating timezone with to large an offset due to suspending, by @tobes
* py3: add new helper: get_color_names_list, by @lasers
* py3: threshold_get_colors to allow name with different values, by @lasers
* py3status lexer updates for docs, by @tobes
* add new module: lm_sensors, by @lasers
* add new module: loadavg, by @lasers
* add new module: mail, by @lasers
* add new module: nvidia_smi, by @lasers
* add new module: sql, by @Cereal2nd and @lasers
* add new module: timewarrior, by @lasers
* add new module: wanda_the_fish, by @lasers
* Added sql module, by Maikel Punie
* allow us to get params from formats and also update them, by @tobes
* clock: use format parsing to find placeholder, by @tobes
* command_output: allow ignoring stderr, by Maxim Baz
* deadbeef: deprecate 7.0, 7.1 support, by @lasers
* deadbeef: use py3.command_output helper, by @lasers
* exchange_rate: fix issue caused by lack of testing, by @lasers
* external_script: cast numeric output automatically, by @lasers
* fedora_updates: fix issue caused by lack of testing, by @tobes
* git-hooks: run flake8 tests first before pushing, by @lasers
* github: update github notifications link with scope, by @su8
* gitlab: add pipelines status placeholder, by @cyrinux
* i3pystatus: standalone fix for thread issue, by @tobes
* replace http with secure https in all modules, by @lasers
* setup: add fast-entry_points, by @lasers
* storage: properly handle and log legacy storage migration, by @Ultrabug
* storage: use $XDG_CACHE_HOME or ~/.cache, by @lasers
* sysdata: add htop-like memory usage, by @lasers
* test_module_doc: fix modules to remove all ignore items, by @lasers
* updated formater doc, by Lorenz Steinert
* weather_owm: work without timezoneapi but also if you set city or location, by @tobes
* whatismyip: don't fetch requests between toggle states, by @lasers


version 3.12 (2018-08-09)
* it looks like some i3 freezes that affected py3status (see #941) have been fixed https://github.com/i3/i3/issues/2539, next i3 release (>4.15) should contain the fix
* py3.request adds a default User-Agent header when none is provided
* py3-cmd: refactoring to add more options for click and refresh commands, add frame click support for #1349, by @lasers
* formatter: parse placeholders with periods, by @lasers
* air_quality module: display nothing instead of error on api error, by @cyrinux
* arch_updates module: better error handling when no internet connection, by @btmcg
* exchange_rate module: use the new core default user-agent
* file_status module: patch to fix plural wording, by @cyrinux
* volume_status module: skip pactl and pamixer if no pulseaudio, by @lasers and reported by @raingart
* volume_status module: (pactl) reinitialize default device, fixes #1402 by @lasers as reported by @sridhars
* whatismyip module: deprecate negative_cache_timeout parameter
* xrandr module: add support for setting background, by @evypb


version 3.11 (2018-07-05)
* py3.notify_user: add support for title and icon parameters to tune notifications, by @cyrinux
* new gitlab module: to powerfully manage your gitlab notifs/todos, by @lasers
* new wwan network manager module, by @cyrinux
* arch_updates module: update documentation to include the pacman-contrib requirement by @markrileybot
* diskdata module: fix stats computation, fixes #1373 by @scotte
* file_status module: add support for several paths with new format options, by @cyrinux
* hddtemp module: workaround for hddtemp byte bug, by @lasers
* net_rate module: handle non-existent interfaces better, fixes #1377, by @scotte
* sysdata module: use py3.format_units, by @simon04
* whatismyip module: replace freegeoip.net which has move and now require an api key, by @cyrinux


version 3.10 (2018-05-21)
* fix pip installation reported on #1351 by @lainiwa


version 3.9 (2018-05-14)
* added --disable_click_events (-m) option to disable all click events, by @jamethy
* allow executing shell code in the config using shell(), by @girst
* test_formatter: add {:g} to remove trailing zeroes, by @lasers
* add py3-cmd to Control section of README, by @kmoe
* fix issue where cache_timeout non-numeric wrt #1340, by @tobes
* py3: play sounds with ffplay, by @lasers
* battery_level module: fixed for systems without POWER_SUPPLY_POWER_NOW neither POWER_SUPPLY_CURRENT_NOW, by @adrianlzt
* bitcoin_price module: changed request url from http to https, by @zack-baker
* keyboard_layout module: add variants support, by @lasers
* keyboard_locks module: rearrange locks, by @lasers
* pomodoro module: fix off-by-one error, rename max_breaks to pomodoros, by @lasers
* volume_status : prioritize default sound system fixing pulseaudio and alsa detection, by @saengowp
* weather_yahoo module: date bugfix and a series of changes, by @lasers
* xrandr module: parse mode properly, by @lasers


version 3.8 (2018-04-02)
* py3: command_output call command with lc_all=c, by woland
* py3: dismiss empty notifications, by @lasers
* py3: make thresholds take none for an answer, by @lasers
* py3: return gradients properly, by @lasers
* run event in threads to fix latency problems, by @tobes
* start modules in threads to parallelize, by @tobes
* persistent storage for modules, by @tobes
* added support for environment variables in config, by alex o'neill
* formatter: add {:g} to remove trailing zeroes, by @lasers
* formatter: inherit commands properly, by @lasers
* formatter: reject the condition if none, by @lasers
* improve logging for modules, by @tobes
* add cookies handling for request, by @raspbeguy
* add installation instructions for nixos, by daniel schaefer
* add multiple qa fixes for multiple modules, by @ultrabug
* add new module: hddtemp, by @lasers
* add new module: transmission, by @lasers
* add option to enable support for green threads using gevent, by @ultrabug
* add yubikey module, by maxim baz
* added google_calendar module, by igor grebenkov
* air_quality: new module from scratch, by @lasers
* allow do_not_disturb signals to be configured, by robert ricci
* allow external on_click events to run immediately, by @tobes
* allow named colors, by @tobes
* allow overiding xrandr resolution using {output}_mode, by @nollain
* allow selection of keyboard layout, by @tobes
* allow test modules to use storage, by @tobes
* allow time_in(cache_forever), by @tobes
* backlight: allow to use multiple backlight commands, add configuration for light, by @anubiann00b
* bitcoin_price: use py3.request helper, by @lasers
* coin_market: expose placeholder, add format_datetime, cleanups, by @lasers
* coin_market: remove first_run, by @lasers
* core: make notify_user less ambiguous in the logs, by @lasers
* core: support shorthand hex colors (thx @tobes), by @lasers
* deadbeef: add sleep_timeout, by @lasers
* deadbeef: check if deadbeef is installed, by @lasers
* display thunderbird_calendar tasks, by themistokle benetatos
* document availability as a debian package, by sébastien delafond
* enable click events for spotify, by @nollain
* exchange_rates: use new feed, by @tobes
* external_script: fix indexerror exception, by @lasers
* external_script: use localized command output, by woland
* external_script: use post_config_hook, by @lasers
* fix deadbeaf error, by @tobes
* github: don't treat first run as special, by @tobes
* google_calendar: code qa, fixups, add new configs, by @ultrabug
* group: allow waiting for active module, by @tobes
* imap: support for imap-idle; enabled by default, by @girst
* keyboard_locks: merge formats, by @lasers
* make post requests work, by @raspbeguy
* module storage: add ctime and mtime metadata keys on storage_set, by @ultrabug
* module storage: move documentation, add methods and overall review with tobes, by @ultrabug
* move arg parsing to own file to help decouple stuff, by @tobes
* mpd_status: fix valueerror, allow hiding on error, by @girst
* net_rate: use post_config_hook, by @lasers
* netdata: annihilate the lines, by @lasers
* online_status: fix timeout for ping, by @lasers
* parse_config: small refactor for append_modules, by alex o'neill
* pomodoro: fix cached_until intervals, by @lasers
* pomodoro: make formats more customizable, by robert ricci
* support i3pystatus modules, by @tobes
* sysdata: first half of cleanup efforts, by @lasers
* task to monitor i3status thread, by @tobes
* taskwarrior: make the command customizable, by @regnat
* taskwarrior: use post_config_hook, by @lasers
* thunderbird_calendar: code qa, cleanups, by daniel foerster
* thunderbird_todos: new module from scratch, by @lasers
* timer: add urgent + timer: add colors, by @lasers
* twitch api requires an app client id, by james curtis
* update standalone testing, by @tobes
* updated insync module to recognise synced state, by @cypher1
* volume_status: add boost for pamixer, by @lasers
* volume_status: check the binaries, by @lasers
* volume_status: enable mouse buttons, by @lasers
* volume_status: use py3.command_output, by woland
* weather_yahoo: new module from scratch, by @lasers
* wifi: use sudo in post_config_hook, by @lasers
* window_title: add new placeholders + simplifying, by @lasers
* xrandr_rotate: display screen properly, by @lasers
* xrandr_rotate: refresh properly, by @lasers


version 3.7 (2017-11-30)
* NOTE: this is a performance focused release
* deep rework of the usage and scheduling of threads to run modules: now py3status does not keep one thread per module running permanently but instead uses a queue to spawn a thread to execute the module only when its cache expires, by @tobes
* memory footprint of py3status got largely reduced thanks to the threads modifications and thanks to a nice hunt on ever growing and useless variables done by @tobes
* the next release will contain logic to switch from threads to greenlets and go further in optimizing py3status
* conversion of many modules to use post_config_hook, by @lasers
* improve spelling in documentation, by @lasers
* let Py3.contains_format() accept a list of placeholder names
* py3: print full command in the error logs, by @lasers
* air_quality module: fix attributeerror exception, by @lasers
* apt_updates module: improved error if apt not installed, by @lasers
* backlight module: allow slower value change after a threshold, by @maximbaz
* backlight module: detect and bypass xbacklight limitations, by @lasers
* diskdata module: new {total_space} placeholder, by @pcewing
* do_not_disturb module: better support for dunst, by @maximbaz
* exchange_rate module: use py3 helper to extract placeholders, by @lasers
* github module: fix urls so trailing / doesn't cause problems, by @lasers
* icinga2 module: fix missing color parameter, by @lasers
* moc module: code/documentation cleanups, by @lasers
* mpris module: code improvements, by @lasers
* pingdom module: fix when no useful data returned, by @lasers
* uptime module: code improvements/simplification, by @lasers
* volume_status module: allow card to be specified for amixer, by @lasers
* volume_status module: bugfix for pamixer when volume is zero, by @lasers
* xrandr_rotate module: run command once, by @lasers
* xrandr_rotate: replace shell commands with python codes, by @lasers
* xsel module: allow logging and clear selection, by @JohnAZoidberg
* yandexdisk_status module: improved error reporting to users, by @lasers


version 3.6 (2017-08-22)
* faster py3-cmd, by @tobes
* universal gradients functionality, by @tobes
* share code so module_test improved, by @tobes
* better report when i3status is missing, by @tobes thx to @Cypher1
* better module doctest failures, by @alexoneill
* allow report exception to be available early, by @tobes
* better error catching for missing {, by @tobes thx to @lasers
* make hide_if_zero work for net_rate fixes #935, by @tobes thx to @maximbaz
* fix py3-cmd link in docs, by @tobes
* fix group width issue when no output, by @tobes
* docs: add new screenshot directive, by @tobes
* only show first line of error in i3bar, by @tobes
* formatter allow some commands to be inherited, by @tobes
* formatter not zero fix for displayed values, by @tobes thx to @maximbaz
* new cmus module: to control your cmus music player, by @lasers
* new coin_market module: to display custom cryptocurrency data, by @lasers
* new moc module: to control your moc music player, by @lasers
* backlight module: combine device/device_path params, by @lasers
* backlight module: improve rounding of brightness value, by @maximbaz
* battery_level module: fix bug with over 100% full icon, by @docwalter
* battery_level module: fix divide by zero bug, by @tablet-mode
* bitcoin_prices module: add safeformat for the separator, by @lasers
* bluetooth module: add safeformat for the separator, by @lasers
* clock module: fix unicode time formatting, by @tobes
* dpms module: add safeformat for all statuses, by @lasers
* external_script: allow colored output, by @enguerrand
* fixed some of the documentation headings, by @armandg
* getjson module: cleanups, by @lasers
* github module: parse and use GitHub pagination headers (closes #945), by @rixx
* iw module: use absolute path for iw, by @paradoxisme
* make headers available via py3.request() and update github module, by @tobes
* mpris module: fix keyboard interrupt in test mode @ritze
* mpris module: improvements to player detection @ritze
* net_iplist module: fix for new formatter, by @guiniol
* pomorodo module: fix typo on docstring, by @valdur55
* selinux module: show permissive as degraded and cleanups, by @lasers
* spaceapi module: Don't die if datetimes are unparseable, by @rixx
* spaceapi module: prevent 'used before assignment' error, by @fmorgner
* spotify module: sanitize album/track title by default, by @vvoland
* sysdata module: Add load support, by @guiniol
* volume_status module: fix PactlBackend on non english system, by @vvoland
* volume_status: Default device detection for pactl, by  @lasers
* volume_status: support for input devices, by @markrileybot
* volume_status module: allow device as a int, by @tobes thx to @yabbes
* vpn_status module: change default format on no VPN, by @markrileybot
* whatismyip module: color_degraded support in status mode, by @aethelz
* whatismyip module: prevent mouse updates, by @lasers
* wifi module: add format, merge formats, by @lasers
* wifi module: fix quality icon python 2 bug, by @markrileybot
* window_title_async: fix workspace glitch, by @lasers

version 3.5 (2017-04-07)
* allow improved access to settings from py3status section, by @tobes
* add a new py3status configuration section and the ability to set i3-nagbar font, by @randomguy
* update sysdata documentation, by @valdur55
* group/frame: use safe_format() not build_composite, by @tobes
* skip empty modules in group, by @tobes
* remove some un-needed ignored parameters, by @tobes
* allow runtime errors to be handled in i3bar, by @tobes
* documentation generation cleanup, by @tobes
* show urgent on closed containers, by @tobes
* improve docstring tests to prevent reserved config parameters, by @tobes
* fix color comparison bug, by @tobes
* fix issue with empty full_text not showing separator, by @tobes
* fix issue with blank module causing extra separator to show, by @tobes
* cleanup i3status config access, by @tobes
* nicer exceptions on cli-commands, by @tobes
* py3 logging nicer formatting, by @tobes
* py3 provide http request functionality, drop requests dependency, by @tobes
* cleanup: remove transformed from module responses, by @tobes
* py3 helper: command_output() signal fix, by @tobes
* py3 helper: allow check_commands() to take a string, by @tobes
* formatter unicode fixup for python2, by @tobes
* new air_quality module, to display the air quality of your place, by @beetleman and @lasers
* new getjson module to display fields from a json url, by @vicyap
* new keyboard_locks module to display keyboard locks states, by @lasers
* new systemd module to check the status of a systemd unit, by @adrianlzt
* new tor_rate module to display the incoming and outgoing data rates of a Tor daemon instance, by @fmorgner
* new xscreensaver module, by @lasers and @neutronst4r
* backlight module: fix mouse behavior thanks to @Tadly on #796, by @tobes
* battery_level module: use helpers, by @lasers
* bitcoin_price module: add format, use post_config_hook, by @lasers
* bluetooth module: use helpers, by @lasers
* bluetooth module: hcitool is deprecated (bluez-5.44) so it is better to use the dbus library directly, by @jmdana
* check_tcp module: remove hardcoded strings, by @lasers
* coin_balance: use post_config_hook, by @lasers
* clementine module: use helpers, fix exception, by @lasers
* clock module: add %s, %T for time_delta calculation, by @ShareDVI
* clock module: use helpers, by @lasers
* clock module: allow better icon selection for given time, by @maximbaz
* deadbeef module: bug fix and improvements and extra placeholders, by @lasers
* diskdata module: use helpers, by @lasers
* diskdata module: fix stats for fs mounted multiple times by @eturner
* dpms module: add button_off, button_toggle, cache_timeout by @lasers
* do_not_disturb: use post_config_hook, by @lasers
* dropbox: use helpers and format fix, by @lasers
* external_script module: fix exception, remove warning, by @lasers
* external_script: use helpers, by @lasers
* frame module: use helpers, by @lasers
* getjson: use py3.request() + bugfix, by @tobes
* getjson: bugfix, by @maximbaz
* github module: use helpers and post_config_hook, by @lasers
* gpmdp module: fix permission, by @lasers
* gpmdp module: use helpers, by @lasers
* hamster module: use helpers, by @lasers
* hamster module: fix potential exceptions, by @lasers
* imap module: add depreciation stuffs, by @lasers
* imap: allow_urgent on unread messages, by @lasers
* insync module: fix exception, by @lasers
* insync module: use helpers, by @lasers
* keyboard_layout module: use helpers, by @lasers
* mpris module: fix mouse clicks by @ritze
* mpris module: use helpers, by @lasers
* mpris module: fixes to player registration, by valdur55
* net_iplist module: use helpers and post_config_hook, by @lasers
* netdata module: cleanups and optimization, by @lasers
* netdata module: add format, by @lasers
* nvidia_temp module: use helpers, by @lasers
* nvidia_temp module: fix exception, by @lasers
* online_status: use helpers, by @lasers
* pingdom module: add format, by @lasers
* pomodoro module: use helpers, by @lasers
* process_status module: add format, use helpers, by @lasers
* rainbow module: add format, by @lasers
* scratchpad_async: use post_config_hook, by @lasers
* selinux module: fix exception, remove hardcoded strings, by @lasers
* spaceapi module: add format by @lasers
* sysdata module: avoid dividing by 0, by @guiniol
* taskwarrior module: use helpers, by @lasers
* taskwarrior: fix potential exceptions, by @lasers
* tor_rate: use post_config_hook, by @lasers
* twitch_streaming: use post_config_hook, by @lasers
* vnstat module: use helpers, add exception, cleanup, by @lasers
* volume_status: bugfix for pactl on debian systems, by @DextersHub
* vpn_status: use post_config_hook, by @lasers
* whatismyip module: support any format placeholder, always use `url_geo` with a better default, by @maximbaz
* whatismyip module: expected support and cleanups by @maximbaz
* wifi module: fix device autodetection magic, by @lasers
* wifi module: remove command_checks(iw), by @lasers
* wifi module: support unicode wifi SSID, by @blahgeek
* wifi module: use helpers, fix exception, by @lasers
* window_title: cleanup, by @lasers
* window_title_async module: do not treat workspace name as window name, by @valdur55
* window_title_async module: use post_config_hook, by @lasers
* xrandr module: add option to hide output if only one combination is available, by @maximbaz
* xrandr_rotate module: use post_config_hook, by @lasers
* xsel module: add format, by @lasers
* yandexdisk_status module: use helpers, remove hardcoded strings, fix exception, by @lasers

version 3.4 (2017-01-26)
* fix python2 unicode use in i3status time modules, by @tobes
* fix python3.6 travis CI, by @tobes
* cache format string tokens to reduce work done, by @tobes
* formatter: new not_zero format command, by @tobes
* simplify the descriptions for all modules, by @lasers
* new do_not_disturb module to toggle notifications, by @maximbaz
* new rss_aggregator module to display your unread feed items, by @raspbeguy
* arch_updates module: add hide_if_zero option, by @lasers
* arch_updates module: multiple fixes, by @tobes
* backlight module: fix crash when monitor doesn't support backlight change, by @laxd
* battery_level module: fix crash when running on a machine with no battery, by @laxd
* battery_level module: prevent logic issues when zero, by @tobes
* battery_level module: support a different type of battery, by @bpinto
* clementine module: add format parameter, by @lasers
* dpms: add format parameter, by @lasers
* mpd_status module: fix max_width, by @lasers thanks to report by @girst
* mpris module: detect players starting after py3status, by @ritze
* net_rate module: add option to aggregate rate from all interfaces, by @guiniol
* netdata module: use next available nic, by @lasers
* online_status module: add deprecation warning, by @lasers
* online_status module: add format parameter, by @lasers
* player_control module: add format parameter, by @lasers
* rainbow module: add multi_color option, by @tobes
* scratchpad_async module: cleanup format parameter, by @lasers
* scratchpad_async: fix method names, by @lasers
* scratchpad_counter and window_title modules: remove i3-py dependencies, by @tobes
* scratchpad_counter module: add format parameter, by @lasers
* sysdata module: add swap support, by @valdur55
* sysdata module: cpu temp no zone bugfix, by @tobes
* sysdata module: deprecate precision and padding, by @guiniol
* sysdata module: use color 'bad' instead of 'high' as a default threshold, by @maximbaz
* taskwarrior module: add format parameter, by @lasers
* timer module: fix cache_timeout as reported by @lasers, by @tobes
* uname modume: add deprecation warning, by @lasers
* volume_status module: PactlBackend does not read user-specified device, by @vicyap
* whatismyip module: document format placeholder, by @lasers
* whatsmyip module: added geolocation support using ip-api.com, by @vicyap with original code from @neutronst4r
* whoami module: add deprecation warning, by @lasers
* whoami module: add format parameter, by @lasers
* whoami module: document format placeholder, by @lasers
* window_title and window_title_async modules: window without name will not crash py3status, by @valdur55
* window_title module: add format parameter, by @lasers
* window_title module: fix display of workspace number instead of empty window title, by @valdur55
* window_title_async module: fix method name, by @lasers
* xrandr module: update format parameter, by @lasers
* xsel: fix xsel, by @lasers

version 3.3 (2016-11-20)
* allow module output to be used in on_click commands, by @tobes
* py3 helper: add command_run and command_output methods, by @tobes
* py3 helper: add support for ranged thresholds to dynamically select the color output, by @tobes
* py3 helper: report better exceptions, by @tobes
* formatter now accepts per module coloring syntax on containers, by @tobes
* formatter and composite overall updates, refactoring, tests, by @tobes
* formatter add attr_getter option, by @tobes
* formatter: allow formatting numeric strings, by @tobes
* Allow updating of placeholder formatting of modules, by @tobes
* universal module config parameter deprecation feature, by @tobes
* disable modules if post-config_hook() raises Exception, by @tobes
* log py3status/python versions and git info on start, by @tobes
* fix multi-line default values support on docstrings, by @guiniol
* fix i3status time modules updating, by @tobes
* flake8 fixes and testing improvements, by @tobes
* add tuples support to doc checker, by @guiniol
* don't call updates on modules before they have been fully initialised, by @tobes
* module test: fix unicode error, by @tobes
* module test: check for alphabetical variable declaration and unicode semantics, by @tobes
* new clock module to display multiple times and dates informations in a flexible way, by @tobes
* new diskdata module to shows both usage data and IO data from disks, by @guiniol
* new net_iplist module to display interfaces and their IPv4 and IPv6 IP addresses, by @guiniol
* backlight module: allow changing brightness using mouse click events
* battery_level module: stability and bugfix, by @inclementweather
* battery_level module: fix on_click() method logic, by @m45t3r
* battery_level module: add measurement_mode parameter to check for battery using /sys, by @m45t3r
* exchange_rates module: cache value instead of reporting an error, by @tobes
* fedora_updates module: add check_security option, by @jakubjedelsky
* github module: open github home page if no repo is configured and you're getting all notifications, by @rixx
* glpi module: add cache_timeout and format parameters, by @pferate
* graphite module: add proxy parameter to allow usage of request's proxy feature, by @btall
* mpris module: fix AttributeError when click without a running player, by @ritze
* net_rate module: make compatible with formatter colors, by @guiniol
* ns_checker module: add format and cache_timeout, by @pferate
* rate_counter module: add format and majorly refactor code, by @pferate
* spaceapi module: go to a space's website onclick, by @rixx
* sysdata module: add dynamic memory unitn by @pferate
* sysdata module: add support for colors/thresholds, by @guiniol
* xrandr module: add rotation support, by @coxley
* volume_status module: add pulseaudio support, by @guiniol
* volume_status module: add pactl support, by @tobes
* vpn_status module: remove shebang, by @jakubjedelsky

version 3.2 (2016-10-11)
* NOTE: this is mainly a bugfix release
* fix safe format refactoring regressions, by Maxim Baz
* fix unicode escape sequences in config parsing, by @tobes
* fix module_test unicode issue, by @tobes
* fix module_test for post_config_hook staticmethods etc, by @tobes
* improve error report on missing default value, by @tobes
* run all post config hooks before starting any modules, by @tobes
* add defaults to docstrings, by @tobes
* container modules switch display to urgent modules' output, by @tobes
* update defaults for modules, by @tobes
* enhanced module testing, by @tobes
* docstring checking tests, by @tobes
* modules to use safe_format(), by @tobes
* battery_level module: fix hide_seconds when a user has two batteries, by Gabriel Féron
* bluetooth module: fix issue where duplicate bluetooth connections are shown, by Yuli Khodorkovskiy
* kdeconnector module: improvements, by Moritz Luedecke
* process_status module: allow process to accept full process name, by Yuli Khodorkovskiy

version 3.1 (2016-09-11)
* NOTE: the documentation is getting stronger, check it out to know more about the new features listed
* @tobes has become the first collaborator of the py3status project !
* i3status.conf file is read with a new parser which allows for richer objects eg lists to be used in config, better unicode support for python2 and better reporting to the user for errors in the config, by @tobes
* new format parser allows for rich and conditional format strings, by @tobes
* it is now possible to use obfuscation on all string module parameters, by @tobes
* colors are now configurable for all modules with dynamic naming, by @tobes
* modules now support a post_config_hook special method to allow fine setup, by @tobes
* click events and updates of modules refactoring, by @tobes
* CI updates for better testing of py3status
* fix: multiple enhancements on core performance and CPU reduction
* fix: tztime modules glitch
* fix: some crashes due to unicode logging
* fix: for when config-file happened to be a symbolic link, by @Stautob
* new module testing framework allowing feature rich standalone tests of modules, by @tobes
* new backlight module to display the current screen backlight level, by @tjaartvdwalt
* new coin_balance module to display balances of diverse crypto-currencies, by Felix Morgner
* new exchange_rate module to check for your favorite currency rates, by @tobes
* new file_status module to check the presence of a file, by @ritze
* new frame module to group and display multiple modules inline, by @tobes
* new gpmdp module for Google Play Music Desktop Player by @Spirotot
* new kdeconnector module to display information about Android devices, by @ritze
* new mpris module to control MPRIS enabled music players, by @ritze
* new process_status module to check the presence of a process, by @ritze
* new rainbow module to enlight your day, by @tobes
* new tcp_status module to check for a given TCP port on a host, by @ritze
* battery_level module: improved detection of active battery, by @ZeiP
* exchange_rate module: fix rate on singe currency, by Jan Mrázek
* volume_status module: now shows as color bad when muted, by @chezstov
* a lot of module fixes and normalization !

version 3.0 (2016-06-23)
* IMPORTANT NOTE: the changelog is so big that this is a condensed version, apologize for missing contribution reports
* split the monolithic code into proper modules, by Alexis 'Horgix' Chotard, @tobes and Daniel Foerster
* major improvements on modules output orchestration and output resulting in considerable CPU consumption reduction, by @tobes
* refactoring of user notifications with added dbus support and rate limiting, by @tobes
* refactoring of i3status.conf file generation, by @tobes
* improved modules error reporting, by @tobes
* py3status can now survive an i3status crash and will try to respawn it, by @tobes
* enhanced modules README formatting with CLI support, by @tobes
* countless of code cleanup and improvements, by @tobes
* implement a 'container' module output type to give the ability to group modules together, by @tobes
* implement a helper named 'py3' for modules to ease their development, by @tobes
* fix and refactoring of the time and tztime modules support, by @tobes
* some py3status modules using i3-ipc could crash i3 when the i3bar was hidden, py3status now requests i3bar to use SIGTSTP instead of SIGSTOP, by @tobes
* add min_width and align as universal module options, by johannes karoff
* add separator and separator_block_width as universal module options, by johannes karoff
* improved and normalized i3status and modules folder detection, by @tobes
* added module dosctrings sanity check and modules README generation from CLI, by @tobes
* qa: flake8 CI to 99 chars, by @tobes
* docs: added contribution guidlines, by Alexis 'Horgix' Chotard and @tobes
* docs: migrate over from the wiki to a proper doc/README.md, by @tobes and Daniel Foerster
* new group module to cycle display of several modules, by @tobes
* new fedora_updates module to check for your Fedora packages updates, by @tobes
* new github module to check a github repository and notifications, by @tobes
* new graphite module to check metrics from graphite
* new insync module to check your current insync status, by Joshua Pratt
* new timer module to have a simple countdown displayed, by @tobes
* new twitch_streaming module to check is a Twitch Streamer is online, by Alex Caswell
* new vpn_status module to check your VPN status, by Nathan Smith
* new xrandr_rotate module to rotate your screens, by Maxim Baz
* new yandexdisk_status module to display Yandex.Disk status, by Vladimir Potapev
* keyboard_layout module: enhanced by Themistokle Benetatos
* pomodoro module: now supports more options and still runs when the i3bar is hidden, by @tobes and @egeskow
* sysdata module: fix python3 compatibility, by Yongming Lai
* weather_yahoo module: remove deprecated city_code setting in favor of woeid, fixes #228
* wifi module: enhanced by @tobes

version 2.9 (2016-03-01)
* fix: handle format_time tztime parameter thx to @cornerman, fix issue #177
* fix: issue #166, by Daniel Foerster
* fix: respect ordering of the ipv6 i3status module even on empty configuration, fix #158 as reported by @nazco
* new arch_updates module, by Iain Tatch
* new deadbeef module to show current track playing, by Themistokle Benetatos
* new icinga2 module, by Ben Oswald
* new scratchpad_async module, by johannes karoff
* new wifi module, by Markus Weimar
* battery_level module: add multiple battery support, by 4iar
* battery_level module: added formatting options, by Alexandre Bonnetain
* battery_level module: added option hide_seconds, by Andrwe Lord Weber
* deadbeef module: fix permissions, remove execution mode, by Alexis 'Horgix' Chotard
* dpms module: added color support, by Andrwe Lord Weber
* spotify module: added format_down option, by Andrwe Lord Weber
* spotify module: fixed color & playbackstatus check, by Andrwe Lord Weber
* spotify module: workaround broken dbus, removed PlaybackStatus query, by christian
* weather_yahoo module: support woeid, add more configuration parameters, by Rail Aliiev
* implement flake8 check via travis-ci, by Rail Aliiev
* yapf formatting on core

version 2.8 (2016-01-03)
* new hamster module for Project Hamster, by Aaron Fields
* new selinux module, by Brian Stinson
* new wwan_status module, by Timo Kohorst
* battery_level module: Notify when battery is running low, by Maxim Baz
* pomodoro module: add pyglet support for sound notifications, by Mateusz Probachta (Beetleman)
* pomodoro module: eliminate intrusive log messages, by Alexandre Bonnetain
* taskwarrior module: fix parsing of taskWarrior's output, by Alexandre Bonnetain
* xrandr module: added missing "above" and "below" positioning options, by brianecker

version 2.7 (2015-11-11)
* major performance and click event detection improvements by Daniel Foerster
* fix poll() calls to convert from seconds, by Daniel Foerster
* fix: directive %Z and any other failure in parsing the time and tztime modules format will result in using i3status date output
* fix: support of %z on time and tztime modules fixes #110 and #123 thx to @derekdreery and @olhotak
* fix ethernet, wireless and battery _first_ instance detection. thx to @rekoil for reporting
* i3status.conf writer lower case boolean values
* i3status.conf parser handles configuration values with the = char
* new rt module: display ongoing tickets from RT queues
* new xsel module: display xsel buffers, by umbsublime
* new window_title_async module, by Anon1234
* battery_level module: major improvements, documentation, add format option, by Maxim Baz
* keyboard_layout module: color customisation, add format option, by Ali Mousavi
* mpd_status module: fix connection leak, by Thomas Sanchez
* pomodoro module: implement format option and add additional display features, by Christoph Schober
* spotify module: fix support for new versions, by Jimmy Garpehäll
* spotify module: add support for colors output based on the playback status, by Sondre Lefsaker
* sysdata module: trim spaces in `cpu_temp`, by beetleman
* whatismyip module: change default check URL and make it configurable

version 2.6 (2015-08-27)
* fix: overall site-packages and user modules detection thx to @coelebs
* fix: add back support for old school modules wrt issue #117
* qa: cleanup obsolete position handling and validation
* new uname module inspired by @ndalliard
* mpd_status: minor bugfix on error handling, use divmod, pep8-style fixes, by Alexandre `Zopieux` Macabies

version 2.5 (2015-08-17)
* IMPORTANT NOTE: the legacy modules loading and ordering has been deprecated
* drop old modules loading mechanism for version 2.5
* new aws_bill module, by Anthony Brodard
* new dropboxd_status module, by Tjaart van der Walt
* new external_script module, by Dominik
* new nvidia_temp module for displaying NVIDIA GPUs' temperature, by J.M. Dana
* new rate_counter module, by Amaury Brisou
* new screenshot module, by Amaury Brisou
* new static_string module, by Dominik
* new taskwarrior module, by James Smith
* new volume_status module, by Jan T.
* new whatismyip module displaying your public/external IP as well as your online status
* dpms module: add format string support and add some options, by Kenneth Watson
* dpms module: external processes might change DPMS so the module should check in the main loop, by J.M. Dana
* example_module: fix standalone testing thanks to @frimdo issue #103
* imap module: fix empty color that made text invisible on i3bar when no unread email, by Alexis 'Horgix' Chotard
* imap module: switch to support format option
* keyboard_layout module: add missing cache_timeout parameter in the docstring
* mpd_status module: add coloring output based on state
* mpd_status: mpc-like templating to remove format_fallback, by Alexandre `Zopieux` Macabies
* netdata module: fix wrong nic default thx to @h8h on issue #111
* pingdom module: update by Eric Masser
* pomodoro: fix display_bar in python3, by Manuel Mendez
* sysdata module: add format string support, refactor and cleanup, by shrimpza
* whatismyip module: add a negative cache timeout for quicker check when offline
* add optional setproctitle, by Federico Ceratto
* fix i3status config file generation thx to @hlmtre some i3status modules have no default configuration
* fix sysdata used RAM detection wrt issue #94 reported by @habash1986
* fix typos in keyboard_layout module, by Jan T
* implement thread profiling, by Federico Ceratto
* update README with dropboxd_status docstring

version 2.4 (2015-03-31)
* IMPORTANT NOTE: this is the last version of py3status supporting the legacy modules loading and ordering, this behavior will be dropped on the next 2.5 version !
* add CLI support for module listing, by Federico Ceratto
* catch daylight savings time change, fix issue #75 thx to @Gamonics
* fix issue #64, ensure modules methods are always iterated alphabetically thx to @shankargopal
* refactor default config file detection, by Federico Ceratto
* rename and move the empty_class example module to the doc/ folder
* improve documentation in the example module, by Federico Ceratto
* add note for Debian users installation using pip wrt issue #61
* remove obsolete i3bar_click_events module
* new online_status module by @obb
* new bluetooth module by J.M. Dana
* new player_control module, by Federico Ceratto
* new spotify module, by Pierre Guilbert
* new xrandr module to handle your screens layout from your bar
* add VLC support to player_control module by @rixx
* dpms module activate/deactivate the screensaver as well by J.M. Dana
* imap module allows choice of color for unread mails, by rixx
* imap module allows choosing to hide the mail status if no unseen mails exist, by rixx
* imap module unread mail string is now fully configurable (format string), by rixx
* imap module may now check several IMAP folders, by rixx
* imap module only shows name if there are unread emails, by rixx
* pomodoro module: add sound support, by Federico Ceratto
* pomodoro module: sort configuration parameters, by Federico Ceratto
* pomodoro module: disable progress bar by default, by Federico Ceratto
* pomodoro module: make progress bar configurable, by Federico Ceratto
* pomodoro module: display time as a progress bar, by Federico Ceratto
* pomodoro module: play sounds before nagging the user., by Federico Ceratto
* pomodoro module: left click can now pause and resume a Pomodoro, by rixx
* fix spaceapi module for Space APIs without 'lastchange' field, by rixx
* fix how xrandr module retrieves the layout with polling for hardware changes, by THEBAULT Julien
* fix and cleanup netdata module as reported by @obb
* fix keyboard_layout module incorrect parsing of "setxkbmap -query", by J.M. Dana
* added better python3 compatibility for battery_level module by Thomas
* added a small debugging output when directly calling battery_level.py by Thomas
* QA on all modules docstrings for a clean CLI parsing
* remove useless 'position' from debug logs
* drop python2.5 from classifiers

version 2.3 (2015-02-17)
* refactor the main loop for instant i3bar update on module or i3status output change wrt issue #59, handle correctly all and multiple time and tztime instances while updating them only on py3status interval thx to @protosphere and @abello
* clear cache of user modules on click events by default for maximal i3bar responsiveness
* fix issue #63 wrt SIGUSR1 spam error, cap it to 1 per 100ms anyway to avoid killing i3status thx to @abello
* lower the click event refresh mechanism rate limit to 100ms
* remove legacy module ordering spammy debug logs
* new spaceapi module, by Timm Szigat
* new module bitcoin-price-checker, by André Doser
* fix typo in imap module thx to @tasse
* fix i3status setup race condition reported by @tasse
* fix time adjustement for short iteration timers thx to @guilbep

version 2.2 (2015-01-23)
* rewrite and cleanup the modules loading mechanism to handle correctly user provided modules instances wrt #57 thx to @wlcx and @Zopieux
* fix module name parsing thx to @guiniol
* fix python3 default i3status.conf file path detection
* fix i3status.conf parsing of one-liner configurations
* support time/tztime definitions with extra parts in the section name, by Jyri-Petteri Paloposki
* add more user configurable params to the pomodoro module wrt issue #53 thx to @promaq
* add possibility to color mpd_status, by Thomas Sanchez
* update get_user_modules docstring
* add debug log of user provided modules
* better format module loading error messages

version 2.1 (2015-01-09)
* fix i3status.conf parsing when config parameters contains brackets wrt issue #51 thx to @ZeiP
* fix NamedTemporaryFile file delete throwing an OSError as we clean it up ourselves to be compatible with all python versions

version 2.0 (2015-01-04)
* two main highlights, see the wiki for more details :
* 1- you can now load, run and order ALL (i3status and py3status) modules from your usual i3status.conf
* 2- you can handle click events on ALL modules (i3status and py3status) directly from your usual i3status.conf thanks to the new on_click parameter
* all modules have been changed to match v2 return dict, QA, config and standalone test code
* implement full i3status.conf parsing wrt issue #44 thx to @tablet-mode
* generate and use a temporary i3status config on the fly so that we can now extend it with our own modules without breaking i3status
* move modules folder so we can install it as a module of py3status, all modules are now importable
* handle loading, running and ordering of py3status modules directly configured from i3status.conf
* user provided modules win over py3status importable modules
* add handling of a special on_click parameter in i3status.conf allowing to send i3 messages and execute special py3status actions
* implement an i3status module name and instance guesser in the event thread to dispatch click events from i3status modules
* make sure every py3status command line parameter gets a short and long flag
* new imap mail checker module by @obb
* add installation instructions for Fedora, by Jakub Jedelsky
* backport code for issue #43 thx to @scotte
* enhanced battery_level module with horizontal bar and click event thx to @AdamBSteele wrt issue #48 and #49
* make i3-nagbar messages non blocking to py3status
* cleaner debug logs
* update README with new wiki links and new capabilities explanations
* update the i3wm.org documentation

version 1.6 (2014-10-07)
* new vnstat module, by Vasiliy Horbachenko
* new net_rate module, alternative module for tracking network rate, by Vasiliy Horbachenko
* Fix include_paths default wrt issue #38, by Frank Haun
* module clementine.py: Make python3 compatible, by Frank Haun
* Update sysdata.py module, by @fhaun
* rename the 'examples' folder to 'modules'
* add an information note in the keyboard module
* normalize the CACHE_TIMEOUT variable name
* PEP8 and cleanup of scratchpad-counter module
* PEP8 and normalization of mpd_status module
* PEP8 and rename the current-title to window-title, normalization
* switch french color to solarized blue on keyboard-layout module
* rename current-keyboard-layout to keyboard-layout, PEP8 cleanup, implement check using setxkbmap for maximal compatibility, add french coloring
* add optional CPU temperature to the sysdata module, by Rayeshman
* new mpd_status module, by Vasiliy Horbachenko
* add pypip badge for version
* new scratchpad-counter module and current-title module for displaying current windows title, by Vasiliy Horbachenko
* fix netdata module to work with python3 wrt issue #31
* new clementine module displaying the current "artist - title" playing in Clementine, by François LASSERRE

version 1.5 (2014-05-03)
* add --version parameter wrt issue #29
* switch back to RST for the README wrt pypi and issue #30 thx to @Weishaupt
* include modules, changelog and license to sources on pypi
* rename the examples folder to modules and include it in the installed files

version 1.4 (2014-04-16)
* new ordering mechanism with verbose logging. fixes rare cases where the modules methods were not always loaded in the same order and caused inconsistent ordering between reloads. thx to @guiniol for reporting/debugging and @IotaSpencer and @tasse for testing.
* debug: dont catch print() on debug mode
* debug: add position requested by modules
* Add new module ns_checker.py, by @nawadanp
* move README to markdown, change ordering
* update the README with the new options from --help

version 1.3 (2014-02-23)
* new standalone mode allowing to bypass i3status when you need a py3status-modules-only i3bar
* debug mode add log info about py3status invocation config
* pep8 cosmetics
* python3 compatibility code wrt issue #24
* make sure i3status_time encoding is UTF-8 wrt issue #24, thx to @zetok

version 1.2 (2014-01-12)
* new module dpms.py allowing activation and deactivation of DPMS thx to André Doser
* order i3status output updates to prevent it from overwritting any modification made on i3status json list by a user module, this avoids a possible user filter flapping on i3status modules
* fix delay on first execution of each module which could be equal to py3status interval time before being executed
* the real i3status thread output json list is passed to all modules as the i3status_output_json parameter, this allows any user module to change any of the i3status output by simply altering the given json on the list, inspired thx to @drestebon on issue #23
* add validation for the position parameter
* make cpu status cached for 10s and leave the output index to 0, by Patrick Shan
* add cpu usage info to sysdata script, by Patrick Shan

version 1.1 (2013-12-15)
* new generic click event handler using the special module file named i3bar_click_events.py which will be forwarded any orphan click event for action. this allows you to take action on clicks made on your i3status modules !
* add the filename as the module_name property to the Module class
* drop useless modes on examples
* new example whoami displaying the currently logged in user
* be more concrete in the i3status.conf example
* add IRC information, join us on #py3status on freenode to share your ideas or ask for help
* redirect stdout and stderr to null to suppress modules outputs, this prevents i3bar from frezzing when a user module prints something to stdout or stderr wrt issue #20
* use base stdout for the output on i3bar
* fix first event opening line wrt issue #19 thx to @lathan
* fix delay on py3status start waiting for i3status, this caused a useless first refresh delay of py3status of i3status interval seconds, thx to @Edholm on issue #18
* fix i3status time adjustment when format does not contain the necessary items to get an exact datetime wrt issue #18
* fix respect user's locale for time transformation, thx to @Edholm on issue #18
* new example module displaying Yahoo Weather forcast
* Float update-time option, by Tom Hunt

version 1.0 (2013-08-30)
* total rewrite (yes, again)
* support for i3bar click_events, they're dispatched to user-written py3status classes based on their name/instance
* add support for on_click methods in user-written modules to handle i3bar click_events (see the pomodoro example)
* default is to clear the method's cache (force a refresh) if you middle click (button 2) on a method's output and the module does not support click_events
* rewrite pomodoro example to showcase the on_click usage
* use i3-nagbar to display warnings/errors to the user and also log them to syslog
* new user-written module output ordering mechanism is more intuitive as it uses strictly numeric then alphabetical sorting
* use select/poll() to implement a non-blocking I/O reading mechanism on threads
* new Events thread is responsible for reading i3bar JSONs and dispatching them to the correct user module (click_events)
* each user-written module is started and executed in its own thread
* remove the pointless -d option
* add a --debug option to be verbose in syslog (useful for debugging your modules)
* add a real CHANGELOG
* add a proper LICENSE file
* make sure all examples are PEP8 compatible
* update the empty_class example to explain on_click and kill usage

version 0.13 (2013-06-24)
* fix instancemethod detection wrt issue #11 thx to @lathan and @bloodred, inspired by pull request #12 by @drahier
* add information about method execution in the empty_class example

version 0.12 (2013-06-19)
* update the readme and help
* dont call private and special methods on Py3status classes
* handle multiple include paths parameters
* dont die on IOError upon suspend wrt issue #10 thx to @drahier
* Three new method added. (net_speed, traffic, ram_info), by Shahin Azad

version 0.11 (2013-04-30)
* fix UserModules.clear(), by Ed Kellett
* fix i3status config reader tztime detection

version 0.10 (2013-04-19)
* fix setup for pypi
* fix issue #5 thx to @drahier for reporting
* fix README wiki URL
* stupid rst
* update the README for rst, better MANIFEST
* add MANIFEST.in and switch README.rst for pypi

version 0.9 (2013-04-17)
* respect positions on injected classes outputs
* update readme for pypi installation
* drop invalid classifier for pypi
* set default i3status colors
* pingdom module dont need to be aggressive on timeout anymore, add POSITION parameter
* glpi module dont need to be aggressive on timeout anymore, add POSITION parameter
* enhanced self key binding pomodoro example as discussed with Fandekasp
* Handle killing of user-written modules nicely by calling their kill method if implemented upon exit of py3status, ignore kill methods execution when running normally
* handle case log file does not exists, by Adrien Lemaire
* plugin now working with keys to start/stop/pause, by Adrien Lemaire
* reading log file for value. Do I really need watchdog ?, by Adrien Lemaire
* define watchdog values to listen, and their action, by Adrien Lemaire
* separate code in send_notification method, by Adrien Lemaire
* adding new pomodoro plugin, by Adrien Lemaire
* drop useless print

version 0.8 (2013-04-08)
* major rewrite
* handle SIGUSR1 for new threaded modules execution, drop useless globals
* load user defined modules from a separate thread so that they cannot cause any delay in updating the i3bar
* PEP8 identation and python3 compatible examples
* adjust the readme help
* major cleanup, better threading of i3status, enhanced main logic for better responsiveness, drop useless variables, respect PEP8 identation, more PEP8 variable cleanup

version 0.7 thanks to @Detegr (2013-04-06)
* add a note on the Control section
* only adjust sleep interval if i3status interval is greater than ours
* add Pingdom checks latency example module

version 0.6 (2013-03-25)
* fix time transformation thx to Lujeni
* specify default folder for user defined classes
* clear the user class cache when receiving SIGUSR1

version 0.5 (2013-03-17)
* add the Control section, cleanup install instructions
* signal SIGUSR1 forces i3status and i3bar refresh, feature request by Michael Schaefer, add better comments

version 0.4 (2013-03-15)
* dont fail if i3status output comes slower than py3status message polling interval
* iterate over user classes in a sorted manner to allow a predictive ordering of outputs
* add Arch installation URL on the README thx to waaaaargh
* python3 compatibility inspired by waaaaargh (Johannes Firlefanz)
* add GLPI open tickets counter module example



================================================
FILE: LICENSE
================================================
Copyright (c) 2013-2015 Ultrabug and contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.

    * Neither the name of Ultrabug nor the
      names of contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.



================================================
FILE: Makefile
================================================
qa:
	hatch run style:format
	hatch run style:check

clean:
	hatch clean

release: clean qa test build
	hatch publish -u __token__

serve:
	mkdocs serve

build:
	hatch build

# TODO: maybe move the docs to github
#deploy: qa test
#	mkdocs gh-deploy

test:
	hatch run all



================================================
FILE: MANIFEST.in
================================================
recursive-include py3status *.py
recursive-include tests *.py
recursive-include doc *.rst *.md *.txt *.py

include CHANGELOG
include LICENSE
include README.md



================================================
FILE: mkdocs.yml
================================================
site_name: Py3status Documentation
site_url: https://ultrabug.github.io/py3status
repo_url: https://github.com/ultrabug/py3status

copyright: Copyright © 2021-2023 Alexys Jacob

theme:
  name: material
  font:
    text: Ubuntu
    code: Ubuntu Mono
  logo: assets/logomark.png
  favicon: assets/favicon.ico
  palette:
    primary: black
  features:
    - navigation.expand
    - navigation.indexes
    - navigation.sections
    - navigation.tabs
    - toc.follow
    - toc.integrate

extra:
  social:
    - icon: fontawesome/brands/github
      link: https://github.com/ultrabug/py3status
      name: py3status on Github

markdown_extensions:
  - admonition

plugins:
  - search

hooks:
  - py3status/autodoc.py

nav:
  - Introduction: index.md
  - Getting Started: getting-started.md
  - User Guide:
    - Installation: user-guide/installation.md
    - Configuration: user-guide/configuration.md
    - Available Modules: user-guide/modules.md
    - Controlling Py3status Remotely: user-guide/remote-control.md
    - User Configuration Examples: user-guide/user-contributed-conf-examples.md
  - Developer Guide:
    - Writing Py3status Modules: dev-guide/writing-modules.md
    - The Py3 Module Helper: dev-guide/the-py3-helper.md
    - Contributing to Py3status: dev-guide/contributing.md



================================================
FILE: pyproject.toml
================================================
[build-system]
requires = ["hatchling>=1.26.1"]
build-backend = "hatchling.build"

[project]
name = "py3status"
dynamic = ["version"]
description = "py3status: an extensible i3status wrapper written in python"
readme = "README.md"
license = "BSD-2-Clause"
requires-python = ">=3.9"
authors = [
    { name = "Ultrabug", email = "ultrabug@ultrabug.net" },
]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Environment :: Console",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: BSD License",
    "Operating System :: POSIX :: Linux",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Programming Language :: Python :: Implementation :: CPython",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
dependencies = [
    "setuptools; python_version >= '3.12'"
]

[project.optional-dependencies]
dbus = [
    "dbus-python==1.3.2",
    "PyGObject==3.46.0",
]
udev = ["pyudev >= 0.21.0"]

[project.urls]
Download = "https://github.com/ultrabug/py3status/tags"
Homepage = "https://github.com/ultrabug/py3status"

[project.scripts]
py3status = "py3status:main"
py3-cmd = "py3status.command:send_command"

[tool.hatch.version]
path = "py3status/version.py"

[tool.hatch.build.targets.sdist]
include = [
    "/py3status",
]

[tool.hatch.envs.default.scripts]
all = [
    "hatch run test:test",
    "hatch run style:check",
]

[tool.hatch.envs.test]
dependencies = [
    "pytest"
]

[tool.hatch.envs.test.scripts]
test = [
    "pytest -xs",
]

[[tool.hatch.envs.test.matrix]]
python = ["py39", "py310", "py311", "py312", "py313"]
type = ["default"]

[tool.hatch.envs.style]
detached = true
dependencies = [
    "black",
    "isort",
    "ruff",
]

[tool.hatch.envs.style.scripts]
check = [
    "isort --check-only --diff py3status",
    "black -q --check --diff py3status",
    "ruff check py3status",
]
format = [
    "isort -q py3status",
    "black -q py3status",
]

[tool.black]
line-length = 100
target-version = ["py312"]
skip-string-normalization = true

[tool.isort]
profile = "black"
line_length = 100

[tool.ruff]
line-length = 100
ignore = ["E501"]

[tool.hatch.envs.docs]
dependencies = [
    "mkdocs-material>=9.4.5",
    "Pillow>=3.4.2",
    "fonttools==4.24.4",
]


================================================
FILE: setup.py
================================================
"""Installation using setup.py is no longer supported.
Use `python -m pip install .` instead."""

import sys

from setuptools import setup

sys.exit(__doc__)

# Fake reference so GitHub still considers it a real package for statistics purposes.
setup(
    name="py3status",
)



================================================
FILE: contrib/py3status.html
================================================
---
layout: default
title: Docs
group: Docs
---
<div id="content" class="usergen">
<h1>User-contributed article: enhanced and extensible i3bar with py3status</h1>

<p>
In the i3 documentation, the recommended tool for <a
href="https://i3wm.org/docs/userguide.html#_displaying_a_status_line">displaying
a status line is to use i3status</a> combined with i3bar.
</p>

<p>
While i3status is very efficient at what it does, it is, by design, fairly
limited to a few modules and file output which does not give the flexibility to
users to easily add anything they want to their bar.
</p>

<p>
This is said pretty clearly on the i3status man page:
</p>
<pre><tt>*EXTERNAL SCRIPTS/PROGRAMS WITH I3STATUS

    In i3status, we don’t want to implement process management again.
    Therefore, there is no module to run arbitrary scripts or commands.
    Instead, you should use your shell.
</tt></pre>

<h2>Introducing py3status</h2>

<p>
The goal of py3status is to fill this gap by allowing users to simply extend
their i3bar <b>while preserving their current i3status configuration</b>.
The main idea is to rely on i3status' strength without adding any configuration
on the user's side. py3status is thus a wrapper script for i3status and its
configuration as explained in the documentation below.
This should be said that py3status is much more than just a wrapper script.
</p>

<h2>Documentation</h2>

<p>View the full documentation now or bookmark it for later viewing:</p>
<ul>
<li>
    <a href="https://ultrabug.github.io/py3status">py3status Documentation</a>
</li>
<li>
    <a href="https://github.com/ultrabug/py3status">Github</a>
</li>
</ul>

<h2>Using py3status</h2>

<p>Using py3status has never been so easy. Update your i3 config with this and
you're done:</p>
<pre><tt>
bar {
    status_command py3status
}
</tt></pre>

<p>
In other words, just replace <i>i3status</i> in your current
<b>status_command</b> by <i>py3status</i>.
</p>

<p>Py3status will look for status config file in this order.</p>
<pre><tt>
1    ~/.config/py3status/config
2    ~/.config/i3status/config
3    ~/.config/i3/i3status.conf
4    ~/.i3status.conf
5    ~/.i3/i3status.conf
6    /etc/xdg/i3status/config
7    /etc/i3status.conf
</tt></pre>

<p>Alternatively, you can start from scratch with an empty status config.</p>
<pre><tt>
bar {
    status_command py3status -c ~/.config/py3status/config
}
</tt></pre>

<p>Learn more about how to configure py3status on the
<a href="https://ultrabug.github.io/py3status/user-guide/configuration">
configuration documentation</a>
</p>

<h2>Using py3status modules</h2>

<p>Like i3status, py3status comes with modules (but a lot of them!).</p>
<p>Learn more about the modules provided by py3status on the
<a href="https://ultrabug.github.io/py3status/user-guide/modules">modules
documentation</a>
</p>

<p>
Like i3status, we can add and configure the modules the same way... usually in
the status config.</p>

<p>An excerpt from <span class="box">man 1 i3status</span>.</p>
<pre><tt>CONFIGURATION

    The basic idea of i3status is that you can specify which "modules" should be
    used (the order directive).
    You can then configure each module with its own section. For every module,
    you can specify the output format.
</tt></pre>

<p>A skeleton reference.</p>
<pre><tt>
order += "module_name"
module_name {
    config_name = "..."
}
</tt></pre>

<p>An example of using <span class="box">imap</span> module.</p>
<pre><tt>
order += "battery 0"
order += "disk /"
order += "imap"    <----
order += "time"
</tt></pre>
<pre><tt>
# add imap settings and open xterm with mutt on left-click
imap {
    user = "alex"
    password = "ilovebugs"
    port = "993"
    server = "imap.mybugprovider.com"

    on_click 1 = "exec xterm -e mutt"
}
</tt></pre>

<h2>Clicking the modules</h2>

<p>
Starting with <span class="box">version 2.0</span>, py3status allows the mouse
click events from the modules to be bound as options in the status config where
the users can configure what to do when they received the click events.
</p>
<p>It is possible to run commands, scripts, or programs with a click.</p>
<p>You can place the configuration parameter
<span class="box">on_click [button number] = "[command]"</span> in the module
section.

Py3status will run the <span class="box">command</span> using
<span class="box">i3-msg</span> when the module's click event matches the
configured module section's click <span class="box">event</span>.</p>

<p>Quick reference:</p>
<pre><tt>
on_click [button number] = "[command]"
on_click 1 = "exec firefox"    ---->    i3-msg "exec firefox"
</tt></pre>

<p>Click events buttons reference:</p>
<pre><tt>
1 left button
2 middle button
3 right button
4 up scroll
5 down scroll
</tt></pre>

<p>Examples of using <span class="box">on_click</span> config:</p>
<pre><tt>
# reload i3 on left-click
# restart i3 on middle-click
time {
    on_click 1 = "reload"
    on_click 2 = "restart"
}

# open wicd-gtk on left-click
# kill wicd-gtk on right-click
ethernet eth0 {
    on_click 1 = "exec wicd-gtk"
    on_click 3 = "exec killall wicd-gtk"
}

# open thunar on left-click
disk {
    on_click 1 = "exec thunar"
}

# open firefox with an URL on left-click
weather_yahoo paris {
    on_click 1 = "exec firefox http://www.my-favorite-weather-site.com/
}
</tt></pre>

<h2>Grouping the modules</h2>

<p>
The <span class="box">group</span> module allows you to group several modules
together to save space. Only one of the them will be displayed at a time.
</p>
<p>
The modules of a <span class="box">group</span> can either be cycled through
automatically or by user action (mouse scroll by default).
</p>

<p>An example of using the <span class="box">group</span> module with 3
different <span class="box">tztime</span> modules:</p>
<pre><tt>
order += "group tz"

# cycle through different timezone hours every 10s
group tz {
    cycle = 10
    format = "{output}"

    tztime la {
        format = "LA %H:%M"
        timezone = "America/Los_Angeles"
    }

    tztime ny {
        format = "NY %H:%M"
        timezone = "America/New_York"
    }

    tztime du {
        format = "DU %H:%M"
        timezone = "Asia/Dubai"
    }
}
</tt></pre>

<h2>Writing new modules for py3status</h2>

<ul>
<li>py3status utilizes an easy-to-use and straightforward system for its
modules.</li>
<li>py3status contains an excellent set of useful functions to make writing
things easier.</li>
<li>py3status continues to grow healthy with well written documentation on the
modules, on the functions and parameters, on making new modules, and many more.
</li>
</ul>

<p>Learn how to
<a href="https://ultrabug.github.io/py3status/dev-guide/writing-modules/">write
(and contribute please!) your own modules!</a></p>


</div>



================================================
FILE: docs/getting-started.md
================================================
# Getting Started

[Install py3status](user-guide/installation.md) then in your i3 config file,
simply **switch from `i3status` to `py3status`** in your `status_command`
option:

```
status_command py3status
```

Usually you have your own i3status configuration, just point to it:

``` 
status_command py3status -c ~/.config/i3status/config
```

## Check out all the available modules

You can get a list with short descriptions of all available modules by
using the CLI:

```bash
$ py3-cmd list --all
```

To get more details about all available modules and their configuration,
use:

```bash
$ py3-cmd list --all --full
```

All modules shipped with py3status are present as the Python source
files in the `py3status/modules` directory.

## Adding, ordering and configuring modules

Check out the [py3status user configuration guide](user-guide/configuration.md)
to learn how to add, order and configure modules!

## Py3status options

You can see the help of py3status by issuing `py3status --help`:

```bash
$ py3status --help

usage: py3status [-h] [-b] [-c FILE] [-d] [-g] [-i PATH] [-l FILE] [-s]
                 [-t INT] [-m] [-u PATH] [-v] [--wm WINDOW_MANAGER]

The agile, python-powered, i3status wrapper

optional arguments:
  -h, --help            show this help message and exit
  -b, --dbus-notify     send notifications via dbus instead of i3-nagbar
                        (default: False)
  -c, --config FILE     load config (default: /home/alexys/.i3/i3status.conf)
  -d, --debug           enable debug logging in syslog and --log-file
                        (default: False)
  -i, --include PATH    append additional user-defined module paths (default:
                        None)
  -l, --log-file FILE   enable logging to FILE (default: None)
  -s, --standalone      run py3status without i3status (default: False)
  -t, --timeout INT     default module cache timeout in seconds (default: 60)
  -m, --disable-click-events
                        disable all click events (default: False)
  -u, --i3status PATH   specify i3status path (default: /usr/bin/i3status)
  -v, --version         show py3status version and exit (default: False)
  --wm WINDOW_MANAGER   specify window manager i3 or sway (default: i3)
```

## Going further

Py3status is very open and flexible, check out the complete user guide to get
more intimate with it:

- [user configuration guide](user-guide/configuration.md)
- [available modules and options](user-guide/modules.md)
- [remote controlling py3status](user-guide/remote-control.md)



================================================
FILE: docs/index.md
================================================
# Introduction

Using py3status, you can take control of your i3bar easily by:

- using one of the available modules shipped with py3status
- grouping multiple modules and automatically or manually cycle their display
- writing your own modules and have their output displayed on your bar
- handling click events on your i3bar and play with them in no time
- seeing your clock tick every second whatever your i3status interval

No extra configuration file needed, just install & enjoy!

## About

You will love py3status if you're using [i3wm](https://i3wm.org) (or
[sway](https://swaywm.org)) and are frustrated by the i3status
limitations on your i3bar such as:

- you cannot hack into it easily
- you want more than the built-in modules and their limited configuration
- you cannot pipe the result of one of more scripts or commands in your bar easily

## Philosophy

- no added configuration file, use the standard i3status.conf
- rely on i3status' strengths and its existing configuration as much as possible
- be extensible, it must be easy for users to add their own
  stuff/output by writing a simple python class which will be loaded
  and executed dynamically - easily allow interactivity with the i3bar
- add some built-in enhancement/transformation of basic i3status modules output
- support Python 3

We apply the zen to improve this project and encourage everyone to read it!

## Need help?

Get help, share ideas or feedback, join community, report bugs, or
others, see:

### GitHub

- [Issues](https://github.com/ultrabug/py3status/issues) /
- [Pull requests](https://github.com/ultrabug/py3status/pulls)

### Live IRC Chat

Join us on \#py3status at [oftc.net](https://www.oftc.net)



================================================
FILE: docs/dev-guide/contributing.md
================================================
# Developing and Contributing

Contributions to py3status including documentation, the core code, or
for new or existing modules are very welcome.

Please read carefully the zen describing the minimal things to keep in
mind when contributing or participating to this project.

Feel free to open an issue to propose your ideas as request for comments
[RFC] and to join us on IRC OFTC \#py3status channel for a live chat.

To make a contribution please create a [pull request](https://github.com/ultrabug/py3status/pulls).

Any functional change should be done via pull requests, even by people
with push access.

Each PR requires at least one approval from project maintainers before a
PR can be merged.

## Zen of py3status

### efficient and simple defaults

> We like py3status because it's a drop-in replacement of i3status. i3
> users don't expect fancy and magical things, they use i3 because it's
> simple and efficient. Keep configuration options and default formats
> as simple as possible

### it's not because you can that you should

> On modules, expose things that you WILL use, not things that you COULD
> use. On core, make features and options as seamless as possible (lazy
> loading) with sane defaults and no mandatory requirements.

### good enough is good enough

> Strive for and accept "good enough" features / proposals. We shall
> refrain from refining indefinitely.

### one feature/idea at a time

> Trust and foster iteration with your peers by refraining from
> digressions. Keep discussions focused on the initial topic and easy to
> get into. Proposals should not contain multiple features or
> corrections at once.

### modules are responsible for user information and interactions

> That is what's written in the bar and its behavior on clicks etc.

### core is responsible for user experience

> Core features and configuration options should focus on user
> experience. Things that are related to the general output of the bar
> are handled by core. Smart things overlaying modules (such as
> standardized options) should also end up in the core.

### rely on i3status color scheme

> No fancy colors by default, only i3status good/degraded/bad. If we
> want to provide enhanced coloring, this should be through a core
> feature such as thresholds.

### rely on the i3bar protocol

> what's possible with it, we should support and offer.

## What you will need

- python3
- i3status:
    - <https://i3wm.org/i3status/>
    - <https://github.com/i3/i3status>

- pytest pytest-flake8:
    - <https://pypi.python.org/pypi/pytest>
    - <https://pypi.python.org/pypi/pytest-flake8>

- black:
    - <https://pypi.org/project/black/>

- tox:
    - <https://pypi.org/project/tox/>

## Setting up a development environment

First clone the git repository

```bash
# using https
$ git clone https://github.com/ultrabug/py3status.git

# using ssh (needs github account)
$ git clone git@github.com:ultrabug/py3status.git
```

Run setup.py to install

```bash
# cd to the directory containing setup.py
$ cd py3status

# install you may need to use sudo to have required permissions
$ pip install -e .
```

you can now run py3status and any changes to the code you make will be
available after a reload.

!!! note
    py3status will only be installed for the version of python that you used
    to run `setup.py`.

    If you wish to have multiple versions available. First run
    `setup.py develop` using the required python versions. Next copy the
    executable eg `sudo cp /usr/bin/py3status /usr/bin/py3status2` Then
    edit the hashbang to point to your chosen python version.

## Python versions

Starting with version 3.26, py3status will only run using python 3.

## Documentation

Documentation pages are located under the docs/ folder.

To run the documentation site locally (useful for previewing changes), use:

```bash
# you need to install hatch
# pip install --user hatch
hatch -e docs mkdocs serve
```

## tox

Py3status uses tox for testing. All submissions to the project must pass
testing. To install these via pip use

```bash
$ pip install pytest
$ pip install pytest-flake8
$ pip install tox
$ pip install black  # needs python 3.6+
```

The tests can be run by using `tox` in the py3status root directory.

Tests are kept in the `tests` directory.

## Github Actions

When you create your Pull Request, checks from the Github Actions CI will
automatically run.

If something fails in the CI:

- Take a look the build log
- If you don't get what is failing or why it is failing, feel free to
  tell it as a comment in your PR: people here are helpful and
  open-minded :)
- Once the problem is identified and fixed, rebase your commit with
  the fix and push it on your fork to trigger the CI again

## Coding in containers

Warning, by default (at least [on Archlinux](https://projects.archlinux.org/svntogit/community.git/tree/trunk/i3status.install?h=packages/i3status#n2)),
i3status has cap_net_admin capabilities, which will make it fail with
`operation not permitted` when running inside a Docker container.

```bash
$ getcap `which i3status`
/usr/sbin/i3status = cap_net_admin+ep
```

To allow it to run without these capabilities (hence disabling some of
the functionalities), remove it with:

```bash
$ sudo setcap -r `which i3status`
```

## Profiling py3status

A small tool to measure `py3status` performance between changes and
allows testing of old versions, etc. It's a little clunky but it does
the job. <https://github.com/tobes/py3status-profiler>

```
# pprofile
Running tests for 10 minutes.
[██████████] 100.00%  10:00  (22.12)
user 21.41s
system 0.71s
total 22.12s

# vmprof
Running tests for 10 minutes.
[██████████] 100.00%  10:00  (2.10)
user 1.77s
system 0.33s
total 2.1s

# cprofile
Running tests for 10 minutes.
[██████████] 100.00%  10:00  (0.92)
user 0.87s
system 0.05s
total 0.92
```



================================================
FILE: docs/dev-guide/the-py3-helper.md
================================================
# The py3 module helper

The Py3 module is a special helper object that gets injected into py3status
modules, providing extra functionality. A module can access it via the
``self.py3`` instance attribute of its py3status class.

## Constants

### CACHE_FOREVER

Special constant that when returned for ``cached_until`` will cause the
module to not update unless externally triggered.

### LOG_ERROR

Show as Error

### LOG_INFO

Show as Informational

### LOG_WARNING

Show as Warning

## Exceptions

### CommandError

An error occurred running the given command.

This exception provides some additional attributes

``error_code``: The error code returned from the call

``output``: Any output returned by the call

``error``: Any error output returned by the call

### Py3Exception

Base Py3 exception class.  All custom Py3 exceptions derive from this
class.

### RequestException

A Py3.request() base exception.  This will catch any of the more specific
exceptions.

### RequestInvalidJSON

The request has not returned valid JSON

### RequestTimeout

A timeout has occurred during a request made via Py3.request().

### RequestURLError

A URL related error has occurred during a request made via Py3.request().

## Methods

### check_commands(cmd_list)

Checks to see if commands in list are available using shutil.which().

returns the first available command.

If a string is passed then that command will be checked for.

### command_output(command, shell=False, capture_stderr=False, localized=False)

Run a command and return its output as unicode.
The command can either be supplied as a sequence or string.

:param command: command to run can be a str or list
:param shell: if `True` then command is run through the shell
:param capture_stderr: if `True` then STDERR is piped to STDOUT
:param localized: if `False` then command is forced to use its default (English) locale

A CommandError is raised if an error occurs

### command_run(command)

Runs a command and returns the exit code.
The command can either be supplied as a sequence or string.

An Exception is raised if an error occurs

### composite_create(item)

Create and return a Composite.

The item may be a string, dict, list of dicts or a Composite.

### composite_join(separator, items)

Join a list of items with a separator.
This is used in joining strings, responses and Composites.

A Composite object will be returned.

### composite_update(item, update_dict, soft=False)

Takes a Composite (item) if item is a type that can be converted into a
Composite then this is done automatically.  Updates all entries it the
Composite with values from update_dict.  Updates can be soft in which
case existing values are not overwritten.

A Composite object will be returned.

### error(msg, timeout=None)

Raise an error for the module.

:param msg: message to be displayed explaining the error
:param timeout: how long before we should retry.  For permanent errors
    `py3.CACHE_FOREVER` should be returned.  If not supplied then the
    modules `cache_timeout` will be used.


### flatten_dict(d, delimiter='-', intermediates=False, parent_key=None)

Flatten a dictionary.

Values that are dictionaries are flattened using delimiter in between
(eg. parent-child)

Values that are lists are flattened using delimiter
followed by the index (eg. parent-0)

example:

```
{
    'fish_facts': {
        'sharks': 'Most will drown if they stop moving',
        'skates': 'More than 200 species',
    },
    'fruits': ['apple', 'peach', 'watermelon'],
    'number': 52
}

# becomes

{
    'fish_facts-sharks': 'Most will drown if they stop moving',
    'fish_facts-skates': 'More than 200 species',
    'fruits-0': 'apple',
    'fruits-1': 'peach',
    'fruits-2': 'watermelon',
    'number': 52
}

# if intermediates is True then we also get unflattened elements
# as well as the flattened ones.

{
    'fish_facts': {
        'sharks': 'Most will drown if they stop moving',
        'skates': 'More than 200 species',
    },
    'fish_facts-sharks': 'Most will drown if they stop moving',
    'fish_facts-skates': 'More than 200 species',
    'fruits': ['apple', 'peach', 'watermelon'],
    'fruits-0': 'apple',
    'fruits-1': 'peach',
    'fruits-2': 'watermelon',
    'number': 52
}
```

### format_contains(format_string, names)

Determines if ``format_string`` contains a placeholder string ``names``
or a list of placeholders ``names``.

``names`` is tested against placeholders using fnmatch so the following
patterns can be used:

```
* 	    matches everything
? 	    matches any single character
[seq] 	matches any character in seq
[!seq] 	matches any character not in seq
```

This is useful because a simple test like
``'{placeholder}' in format_string``
will fail if the format string contains placeholder formatting
eg ``'{placeholder:.2f}'``


### format_units(value, unit='B', optimal=5, auto=True, si=False)

Takes a value and formats it for user output, we can choose the unit to
use eg B, MiB, kbits/second.  This is mainly for use with bytes/bits it
converts the value into a human readable form.  It has various
additional options but they are really only for special cases.

The function returns a tuple containing the new value (this is a number
so that the user can still format it if required) and a unit that is
the units that we have been converted to.

By supplying unit to the function we can force those units to be used
eg ``unit=KiB`` would force the output to be in Kibibytes.  By default we
use non-si units but if the unit is si eg kB then we will switch to si
units.  Units can also be things like ``Mbit/sec``.

If the auto parameter is False then we use the unit provided.  This
only makes sense when the unit is singular eg 'Bytes' and we want the
result in bytes and not say converted to MBytes.

optimal is used to control the size of the output value.  We try to
provide an output value of that number of characters (including decimal
point), it may also be less due to rounding.  If a fixed unit is used
the output may be more than this number of characters.


### get_color_names_list(format_string, matches=None)

Returns a list of color names in ``format_string``.

- ***format_string***: Accepts a format string.
- ***matches***: Filter results with a string or a list of strings.

If ``matches`` is provided then it is used to filter the result
using fnmatch so the following patterns can be used:

```
* 	    matches everything
? 	    matches any single character
[seq] 	matches any character in seq
[!seq] 	matches any character not in seq
```

### get_composite_string(format_string)

Return a string from a Composite.

### get_output(module_name)

Return the output of the named module.  This will be a list.

### get_placeholder_formats_list(format_string)

Parses the format_string and returns a list of tuples
[(placeholder, format), ...].

eg ``'{placeholder:.2f}'`` will give ``[('placeholder', ':.2f')]``

### get_placeholders_list(format_string, matches=None)

Returns a list of placeholders in ``format_string``.

If ``matches`` is provided then it is used to filter the result
using fnmatch so the following patterns can be used:

```
* 	    matches everything
? 	    matches any single character
[seq] 	matches any character in seq
[!seq] 	matches any character not in seq
```

This is useful because we just get simple placeholder without any
formatting that may be applied to them
eg ``'{placeholder:.2f}'`` will give ``['{placeholder}']``

### get_wm_msg()

Return the control program of the current window manager.

On i3, will return "i3-msg"
On sway, will return "swaymsg"

### i3s_config()

returns the i3s_config dict.

### is_color(color)

Tests to see if a color is defined.
Because colors can be set to None in the config and we want this to be
respected in an expression like.

```python
color = self.py3.COLOR_MUTED or self.py3.COLOR_BAD
```

The color is treated as True but sometimes we want to know if the color
has a value set in which case the color should count as False.  This
function is a helper for this second case.

### is_composite(item)

Check if item is a Composite and return True if it is.

### is_my_event(event)

Checks if an event triggered belongs to the module receiving it.  This
is mainly for containers who will also receive events from any children
they have.

Returns True if the event name and instance match that of the module
checking.

### log(message, level='info')

Log the message.
The level must be one of LOG_ERROR, LOG_INFO or LOG_WARNING

### notify_user(msg, level='info', rate_limit=5, title=None, icon=None)

Send a notification to the user.
level must be 'info', 'error' or 'warning'.
rate_limit is the time period in seconds during which this message
should not be repeated.
icon must be an icon path or icon name.

### play_sound(sound_file)

Plays sound_file if possible.

### prevent_refresh()

Calling this function during the on_click() method of a module will
request that the module is not refreshed after the event. By default
the module is updated after the on_click event has been processed.

### register_function(function_name, function)

Register a function for the module.

The following functions can be registered:

#### content_function()

Called to discover what modules a container is displaying.  This is
used to determine when updates need passing on to the container and
also when modules can be put to sleep.

the function must return a set of module names that are being
displayed.

!!! note
    This function should only be used by containers.

#### urgent_function(module_names)

This function will be called when one of the contents of a container
has changed from a non-urgent to an urgent state.  It is used by the
group module to switch to displaying the urgent module.

``module_names`` is a list of modules that have become urgent

!!! note
    This function should only be used by containers.

### request(url, params=None, data=None, headers=None, timeout=None, auth=None, cookiejar=None, retry_times=None, retry_wait=None)

Make a request to a url and retrieve the results.

If the headers parameter does not provide an 'User-Agent' key, one will
be added automatically following the convention:

    py3status/<version> <per session random uuid>

- url: url to request eg `http://example.com`
- params: extra query string parameters as a dict
- data: POST data as a dict.  If this is not supplied the GET method will be used
- headers: http headers to be added to the request as a dict
- timeout: timeout for the request in seconds
- auth: authentication info as tuple `(username, password)`
- cookiejar: an object of a CookieJar subclass
- retry_times: how many times to retry the request
- retry_wait: how long to wait between retries in seconds

returns: HttpResponse

### safe_format(format_string, param_dict=None, force_composite=False, attr_getter=None, max_width=None)

Parser for advanced formatting.

Unknown placeholders will be shown in the output eg ``{foo}``.

Square brackets ``[]`` can be used. The content of them will be removed
from the output if there is no valid placeholder contained within.
They can also be nested.

A pipe (vertical bar) ``|`` can be used to divide sections the first
valid section only will be shown in the output.

A backslash ``\`` can be used to escape a character eg ``\[`` will show ``[``
in the output.

``\?`` is special and is used to provide extra commands to the format
string,  example ``\?color=#FF00FF``. Multiple commands can be given
using an ampersand ``&`` as a separator, example ``\?color=#FF00FF&show``.

``\?if=<placeholder>`` can be used to check if a placeholder exists. An
exclamation mark ``!`` after the equals sign ``=`` can be used to negate
the condition.

``\?if=<placeholder>=<value>`` can be used to determine if {<placeholder>}
would be replaced with <value>. ``[]`` in <value> don't need to be escaped.

``{<placeholder>}`` will be converted, or removed if it is None or empty.
Formatting can also be applied to the placeholder Eg
``{number:03.2f}``.

example format_string:

``"[[{artist} - ]{title}]|{file}"``
This will show ``artist - title`` if artist is present,
``title`` if title but no artist,
and ``file`` if file is present but not artist or title.

param_dict is a dictionary of placeholders that will be substituted.
If a placeholder is not in the dictionary then if the py3status module
has an attribute with the same name then it will be used.

Composites can be included in the param_dict.

The result returned from this function can either be a string in the
case of simple parsing or a Composite if more complex.

If force_composite parameter is True a composite will always be
returned.

attr_getter is a function that will when called with an attribute name
as a parameter will return a value.

max_width lets you to control the total max width of 'full_text' the
module is allowed to output on the bar.

### stop_sound()

Stops any currently playing sounds for this module.

### storage_del(key=None)

Remove the value stored with the key from storage.
If key is not supplied then all values for the module are removed.

### storage_get(key)

Retrieve a value for the module.

### storage_items()

Return key, value pairs of the stored data for the module.

Keys will contain the following metadata entries:
- '_ctime': storage creation timestamp
- '_mtime': storage last modification timestamp

### storage_keys()

Return a list of the keys for values stored for the module.

Keys will contain the following metadata entries:
- '_ctime': storage creation timestamp
- '_mtime': storage last modification timestamp

### storage_set(key, value)

Store a value for the module.

### threshold_get_color(value, name=None)

Obtain color for a value using thresholds.

The value will be checked against any defined thresholds.  These should
have been set in the i3status configuration.  If more than one
threshold is needed for a module then the name can also be supplied.
If the user has not supplied a named threshold but has defined a
general one that will be used.

If the gradients config parameter is True then rather than sharp
thresholds we will use a gradient between the color values.

- value: numerical value to be graded
- name: accepts a string, otherwise 'threshold'
    accepts 3-tuples to allow name with different
    values eg ('name', 'key', 'thresholds')

### time_in(seconds=None, sync_to=None, offset=0)

Returns the time a given number of seconds into the future.  Helpful
for creating the ``cached_until`` value for the module output.

!!! note
    from version 3.1 modules no longer need to explicitly set a
    ``cached_until`` in their response unless they wish to directly control
    it.

- seconds: specifies the number of seconds that should occur before the
    update is required.  Passing a value of ``CACHE_FOREVER`` returns
    ``CACHE_FOREVER`` which can be useful for some modules.

- sync_to: causes the update to be synchronized to a time period.  1 would
    cause the update on the second, 60 to the nearest minute. By default we
    synchronize to the nearest second. 0 will disable this feature.

- offset: is used to alter the base time used. A timer that started at a
    certain time could set that as the offset and any synchronization would
    then be relative to that time.

### trigger_event(module_name, event)

Trigger an event on a named module.

### update(module_name=None)

Update a module.  If module_name is supplied the module of that
name is updated.  Otherwise the module calling is updated.

### update_placeholder_formats(format_string, formats)

Update a format string adding formats if they are not already present.
This is useful when for example a placeholder has a floating point
value but by default we only want to show it to a certain precision.



================================================
FILE: docs/dev-guide/writing-modules.md
================================================
# Writing custom py3status modules

Writing custom modules for py3status is as easy as declaring a Python class.
This guide will teach you how.

## Importing custom modules

First of all, it is important to know that py3status will try to find your
custom modules in the following locations:

- `~/.config/py3status/modules`
- `~/.config/i3status/py3status`
- `~/.config/i3/py3status`
- `~/.i3/py3status`

which if you are used to XDG_CONFIG paths relates to:

- `XDG_CONFIG_HOME/py3status/modules`
- `XDG_CONFIG_HOME/i3status/py3status`
- `XDG_CONFIG_HOME/i3/py3status`
- `~/.i3/py3status`

You can also specify the modules location using
`py3status -i <path to custom modules directory>` in your i3
configuration file.

## Example 1: The basics - Hello World!

Now let's start by looking at a simple example.

Here we start with the most basic module that just outputs a static
string to the status bar.

```python
# -*- coding: utf-8 -*-
"""
Example module that says 'Hello World!'

This demonstrates how to produce a simple custom module.
"""


class Py3status:

    def hello_world(self):
        return {
            'full_text': 'Hello World!',
            'cached_until': self.py3.CACHE_FOREVER
        }
```

### Running the example

Save the file as `hello_world.py` in a directory that py3status will
check for modules. By default it will look in `$HOME/.i3/py3status/` or
you can specify additional directories using `--include` when you run
py3status.

You need to tell py3status about your new module, so in your
`i3status.conf` add:

```
order += "hello_world"
```

Then restart i3 by pressing `Mod` + `Shift` + `R`. Your new module
should now show up in the status bar.

### How does it work?

The `Py3status` class tells py3status that this is a module. The module
gets loaded. py3status then calls any public methods that the class
contains to get a response. In our example there is a single method
`hello_world()`. Read more here: [module methods](#module_methods).

### The response

The response that a method returns must be a python `dict`. It should
contain at least two key / values.

#### full_text

This is the text that will be displayed in the status bar.

#### cached_until

This tells py3status how long it should consider your response valid
before it should re-run the method to get a fresh response. In our
example our response will not need to be updated so we can use the
special `self.py3.CACHE_FOREVER` constant. This tells py3status to
consider our response always valid.

`cached_until` should be generated via the `self.py3.time_in()` method.

#### self.py3

This is a special object that gets injected into py3status modules. It
helps provide functionality for the module, such as the `CACHE_FOREVER`
constant. Read more about the py3.

## Example 2: Configuration parameters

Allow users to supply configuration to a module.

```python
# -*- coding: utf-8 -*-
"""
Example module that says 'Hello World!' that can be customised.

This demonstrates how to use configuration parameters.

Configuration parameters:
    format: Display format (default 'Hello World!')
"""


class Py3status:

    format = 'Hello World!'

    def hello_world(self):
        return {
            'full_text': self.format,
            'cached_until': self.py3.CACHE_FOREVER
        }
```

This module still outputs 'Hello World' as before but now you can
customise the output using your `i3status.config` for example to show
the text in French.

```
hello_world {
    format = 'Bonjour tout le monde!'
}
```

In your module `self.format` will have been set to the value supplied in
the config.

## Example 3: Click events

Catch click events and perform an action.

```python
# -*- coding: utf-8 -*-
"""
Example module that handles events

This demonstrates how to use events.
"""


class Py3status:

    def __init__(self):
        self.full_text = 'Click me'

    def click_info(self):
        return {
            'full_text': self.full_text,
            'cached_until': self.py3.CACHE_FOREVER
        }

    def on_click(self, event):
        """
        event will be a dict like
        {'y': 13, 'x': 1737, 'button': 1, 'name': 'example', 'instance': 'first'}
        """
        button = event['button']
        # update our output (self.full_text)
        format_string = 'You pressed button {button}'
        data = {'button': button}
        self.full_text = self.py3.safe_format(format_string, data)
        # Our modules update methods will get called automatically.
```

The `on_click` method of a module is special and will get called when
the module is clicked on. The event parameter will be a dict that gives
information about the event.

A typical event dict will look like this:
`{'y': 13, 'x': 1737, 'button': 1, 'name': 'example', 'instance': 'first'}`

You should only receive events for the module clicked on, so generally
we only care about the button.

The `__init__()` method is called when our class is instantiated.

!!! note
    __init__ is called before any config parameters have been set.

We use the `safe_format()` method of `py3` for formatting. Read more
about the py3.

## Example 4: Status string placeholders

Status string placeholders allow us to add information to formats.

```python
# -*- coding: utf-8 -*-
"""
Example module that demonstrates status string placeholders

Configuration parameters:
    format: Initial format to use
        (default 'Click me')
    format_clicked: Display format to use when we are clicked
        (default 'You pressed button {button}')

Format placeholders:
    {button} The button that was pressed
"""


class Py3status:
    format = 'Click me'
    format_clicked = 'You pressed button {button}'

    def __init__(self):
        self.button = None

    def click_info(self):
        if self.button:
            data = {'button': self.button}
            full_text = self.py3.safe_format(self.format_clicked, data)
        else:
            full_text = self.format

        return {
            'full_text': full_text,
            'cached_until': self.py3.CACHE_FOREVER
        }

    def on_click(self, event):
        """
        event will be a dict like
        {'y': 13, 'x': 1737, 'button': 1, 'name': 'example', 'instance': 'first'}
        """
        self.button = event['button']
        # Our modules update methods will get called automatically.
```

This works just like the previous example but we can now be customised.
The following example assumes that our module has been saved as
click_info.py.

```
click_info {
    format = "Cliquez ici"
    format_clicked = "Vous avez appuyé sur le bouton {button}"
}
```

## Example 5: Using color constants

`self.py3` in our module has color constants that we can access, these
allow the user to set colors easily in their config.

```python
# -*- coding: utf-8 -*-
"""
Example module that uses colors.

We generate a random number between and color it depending on its value.
Clicking on the module will update it an a new number will be chosen.

Configuration parameters:
    format: Initial format to use
        (default 'Number {number}')

Format placeholders:
    {number} Our random number

Color options:
    color_high: number is 5 or higher
    color_low: number is less than 5
"""

from random import randint


class Py3status:
    format = 'Number {number}'

    def random(self):
        number = randint(0, 9)
        full_text = self.py3.safe_format(self.format, {'number': number})

        if number < 5:
            color = self.py3.COLOR_LOW
        else:
            color = self.py3.COLOR_HIGH

        return {
            'full_text': full_text,
            'color': color,
            'cached_until': self.py3.CACHE_FOREVER
        }

    def on_click(self, event):
        # by defining on_click pressing any mouse button will refresh the
        # module.
        pass
```

The colors can be set in the config in the module or its container or in
the general section. The following example assumes that our module has
been saved as `number.py`. Although the constants are capitalized they
are defined in the config in lower case.

```
number {
    color_high = '#FF0000'
    color_low = '#00FF00'
}
```

## Module methods

Py3status will call a method in a module to provide output to the i3bar.
Methods that have names starting with an underscore will not be used in
this way. Any methods defined as static methods will also not be used.

### Outputs

Output methods should provide a response dict.

Example response:

```python
{
    'full_text': "This text will be displayed",
    'cached_until': 1470922537,  # Time in seconds since the epoch
}
```

The response can include the following keys

**cached_until**

The time (in seconds since the epoch) that the output will be classed as
no longer valid and the output function will be called again.

Since version 3.1, if no `cached_until` value is provided the output
will be cached for `cache_timeout` seconds by default this is `60` and
can be set using the `-t` or `--timeout` option when running py3status.
To never expire the `self.py3.CACHE_FOREVER` constant should be used.

`cached_until` should be generated via the `self.py3.time_in()` method.

**color**

The color that the module output will be displayed in.

**composite**

Used to output more than one item to i3bar from a single output method.
If this is provided then `full_text` should not be.

**full_text**

This is the text output that will be sent to i3bar.

**index**

The index of the output. Allows composite output to identify which
component of their output had an event triggered.

**separator**

If `False` no separator will be shown after the output block (requires
i3bar 4.12).

**urgent**

If `True` the output will be shown as urgent in i3bar.

### Special methods

Some special method are also defined.

**kill()**

Called just before a module is destroyed.

**on_click(event)**

Called when an event is received by a module.

**post_config_hook()**

Called once an instance of a module has been created and the
configuration parameters have been set. This is useful for any work a
module must do before its output methods are run for the first time.
`post_config_hook()` introduced in version 3.1

## Py3 module helper

Py3 is a special helper object that gets injected into py3status
modules, providing extra functionality. A module can access it via the
self.py3 instance attribute of its py3status class. For details see py3.

## Composites

Whilst most modules return a simple response eg:

```python
{
    'full_text': <some text>,
    'cached_until': <cache time>,
}
```

Sometimes it is useful to provide a more complex, composite response. A
composite is made up of more than one simple response which allows for
example a response that has multiple colors. Different parts of the
response can also be differentiated between when a click event occurs
and so allow clicking on different parts of the response to have
different outcomes. The different parts of the composite will not have
separators between them in the output so they will appear as a single
module to the user.

The format of a composite is as follows:

```python
{
    'cached_until': <cache time>,
    'composite': [
        {
            'full_text': <some text>,
        },
        {
            'full_text': <some more text>,
            'index': <some index>
        },
    ]
}
```

The `index` key in the response is used to identify the individual block
and when the modules `on_click()` method is called the event will
include this. Supplied index values should be strings. If no index is
given then it will have an integer value indicating its position in the
composite.

## Module data storage

Py3status allows modules to maintain state through the use of the
storage functions of the Py3 helper.

Currently bool, int, float, None, unicode, dicts, lists, datetimes etc
are supported. Basically anything that can be pickled. We do our best to
ensure that the resulting pickles are compatible with both python
versions 2 and 3.

The following helper functions are defined in the modules py3.

These functions may return `None` if storage is not available as well as
some metadata such as storage creation timestamp `_ctime` and last
modification timestamp `_mtime`.

Example:

```python
def module_function(self):
    # set some storage
    self.py3.storage_set('my_key', value)
    # get the value or None if key not present
    value = self.py3.storage_get('my_key')
```

## Module documentation

All contributed modules should have correct documentation. This
documentation is in a specific format and is used to generate user
documentation.

The docstring of a module is used. The format is as follows:

- Single line description of the module followed by a single blank
    line.
- Longer description of the module providing more detail.
- Configuration parameters. This section describes the user settable
    parameters for the module. All parameters should be listed (in
    alphabetical order). default values should be given in parentheses
    eg `(default 7)`.
- Format placeholders. These are used for substituting values in
    format strings. All placeholders should be listed (in alphabetical
    order) and describe the output that they provide.
- Color options. These are the color options that can be provided for
    this module. All color options should be listed (in alphabetical
    order) that the module uses.
- Requires. A list of all the additional requirements for the module
    to work. These may be command line utilities, python libraries etc.
- Example. Example configurations for the module can be given.
- Author and license. Finally information on the modules author and a
    license can be provided.

Here is an example of a docstring.

```python
"""
Single line summary

Longer description of the module.  This should help users understand the
modules purpose.

Configuration parameters:
    parameter: Explanation of this parameter (default <value>)
    parameter_other: This parameter has a longer explanation that continues
        onto a second line so it is indented.
        (default <value>)

Format placeholders:
    {info} Description of the placeholder

Color options:
    color_meaning: what this signifies, defaults to color_good
    color_meaning2: what this signifies

Requires:
    program: Information about the program
    python_lib: Information on the library

Example:

```
module {
    parameter = "Example"
    parameter_other = 7
}
```

@author <author>
@license <license>
"""
```

## Deprecation of configuration parameters

Sometimes it is necessary to deprecate configuration parameters. Modules
are able to specify information about deprecation so that it can be done
automatically. Deprecation information is specified in the Meta class of
a py3status module using the deprecated attribute. The following types
of deprecation are supported.

The deprecation types will be performed in the order here.

**rename**

The parameter has been renamed. We will update the configuration to use
the new name.

```python
class Py3status:

    class Meta:

        deprecated = {
            'rename': [
                {
                    'param': 'format_available',  # parameter name to be renamed
                    'new': 'icon_available',   # the parameter that will get the value
                    'msg': 'obsolete parameter use `icon_available`',  # message
                },
            ],
        }
```

**format_fix_unnamed_param**

Some formats used `{}` as a placeholder this needs to be updated to a
named placeholder eg `{value}`.

```python
class Py3status:

    class Meta:

        deprecated = {
            'format_fix_unnamed_param': [
                {
                    'param': 'format',  # parameter to be changed
                    'placeholder': 'percent',  # the place holder to use
                    'msg': '{} should not be used in format use `{percent}`',  # message
                },
            ],
        }
```

**rename_placeholder**

We can use this to rename placeholders in format strings

```python
class Py3status:

    class Meta:

        deprecated = {
            'rename_placeholder': [
                {
                    'placeholder': 'cpu',  # old placeholder name
                    'new': 'cpu_usage',  # new placeholder name
                    'format_strings': ['format'],  # config settings to update
                },
            ],
        }
```

**update_placeholder_format**

This allows us to update the format of a placeholder in format strings.
The key value pairs {placeholder: format} can be supplied as a dict in
`placeholder_formats` or the dict can be provided by `function` the
function will be called with the current config and must return a dict.
If both are supplied then `placeholder_formats` will be updated using
the dict supplied by the function.

```python
class Py3status:

    class Meta:

        deprecated = {
            'update_placeholder_format': [
                {
                    'function': update_placeholder_format,  # function returning dict
                    'placeholder_formats': {   # dict of placeholder:format
                        'cpu_usage': ':.2f',
                    },
                    'format_strings': ['format'],  # config settings to update
                }
            ],
        }
```

**substitute_by_value**

This allows one configuration parameter to set the value of another.

```python
class Py3status:

    class Meta:

        deprecated = {
            'substitute_by_value': [
                {
                    'param': 'mode',  # parameter to be checked for substitution
                    'value': 'ascii_bar',  # value that will trigger the substitution
                    'substitute': {
                        'param': 'format',  # parameter to be updated
                        'value': '{ascii_bar}',  # the value that will be set
                    },
                    'msg': 'obsolete parameter use `format = "{ascii_bar}"`',  #message
                },
            ],
        }
```

**function**

For more complex substitutions a function can be defined that will be
called with the config as a parameter. This function must return a dict
of key value pairs of parameters to update

```python
class Py3status:

    class Meta:

        # Create a function to be called
        def deprecate_function(config):
            # This function must return a dict
            return {'thresholds': [
                        (0, 'bad'),
                        (config.get('threshold_bad', 20), 'degraded'),
                        (config.get('threshold_degraded', 50), 'good'),
                    ],
            }

        deprecated = {
            'function': [
                {
                    'function': deprecate_function,  # function to be called
                },
            ],
        }
```

**remove**

The parameters will be removed.

```python
class Py3status:

    class Meta:

        deprecated = {
            'remove': [
                {
                    'param': 'threshold_bad',  # name of parameter to remove
                    'msg': 'obsolete set using thresholds parameter',  #message
                },
            ],
        }
```

## Updating of configuration parameters

Sometimes it is necessary to update configuration parameters. Modules
are able to specify information about updates so that it can be done
automatically. Config updating information is specified in the Meta
class of a py3status module using the update_config attribute. The
following types of updates are supported.

**update_placeholder_format**

This allows us to update the format of a placeholder in format strings.
The key value pairs {placeholder: format} can be supplied as a dict in
`placeholder_formats` or the dict can be provided by `function` the
function will be called with the current config and must return a dict.
If both are supplied then `placeholder_formats` will be updated using
the dict supplied by the function.

This is similar to the deprecation method but is to allow default
formatting of placeholders to be set.

In a module like sysdata we have placeholders eg `{cpu_usage}` this ends
up having a value something like `20.542317173377157` which is strange
as the value to use but gives the user the ability to have as much
precision as they want. A module writer may decide that they want this
displayed as `20.54` so `{cpu_usage:.2f}` would do this. Having a
default format containing that just looks long/silly and the user
setting a custom format just wants to do `format = 'CPU: {cpu_usage}%'`
and get expected results ie not the full precision. If they don't like
the default formatting of the number they could still do format = 'CPU:
{cpu_usage:d}%' etc.

So using this allows sensible defaults formatting and allows simple
placeholders for user configurations.

```python
class Py3status:

    class Meta:

        update_config = {
            'update_placeholder_format': [
                {
                    'placeholder_formats': {   # dict of placeholder:format
                        'cpu_usage': ':.2f',
                    },
                    'format_strings': ['format'],  # config settings to update
                }
            ],
        }
```

## Module testing

Each module should be able to run independently for testing purposes.
This is simply done by adding the following code to the bottom of your
module.

```python
if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test
    module_test(Py3status)
```

If a specific config should be provided for the module test, this can be
done as follows.

```python
if __name__ == "__main__":
    """
    Run module in test mode.
    """
    config = {
        'always_show': True,
    }
    from py3status.module_test import module_test
    module_test(Py3status, config=config)
```

Such modules can then be tested independently by running
`python /path/to/module.py`.

```bash
$ python loadavg.py
[{'full_text': 'Loadavg ', 'separator': False,
'separator_block_width': 0, 'cached_until': 1538755796.0},
{'full_text': '1.87 1.73 1.87', 'color': '#9DD7FB'}]
^C
```

We also can produce an output similar to i3bar output in terminal with
`python /path/to/module.py --term`.

```bash
$ python loadavg.py --term
Loadavg 1.41 1.61 1.82
Loadavg 1.41 1.61 1.82
Loadavg 1.41 1.61 1.82
^C
```
## Publishing custom modules on PyPI

You can share your custom modules and make them available for py3status
users even if they are not directly part of the py3status main project!

All you have to do is to package your module and publish it to PyPI.

py3status will discover custom modules if they are installed in the same
host interpreter and if an entry_point in your package `setup.py` is
defined:

    setup(
        entry_points={"py3status": ["module = package_name.py3status_module_name"]},
    )

The awesome pewpew module can be taken as an example on how to do it
easily:

- Module repository: <https://github.com/obestwalter/py3status-pewpew>
- Example setup.py:
    <https://github.com/obestwalter/py3status-pewpew/blob/master/setup.py>

We will gladly add `extra_requires` pointing to your modules so that
users can require them while installing py3status. Just open an issue to
request this or propose a PR.

If you have installed py3status in a virtualenv (maybe because your
custom module has dependencies that need to be available) you can also
create an installable package from your module and publish it on PyPI.

!!! note
    To clearly identify your py3status package and for others to discover it easily
    it is recommended to name the PyPI package `py3status-<your module name>`.



================================================
FILE: docs/user-guide/configuration.md
================================================
# Configuration

py3status comes with a large range of modules.

Modules in py3status are configured using your usual `i3status.conf` or
your own `py3status.conf` which follows the exact same format.

py3status will try to find its configuration file in the following
locations:

- `~/.config/py3status/config`
- `~/.config/i3status/config`
- `~/.config/i3/i3status.conf`
- `~/.i3status.conf`
- `~/.i3/i3status.conf`
- `/etc/xdg/i3status/config`
- `/etc/i3status.conf`

which if you are used to XDG_CONFIG paths relates to:

- `XDG_CONFIG_HOME/py3status/config`
- `XDG_CONFIG_HOME/i3status/config`
- `XDG_CONFIG_HOME/i3/i3status.conf`
- `~/.i3status.conf`
- `~/.i3/i3status.conf`
- `XDG_CONFIG_DIRS/i3status/config`
- `/etc/i3status.conf`

You can also specify the config location using
`py3status -c <path to config file>` in your i3 configuration file.

## Loading and ordering py3status modules

To load a py3status module you just have to list it like any other
i3status module using the `order +=` parameter.

Ordering your py3status modules in your i3bar is just the same as
i3status modules, just list the order parameter where you want your
module to be displayed.

For example you could insert and load the `imap` module like this:

```
order += "disk /home"
order += "disk /"
order += "imap"
order += "time"
```

## Configuring a py3status module

Your py3status modules are configured the exact same way as i3status
modules, directly from your `i3status.conf` (or your own configuration file),
like this :

```
# configure the py3status imap module
# and run thunderbird when I left click on it
imap {
    cache_timeout = 60
    imap_server = 'imap.myprovider.com'
    mailbox = 'INBOX'
    password = 'coconut'
    port = '993'
    user = 'mylogin'
    on_click 1 = "exec thunderbird"
}
```

## Modules dependencies

Py3status itself **does not** handle the possible dependencies of the
modules you use. Each module's documentation has a dedicated `Requires`
section allowing you to know which libraries or binaries they depend
on. It's up to you to install them on your system.

## The py3status configuration section

This special section holds py3status specific configuration. Settings
here will affect all py3status modules. Many settings e.g. colors can
still be overridden by also defining in the individual module.

- `stop_signal`. Specify a signal number to be used by i3bar to stop/resume the bar refresh. This is useful if you want to prevent i3bar from stopping py3status when the bar is not visible (hidden/fullscreen).

```
# prevent i3bar from stopping py3status when hidden/fullscreen
py3status {
    stop_signal = 0
}
```

- `nagbar_font`. Specify a font for `i3-nagbar -f <font>`.

```
py3status {
    nagbar_font = 'pango:Ubuntu Mono 12'
}
```

- `storage`: Set storage name or path.

Store cache in `$XDG_CACHE_HOME` or `~/.cache`:

```
# default behavior
py3status {
    storage = 'py3status_cache.data'
}
```

Store per config cache in `$XDG_CACHE_HOME` or `~/.cache`:

```
# first config
py3status {
    storage = 'py3status_top.data'
}
```

```
# second config
py3status {
    storage = 'py3status_bottom.data'
}
```

Store per config cache in different directories:

```
# first config
py3status {
    storage = '~/.config/py3status/cache_top.data'
}
```

```
# second config
py3status {
    storage = '~/.config/py3status/cache_bottom.data'
}
```

## Generic per-module configuration

You can specify the following options in module configuration.

-   `min_length`: Specify a minimum length of characters for modules.
-   `position`: Specify how modules should be positioned when the
    `min_length` is not reached. Either `left` (default), `center`, or
    `right`.

```
static_string {
    min_length = 15
    position = 'center'
}
```

## Generic configuration applying to all modules

You can specify the options in module or py3status configuration
section.

The following options will work on `i3`.

- `align`: Specify how modules should be aligned when the `min_width`
  is not reached. Either `left` (default), `center`, or `right`.
- `background`: Specify a background color for py3status modules.
- `markup`: Specify how modules should be parsed.
- `min_width`: Specify a minimum width of pixels for modules.
- `separator`: Specify a separator boolean for modules.
- `separator_block_width`: Specify a separator block width for
  modules.

The following options will work on `i3-gaps`.

- `border`: Specify a border color for modules.
- `border_bottom`: Specify a border width for modules
- `border_left`: Specify a border width for modules.
- `border_right`: Specify a border width for modules.
- `border_top`: Specify a border width for modules.

The following options will work on `py3status`.

- `min_length`: Specify a minimum length of characters for modules.
- `position`: Specify how modules should be positioned when the
  `min_length` is not reached. Either `left` (default), `center`, or
  `right`.

```
# customize a theme
py3status {
   align = 'left'
   markup = 'pango'
   min_width = 20
   separator = True
   separator_block_width = 9

   background = '#285577'
   border = '#4c7899'
   border_bottom = 1
   border_left = 1
   border_right = 1
   border_top = 1

   min_length = 15
   position = 'right'
}
```

You can specify the options in module or py3status configuration
section.

The following options will work on `i3bar` and `py3status`.

- `urgent_background`: Specify urgent background color for modules.
- `urgent_foreground`: Specify urgent foreground color for modules.
- `urgent_border`: Specify urgent border color for modules.

The following options will work on `i3bar-gaps` and `py3status`.

- `urgent_border_bottom`: Specify urgent border width for modules
- `urgent_border_left`: Specify urgent border width for modules.
- `urgent_border_right`: Specify urgent border width for modules.
- `urgent_border_top`: Specify urgent border width for modules.

You lose urgent functionality too that can be sometimes utilized by
container modules, e.g., frame and group.

```
# customize urgent
py3status {
   urgent_background  = 'blue'
   urgent_foreground = 'white'
   urgent_border = 'red'
   urgent_border_bottom = 1
   urgent_border_left = 1
   urgent_border_right = 1
   urgent_border_top = 1
}
```

You can specify the options in module or py3status configuration
section.

- `resources`: Specify a list of 3-tuples, e.g.,
  `[(option, resource, fallback)]`, to import resources.

```
# import resources
py3status {
   resources = [
       ('color_bad', '*color9', 'lightcoral'),
       ('color_good', '*color10', 'lightgreen'),
       ('color_degraded', '*color11', 'khaki'),
       ('nagbar_font', 'py3status.font', 'pango:Ubuntu Mono 12'),
   ]
}
```

```
# import 16 colors
py3status {
   resources = [
       ('color_color0', '*color0', 'black'),
       ('color_color1', '*color1', 'black'),
       ('color_color2', '*color2', 'black'),
       ('color_color3', '*color3', 'black'),
       ('color_color4', '*color4', 'black'),
       ('color_color5', '*color5', 'black'),
       ('color_color6', '*color6', 'black'),
       ('color_color7', '*color7', 'black'),
       ('color_color8', '*color8', 'black'),
       ('color_color9', '*color9', 'black'),
       ('color_color10', '*color10', 'black'),
       ('color_color11', '*color11', 'black'),
       ('color_color12', '*color12', 'black'),
       ('color_color13', '*color13', 'black'),
       ('color_color14', '*color14', 'black'),
       ('color_color15', '*color15', 'black'),
   ]
}

# apply colors
coin_market {
    thresholds = [(-100, "color9"), (0, "color10")]
}
```

## Configuration obfuscation

Py3status allows you to hide individual configuration parameters so that
they do not leak into log files, user notifications or to the i3bar.
Additionally they allow you to obfuscate configuration parameters using
base64 encoding.

To "hide" a value you can use the `hide()` configuration function. This
prevents the module displaying the value as a format placeholder and
from appearing in the logs.

```
# Example of 'hidden' configuration
imap {
    imap_server = 'imap.myprovider.com'
    password = hide('hunter22')
    user = 'mylogin'
}
```

To base64 encode a value you can use the `base64()` configuration
function. This also prevents the module displaying the value as a format
placeholder and from appearing in the logs.

```
# Example of obfuscated configuration
imap {
    imap_server = 'imap.myprovider.com'
    password = base64('Y29jb251dA==')
    user = 'mylogin'
}
```

Since version 3.1 obfuscation options can also be added by the legacy
method. Add `:hide` or `:base64` to the name of the parameters. You are
advised to use the new `hide()` and `base64()` configuration functions.

!!! note
    Legacy obfuscation is only available for string:
    parameters with `:hide` or `:base64`. If you want other types then
    be sure to use `hide()` and `base64()` configuration functions.

```
# normal_parameter will be shown in log files etc as 'some value'
# obfuscated_parameter will be shown in log files etc as '***'
module {
    normal_parameter = 'some value'
    obfuscated_parameter:hide = 'some value'
}
```

In the previous example configuration the users password is in plain
text. Users may want to make it less easy to read. Py3status allows
strings to be base64 encoded.

To use an encoded string add `:base64` to the name of the parameter.

```
# Example of obfuscated configuration
imap {
    imap_server = 'imap.myprovider.com'
    password:base64 = 'Y29jb251dA=='
    user = 'mylogin'
}
```

!!! warning
    Base64 encoding is very simple and should not be considered secure in
    any way.

## Configuring colors

Since version 3.1 py3status allows greater color configuration. Colors
can be set in the general section of your `i3status.conf` or in an
individual modules configuration. If a color is not in a modules
configuration then the values from the general section will be used.

If a module does not specify colors but it is in a container, then the
colors of the container will be used if they are set, before using ones
defined in the general section.

Generally colors can specified using hex values eg `#FF00FF` or `#F0F`.
It is also possible to use css3 color names eg `red` `hotpink`.
[Check here for al ist of available color names](https://drafts.csswg.org/css-color/#named-colors).

```
general {
    # These will be used if not supplied by a module
    color = '#FFFFFF'
    color_good = '#00FF00'
    color_bad = '#FF0000'
    color_degraded = '#FFFF00'
}

time {
    color = 'FF00FF'
    format = "%H:%M"
}

battery_level {
    color_good = '#00AA00'
    color_bad = '#AA0000'
    color_degraded = '#AAAA00'
    color_charging = '#FFFF00'
}
```

## Configuring thresholds

Some modules allow you to define thresholds in a module. These are used
to determine which color to use when displaying the module. Thresholds
are defined in the config as a list of tuples. With each tuple
containing a value and a color. The color can either be a named color eg
`good` referring to `color_good` or a hex value.

```
volume_status {
    thresholds = [
        (0, "#FF0000"),
        (20, "degraded"),
        (50, "bad"),
    ]
}
```

If the value checked against the threshold is equal to or more than a
threshold then that color supplied will be used.

In the above example the logic would be

```
if 0 >= value < 20 use #FF0000
else if 20 >= value < 50 use color_degraded
else if 50 >= value use color_good
```

Some modules may allow more than one threshold to be defined. If all the
thresholds are the same they can be defined as above but if you wish to
specify them separately you can by giving a dict of lists.

```
my_module {
    thresholds = {
        'threshold_1': [
            (0, "#FF0000"),
            (20, "degraded"),
            (50, "bad"),
        ],
        'threshold_2': [
            (0, "good"),
            (30, "bad"),
        ],
    }
}
```

You can specify `hidden` color to hide a block.

```
# hide a block when ``1avg`` (i.e., 12.4) is less than 20 percent
format = "[\?color=1avg [\?color=darkgray&show 1min] {1min}]"
loadavg {
   thresholds = [
        (0, "hidden"),
       (20, "good"),
       (40, "degraded"),
       (60, "#ffa500"),
       (80, "bad"),
   ]
}

# hide cpu block when ``cpu_used_percent`` is less than 50 percent
# hide mem block when ``mem_used_percent`` is less than 50 percent
sysdata {
    thresholds = [
        (50, "hidden"),
        (75, "bad"),
    ]
}
```

## Formatter

All modules allow you to define the format of their output. This is done
with the format option. You can:

- display static text:

```
mpd_status {
   format = "MPD:"
}
```

- use a backslash `\` to escape a character (`\[` will show `[`).
- display data provided by the module. This is done with
  "placeholders", which follow the format {placeholder_name}. The
  following example shows the state of the MPD (play/pause/stop) and
  the artist and title of the currently playing song.

```
mpd_status {
   format = "MPD: {state} {artist} {title}"
}
```

    - Unknown placeholders act as if they were static text and
      placeholders that are empty or None will be removed.
    - Formatting can also be applied to the placeholder Eg
      `{number:03.2f}`.
- hide invalid (no valid data or undefined) placeholders by enclosing
  them in `[]`. The following example will show `artist - title` if
  artist is present and `title` if title but no artist is present.

```
mpd_status {
   format = "MPD: {state} [[{artist} - ]{title}]"
}
```

-   show the first block with valid output by dividing them with a pipe
    `|`. The following example will show the filename if neither artist
    nor title are present.

```
mpd_status {
   format = "MPD: {state} [[{artist} - ]{title}]|{file}"
}
```

-   `\?` can be used to provide extra commands to the format string.
    Multiple commands can be given using an ampersand `&` as a
    separator.

```
my_module {
   format = "\?color=#FF00FF&show blue"
}
```

- change the output with conditions. This is done by following the
  `\?` with a an if statement. Multiple conditions or commands can be
  combined by using an ampersand `&` as a separator. Here are some
  examples:
    - `\?if=online green | red` checks if the placeholder exists and
      would display `green` in that case. A condition that evaluates
      to false invalidates a section and the section can be hidden
      with `[]` or skipped with `|`
    - `\?if=!online red | green` this dose the same as the above
      condition, the only difference is that the exclamation mark `!`
      negates the condition.
    - `\?if=state=play PLAYING! | not playing` checks if the
      placeholder contains `play` and displays `PLAYING!` if not it
      will display `not playing`.

A format string using nearly all of the above options could look like
this:

```
mpd_status {
  format = "MPD: {state} [\?if=![stop] [[{artist} - ]{title}]|[{file}]]"
}
```

This will show `MPD: [state]` if the state of the MPD is `[stop]` or
`MPD: [state] artist - title` if it is `[play]` or `[pause]` and artist
and title are present, `MPD: [state] title` if artist is missing and
`MPD: [state] file` if artist and title are missing.

## Marking modules as urgent

Some modules use i3bar's urgent feature to indicate that something
important has occurred. The `allow_urgent` configuration parameter can
be used to allow/prevent a module from setting itself as urgent.

```
# prevent modules showing as urgent, except github
py3status {
    allow_urgent = false
}

github {
    allow_urgent = true
}
```

## Controlling error behavior

When a module error has occurred, it will be reported on the bar. The
`on_error` configuration parameter allows users to choose what to do
instead.

Supported values:

-   `show` (default): report the error on the bar (click to view)
-   `hide`: hide the module on the bar

```
# hide errors on all modules by default (still reported on logs)
py3status {
    on_error = "hide"
}

# hide errors on non-NVIDIA hardwares
nvidia_smi {
    on_error = "hide"
}

# hide errors on sway where xrandr does not work
xrandr {
    on_error = "hide"
}
```

## Grouping Modules

The module_group module allows you to group several modules together.
Only one of the modules are displayed at a time. The displayed module
can either be cycled through automatically or by user action (the
default, on mouse scroll).

This module is very powerful and allows you to save a lot of space on
your bar.

```
order += "group tz"

# cycle through different timezone hours every 10s
group tz {
    cycle = 10
    format = "{output}"

    tztime la {
        format = "LA %H:%M"
        timezone = "America/Los_Angeles"
    }

    tztime ny {
        format = "NY %H:%M"
        timezone = "America/New_York"
    }

    tztime du {
        format = "DU %H:%M"
        timezone = "Asia/Dubai"
    }
}
```

The module_frame module also allows you to group several modules
together, however in a frame all the modules are shown. This allows you
to have more than one module shown in a group.

```
order += "group frames"

# group showing disk space or times using button to change what is shown.
group frames {
    click_mode = "button"

    frame time {
        tztime la {
            format = "LA %H:%M"
            timezone = "America/Los_Angeles"
        }

        tztime ny {
            format = "NY %H:%M"
            timezone = "America/New_York"
        }

        tztime du {
            format = "DU %H:%M"
            timezone = "Asia/Dubai"
        }
    }

    frame disks {
        disk "/" {
            format = "/ %avail"
        }

        disk "/home" {
            format = "/home %avail"
        }
    }
}
```

Frames can also have a toggle button to hide/show the content

```
# A frame showing times in different cities.
# We also have a button to hide/show the content

frame time {
    format = '{output}{button}'
    format_separator = ' '  # have space instead of usual i3bar separator

    tztime la {
        format = "LA %H:%M"
        timezone = "America/Los_Angeles"
    }

    tztime ny {
        format = "NY %H:%M"
        timezone = "America/New_York"
    }

    tztime du {
        format = "DU %H:%M"
        timezone = "Asia/Dubai"
    }
}
```

## Custom click events

py3status allows you to easily add click events to modules in your
i3bar. These modules can be both i3status or py3status modules. This is
done in your `i3status.config` using the `on_click` parameter.

Just add a new configuration parameter named `on_click [button number]`
to your module config and py3status will then execute the given i3
command (using i3-msg).

This means you can run simple tasks like executing a program or execute
any other i3 specific command.

As an added feature and in order to get your i3bar more responsive,
every `on_click` command will also trigger a module refresh. This works
for both py3status modules and i3status modules as described in the
refresh command below.

```
# button numbers
1 = left click
2 = middle click
3 = right click
4 = scroll up
5 = scroll down
```

```
# reload the i3 config when I left click on the i3status time module
# and restart i3 when I middle click on it
time {
    on_click 1 = "reload"
    on_click 2 = "restart"
}

# control the volume with your mouse (need >i3-4.8)
# launch alsamixer when I left click
# kill it when I right click
# toggle mute/unmute when I middle click
# increase the volume when I scroll the mouse wheel up
# decrease the volume when I scroll the mouse wheel down
volume master {
    format = "♪: %volume"
    device = "default"
    mixer = "Master"
    mixer_idx = 0
    on_click 1 = "exec i3-sensible-terminal -e alsamixer"
    on_click 2 = "exec amixer set Master toggle"
    on_click 3 = "exec killall alsamixer"
    on_click 4 = "exec amixer set Master 1+"
    on_click 5 = "exec amixer set Master 1-"
}

# run wicd-gtk GUI when I left click on the i3status ethernet module
# and kill it when I right click on it
ethernet eth0 {
    # if you use %speed, i3status requires root privileges
    format_up = "E: %ip"
    format_down = ""
    on_click 1 = "exec wicd-gtk"
    on_click 3 = "exec killall wicd-gtk"
}

# run thunar when I left click on the / disk info module
disk "/" {
    format = "/ %free"
    on_click 1 = "exec thunar /"
}

# this is a py3status module configuration
# open an URL on opera when I left click on the weather_yahoo module
weather_yahoo paris {
    cache_timeout = 1800
    woeid = 615702
    forecast_days = 2
    on_click 1 = "exec opera http://www.meteo.fr"
    request_timeout = 10
}
```

## Special on_click commands

There are two commands you can pass to the `on_click` parameter that
have a special meaning to py3status :

- `refresh` : This will refresh (expire the cache) of the clicked
    module. This also works for i3status modules (it will send a SIGUSR1
    to i3status for you).
- `refresh_all` : This will refresh all the modules from your i3bar
    (i3status included). This has the same effect has sending a SIGUSR1
    to py3status.

## Module data and on_click commands

Since version 3.3 it is possible to use the output text of a module in
the `on_click` command. To do this `$OUTPUT` can be used in command and
it will be substituted by the modules text output when the command is
run.

```
# copy module output to the clipboard using xclip
my_module {
    on_click 1 = 'exec echo $OUTPUT | xclip -i'
}
```

If the output of a module is a composite then the output of the part
clicked on can be accessed using `$OUTPUT_PART`.

## Environment Variables

You may use the value of an environment variable in your configuration
with the `env(...)` directive. These values are captured at startup and
may be converted to the needed datatype (only `str`, `int`, `float`,
`bool` and `auto` are currently supported).

Note, the `auto` conversion will try to guess the type of the contents
and automatically convert to that type. Without an explicit conversion
function, it defaults to `auto`.

This is primarily designed to obfuscate sensitive information when
sharing your configuration file, such as usernames, passwords, API keys,
etc.

The `env(...)` expression can be used anywhere a normal constant would
be used. Note, you cannot use the directive in place of a dictionary
key, i.e `{..., env(KEY): 'val', ...}`.

See the examples below!

```
order += "my_module"
order += env(ORDER_MODULE)

module {
    normal_parameter = 'some value'
    env_parameter = env(SOME_ENVIRONMENT_PARAM)
    sensitive_api_key = env(API_KEY)

    complex_parameter = {
      'key': env(VAL)
    }

    equivalent1 = env(MY_VAL)
    equivalent2 = env(MY_VAL, auto)

    list_of_tuples = [
      (env(APPLE_NUM, int), 'apple'),
      (2, env(ORANGE))
    ]

    float_param = env(MY_NUM, float)
}
```

## Inline Shell Code

You can use the standard output of a shell script in your configuration
with the `shell(...)` directive. These values are captured at startup
and may be converted to the needed datatype (only `str`, `int`, `float`,
`bool` and `auto` (default) are currently supported).

The shell script executed must return a single line of text on stdout
and then terminate. If the type is explicitly declared `bool`, the exit
status of the script is respected (a non-zero exit status being
interpreted falsey). In any other case if the script exits with a
non-zero exit status an error will be thrown.

The `shell(...)` expression can be used anywhere a constant or an
`env(...)` directive can be used (see the section "Environment
Variables").

Usage example:

```
my_module {
    password = shell(pass show myPasswd | head -n1)
    some_string = shell(/opt/mydaemon/get_api_key.sh, str)
    pid = shell(cat /var/run/mydaemon/pidfile, int)
    my_bool = shell(pgrep thttpd, bool)
}
```

Due to the way the config is parsed you need to to escape any closing
parenthesis `)` using a backslash `\)`.

```
static_string {
    # note we need to explicitly cast the result to str
    # because we are using it as the format which must be a
    # string
    format = shell(echo $((6 + 2\)\), str)
}
```

## Refreshing modules on udev events with on_udev dynamic options

Refreshing of modules can be triggered when an udev event is detected on
a specific subsystem using the `on_udev_<subsystem>` configuration
parameter and an associated action.

Possible actions:

- `refresh`: immediately refresh the module and keep on updating it as
    usual
- `refresh_and_freeze`: module is ONLY refreshed when said udev
    subsystem emits an event

```
# refresh xrandr only when udev 'drm' events are triggered
xrandr {
    on_udev_drm = "refresh_and_freeze"
}
```

!!! note
    This feature will only activate when `pyudev` is installed on the system.
    This is an optional dependency of py3status and is therefore not
    enforced by all package managers.

## HTTP Request Settings

### Handling timeouts

Timeouts are handled thanks to the global `request_timeout` setting.

Request Timeout for URL request based modules can be specified in the
module configuration. To find out if your module supports that, look for
`self.py3.request` in the code. Otherwise, we will use `10`.

```
# stop waiting for a response after 10 seconds
exchange_rate {
    request_timeout = 10
}
```

### Handling retries

Retries are handled thanks to the global `request_retry_times` and
`request_retry_wait` settings.

Requests failing due to network unavailability or remote server timeouts
are retried automatically `request_retry_times` times (default `3`) at a
`request_retry_wait` (default `2`) seconds interval.

This allows to be more graceful to i3 startup when network is not up yet
or to short network disruptions and not display an error on the bar in
that case.

To find out if your module supports that, look for `self.py3.request` in
the code.

```
# try to contact the OWM API 10 times every 5 seconds before displaying
# an error on the bar for the module
# that is equivalent to 50 seconds of retrying before an error occurs
weather_owm {
    request_retry_times = 10
    request_retry_wait = 5
}
```

## Running Py3status outside i3bar

Want Py3status in your beloved tmux? Sure!

While Py3status is by default running using the `i3bar` output format,
you can change the `output_format` of the `general` section of the
configuration file to get your favorite status bar in the following
programs:

- i3bar (default)
- dzen2
- lemonbar
- term
- tmux
- xmobar
- none (no special output format)



================================================
FILE: docs/user-guide/installation.md
================================================
# Installation

## Arch Linux

Stable updates, official releases:

```bash
$ pacman -S py3status
```

Real-time updates from master branch:

```bash
$ yay -S py3status-git
```

## Debian & Ubuntu

Stable updates. In testing and unstable, and soon in stable backports:

```bash
$ apt-get install py3status
```

Buster users might want to check out issue #1916 and use pip3 instead or the alternative method proposed until [this debian bug](https://bugs.debian.org/890329) is handled and stable.

!!! note
    If you want to use pip, you should consider using *pypi-install* from
    the *python-stdeb* package (which will create a .deb out from a python
    package) instead of directly calling pip.

```bash
$ pip3 install py3status
```

## Fedora

```bash
$ dnf install py3status
```

## Gentoo Linux

Check available USE flags if you need them!

```bash
$ emerge -a py3status
```

## Alpine Linux

In community repository since Alpine Linux 3.17.

```bash
$ apk add py3status
```

## PyPi

```bash
$ pip install py3status
```

There are optional requirements that you could find useful:

- `py3status[udev]` for udev support.

Or if you want everything:

- `py3status[all]` to install all core extra requirements and features.

## Void Linux

```bash
$ xbps-install -S py3status
```

## NixOS

To have py3status globally persistent add to your NixOS configuration file
py3status as a Python 3 package with:

```
(python3Packages.py3status.overrideAttrs (oldAttrs: {
  propagatedBuildInputs = with python3Packages;[ pytz tzlocal ] ++ oldAttrs.propagatedBuildInputs;
}))
```

If you are, and you probably are, using [i3](https://i3wm.org/) you
might want a section in your `/etc/nixos/configuration.nix` that looks
like this:

```
{
  services.xserver.windowManager.i3 = {
    enable = true;
    extraPackages = with pkgs; [
      dmenu
      i3status
      i3lock
      (python3Packages.py3status.overrideAttrs (oldAttrs: {
        propagatedBuildInputs = with python3Packages; [ pytz tzlocal ] ++ oldAttrs.propagatedBuildInputs;
      }))
    ];
  };
}
```

In this example I included the python packages **pytz** and **tzlocal**
which are necessary for the py3status module **clock**. The default
packages that come with i3 (dmenu, i3status, i3lock) have to be
mentioned if they should still be there.

```bash
$ nix-env -i python3.6-py3status
```



================================================
FILE: docs/user-guide/remote-control.md
================================================
# Controlling py3status remotely

Just like i3status, you can force an update of your i3bar by sending a
SIGUSR1 signal to py3status. Note that this will also send a SIGUSR1
signal to i3status.

```bash
$ killall -USR1 py3status
```

## The py3-cmd CLI

py3status can be controlled remotely via the `py3-cmd` cli utility.

This utility allows you to run a number of commands.

```
# button numbers
1 = left click
2 = middle click
3 = right click
4 = scroll up
5 = scroll down
```

### Commands available

#### click

Send a click event to a module as though it had been clicked on. You can
specify the button to simulate.

```bash
# send a left/middle/right click
$ py3-cmd click --button 1 dpms      # left
$ py3-cmd click --button 2 sysdata   # middle
$ py3-cmd click --button 3 pomodoro  # right

# send a up/down click
$ py3-cmd click --button 4 volume_status  # up
$ py3-cmd click --button 5 volume_status  # down
```

```bash
# toggle button in frame module
$ py3-cmd click --button 1 --index button frame  # left

# change modules in group module
$ py3-cmd click --button 5 --index button group  # down

# change time units in timer module
$ py3-cmd click --button 4 --index hours timer    # up
$ py3-cmd click --button 4 --index minutes timer  # up
$ py3-cmd click --button 4 --index seconds timer  # up
```

#### list

Print a list of modules or module docstrings.

```bash
# list one or more modules
$ py3-cmd list clock loadavg xrandr  # full
$ py3-cmd list coin* git* window*    # fnmatch
$ py3-cmd list [a-e]*                # abcde

# list all modules
$ py3-cmd list --all

# show full (i.e. docstrings)
$ py3-cmd list vnstat uname -f
```

#### refresh

Cause named module(s) to have their output refreshed.

```bash
# refresh all instances of the wifi module
$ py3-cmd refresh wifi

# refresh multiple modules
$ py3-cmd refresh coin_market github weather_yahoo

# refresh module with instance name
$ py3-cmd refresh "weather_yahoo chicago"

# refresh all modules
$ py3-cmd refresh --all
```

### Calling commands from i3

`py3-cmd` can be used in your i3 configuration file.

To send a click event to the whatismyip module when `Mod+x` is pressed

```
bindsym $mod+x exec py3-cmd click whatismyip
```

This example shows how volume control keys can be bound to change the
volume and then cause the `volume_status` module to be updated.

```
bindsym XF86AudioRaiseVolume  exec "amixer -q sset Master 5%+ unmute; py3-cmd refresh volume_status"
bindsym XF86AudioLowerVolume  exec "amixer -q sset Master 5%- unmute; py3-cmd refresh volume_status"
bindsym XF86AudioMute         exec "amixer -q sset Master toggle; py3-cmd refresh volume_status"
```



================================================
FILE: docs/user-guide/user-contributed-conf-examples.md
================================================
# User Contributed Configuration Examples

Here you can find community contributed configuration examples to help
you get started with some modules or benefit from the tricks of other
hackers!

## Ultrabug's configuration examples

```
# one button for bluetooth on/off
bluetooth {
    format = ""
    on_click 1 = "exec bluetoothctl power on"
    on_click 3 = "exec bluetoothctl power off"
}

# I use pulseausio and I like to control the sinks and sources 
# directly from my bar!
#
# These modules allow me to not only control the volume of the given
# devices but to also switch the sound output from one to another

# This is the speakers from my laptop, I can switch sound to it
# on middle click
volume_status speakers {
    command = "pactl"
    device = "alsa_output.pci-0000_00_1f.3.analog-stereo"
    format = "💻{percentage}%"
    format_muted = "💻{percentage}%"
    on_click 2 = "exec pactl set-default-sink alsa_output.pci-0000_00_1f.3.analog-stereo"
    thresholds = [(0, 'bad'), (5, 'degraded'), (10, 'good')]
}

# I plugin a USB headset, it appears, I can switch default sound to
# it while controlling its volume output. When disconnected, it
# disappears from the bar
volume_status sennheiser {
    command = "pactl"
    device = "alsa_output.usb-Sennheiser_"
    format = "[\?if=!percentage=? 🎧{percentage}%]"
    format_muted = '🎧{percentage}%'
    on_click 2 = "exec pactl set-default-sink alsa_output.usb-Sennheiser_Sennheiser_SC_160_USB_A002430203100377-00.analog-stereo"
    thresholds = [(0, 'bad'), (5, 'degraded'), (10, 'good')]
}

# I also can activate a remote bluetooth speaker by clicking on this,
# when it connects the sound percentage appears, I can switch output
# to it by middle clicking or disconnect it by right clicking
volume_status bose {
    command = "pactl"
    device = "bluez_sink..+.a2dp_sink"
    format = "[\?if=!percentage=? 📻{percentage}%][\?if=percentage=? 📻]"
    format_muted = '📻{percentage}%'
    on_click 2 = "exec pactl set-default-sink bluez_sink.2C_41_A1_Z7_FA_C2.a2dp_sink"
    on_click 1 = "exec bluetoothctl connect 2C:41:A1:Z7:FA:C2"
    on_click 3 = "exec bluetoothctl disconnect 2C:41:A1:Z7:FA:C2"
    thresholds = [(0, 'bad'), (5, 'degraded'), (10, 'good')]
    max_volume = 200
}

# I also control the default microphone volume from the bar
# and can mute it
volume_status mic {
    format = '🎙️{percentage}%'
    format_muted = '🎙️{percentage}%'
    button_down = 5
    button_mute = 1
    button_up = 4
    is_input = true
    thresholds = [(0, 'bad'), (10, 'degraded'), (20, 'good')]
}

# DMPS status shows as a red/green screen
dpms {
    icon_off = ""
    icon_on = ""
}

# cycling time in meaningful cities
group tz {
    cycle = 10
    format = "{output}"
    #click_mode = "button"

    tztime la {
        format = "🌉%H:%M"
        timezone = "America/Los_Angeles"
    }

    tztime ny {
        format = "🗽%H:%M"
        timezone = "America/New_York"
    }

    tztime du {
        format = "🕌%H:%M"
        timezone = "Asia/Dubai"
    }

    tztime tw {
        format = "⛩️%H:%M"
        timezone = "Asia/Taipei"
    }

    tztime in {
        format = "🛕%H:%M"
        timezone = "Asia/Kolkata"
    }
}
```

## CorruptCommit's configuration examples

```
# If I had time, I would make these proper modules.  Free feel to make them
# if you got time.

# weather without needing an API key
getjson wttr {
    url = "https://wttr.in/Paris?format=j1"
    format = "{current_condition-0-FeelsLikeC}° {current_condition-0-weatherDesc-0-value}"
    cache_timeout = 3600
}

# example output
# 6° Partly cloudy

# SABnzbd status
getjson sabnzbd {
    url = "https://sabnzbd.example.com/api?mode=queue&apikey=000000000&output=json"
    format = "SABnzbd: {queue-status}"
    cache_timeout = 60
}
# example output
# SABnzbd: Idle
```



================================================
FILE: py3status/__init__.py
================================================
import locale
import sys

try:
    from setproctitle import setproctitle

    setproctitle("py3status")
except ImportError:
    pass


def main():
    from py3status.argparsers import parse_cli_args

    options = parse_cli_args()

    from py3status.core import Py3statusWrapper

    try:
        locale.setlocale(locale.LC_ALL, "")
    except locale.Error as err:
        print(f"No locale available ({err})")
        sys.exit(2)

    py3 = None
    try:
        py3 = Py3statusWrapper(options)
        py3.setup()
    except (BrokenPipeError, KeyboardInterrupt) as err:
        if py3:
            py3.notify_user(f"Setup interrupted ({err})")
        sys.exit(0)
    except Exception as err:
        if py3:
            py3.report_exception(f"Setup error ({err})")
        else:
            # we cannot report this Exception
            raise
        sys.exit(2)

    try:
        py3.run()
    except (BrokenPipeError, KeyboardInterrupt):
        pass
    except Exception as err:
        py3.report_exception(f"Runtime error ({err})")
        sys.exit(3)
    finally:
        py3.stop()
        sys.exit(0)


if __name__ == "__main__":
    main()



================================================
FILE: py3status/argparsers.py
================================================
import argparse
import os
import subprocess
from pathlib import Path
from platform import python_version
from shutil import which

from py3status.version import version


def parse_cli_args():
    """
    Parse the command line arguments
    """
    # get config paths
    home_path = Path.home()
    xdg_home_path = Path(os.environ.get("XDG_CONFIG_HOME", home_path / ".config"))
    xdg_dirs_path = Path(os.environ.get("XDG_CONFIG_DIRS", "/etc/xdg"))

    # get window manager
    with Path(os.devnull).open("w") as devnull:
        if subprocess.call(["pgrep", "^(i3|i3-with-shmlog)$"], stdout=devnull) == 0:
            wm = "i3"
        else:
            wm = "sway"

    # i3status config file default detection
    # respect i3status' file detection order wrt issue #43
    i3status_config_file_candidates = [
        xdg_home_path / "py3status/config",
        xdg_home_path / "i3status/config",
        xdg_home_path / "i3/i3status.conf",  # custom
        home_path / ".i3status.conf",
        home_path / ".i3/i3status.conf",  # custom
        xdg_dirs_path / "i3status/config",
        Path("/etc/i3status.conf"),
    ]
    for path in i3status_config_file_candidates:
        if path.exists():
            i3status_config_file_default = path
            break
    else:
        # if files does not exists, defaults to ~/.i3/i3status.conf
        i3status_config_file_default = i3status_config_file_candidates[3]

    class Parser(argparse.ArgumentParser):
        # print usages and exit on errors
        def error(self, message):
            print(f"\x1b[1;31merror: \x1b[0m{message}")
            self.print_help()
            self.exit(1)

        # hide choices on errors
        def _check_value(self, action, value):
            if action.choices is not None and value not in action.choices:
                raise argparse.ArgumentError(action, f"invalid choice: '{value}'")

    class HelpFormatter(argparse.ArgumentDefaultsHelpFormatter):
        def _format_action_invocation(self, action):
            metavar = self._format_args(action, action.dest.upper())
            return "{} {}".format(", ".join(action.option_strings), metavar)

    # command line options
    parser = Parser(
        description="The agile, python-powered, i3status wrapper",
        formatter_class=HelpFormatter,
    )
    parser.add_argument(
        "-b",
        "--dbus-notify",
        action="store_true",
        dest="dbus_notify",
        help="send notifications via dbus instead of i3-nagbar",
    )
    parser.add_argument(
        "-c",
        "--config",
        action="store",
        default=i3status_config_file_default,
        dest="i3status_config_path",
        help="load config",
        metavar="FILE",
        type=Path,
    )
    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        help="enable debug logging in syslog or log file if --log-file option is passed",
    )
    parser.add_argument(
        "-i",
        "--include",
        action="append",
        dest="include_paths",
        help="append additional user-defined module paths",
        metavar="PATH",
        type=Path,
    )
    parser.add_argument(
        "-l",
        "--log-file",
        action="store",
        dest="log_file",
        help="enable logging to FILE (this option is not set by default)",
        metavar="FILE",
        type=Path,
    )
    parser.add_argument(
        "-s",
        "--standalone",
        action="store_true",
        dest="standalone",
        help="run py3status without i3status",
    )
    parser.add_argument(
        "-t",
        "--timeout",
        action="store",
        default=60,
        dest="cache_timeout",
        help="default module cache timeout in seconds",
        metavar="INT",
        type=int,
    )
    parser.add_argument(
        "-m",
        "--disable-click-events",
        action="store_true",
        dest="disable_click_events",
        help="disable all click events",
    )
    parser.add_argument(
        "-u",
        "--i3status",
        action="store",
        default=which("i3status") or "i3status",
        dest="i3status_path",
        help="specify i3status path",
        metavar="PATH",
        type=Path,
    )
    parser.add_argument(
        "-v",
        "--version",
        action="store_true",
        dest="print_version",
        help="show py3status version and exit",
    )
    parser.add_argument(
        "--wm",
        action="store",  # add comment to preserve formatting
        dest="wm",
        metavar="WINDOW_MANAGER",
        default=wm,
        choices=["i3", "sway"],
        help="specify window manager i3 or sway",
    )

    # parse options, command, etc
    options = parser.parse_args()

    # make versions
    options.python_version = python_version()
    options.version = version
    if options.print_version:
        msg = "py3status version {version} (python {python_version}) on {wm}"
        print(msg.format(**vars(options)))
        parser.exit()

    # get wm
    options.wm_name = options.wm
    options.wm = {
        "i3": {"msg": "i3-msg", "nag": "i3-nagbar"},
        "sway": {"msg": "swaymsg", "nag": "swaynag"},
    }[options.wm]

    # make include path to search for user modules if None
    if not options.include_paths:
        options.include_paths = [
            xdg_home_path / "py3status/modules",
            xdg_home_path / "i3status/py3status",
            xdg_home_path / "i3/py3status",
            home_path / ".i3/py3status",
        ]

    include_paths = []
    for path in options.include_paths:
        path = path.resolve()
        if path.is_dir() and any(path.iterdir()):
            include_paths.append(path)
    options.include_paths = include_paths

    # defaults
    del options.print_version
    options.minimum_interval = 0.1  # minimum module update interval
    options.click_events = not options.__dict__.pop("disable_click_events")

    # all done
    return options



================================================
FILE: py3status/autodoc.py
================================================
import re
from pathlib import Path

from py3status.docstrings import core_module_docstrings
from py3status.screenshots import create_screenshots, get_samples


def file_sort(my_list):
    """
    Sort a list of files in a nice way.
    eg item-10 will be after item-9
    """

    def alphanum_key(key):
        """
        Split the key into str/int parts
        """
        return [int(s) if s.isdigit() else s for s in re.split("([0-9]+)", key)]

    my_list.sort(key=alphanum_key)
    return my_list


def screenshots(config, screenshots_data, module_name):
    """
    Create .md output for any screenshots a module may have.
    """
    shots = screenshots_data.get(module_name)
    if not shots:
        return ""

    out = []
    for index, shot in enumerate(file_sort(shots)):
        if not Path(f"{config['docs_dir']}/user-guide/screenshots/{shot}.png").exists():
            continue
        out.append(f"\n![{module_name} example {index}](screenshots/{shot}.png)\n")
    return "".join(out)


def create_module_docs(config):
    """
    Create documentation for modules.
    """
    data = core_module_docstrings(format="md")
    # get screenshot data
    screenshots_data = {}
    samples = get_samples()
    for sample in samples:
        module = sample.split("-")[0]
        if module not in screenshots_data:
            screenshots_data[module] = []
        screenshots_data[module].append(sample)

    out = ["# Available modules"]
    # details
    for module in sorted(data):
        out.append(
            "\n## {name}\n\n{screenshots}\n{details}\n".format(
                name=module,
                screenshots=screenshots(config, screenshots_data, module),
                details="".join(data[module]).strip(),
            )
        )
    # write include file
    path = f"{config['docs_dir']}/user-guide/modules.md"
    print(f"Writing modules documentation to {path}...")
    Path(path).write_text("".join(out))
    return config


def on_config(config):
    """
    Create any include files needed for sphinx documentation
    """
    create_screenshots(config)
    create_module_docs(config)
    return config



================================================
FILE: py3status/command.py
================================================
import argparse
import json
import os
import socket
import threading
from pathlib import Path

SERVER_ADDRESS = "/tmp/py3status_uds"
MAX_SIZE = 1024

CLICK_EPILOG = """
examples:
    button:
        # send a left/middle/right click
        py3-cmd click --button 1 dpms      # left
        py3-cmd click --button 2 sysdata   # middle
        py3-cmd click --button 3 pomodoro  # right

        # send a up/down click
        py3-cmd click --button 4 volume_status  # up
        py3-cmd click --button 5 volume_status  # down

    index:
        # toggle button in frame module
        py3-cmd click --button 1 --index button frame  # left

        # change modules in group module
        py3-cmd click --button 5 --index button group  # down

        # change time units in timer module
        py3-cmd click --button 4 --index hours timer    # up
        py3-cmd click --button 4 --index minutes timer  # up
        py3-cmd click --button 4 --index seconds timer  # up

    height, modifiers, relative_x, relative_y, width, x, y:
        # py3-cmd allows users to specify click events with
        # more options. however, there are no modules that
        # uses the aforementioned options.
"""
DOCSTRING_EPILOG = """
examples:
    check:
        # check one or more docstrings
        py3-cmd docstring --check clock loadavg xrandr

        # check all docstrings
        py3-cmd docstring --check

    diff:
        # show diff docstrings
        py3-cmd docstring --diff

    update:
        # update one or more docstrings
        py3-cmd docstring --update clock loadavg xrandr

        # update modules according to README.md
        py3-cmd docstring --update modules
"""
LIST_EPILOG = """
examples:
    list:
        # list one or more modules
        py3-cmd list clock loadavg xrandr  # full
        py3-cmd list coin* git* window*    # fnmatch
        py3-cmd list [a-e]*                # abcde

        # list all modules
        py3-cmd list --all

        # show full (i.e. docstrings)
        py3-cmd list vnstat uname -f
"""
REFRESH_EPILOG = """
examples:
    refresh:
        # refresh all instances of the wifi module
        py3-cmd refresh wifi

        # refresh multiple modules
        py3-cmd refresh coin_market github weather_yahoo

        # refresh a module with instance name
        py3-cmd refresh "weather_yahoo chicago"

        # refresh all modules
        py3-cmd refresh --all
"""
EPILOGS = {
    "refresh": REFRESH_EPILOG,
    "list": LIST_EPILOG,
    "docstring": DOCSTRING_EPILOG,
    "click": CLICK_EPILOG,
}
INFORMATION = [
    ("V", "version", "show version number and exit"),
    ("v", "verbose", "enable verbose mode"),
]
SUBPARSERS = [
    ("click", "click modules", "+"),
    ("docstring", "docstring utility", "*"),
    ("list", "list modules", "*"),
    ("refresh", "refresh modules", "*"),
    # ('exec', 'execute methods', '+'),
]
CLICK_OPTIONS = [
    ("button", "specify a button number (default %(default)s)"),
    ("height", "specify a height of the block, in pixel"),
    ("index", "specify an index value often found in modules"),
    ("modifiers", "specify modifiers, optionally joined by plus signs"),
    ("relative_x", "specify relative X on the block, from the top left"),
    ("relative_y", "specify relative Y on the block, from the top left"),
    ("width", "specify a width of the block, in pixel"),
    ("x", "specify absolute X on the bar, from the top left"),
    ("y", "specify absolute Y on the bar, from the top left"),
]
LIST_OPTIONS = [
    ("", "all", "show all modules"),
    ("", "core", "show core modules"),
    ("", "user", "show user modules"),
    ("f", "full", "show full (i.e. docstrings)"),
]
DOCSTRING_OPTIONS = [
    ("check", "check docstrings"),
    ("diff", "diff docstrings"),
    ("update", "update docstrings"),
]
REFRESH_OPTIONS = [("all", "refresh all modules")]


class CommandRunner:
    """
    Encapsulates the remote commands that are available to run.
    """

    def __init__(self, py3_wrapper):
        self.debug = py3_wrapper.config["debug"]
        self.py3_wrapper = py3_wrapper

    def find_modules(self, requested_names):
        """
        find the module(s) given the name(s)
        """
        found_modules = set()
        for requested_name in requested_names:
            is_instance = " " in requested_name

            for module_name, module in self.py3_wrapper.output_modules.items():
                if module["type"] == "py3status":
                    name = module["module"].module_nice_name
                else:
                    name = module["module"].module_name
                if is_instance:
                    if requested_name == name:
                        found_modules.add(module_name)
                else:
                    if requested_name == name.split(" ")[0]:
                        found_modules.add(module_name)

        if self.debug:
            self.py3_wrapper.log(f"found {found_modules}")
        return found_modules

    def refresh(self, data):
        """
        refresh the module(s)
        """
        modules = data.get("module")
        # for i3status modules we have to refresh the whole i3status output.
        update_i3status = False
        for module_name in self.find_modules(modules):
            module = self.py3_wrapper.output_modules[module_name]
            if self.debug:
                self.py3_wrapper.log(f"refresh {module}")
            if module["type"] == "py3status":
                module["module"].force_update()
            else:
                update_i3status = True
        if update_i3status:
            self.py3_wrapper.i3status_thread.refresh_i3status()

    def click(self, data):
        """
        send a click event to the module(s)
        """
        modules = data.get("module")
        for module_name in self.find_modules(modules):
            module = self.py3_wrapper.output_modules[module_name]
            if module["type"] == "py3status":
                name = module["module"].module_name
                instance = module["module"].module_inst
            else:
                name = module["module"].name
                instance = module["module"].instance
            # make an event
            event = {"name": name, "instance": instance}
            for name, message in CLICK_OPTIONS:
                event[name] = data.get(name)

            if self.debug:
                self.py3_wrapper.log(event)
            # trigger the event
            self.py3_wrapper.events_thread.dispatch_event(event)

    def run_command(self, data):
        """
        check the given command and send to the correct dispatcher
        """
        command = data.get("command")
        if self.debug:
            self.py3_wrapper.log(f"Running remote command {command}")
        if command == "refresh":
            self.refresh(data)
        elif command == "refresh_all":
            self.py3_wrapper.refresh_modules()
        elif command == "click":
            self.click(data)


class CommandServer(threading.Thread):
    """
    Set up a Unix domain socket to allow commands to be sent to py3status
    instance.
    """

    def __init__(self, py3_wrapper):
        threading.Thread.__init__(self)

        self.debug = py3_wrapper.config["debug"]
        self.py3_wrapper = py3_wrapper

        self.command_runner = CommandRunner(py3_wrapper)
        server_address = Path(f"{SERVER_ADDRESS}.{os.getpid()}")
        self.server_address = server_address

        # Make sure the socket does not already exist
        try:
            server_address.unlink()
        except OSError:
            if server_address.exists():
                raise

        # Create a UDS socket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(server_address.as_posix())

        if self.debug:
            self.py3_wrapper.log(f"Unix domain socket at {server_address}")

        # Listen for incoming connections
        sock.listen(1)
        self.sock = sock

    def kill(self):
        """
        Remove the socket as it is no longer needed.
        """
        try:
            self.server_address.unlink()
        except OSError:
            if self.server_address.exists():
                raise

    def run(self):
        """
        Main thread listen to socket and send any commands to the
        CommandRunner.
        """
        while True:
            try:
                data = None
                # Wait for a connection
                if self.debug:
                    self.py3_wrapper.log("waiting for a connection")

                connection, client_address = self.sock.accept()
                try:
                    if self.debug:
                        self.py3_wrapper.log("connection from")

                    data = connection.recv(MAX_SIZE)
                    if data:
                        data = json.loads(data.decode("utf-8"))
                        if self.debug:
                            self.py3_wrapper.log(f"received {data}")
                        self.command_runner.run_command(data)
                finally:
                    # Clean up the connection
                    connection.close()
            except Exception:
                if data:
                    self.py3_wrapper.log("Command error")
                    self.py3_wrapper.log(data)
                self.py3_wrapper.report_exception("command failed")


def command_parser():
    """
    build and return our command parser
    """

    class Parser(argparse.ArgumentParser):
        # print usages and exit on errors
        def error(self, message):
            print(f"\x1b[1;31merror: \x1b[0m{message}")
            self.print_help()
            self.exit(1)

        # hide choices on errors
        def _check_value(self, action, value):
            if action.choices is not None and value not in action.choices:
                raise argparse.ArgumentError(action, f"invalid choice: '{value}'")

    # make parser
    parser = Parser(formatter_class=argparse.RawTextHelpFormatter)

    # parser: add verbose, version
    for short, name, msg in INFORMATION:
        parser.add_argument(f"-{short}", f"--{name}", action="store_true", help=msg)

    # make subparsers // ALIAS_DEPRECATION: remove metavar later
    metavar = "{click,list,refresh}"
    subparsers = parser.add_subparsers(dest="command", metavar=metavar)
    sps = {}

    # subparsers: add click, list, refresh... hide docstring
    data = {"formatter_class": argparse.RawTextHelpFormatter}
    for name, msg, nargs in SUBPARSERS:
        data.update({"epilog": EPILOGS[name], "help": msg})
        # don't show docstring in py3-cmd --help
        if name in ["docstring"]:
            del data["help"]
        sps[name] = subparsers.add_parser(name, **data)
        sps[name].add_argument(nargs=nargs, dest="module", help="module name")

    # ALIAS_DEPRECATION: subparsers: add click (aliases)
    buttons = {
        "leftclick": 1,
        "middleclick": 2,
        "rightclick": 3,
        "scrollup": 4,
        "scrolldown": 5,
    }
    for name in sorted(buttons):
        sps[name] = subparsers.add_parser(name)
        sps[name].add_argument(nargs="+", dest="module", help="module name")

    # click subparser: add button, index, width, height, relative_{x,y}, x, y
    sp = sps["click"]
    for name, msg in CLICK_OPTIONS:
        arg = f"--{name}"
        if name == "button":
            sp.add_argument(arg, metavar="INT", type=int, help=msg, default=1)
        elif name == "index":
            sp.add_argument(arg, metavar="INDEX", help=msg)
        elif name == "modifiers":
            sp.add_argument(arg, metavar="KEY", help=msg)
        else:
            sp.add_argument(arg, metavar="INT", type=int, help=msg)

    # docstring subparser: add check, diff, update
    sp = sps["docstring"]
    for name, msg in DOCSTRING_OPTIONS:
        arg = f"--{name}"
        sp.add_argument(arg, action="store_true", help=msg)

    # refresh subparser: add all
    sp = sps["refresh"]
    for name, msg in REFRESH_OPTIONS:
        arg = f"--{name}"
        sp.add_argument(arg, action="store_true", help=msg)

    # list subparser: add all, core, user, full
    sp = sps["list"]
    for short, name, msg in LIST_OPTIONS:
        name = f"--{name}"
        if short:
            short = f"-{short}"
            sp.add_argument(short, name, action="store_true", help=msg)
        else:
            sp.add_argument(name, action="store_true", help=msg)

    # parse args, post-processing
    options = parser.parse_args()

    if options.command == "click":
        # cast string index to int
        if options.index:
            try:
                options.index = int(options.index)
            except ValueError:
                pass
        # specify modifiers, optionally joined by plus signs
        if options.modifiers:
            options.modifiers = options.modifiers.split("+")
        else:
            options.modifiers = []
    elif options.command == "refresh":
        # refresh all
        # ALL_DEPRECATION
        if options.module is None:
            options.module = []
        # end
        valid = False
        if options.all:  # keep this
            options.command = "refresh_all"
            options.module = []
            valid = True
        if "all" in options.module:  # remove this later
            options.command = "refresh_all"
            options.module = []
            valid = True
        if not options.module and not valid:
            sps["refresh"].error("missing positional or optional arguments")
    elif options.command in ["list", "docstring"]:
        parse_list_or_docstring(options, sps)
        parser.exit()
    elif options.version:
        # print version
        from platform import python_version

        from py3status.version import version

        print(f"py3status {version} (python {python_version()})")
        parser.exit()
    elif not options.command:
        parser.error("too few arguments")

    # ALIAS_DEPRECATION
    alias = options.command in buttons

    # py3-cmd click 3 dpms ==> py3-cmd click --button 3 dpms
    new_modules = []
    for index, name in enumerate(options.module):
        if name.isdigit():
            if alias:
                continue
            if not index:  # zero index
                options.button = int(name)
        else:
            new_modules.append(name)

    # ALIAS_DEPRECATION: Convert (click) aliases to buttons
    if alias:
        options.button = buttons[options.command]
        options.command = "click"

    if options.command == "click" and not new_modules:
        sps[options.command].error("too few arguments")
    options.module = new_modules

    return options


def parse_list_or_docstring(options, sps):
    """
    Handle py3-cmd list and docstring options.
    """
    import py3status.docstrings as docstrings

    # HARDCODE: make include path to search for user modules
    home_path = Path.home()
    xdg_home_path = Path(os.environ.get("XDG_CONFIG_HOME", home_path / ".config")).resolve()
    options.include_paths = [
        xdg_home_path / "py3status/modules",
        xdg_home_path / "i3status/py3status",
        xdg_home_path / "i3/py3status",
        home_path / ".i3/py3status",
    ]
    include_paths = []
    for path in options.include_paths:
        if path.is_dir() and any(path.iterdir()):
            include_paths.append(path)
    options.include_paths = include_paths

    # init
    config = vars(options)
    modules = [Path(x).stem for x in config["module"]]

    # list module names and details
    if config["command"] == "list":
        tests = [not config[x] for x in ["all", "user", "core"]]
        if all([not modules] + tests):
            msg = "missing positional or optional arguments"
            sps["list"].error(msg)
        docstrings.show_modules(config, modules)

    # docstring formatting and checking
    elif config["command"] == "docstring":
        if config["check"]:
            docstrings.check_docstrings(False, config, modules)
        elif config["diff"]:
            docstrings.check_docstrings(True, config, None)
        elif config["update"]:
            if not modules:
                msg = "missing positional arguments or `modules`"
                sps["docstring"].error(msg)
            if "modules" in modules:
                docstrings.update_docstrings()
            else:
                docstrings.update_readme_for_modules(modules)
        else:
            msg = "missing positional or optional arguments"
            sps["docstring"].error(msg)


def send_command():
    """
    Run a remote command. This is called via py3-cmd utility.

    We look for any uds sockets with the correct name prefix and send our
    command to all that we find.  This allows us to communicate with multiple
    py3status instances.
    """

    def verbose(msg):
        """
        print output if verbose is set.
        """
        if options.verbose:
            print(msg)

    options = command_parser()
    msg = json.dumps(vars(options)).encode("utf-8")
    if len(msg) > MAX_SIZE:
        verbose(f"Message length too long, max length ({MAX_SIZE})")

    # find all likely socket addresses
    uds_list = Path(SERVER_ADDRESS).parent.glob(f"{Path(SERVER_ADDRESS).name}.[0-9]*")

    verbose(f"message {msg!r}")
    for uds in uds_list:
        # Create a UDS socket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

        # Connect the socket to the port where the server is listening
        verbose(f"connecting to {uds}")
        try:
            sock.connect(uds.as_posix())
        except OSError:
            # this is a stale socket so delete it
            verbose("stale socket deleting")
            try:
                uds.unlink()
            except OSError:
                pass
            continue
        try:
            # Send data
            verbose("sending")
            sock.sendall(msg)
        finally:
            verbose("closing socket")
            sock.close()



================================================
FILE: py3status/composite.py
================================================
class Composite:
    """
    Helper class to identify a composite and store its content
    A Composite is essentially a wrapped list containing response items.
    """

    def __init__(self, content=None):
        # try and create a composite from various input types
        if content is None:
            content = []
        elif isinstance(content, Composite):
            content = content.get_content()[:]
        elif isinstance(content, dict):
            content = [content]
        elif isinstance(content, str):
            content = [{"full_text": content}]

        assert isinstance(content, list)
        self._content = content

    def __repr__(self):
        return f"<Composite {self._content}>"

    def __len__(self):
        return len(self._content)

    def __getitem__(self, key):
        if isinstance(key, slice):
            return Composite(self._content[key])
        return self._content[key]

    def __setitem__(self, key, value):
        self._content[key] = value

    def __delitem__(self, key):
        del self._content[key]

    def __iter__(self):
        return iter(self._content)

    def __iadd__(self, other):
        self.append(other)
        return self

    def copy(self):
        """
        Return a shallow copy of the Composite
        """
        return Composite([x.copy() for x in self._content])

    def append(self, item):
        """
        Add an item to the Composite.  Item can be a Composite, list etc
        """
        if isinstance(item, Composite):
            self._content += item.get_content()
        elif isinstance(item, list):
            self._content += item
        elif isinstance(item, dict):
            self._content.append(item)
        elif isinstance(item, str):
            self._content.append({"full_text": item})
        else:
            msg = "{!r} not suitable to append to Composite"
            raise Exception(msg.format(item))

    def get_content(self):
        """
        Retrieve the contained list
        """
        return self._content

    def text(self):
        """
        Return the text only component of the composite.
        """
        return "".join(x.get("full_text", "") for x in self._content)

    def simplify(self):
        """
        Simplify the content of a Composite merging any parts that can be
        and returning the new Composite as well as updating itself internally
        """
        final_output = []
        diff_last = None
        item_last = None
        for item in self._content:
            # remove any undefined colors
            if hasattr(item.get("color"), "none_setting"):
                del item["color"]
            # ignore empty items
            if not item.get("full_text") and not item.get("separator"):
                continue
            # merge items if we can
            diff = item.copy()
            del diff["full_text"]

            if diff == diff_last or (item["full_text"].strip() == "" and item_last):
                item_last["full_text"] += item["full_text"]
            else:
                diff_last = diff
                item_last = item.copy()  # copy item as we may change it
                final_output.append(item_last)
        self._content = final_output
        return self

    @staticmethod
    def composite_join(separator, items):
        """
        Join a list of items with a separator.
        This is used in joining strings, responses and Composites.
        The output will be a Composite.
        """
        output = Composite()
        first_item = True
        for item in items:
            # skip empty items
            if not item:
                continue
            # skip separator on first item
            if first_item:
                first_item = False
            else:
                output.append(separator)
            output.append(item)
        return output

    @staticmethod
    def composite_update(item, update_dict, soft=False):
        """
        Takes a Composite (item) and updates all entries with values from
        update_dict.  Updates can be soft in which case existing values are not
        overwritten.

        If item is of type string it is first converted to a Composite
        """
        item = Composite(item)

        for part in item.get_content():
            if soft:
                for key, value in update_dict.items():
                    if key not in part:
                        part[key] = value
            else:
                part.update(update_dict)
        return item



================================================
FILE: py3status/constants.py
================================================
# This file contains various useful constants for py3status

GENERAL_DEFAULTS = {
    "color_bad": "#FF0000",
    "color_degraded": "#FFFF00",
    "color_good": "#00FF00",
    "color_separator": "#333333",
    "colors": True,
    "interval": 5,
    "output_format": None,
}

MAX_NESTING_LEVELS = 4

TIME_FORMAT = "%Y-%m-%d %H:%M:%S"

TZTIME_FORMAT = "%Y-%m-%d %H:%M:%S %Z"

TIME_MODULES = ["time", "tztime"]

I3S_INSTANCE_MODULES = [
    "battery",
    "cpu_temperature",
    "disk",
    "ethernet",
    "memory",
    "path_exists",
    "read_file",
    "run_watch",
    "tztime",
    "volume",
    "wireless",
]

I3S_SINGLE_NAMES = ["cpu_usage", "ddate", "ipv6", "load", "time"]

I3S_ALLOWED_COLORS = ["color_bad", "color_good", "color_degraded"]

# i3status modules that allow colors to be passed.
# general section also allows colors so is included.
I3S_COLOR_MODULES = ["general", "battery", "cpu_temperature", "disk", "load"]

I3S_MODULE_NAMES = I3S_SINGLE_NAMES + I3S_INSTANCE_MODULES

CONFIG_FILE_SPECIAL_SECTIONS = ["general", "py3status"]

ERROR_CONFIG = """
    general {colors = true interval = 60}

    order += "static_string py3status"
    order += "tztime local"
    order += "group error"

    static_string py3status {format = "py3status"}
    tztime local {format = "%c"}
    group error{
        button_next = 1
        button_prev = 0
        fixed_width = False
        format = "{output}"
        static_string error_min {format = "CONFIG ERROR" color = "#FF0000"}
        static_string error {format = "$error" color = "#FF0000"}
}
"""

COLOR_NAMES_EXCLUDED = ["good", "bad", "degraded", "separator", "threshold", "None"]

COLOR_NAMES = {
    "aliceblue": "#F0F8FF",
    "antiquewhite": "#FAEBD7",
    "aqua": "#00FFFF",
    "aquamarine": "#7FFFD4",
    "azure": "#F0FFFF",
    "beige": "#F5F5DC",
    "bisque": "#FFE4C4",
    "black": "#000000",
    "blanchedalmond": "#FFEBCD",
    "blue": "#0000FF",
    "blueviolet": "#8A2BE2",
    "brown": "#A52A2A",
    "burlywood": "#DEB887",
    "cadetblue": "#5F9EA0",
    "chartreuse": "#7FFF00",
    "chocolate": "#D2691E",
    "coral": "#FF7F50",
    "cornflowerblue": "#6495ED",
    "cornsilk": "#FFF8DC",
    "crimson": "#DC143C",
    "cyan": "#00FFFF",
    "darkblue": "#00008B",
    "darkcyan": "#008B8B",
    "darkgoldenrod": "#B8860B",
    "darkgray": "#A9A9A9",
    "darkgrey": "#A9A9A9",
    "darkgreen": "#006400",
    "darkkhaki": "#BDB76B",
    "darkmagenta": "#8B008B",
    "darkolivegreen": "#556B2F",
    "darkorange": "#FF8C00",
    "darkorchid": "#9932CC",
    "darkred": "#8B0000",
    "darksalmon": "#E9967A",
    "darkseagreen": "#8FBC8F",
    "darkslateblue": "#483D8B",
    "darkslategray": "#2F4F4F",
    "darkslategrey": "#2F4F4F",
    "darkturquoise": "#00CED1",
    "darkviolet": "#9400D3",
    "deeppink": "#FF1493",
    "deepskyblue": "#00BFFF",
    "dimgray": "#696969",
    "dimgrey": "#696969",
    "dodgerblue": "#1E90FF",
    "firebrick": "#B22222",
    "floralwhite": "#FFFAF0",
    "forestgreen": "#228B22",
    "fuchsia": "#FF00FF",
    "gainsboro": "#DCDCDC",
    "ghostwhite": "#F8F8FF",
    "gold": "#FFD700",
    "goldenrod": "#DAA520",
    "gray": "#808080",
    "grey": "#808080",
    "green": "#008000",
    "greenyellow": "#ADFF2F",
    "honeydew": "#F0FFF0",
    "hotpink": "#FF69B4",
    "indianred": "#CD5C5C",
    "indigo": "#4B0082",
    "ivory": "#FFFFF0",
    "khaki": "#F0E68C",
    "lavender": "#E6E6FA",
    "lavenderblush": "#FFF0F5",
    "lawngreen": "#7CFC00",
    "lemonchiffon": "#FFFACD",
    "lightblue": "#ADD8E6",
    "lightcoral": "#F08080",
    "lightcyan": "#E0FFFF",
    "lightgoldenrodyellow": "#FAFAD2",
    "lightgray": "#D3D3D3",
    "lightgrey": "#D3D3D3",
    "lightgreen": "#90EE90",
    "lightpink": "#FFB6C1",
    "lightsalmon": "#FFA07A",
    "lightseagreen": "#20B2AA",
    "lightskyblue": "#87CEFA",
    "lightslategray": "#778899",
    "lightslategrey": "#778899",
    "lightsteelblue": "#B0C4DE",
    "lightyellow": "#FFFFE0",
    "lime": "#00FF00",
    "limegreen": "#32CD32",
    "linen": "#FAF0E6",
    "magenta": "#FF00FF",
    "maroon": "#800000",
    "mediumaquamarine": "#66CDAA",
    "mediumblue": "#0000CD",
    "mediumorchid": "#BA55D3",
    "mediumpurple": "#9370DB",
    "mediumseagreen": "#3CB371",
    "mediumslateblue": "#7B68EE",
    "mediumspringgreen": "#00FA9A",
    "mediumturquoise": "#48D1CC",
    "mediumvioletred": "#C71585",
    "midnightblue": "#191970",
    "mintcream": "#F5FFFA",
    "mistyrose": "#FFE4E1",
    "moccasin": "#FFE4B5",
    "navajowhite": "#FFDEAD",
    "navy": "#000080",
    "oldlace": "#FDF5E6",
    "olive": "#808000",
    "olivedrab": "#6B8E23",
    "orange": "#FFA500",
    "orangered": "#FF4500",
    "orchid": "#DA70D6",
    "palegoldenrod": "#EEE8AA",
    "palegreen": "#98FB98",
    "paleturquoise": "#AFEEEE",
    "palevioletred": "#DB7093",
    "papayawhip": "#FFEFD5",
    "peachpuff": "#FFDAB9",
    "peru": "#CD853F",
    "pink": "#FFC0CB",
    "plum": "#DDA0DD",
    "powderblue": "#B0E0E6",
    "purple": "#800080",
    "rebeccapurple": "#663399",
    "red": "#FF0000",
    "rosybrown": "#BC8F8F",
    "royalblue": "#4169E1",
    "saddlebrown": "#8B4513",
    "salmon": "#FA8072",
    "sandybrown": "#F4A460",
    "seagreen": "#2E8B57",
    "seashell": "#FFF5EE",
    "sienna": "#A0522D",
    "silver": "#C0C0C0",
    "skyblue": "#87CEEB",
    "slateblue": "#6A5ACD",
    "slategray": "#708090",
    "slategrey": "#708090",
    "snow": "#FFFAFA",
    "springgreen": "#00FF7F",
    "steelblue": "#4682B4",
    "tan": "#D2B48C",
    "teal": "#008080",
    "thistle": "#D8BFD8",
    "tomato": "#FF6347",
    "turquoise": "#40E0D0",
    "violet": "#EE82EE",
    "wheat": "#F5DEB3",
    "white": "#FFFFFF",
    "whitesmoke": "#F5F5F5",
    "yellow": "#FFFF00",
    "yellowgreen": "#9ACD32",
}

ON_TRIGGER_ACTIONS = ["refresh", "refresh_and_freeze"]

POSITIONS = ["left", "center", "right"]

RETIRED_MODULES = {
    "bitcoin_price": {
        "new": ["coin_market"],
        "msg": "Module {old} is no longer available due to unmaintained APIs. You can try a different module {new}.",
    },
    "clementine": {
        "new": ["playerctl"],
        "msg": "Module {old} has been replaced with a module {new}.",
    },
    "gpmdp": {
        "new": ["playerctl"],
        "msg": "Module {old} has been replaced with a module {new}.",
    },
    "nvidia_temp": {
        "new": ["nvidia_smi"],
        "msg": "Module {old} has been replaced with a module {new}.",
    },
    "player_control": {
        "new": ["playerctl"],
        "msg": "Module {old} has been replaced with a module {new}.",
    },
    "scratchpad_async": {
        "new": ["scratchpad"],
        "msg": "Module {old} has been replaced with a consolidated module {new}.",
    },
    "scratchpad_counter": {
        "new": ["scratchpad"],
        "msg": "Module {old} has been replaced with a consolidated module {new}.",
    },
    "window_title": {
        "new": ["window"],
        "msg": "Module {old} has been replaced with a consolidated module {new}.",
    },
    "window_title_async": {
        "new": ["window"],
        "msg": "Module {old} has been replaced with a consolidated module {new}.",
    },
    "weather_yahoo": {
        "new": ["weather_owm"],
        "msg": "Module {old} is no longer available due to retired Yahoo Weather APIs and new Oath requirements. You can try a different module {new}.",
    },
    "xkb_layouts": {
        "new": ["xkb_input"],
        "msg": "Module {old} has been replaced with a module {new} to support sway too.",
    },
}

MARKUP_LANGUAGES = ["pango", "none"]

ON_ERROR_VALUES = ["hide", "show"]



================================================
FILE: py3status/core.py
================================================
import importlib.metadata
import sys
import time
from collections import deque
from pathlib import Path
from pprint import pformat
from signal import SIGCONT, SIGTERM, SIGTSTP, SIGUSR1, Signals, signal
from subprocess import Popen
from syslog import LOG_ERR, LOG_INFO, LOG_WARNING, syslog
from threading import Event, Thread
from traceback import extract_tb, format_stack, format_tb

from py3status.command import CommandServer
from py3status.events import Events
from py3status.formatter import expand_color
from py3status.helpers import print_stderr
from py3status.i3status import I3status
from py3status.module import Module
from py3status.output import OutputFormat
from py3status.parse_config import process_config
from py3status.profiling import profile
from py3status.udev_monitor import UdevMonitor

LOG_LEVELS = {"error": LOG_ERR, "warning": LOG_WARNING, "info": LOG_INFO}

DBUS_LEVELS = {"error": "critical", "warning": "normal", "info": "low"}

CONFIG_SPECIAL_SECTIONS = [
    ".group_extras",
    ".module_groups",
    "general",
    "i3s_modules",
    "on_click",
    "order",
    "py3_modules",
    "py3status",
]

ENTRY_POINT_NAME = "py3status"
ENTRY_POINT_KEY = "entry_point"


class Runner(Thread):
    """
    A Simple helper to run a module in a Thread so it is non-locking.
    """

    def __init__(self, module, py3_wrapper, module_name):
        Thread.__init__(self)
        self.daemon = True
        self.module = module
        self.module_name = module_name
        self.py3_wrapper = py3_wrapper
        self.start()

    def run(self):
        try:
            self.module.run()
        except:  # noqa e722
            self.py3_wrapper.report_exception("Runner")
        # the module is no longer running so notify the timeout logic
        if self.module_name:
            self.py3_wrapper.timeout_finished.append(self.module_name)


class NoneSetting:
    """
    This class represents no setting in the config.
    """

    # this attribute is used to identify that this is a none setting
    none_setting = True

    def __len__(self):
        return 0

    def __repr__(self):
        # this is for output via module_test
        return "None"


class Task:
    """
    A simple task that can be run by the scheduler.
    """

    def run(self):
        # F901 'raise NotImplemented' should be 'raise NotImplementedError'
        raise NotImplemented()  # noqa f901


class CheckI3StatusThread(Task):
    """
    Checks that the i3status thread is alive
    """

    def __init__(self, i3status_thread, py3_wrapper):
        self.i3status_thread = i3status_thread
        self.timeout_queue_add = py3_wrapper.timeout_queue_add
        self.notify_user = py3_wrapper.notify_user

    def run(self):
        # check i3status thread
        if not self.i3status_thread.is_alive():
            err = self.i3status_thread.error
            if not err:
                err = "I3status died horribly."
            self.notify_user(err)
        else:
            # check again in 5 seconds
            self.timeout_queue_add(self, int(time.monotonic()) + 5)


class ModuleRunner(Task):
    """
    Starts up a Module
    """

    def __init__(self, module):
        self.module = module

    def run(self):
        self.module.start_module()


class Common:
    """
    This class is used to hold core functionality so that it can be shared more
    easily.  This allow us to run the module tests through the same code as
    when we are running for real.
    """

    def __init__(self, py3_wrapper):
        self.py3_wrapper = py3_wrapper
        self.none_setting = NoneSetting()
        self.config = py3_wrapper.config

    def get_config_attribute(self, name, attribute):
        """
        Look for the attribute in the config.  Start with the named module and
        then walk up through any containing group and then try the general
        section of the config.
        """

        # A user can set a param to None in the config to prevent a param
        # being used.  This is important when modules do something like
        #
        # color = self.py3.COLOR_MUTED or self.py3.COLOR_BAD
        config = self.config["py3_config"]
        param = config[name].get(attribute, self.none_setting)
        if hasattr(param, "none_setting") and name in config[".module_groups"]:
            for module in config[".module_groups"][name]:
                if attribute in config.get(module, {}):
                    param = config[module].get(attribute)
                    break
        if hasattr(param, "none_setting"):
            # check py3status config section
            param = config["py3status"].get(attribute, self.none_setting)
        if hasattr(param, "none_setting"):
            # check py3status general section
            param = config["general"].get(attribute, self.none_setting)
        if param and (attribute == "color" or attribute.startswith("color_")):
            # check color value
            param = expand_color(param.lower(), self.none_setting)
        return param

    def report_exception(self, msg, notify_user=True, level="error", error_frame=None):
        """
        Report details of an exception to the user.
        This should only be called within an except: block Details of the
        exception are reported eg filename, line number and exception type.

        Because stack trace information outside of py3status or it's modules is
        not helpful in actually finding and fixing the error, we try to locate
        the first place that the exception affected our code.

        Alternatively if the error occurs in a module via a Py3 call that
        catches and reports the error then we receive an error_frame and use
        that as the source of the error.

        NOTE: msg should not end in a '.' for consistency.
        """
        # Get list of paths that our stack trace should be found in.
        py3_paths = [Path(__file__).resolve()] + self.config["include_paths"]
        traceback = None

        try:
            # We need to make sure to delete tb even if things go wrong.
            exc_type, exc_obj, tb = sys.exc_info()
            stack = extract_tb(tb)
            error_str = f"{exc_type.__name__}: {exc_obj}\n"
            traceback = [error_str]

            if error_frame:
                # The error occurred in a py3status module so the traceback
                # should be made to appear correct.  We caught the exception
                # but make it look as though we did not.
                traceback += format_stack(error_frame, 1) + format_tb(tb)
                filename = Path(error_frame.f_code.co_filename).name
                line_no = error_frame.f_lineno
            else:
                # This is a none module based error
                traceback += format_tb(tb)
                # Find first relevant trace in the stack.
                # it should be in py3status or one of it's modules.
                found = False
                for item in reversed(stack):
                    filename = item[0]
                    for path in py3_paths:
                        if filename.startswith(path):
                            # Found a good trace
                            filename = item[0].name
                            line_no = item[1]
                            found = True
                            break
                    if found:
                        break
            # all done!  create our message.
            msg = "{} ({}) {} line {}.".format(msg, exc_type.__name__, filename, line_no)
        except:  # noqa e722
            # something went wrong report what we can.
            msg = f"{msg}."
        finally:
            # delete tb!
            del tb
        # log the exception and notify user
        self.py3_wrapper.log(msg, "warning")
        if traceback:
            # if debug is not in the config  then we are at an early stage of
            # running py3status and logging is not yet available so output the
            # error to STDERR so it can be seen
            if "debug" not in self.config:
                print_stderr("\n".join(traceback))
            elif self.config.get("log_file"):
                self.py3_wrapper.log("".join(["Traceback\n"] + traceback))
        if notify_user:
            self.py3_wrapper.notify_user(msg, level=level)


class Py3statusWrapper:
    """
    This is the py3status wrapper.
    """

    def __init__(self, options):
        """
        Useful variables we'll need.
        """
        self.config = vars(options)
        self.i3bar_running = True
        self.inhibit_signal_ts = time.monotonic()
        self.last_refresh_ts = time.monotonic()
        self.lock = Event()
        self.modules = {}
        self.next_allowed_signal = SIGTSTP
        self.notified_messages = set()
        self.options = options
        self.output_modules = {}
        self.py3_modules = []
        self.running = True
        self.stop_signal = SIGTSTP
        self.update_queue = deque()
        self.update_request = Event()

        # shared code
        self.common = Common(self)
        self.get_config_attribute = self.common.get_config_attribute
        self.report_exception = self.common.report_exception

        # these are used to schedule module updates
        self.timeout_add_queue = deque()
        self.timeout_due = None
        self.timeout_finished = deque()
        self.timeout_keys = []
        self.timeout_missed = {}
        self.timeout_queue = {}
        self.timeout_queue_lookup = {}
        self.timeout_queue_lookup_previous = {}
        self.timeout_running = set()
        self.timeout_update_due = deque()

    def timeout_queue_add(self, item, cache_time=0):
        """
        Add a item to be run at a future time.
        This must be a Module, I3statusModule or a Task
        """
        # add the info to the add queue.  We do this so that actually adding
        # the module is done in the core thread.
        self.timeout_add_queue.append((item, cache_time))
        # if the timeout_add_queue is not due to be processed until after this
        # update request is due then trigger an update now.
        if self.timeout_due is None or cache_time < self.timeout_due:
            self.update_request.set()

    def clear_timeout_due(self, module):
        old = self.timeout_queue_lookup_previous.get(module, None)
        if old:
            if old == self.timeout_due:
                self._set_new_timeout_due()
            elif old in self.timeout_keys:
                self.timeout_keys.remove(old)
                self._set_new_timeout_due()

    def _set_new_timeout_due(self):
        # sort keys so earliest is first
        self.timeout_keys.sort()

        # when is next timeout due?
        try:
            self.timeout_due = self.timeout_keys[0]
        except IndexError:
            self.timeout_due = None

    def timeout_process_add_queue(self, module, cache_time):
        """
        Add a module to the timeout_queue if it is scheduled in the future or
        if it is due for an update immediately just trigger that.

        the timeout_queue is a dict with the scheduled time as the key and the
        value is a list of module instance names due to be updated at that
        point. An ordered list of keys is kept to allow easy checking of when
        updates are due.  A list is also kept of which modules are in the
        update_queue to save having to search for modules in it unless needed.
        """
        # If already set to update do nothing
        if module in self.timeout_update_due:
            return

        # remove if already in the queue
        key = self.timeout_queue_lookup.get(module, None)
        if key:
            queue_item = self.timeout_queue[key]
            queue_item.remove(module)
            if not queue_item:
                del self.timeout_queue[key]
                self.timeout_keys.remove(key)

        if cache_time == 0:
            # if cache_time is 0 we can just trigger the module update
            self.timeout_update_due.append(module)
            if module in self.timeout_queue_lookup.keys():
                del self.timeout_queue_lookup[module]
        else:
            # add the module to the timeout queue
            if cache_time not in self.timeout_keys:
                self.timeout_queue[cache_time] = {module}
                self.timeout_keys.append(cache_time)

                self._set_new_timeout_due()
            else:
                self.timeout_queue[cache_time].add(module)
            # note that the module is in the timeout_queue
            self.timeout_queue_lookup[module] = cache_time
            self.timeout_queue_lookup_previous[module] = cache_time

    def timeout_queue_process(self):
        """
        Check the timeout_queue and set any due modules to update.
        """
        # process any items that need adding to the queue
        while self.timeout_add_queue:
            self.timeout_process_add_queue(*self.timeout_add_queue.popleft())
        now = time.monotonic()
        due_timeouts = []
        # find any due timeouts
        for timeout in self.timeout_keys:
            if timeout > now:
                break
            due_timeouts.append(timeout)

        if due_timeouts:
            # process them
            for timeout in due_timeouts:
                modules = self.timeout_queue[timeout]
                # remove from the queue
                del self.timeout_queue[timeout]
                self.timeout_keys.remove(timeout)

                for module in modules:
                    # module no longer in queue
                    del self.timeout_queue_lookup[module]
                    # tell module to update
                    self.timeout_update_due.append(module)

            # when is next timeout due?
            try:
                self.timeout_due = self.timeout_keys[0]
            except IndexError:
                self.timeout_due = None

        # process any finished modules.
        # Now that the module has finished running it may have been marked to
        # be triggered again. This is most likely to happen when events are
        # being processed and the events are arriving much faster than the
        # module can handle them.  It is important as a module may handle
        # events but not trigger the module update.  If during the event the
        # module is due to update the update is not actioned but it needs to be
        # once the events have finished or else the module will no longer
        # continue to update.
        while self.timeout_finished:
            module_name = self.timeout_finished.popleft()
            self.timeout_running.discard(module_name)
            if module_name in self.timeout_missed:
                module = self.timeout_missed.pop(module_name)
                self.timeout_update_due.append(module)

        # run any modules that are due
        while self.timeout_update_due:
            module = self.timeout_update_due.popleft()
            module_name = getattr(module, "module_full_name", None)
            # if the module is running then we do not want to trigger it but
            # instead wait till it has finished running and then trigger
            if module_name and module_name in self.timeout_running:
                self.timeout_missed[module_name] = module
            else:
                self.timeout_running.add(module_name)
                Runner(module, self, module_name)

        # we return how long till we next need to process the timeout_queue
        # this value should not be negative to avoid cpu overwhelming loops
        if self.timeout_due is not None:
            return max(0, self.timeout_due - time.monotonic())

    def get_user_modules(self):
        """Mapping from module name to relevant objects.

        There are two ways of discovery and storage:
        `include_paths` (no installation): include_path, f_name
        `entry_point` (from installed package): "entry_point", <Py3Status class>

        Modules of the same name from entry points shadow all other modules.
        """
        user_modules = self._get_path_based_modules()
        user_modules.update(self._get_entry_point_based_modules())
        return user_modules

    def _get_path_based_modules(self):
        """
        Search configured include directories for user provided modules.

        user_modules: {
            'weather_yahoo': ('~/i3/py3status/', 'weather_yahoo.py')
        }
        """
        user_modules = {}
        for include_path in self.config["include_paths"]:
            for f_name in sorted(include_path.iterdir()):
                if f_name.suffix != ".py":
                    continue
                module_name = f_name.stem
                # do not overwrite modules if already found
                if module_name in user_modules:
                    pass
                user_modules[module_name] = (include_path, f_name)
                self.log(f"available module from {include_path}: {module_name}")
        return user_modules

    def _get_entry_point_based_modules(self):
        classes_from_entry_points = {}
        # TODO: drop on 3.9 EOL
        if sys.version_info.minor < 10:
            eps = importlib.metadata.entry_points().get(ENTRY_POINT_NAME, [])
        else:
            eps = importlib.metadata.entry_points(group=ENTRY_POINT_NAME)
        print("eps", ENTRY_POINT_NAME, eps)

        for entry_point in eps:
            try:
                module = entry_point.load()
            except Exception as err:
                self.log(f"entry_point '{entry_point}' error: {err}")
                continue
            klass = getattr(module, Module.EXPECTED_CLASS, None)
            if klass:
                module_name = entry_point.name.split(".")[-1]
                classes_from_entry_points[module_name] = (ENTRY_POINT_KEY, klass)
                self.log(f"available module from entry point {ENTRY_POINT_KEY}: {module_name}")
        return classes_from_entry_points

    def get_user_configured_modules(self):
        """
        Get a dict of all available and configured py3status modules
        in the user's i3status.conf.

        As we already have a convenient way of loading the module, we'll
        populate the map with the Py3Status class right away
        """
        user_modules = {}
        if not self.py3_modules:
            return user_modules
        for module_name, module_info in self.get_user_modules().items():
            for module in self.py3_modules:
                if module_name == module.split(" ")[0]:
                    source, item = module_info
                    user_modules[module_name] = (source, item)
        return user_modules

    def load_modules(self, modules_list, user_modules):
        """
        Load the given modules from the list (contains instance name) with
        respect to the user provided modules dict.

        modules_list: ['weather_yahoo paris', 'pewpew', 'net_rate']
        user_modules: {
            'weather_yahoo': ('/etc/py3status.d/', 'weather_yahoo.py'),
            'pewpew': ('entry_point', <Py3Status class>),
        }
        """
        for module in modules_list:
            # ignore already provided modules (prevents double inclusion)
            if module in self.modules:
                continue
            try:
                instance = None
                payload = user_modules.get(module.split(" ")[0])
                if payload:
                    kind, Klass = payload
                    if kind == ENTRY_POINT_KEY:
                        instance = Klass()
                my_m = Module(module, user_modules, self, instance=instance)
                # only handle modules with available methods
                if my_m.methods:
                    self.modules[module] = my_m
                elif self.config["debug"]:
                    self.log(f'ignoring module "{module}" (no methods found)')
            except Exception:
                err = sys.exc_info()[1]
                msg = f'Loading module "{module}" failed ({err}).'
                self.report_exception(msg, level="warning")

    def _log_gitversion(self):
        # A git repo is detected looking for the .git directory

        git_path = Path(__file__).resolve().parent.parent / ".git"
        if not git_path.exists():
            return

        self.log("Running within git repo")

        try:
            import git
        except ImportError:
            repo = None
        else:
            try:
                repo = git.Repo(git_path.parent)
            except Exception:
                repo = None

        if not repo:
            try:
                with (git_path / "HEAD").open() as f:
                    out = f.readline()
            except OSError:
                self.log(
                    "Unable to read git HEAD. " "Use python git package for more repo information"
                )
                return
            branch = "/".join(out.strip().split("/")[2:])
            self.log(f"git branch: {branch}")
            # last commit
            log_path = git_path / "logs" / "refs" / "heads" / branch
            with log_path.open() as f:
                out = f.readlines()[-1]
            sha = out.split(" ")[1][:7]
            msg = ":".join(out.strip().split("\t")[-1].split(":")[1:])
            self.log(f"git commit: {sha}{msg}")
        else:
            commit = repo.head.commit
            self.log(f"git branch: {repo.active_branch.name}")
            self.log(f"git commit: {commit.hexsha[:7]} {commit.summary}")
            self.log(f"git clean: {not repo.is_dirty()!s}")

    def setup(self):
        """
        Setup py3status and spawn i3status/events/modules threads.
        """

        # log py3status and python versions
        self.log("=" * 8)
        msg = "Starting py3status version {version} python {python_version}"
        self.log(msg.format(**self.config))

        # if running from git then log the branch and last commit
        self._log_gitversion()

        self.log("window manager: {}".format(self.config["wm_name"]))

        if self.config["debug"]:
            self.log(f"py3status started with config {self.config}")

        # read i3status.conf
        config_path = self.config["i3status_config_path"]
        self.log("config file: {}".format(self.config["i3status_config_path"]))
        self.config["py3_config"] = process_config(config_path, self)

        # autodetect output_format
        output_format = self.config["py3_config"]["general"]["output_format"]
        if output_format is None:
            if sys.stdout.isatty():
                print("py3status: trying to auto-detect output_format setting")
                print('py3status: auto-detected "term"')
                output_format = "term"

        self.config["py3_config"]["general"]["output_format"] = output_format or "i3bar"

        # read resources
        if "resources" in str(self.config["py3_config"].values()):
            from subprocess import check_output

            resources = check_output(["xrdb", "-query"]).decode().splitlines()
            self.config["resources"] = {
                k: v.strip() for k, v in (x.split(":", 1) for x in resources)
            }

        # setup i3status thread
        self.i3status_thread = I3status(self)

        # If standalone or no i3status modules then use the mock i3status
        # else start i3status thread.
        i3s_modules = self.config["py3_config"]["i3s_modules"]
        if self.config["standalone"] or not i3s_modules:
            self.i3status_thread.mock()
            i3s_mode = "mocked"
        else:
            for module in i3s_modules:
                self.log(f"adding module {module}")
            i3s_mode = "started"
            self.i3status_thread.start()
            while not self.i3status_thread.ready:
                if not self.i3status_thread.is_alive():
                    # i3status is having a bad day, so tell the user what went
                    # wrong and do the best we can with just py3status modules.
                    err = self.i3status_thread.error
                    self.notify_user(err)
                    self.i3status_thread.mock()
                    i3s_mode = "mocked"
                    break
                time.sleep(0.1)
        if self.config["debug"]:
            self.log(
                "i3status thread {} with config {}".format(i3s_mode, self.config["py3_config"])
            )

        # add i3status thread monitoring task
        if i3s_mode == "started":
            task = CheckI3StatusThread(self.i3status_thread, self)
            self.timeout_queue_add(task)

        # setup input events thread
        self.events_thread = Events(self)
        self.events_thread.daemon = True
        self.events_thread.start()
        if self.config["debug"]:
            self.log("events thread started")

        # initialise the command server
        self.commands_thread = CommandServer(self)
        self.commands_thread.daemon = True
        self.commands_thread.start()
        if self.config["debug"]:
            self.log("commands thread started")

        # initialize the udev monitor (lazy)
        self.udev_monitor = UdevMonitor(self)

        # suppress modules' output wrt issue #20
        if not self.config["debug"]:
            sys.stdout = Path("/dev/null").open("w")
            sys.stderr = Path("/dev/null").open("w")

        # make sure we honor custom i3bar protocol stop/resume signals
        # while providing users a way to opt out from that feature
        # using the 0 value as specified by the i3bar protocol
        custom_stop_signal = self.config["py3_config"].get("py3status", {}).get("stop_signal")
        if custom_stop_signal is not None:
            try:
                # 0 is a special value for i3bar protocol, use it as-is
                if custom_stop_signal == 0:
                    self.stop_signal = custom_stop_signal
                else:
                    self.stop_signal = Signals(custom_stop_signal)
            except ValueError:
                error = (
                    f"py3status.stop_signal '{custom_stop_signal}' is invalid "
                    f"and should be a number between 0 (disable) and 31"
                )
                self.log(error, level="error")
                raise Exception(error)

        # SIGTSTP can be received and indicates that all output should
        # stop and we should consider py3status suspended.  It is however
        # important that any processes using i3 ipc should continue to receive
        # those events otherwise it can lead to a stall in i3.
        signal(SIGTSTP, self.i3bar_stop)
        # SIGCONT indicates output should be resumed.
        signal(SIGCONT, self.i3bar_start)

        # get the list of py3status configured modules
        self.py3_modules = self.config["py3_config"]["py3_modules"]

        # get a dict of all user provided modules
        self.log("modules include paths: {}".format(self.config["include_paths"]))
        user_modules = self.get_user_configured_modules()
        if self.config["debug"]:
            self.log(f"user_modules={user_modules}")

        if self.py3_modules:
            # load and spawn i3status.conf configured modules threads
            self.load_modules(self.py3_modules, user_modules)

        # determine the target output format
        self.output_format = OutputFormat.instance_for(
            self.config["py3_config"]["general"]["output_format"]
        )

        # determine the output separator, if needed
        color_separator = None
        if self.config["py3_config"]["general"]["colors"]:
            color_separator = self.config["py3_config"]["general"]["color_separator"]
        self.output_format.format_separator(
            self.config["py3_config"]["general"].get("separator", None),
            color_separator,
        )

    def notify_user(
        self,
        msg,
        level="error",
        rate_limit=None,
        module_name="",
        icon=None,
        title="py3status",
    ):
        """
        Display notification to user via i3-nagbar or send-notify
        We also make sure to log anything to keep trace of it.

        NOTE: Message should end with a '.' for consistency.
        """
        dbus = self.config.get("dbus_notify")
        if dbus:
            # force msg, icon, title to be a string
            title = f"{title}"
            msg = f"{msg}"
            if icon:
                icon = f"{icon}"
        else:
            msg = f"py3status: {msg}"
        if level != "info" and module_name == "":
            fix_msg = "{} Please try to fix this and reload i3wm (Mod+Shift+R)"
            msg = fix_msg.format(msg)
        # Rate limiting. If rate limiting then we need to calculate the time
        # period for which the message should not be repeated.  We just use
        # A simple chunked time model where a message cannot be repeated in a
        # given time period. Messages can be repeated more frequently but must
        # be in different time periods.

        limit_key = ""
        if rate_limit:
            try:
                limit_key = time.monotonic() // rate_limit
            except TypeError:
                pass
        # We use a hash to see if the message is being repeated.  This is crude
        # and imperfect but should work for our needs.
        msg_hash = hash(f"{module_name}#{limit_key}#{msg}#{title}")
        if msg_hash in self.notified_messages:
            return
        elif module_name:
            log_msg = 'Module `{}` sent a notification. "{}: {}"'.format(module_name, title, msg)
            self.log(log_msg, level)
        else:
            self.log(msg, level)
        self.notified_messages.add(msg_hash)

        try:
            if dbus:
                # fix any html entities
                msg = msg.replace("&", "&amp;")
                msg = msg.replace("<", "&lt;")
                msg = msg.replace(">", "&gt;")
                cmd = ["notify-send"]
                if icon:
                    cmd += ["-i", icon]
                cmd += ["-u", DBUS_LEVELS.get(level, "normal"), "-t", "10000"]
                cmd += [title, msg]
            else:
                py3_config = self.config.get("py3_config", {})
                nagbar_font = py3_config.get("py3status", {}).get("nagbar_font")
                wm_nag = self.config["wm"]["nag"]
                cmd = [wm_nag, "-m", msg, "-t", level]
                if nagbar_font:
                    cmd += ["-f", nagbar_font]
            Popen(
                cmd,
                stdout=Path("/dev/null").open("w"),
                stderr=Path("/dev/null").open("w"),
            )
        except Exception as err:
            self.log(f"notify_user error: {err}")

    def stop(self):
        """
        Set the Event lock, this will break all threads' loops.
        """
        self.running = False
        # stop the command server
        try:
            self.commands_thread.kill()
        except:  # noqa e722
            pass

        try:
            self.lock.set()
            if self.config["debug"]:
                self.log("lock set, exiting")
            # run kill() method on all py3status modules
            for module in self.modules.values():
                module.kill()
        except:  # noqa e722
            pass

    def refresh_modules(self, module_string=None, exact=True):
        """
        Update modules.
        if module_string is None all modules are refreshed
        if module_string then modules with the exact name or those starting
        with the given string depending on exact parameter will be refreshed.
        If a module is an i3status one then we refresh i3status.
        To prevent abuse, we rate limit this function to 100ms for full
        refreshes.
        """
        if not module_string:
            if time.monotonic() > (self.last_refresh_ts + 0.1):
                self.last_refresh_ts = time.monotonic()
            else:
                # rate limiting
                return
        update_i3status = False
        for name, module in self.output_modules.items():
            if (
                module_string is None
                or (exact and name == module_string)
                or (not exact and name.startswith(module_string))
            ):
                if module["type"] == "py3status":
                    if self.config["debug"]:
                        self.log(f"refresh py3status module {name}")
                    module["module"].force_update()
                else:
                    if self.config["debug"]:
                        self.log(f"refresh i3status module {name}")
                    update_i3status = True
        if update_i3status:
            self.i3status_thread.refresh_i3status()

    def sig_handler(self, signum, frame):
        """
        SIGUSR1 was received, the user asks for an immediate refresh of the bar
        """
        self.log("received USR1")
        self.refresh_modules()

    def terminate(self, signum, frame):
        """
        Received request to terminate (SIGTERM), exit nicely.
        """
        self.log("received SIGTERM")
        raise KeyboardInterrupt()

    def purge_module(self, module_name):
        """
        A module has been removed e.g. a module that had an error.
        We need to find any containers and remove the module from them.
        """
        containers = self.config["py3_config"][".module_groups"]
        containers_to_update = set()
        if module_name in containers:
            containers_to_update.update(set(containers[module_name]))
        for container in containers_to_update:
            try:
                self.modules[container].module_class.items.remove(module_name)
            except ValueError:
                pass

    def notify_update(self, update, urgent=False):
        """
        Name or list of names of modules that have updated.
        """
        if not isinstance(update, list):
            update = [update]
        self.update_queue.extend(update)

        # find containers that use the modules that updated
        containers = self.config["py3_config"][".module_groups"]
        containers_to_update = set()
        for item in update:
            if item in containers:
                containers_to_update.update(set(containers[item]))
        # force containers to update
        for container in containers_to_update:
            container_module = self.output_modules.get(container)
            if container_module:
                # If the container registered a urgent_function then call it
                # if this update is urgent.
                if urgent and container_module.get("urgent_function"):
                    container_module["urgent_function"](update)
                # If a container has registered a content_function we use that
                # to see if the container needs to be updated.
                # We only need to update containers if their active content has
                # changed.
                if container_module.get("content_function"):
                    if set(update) & container_module["content_function"]():
                        container_module["module"].force_update()
                else:
                    # we don't know so just update.
                    container_module["module"].force_update()

        # we need to update the output
        if self.update_queue:
            self.update_request.set()

    def log(self, msg, level="info"):
        """
        log this information to syslog or user provided logfile.
        """
        if not self.config.get("log_file"):
            # If level was given as a str then convert to actual level
            level = LOG_LEVELS.get(level, level)
            syslog(level, f"{msg}")
        else:
            # Binary mode so fs encoding setting is not an issue
            with self.config["log_file"].open("ab") as f:
                log_time = time.strftime("%Y-%m-%d %H:%M:%S")
                # nice formatting of data structures using pretty print
                if isinstance(msg, (dict, list, set, tuple)):
                    msg = pformat(msg)
                    # if multiline then start the data output on a fresh line
                    # to aid readability.
                    if "\n" in msg:
                        msg = "\n" + msg
                out = f"{log_time} {level.upper()} {msg}\n"
                try:
                    # Encode unicode strings to bytes
                    f.write(out.encode("utf-8"))
                except (AttributeError, UnicodeDecodeError):
                    # Write any byte strings straight to log
                    f.write(out)

    def create_output_modules(self):
        """
        Setup our output modules to allow easy updating of py3modules and
        i3status modules allows the same module to be used multiple times.
        """
        py3_config = self.config["py3_config"]
        i3modules = self.i3status_thread.i3modules
        output_modules = self.output_modules
        # position in the bar of the modules
        positions = {}
        for index, name in enumerate(py3_config["order"]):
            if name not in positions:
                positions[name] = []
            positions[name].append(index)

        # py3status modules
        for name in self.modules:
            if name not in output_modules:
                output_modules[name] = {}
                output_modules[name]["position"] = positions.get(name, [])
                output_modules[name]["module"] = self.modules[name]
                output_modules[name]["type"] = "py3status"
                output_modules[name]["color"] = self.mappings_color.get(name)
        # i3status modules
        for name in i3modules:
            if name not in output_modules:
                output_modules[name] = {}
                output_modules[name]["position"] = positions.get(name, [])
                output_modules[name]["module"] = i3modules[name]
                output_modules[name]["type"] = "i3status"
                output_modules[name]["color"] = self.mappings_color.get(name)

        self.output_modules = output_modules

    def create_mappings(self, config):
        """
        Create any mappings needed for global substitutions eg. colors
        """
        mappings = {}
        for name, cfg in config.items():
            # Ignore special config sections.
            if name in CONFIG_SPECIAL_SECTIONS:
                continue
            color = self.get_config_attribute(name, "color")
            if hasattr(color, "none_setting"):
                color = None
            mappings[name] = color
        # Store mappings for later use.
        self.mappings_color = mappings

    def process_module_output(self, module):
        """
        Process the output for a module and return a json string representing it.
        Color processing occurs here.
        """
        outputs = module["module"].get_latest()
        if self.config["py3_config"]["general"].get("colors") is False:
            for output in outputs:
                output.pop("color", None)
        else:
            color = module["color"]
            if color:
                for output in outputs:
                    # Color: substitute the config defined color
                    if "color" not in output:
                        output["color"] = color
        # format output and return
        return self.output_format.format(outputs)

    def i3bar_stop(self, signum, frame):
        if self.next_allowed_signal == signum and time.monotonic() > self.inhibit_signal_ts:
            self.log(f"received stop_signal {Signals(signum).name}")
            self.i3bar_running = False
            # i3status should be stopped
            self.i3status_thread.suspend_i3status()
            self.sleep_modules()
            self.next_allowed_signal = SIGCONT
        else:
            self.log(f"inhibited stop_signal {Signals(signum).name}", level="warning")
            self.inhibit_signal_ts = time.monotonic() + 0.1

    def i3bar_start(self, signum, frame):
        if self.next_allowed_signal == signum and time.monotonic() > self.inhibit_signal_ts:
            self.log(f"received resume signal {Signals(signum).name}")
            self.i3bar_running = True
            self.wake_modules()
            self.next_allowed_signal = self.stop_signal
        else:
            self.log(f"inhibited start_signal {Signals(signum).name}", level="warning")
            self.inhibit_signal_ts = time.monotonic() + 0.1

    def sleep_modules(self):
        # Put all py3modules to sleep so they stop updating
        for module in self.output_modules.values():
            if module["type"] == "py3status":
                module["module"].sleep()

    def wake_modules(self):
        # Wake up all py3modules.
        for module in self.output_modules.values():
            if module["type"] == "py3status":
                module["module"].wake()

    @profile
    def run(self):
        """
        Main py3status loop, continuously read from i3status and modules
        and output it to i3bar for displaying.
        """
        # SIGUSR1 forces a refresh of the bar both for py3status and i3status,
        # this mimics the USR1 signal handling of i3status (see man i3status)
        signal(SIGUSR1, self.sig_handler)
        signal(SIGTERM, self.terminate)

        # initialize usage variables
        py3_config = self.config["py3_config"]

        # prepare the color mappings
        self.create_mappings(py3_config)

        # self.output_modules needs to have been created before modules are
        # started.  This is so that modules can do things like register their
        # content_function.
        self.create_output_modules()

        # start up all our modules
        for module in self.modules.values():
            task = ModuleRunner(module)
            self.timeout_queue_add(task)

        # this will be our output set to the correct length for the number of
        # items in the bar
        output = [None] * len(py3_config["order"])

        # start our output
        header = {
            "version": 1,
            "click_events": self.config["click_events"],
            "stop_signal": self.stop_signal or 0,
        }
        self.output_format.write_header(header)

        update_due = None
        # main loop
        while True:
            # process the timeout_queue and get interval till next update due
            update_due = self.timeout_queue_process()

            # wait until an update is requested
            if self.update_request.wait(timeout=update_due):
                # event was set so clear it
                self.update_request.clear()

            while not self.i3bar_running:
                time.sleep(0.1)

            # check if an update is needed
            if self.update_queue:
                while len(self.update_queue):
                    module_name = self.update_queue.popleft()
                    module = self.output_modules[module_name]
                    out = self.process_module_output(module)

                    for index in module["position"]:
                        # store the output as json
                        output[index] = out

                # build output string and dump to stdout
                self.output_format.write_line(output)



================================================
FILE: py3status/docstrings.py
================================================
import ast
import difflib
import re
from pathlib import Path

from py3status.helpers import print_stderr


def modules_directory():
    """
    Get the core modules directory.
    """
    return Path(__file__).resolve().parent / "modules"


def parse_readme():
    """
    Crude parsing of modules/README.md
    returns a dict of {<module_name>: <documentation>}
    """
    name = None
    re_mod = re.compile(r'^### <a name="(?P<name>[a-z_0-9]+)"></a>')
    readme_file = modules_directory() / "README.md"
    modules_dict = {}
    with readme_file.open() as f:
        for row in f.readlines():
            match = re_mod.match(row)
            if match:
                name = match.group("name")
                modules_dict[name] = []
                continue
            if row.startswith("---"):
                name = None
                continue
            if name:
                modules_dict[name].append(row)
    return modules_dict


def core_module_docstrings(include_core=True, include_user=False, config=None, format="md"):
    """
    Get docstrings for all core modules and user ones if requested
    returns a dict of {<module_name>: <docstring>}
    """
    paths = {}
    docstrings = {}
    if include_core:
        for file in modules_directory().iterdir():
            if file.suffix == ".py":
                if file.stem != "__init__":
                    paths[file.stem] = (file, "core")

    if include_user:
        # include user modules
        for include_path in sorted(config["include_paths"]):
            for file in sorted(include_path.iterdir()):
                if file.suffix != ".py":
                    continue
                paths[file.stem] = (file, "user")
    for name in paths:
        path, module_type = paths[name]
        with path.open() as f:
            try:
                module = ast.parse(f.read())
            except SyntaxError:
                # there is a syntax error so ignore module
                continue
            raw_docstring = ast.get_docstring(module)

            # prevent issue when no docstring exists
            if raw_docstring is None:
                continue

            # remove any sample outputs
            parts = re.split("^SAMPLE OUTPUT$", raw_docstring, flags=re.M)
            docstring = parts[0]

            if format == "md":
                docstring = [d for d in _from_docstring_md(str(docstring).strip().split("\n"))]
            elif format == "rst":
                docstring = [d for d in _from_docstring_rst(str(docstring).strip().split("\n"))]
            else:
                raise Exception("`md` and `rst` format supported only")

            docstrings[name] = docstring + ["\n"]
    return docstrings


def create_readme(data):
    """
    Create README.md text for the given module data.
    """
    out = ['<a name="top"></a>Modules\n========\n\n']
    # Links
    for module, lines in sorted(data.items()):
        desc = "".join(lines).strip().split("\n")[0]
        format_str = "\n**[{name}](#{name})** — {desc}\n"
        out.append(format_str.format(name=module, desc=desc))
    # details
    for module, lines in sorted(data.items()):
        out.append(
            '\n---\n\n### <a name="{name}"></a>{name}\n\n{details}\n'.format(
                name=module, details="".join(lines).strip()
            )
        )
    return "".join(out)


re_listing = re.compile(r"^\w.*:$")

# match in README.md
re_to_param = re.compile(r"^  - `([a-z]\S+)`($|[ \t])")
re_to_status = re.compile(r"^  - `({\S+})`($|[ \t])")
re_to_item = re.compile(r"^\s+-")
re_to_data = re.compile(r"^\*\*(author|license|source)\*\*($|[ \t])")
re_to_tag = re.compile("&lt;([^.]*)&gt;")
re_to_defaults = re.compile(r"\*(\(default.*\))\*")

# match in module docstring
re_from_param = re.compile(r"^    ([a-z<]\S+):($|[ \t])(.*)$")
re_from_status = re.compile(r"^\s+({\S+})($|[ \t])(.*)$")
re_from_item = re.compile(r"^\s+-(?=\s)")
re_from_data = re.compile("^@(author|license|source)($|[ \t])")
re_from_tag = re.compile("((`[^`]*`)|[<>&])")
re_from_defaults = re.compile(r"(\(default.*\))\s*$")

# for rst
re_lone_backtick = re.compile("(?<!`)`(?!`)")


def _reformat_docstring(doc, format_fn, code_newline=""):
    """
    Go through lines of file and reformat using format_fn
    """
    out = []
    status = {"listing": False, "add_line": False, "eat_line": False}
    code = False
    for line in doc:
        if status["add_line"]:
            out.append("\n")
        status["add_line"] = False
        if status["eat_line"]:
            status["eat_line"] = False
            if line.strip() == "":
                continue
        # check for start/end of code block
        if line.strip() == "```":
            code = not code
            out.append(line + code_newline)
            continue
        if not code:
            # if we are in a block listing a blank line ends it
            if line.rstrip() == "":
                status["listing"] = False
            # format the line
            line = format_fn(line, status)
            # see if block start
            if re_listing.match(line):
                status["listing"] = True
        out.append(line.rstrip() + "\n")
    return out


def _to_docstring(doc):
    """
    format from Markdown to docstring
    """

    def format_fn(line, status):
        """format function"""
        # swap &lt; &gt; to < >
        line = re_to_tag.sub(r"<\1>", line)
        if re_to_data.match(line):
            line = re_to_data.sub(r"@\1 ", line)
            status["eat_line"] = True
        line = re_to_defaults.sub(r"\1", line)
        if status["listing"]:
            # parameters
            if re_to_param.match(line):
                line = re_to_param.sub(r"    \1: ", line)
            # status items
            elif re_to_status.match(line):
                line = re_to_status.sub(r"    \1 ", line)
            # bullets
            elif re_to_item.match(line):
                line = re_to_item.sub(r"    -", line)
            # is continuation line
            else:
                line = " " * 8 + line.lstrip()
        return line

    return _reformat_docstring(doc, format_fn)


def _from_docstring_md(doc):
    """
    format from docstring to Markdown
    """

    def format_fn(line, status):
        """format function"""

        def fix_tags(line):
            # In markdown we need to escape < > and & for display
            # but we don't want to do this is the value is quoted
            # by backticks ``

            def fn(match):
                # swap matched chars
                found = match.group(1)
                if found == "<":
                    return "&lt;"
                if found == ">":
                    return "&gt;"
                if found == "&":
                    return "&amp;"
                return match.group(0)

            return re_from_tag.sub(fn, line)

        if re_from_data.match(line):
            line = re_from_data.sub(r"**\1** ", line)
            status["add_line"] = True
        line = re_from_defaults.sub(r"*\1*", line)
        if status["listing"]:
            # parameters
            if re_from_param.match(line):
                m = re_from_param.match(line)
                line = "\n- `{}` {}".format(m.group(1), fix_tags(m.group(3)))
            # status items
            elif re_from_status.match(line):
                m = re_from_status.match(line)
                line = "\n- `{}` {}".format(m.group(1), fix_tags(m.group(3)))
            # bullets
            elif re_from_item.match(line):
                line = re_from_item.sub(r"  -", fix_tags(line))
            # is continuation line
            else:
                line = fix_tags(line)
                line = " " * 4 + line.lstrip()
        else:
            line = fix_tags(line)
        return line

    return _reformat_docstring(doc, format_fn, code_newline="\n")


def _from_docstring_rst(doc):
    """
    format from docstring to ReStructured Text
    """

    def format_fn(line, status):
        """format function"""

        if re_from_data.match(line):
            line = re_from_data.sub(r"**\1** ", line)
            status["add_line"] = True
        line = re_from_defaults.sub(r"*\1*", line)
        if status["listing"]:
            # parameters
            if re_from_param.match(line):
                m = re_from_param.match(line)
                line = "  - ``{}`` {}".format(m.group(1), m.group(3))
            # status items
            elif re_from_status.match(line):
                m = re_from_status.match(line)
                line = "  - ``{}`` {}".format(m.group(1), m.group(3))
            # bullets
            elif re_from_item.match(line):
                line = re_from_item.sub(r"  -", line)
            # is continuation line
            else:
                line = " " * 4 + line.lstrip()
        # in .rst format code samples use double backticks vs single ones for
        # .md This converts them.
        line = re_lone_backtick.sub("``", line)
        return line

    return _reformat_docstring(doc, format_fn, code_newline="\n")


def update_docstrings():
    """
    update the docstring of each module using info in the
    modules/README.md file
    """
    modules_dict = parse_readme()
    files = {}
    # update modules
    for mod in modules_dict:
        mod_file = modules_directory() / f"{mod}.py"
        with mod_file.open() as f:
            files[mod] = f.readlines()

    for mod, rows in files.items():
        replaced = False
        done = False
        lines = False
        out = []
        quotes = None
        for row in rows:
            # deal with single or double quoted docstring
            if not quotes:
                if row.strip().startswith('"""'):
                    quotes = '"""'
                if row.strip().startswith("'''"):
                    quotes = "'''"
            if quotes and row.strip().startswith(quotes) and not done:
                out.append(row)
                if not replaced:
                    out = out + ["".join(_to_docstring(modules_dict[mod])).strip() + "\n"]
                    replaced = True
                if lines:
                    done = True
                if not done and not lines:
                    lines = True
                continue
            if not lines or done:
                out.append(row)
        mod_file = modules_directory() / f"{mod}.py"
        with mod_file.open("w") as f:
            f.writelines(out)
    print_stderr("Modules updated from README.md")


def check_docstrings(show_diff=False, config=None, mods=None):
    """
    Check docstrings in module match the README.md
    """

    readme = parse_readme()
    modules_readme = core_module_docstrings(config=config)
    warned = False
    if create_readme(readme) != create_readme(modules_readme):
        for module, lines in sorted(readme.items()):
            if mods and module not in mods:
                continue
            err = None
            if module not in modules_readme:
                err = f"Module {module} in README but not in /modules"
            elif "".join(lines).strip() != "".join(modules_readme[module]).strip():
                err = f"Module {module} docstring does not match README"
            if err:
                if not warned:
                    print_stderr("Documentation does not match!\n")
                    warned = True
                print_stderr(err)

        for module in modules_readme:
            if mods and module not in mods:
                continue
            if module not in readme:
                print_stderr(f"Module {module} in /modules but not in README")
        if show_diff:
            print_stderr(
                "\n".join(
                    difflib.unified_diff(
                        create_readme(readme).split("\n"),
                        create_readme(modules_readme).split("\n"),
                    )
                )
            )
        else:
            if warned:
                print_stderr("\nUse `py3-cmd docstring --diff` to view diff.")


def update_readme_for_modules(modules):
    """
    Update README.md updating the sections for the module names listed.
    """
    readme = parse_readme()
    module_docstrings = core_module_docstrings()
    if modules == ["__all__"]:
        modules = list(core_module_docstrings())
    for module in modules:
        if module in module_docstrings:
            print_stderr(f"Updating README.md for module {module}")
            readme[module] = module_docstrings[module]
        else:
            print_stderr(f"Module {module} not in core modules")

    # write the file
    readme_file = modules_directory() / "README.md"
    readme_file.write_text(create_readme(readme))


def show_modules(config, modules_list):
    """
    List modules available optionally with details.
    """
    details = config["full"]
    core_mods = not config["user"]
    user_mods = not config["core"]

    modules = core_module_docstrings(include_core=core_mods, include_user=user_mods, config=config)

    new_modules = []
    if modules_list:
        from fnmatch import fnmatch

        for _filter in modules_list:
            for name in modules:
                if fnmatch(name, _filter):
                    if name not in new_modules:
                        new_modules.append(name)
    else:
        new_modules = list(modules)

    for name in sorted(new_modules):
        module = _to_docstring(modules[name])
        desc = module[0][:-1]
        if details:
            dash_len = len(name) + 4
            print("#" * dash_len)
            print(f"# {name} #")
            print("#" * dash_len)
            for description in module:
                print(description[:-1])
        else:
            print(f"{name:<22} {desc}")



================================================
FILE: py3status/events.py
================================================
import select
import sys
from json import loads
from shlex import quote as shell_quote
from subprocess import PIPE, Popen
from threading import Thread

from py3status.profiling import profile


class IOPoller:
    """
    This class implements a predictive and timing-out I/O reader
    using select and the poll() mechanism for greater compatibility.
    """

    def __init__(self, io, eventmask=select.POLLIN):
        """
        Our default is to read (POLLIN) the specified 'io' file descriptor.
        """
        self.io = io
        self.poller = select.poll()
        self.poller.register(io, eventmask)

    def readline(self, timeout=500):
        """
        Try to read our I/O for 'timeout' milliseconds, return None otherwise.
        This makes calling and reading I/O non blocking !
        """
        poll_result = self.poller.poll(timeout)
        if poll_result:
            line = self.io.readline().strip()
            # when using pydev.debugger sys.stdin gets overwritten and placed
            # into sys.stdin.original_stdin issue #2090
            if self.io == getattr(sys.stdin, "original_stdin", sys.stdin) and line == "[":
                # skip first event line wrt issue #19
                line = self.io.readline().strip()
            try:
                # python3 compatibility code
                line = line.decode()
            except (AttributeError, UnicodeDecodeError):
                pass
            return line
        else:
            return None


class EventTask:
    """
    A simple task that can be run by the scheduler.
    """

    def __init__(self, module_name, event, default_event, events_thread):
        self.events_thread = events_thread
        self.module_full_name = module_name
        self.default_event = default_event
        self.event = event

    def run(self):
        self.events_thread.process_event(self.module_full_name, self.event, self.default_event)


class EventClickTask:
    """
    A task to run an external on_click event
    """

    def __init__(self, module_name, event, events_thread, command):
        self.events_thread = events_thread
        self.module_name = module_name
        self.command = command
        self.event = event

    def run(self):
        self.events_thread.on_click_dispatcher(self.module_name, self.event, self.command)


class Events(Thread):
    """
    This class is responsible for dispatching event JSONs sent by the i3bar.
    """

    def __init__(self, py3_wrapper):
        """
        We need to poll stdin to receive i3bar messages.
        """
        Thread.__init__(self)
        self.config = py3_wrapper.config
        self.error = None
        self.py3_config = py3_wrapper.config["py3_config"]
        self.modules = py3_wrapper.modules
        self.on_click = self.py3_config["on_click"]
        self.output_modules = py3_wrapper.output_modules
        self.poller_inp = IOPoller(sys.stdin)
        self.py3_wrapper = py3_wrapper

    def get_module_text(self, module_name, event):
        """
        Get the full text for the module as well as the partial text if the
        module is a composite.  Partial text is the text for just the single
        section of a composite.
        """
        index = event.get("index")
        module_info = self.py3_wrapper.output_modules.get(module_name)
        output = module_info["module"].get_latest()
        full_text = "".join(out["full_text"] for out in output)

        partial = None
        if index is not None:
            if isinstance(index, int):
                partial = output[index]
            else:
                for item in output:
                    if item.get("index") == index:
                        partial = item
                        break
        if partial:
            partial_text = partial["full_text"]
        else:
            partial_text = full_text
        return (x.strip() for x in (full_text, partial_text))

    def on_click_dispatcher(self, module_name, event, command):
        """
        Dispatch on_click config parameters to either:
            - Our own methods for special py3status commands (listed below)
            - The i3-msg program which is part of i3wm
        """
        if command is None:
            return
        elif command == "refresh_all":
            self.py3_wrapper.refresh_modules()
        elif command == "refresh":
            self.py3_wrapper.refresh_modules(module_name)
        else:
            # In commands we are able to use substitutions for the text output
            # of a module
            if "$OUTPUT" in command or "$OUTPUT_PART" in command:
                full_text, partial_text = self.get_module_text(module_name, event)
                command = command.replace("$OUTPUT_PART", shell_quote(partial_text))
                command = command.replace("$OUTPUT", shell_quote(full_text))

            # this is a i3 message
            self.wm_msg(module_name, command)
            # to make the bar more responsive to users we ask for a refresh
            # of the module or of i3status if the module is an i3status one
            self.py3_wrapper.refresh_modules(module_name)

    def wm_msg(self, module_name, command):
        """
        Execute the message with i3-msg or swaymsg and log its output.
        """
        wm_msg = self.config["wm"]["msg"]
        pipe = Popen([wm_msg, command], stdout=PIPE)
        self.py3_wrapper.log(
            '{} module="{}" command="{}" stdout={}'.format(
                wm_msg, module_name, command, pipe.stdout.read()
            )
        )

    def process_event(self, module_name, event, default_event=False):
        """
        Process the event for the named module.
        Events may have been declared in i3status.conf, modules may have
        on_click() functions. There is a default middle click event etc.
        """

        # get the module that the event is for
        module_info = self.output_modules.get(module_name)

        # if module is a py3status one call it.
        if module_info["type"] == "py3status":
            module = module_info["module"]
            module.click_event(event)
            if self.config["debug"]:
                self.py3_wrapper.log(f"dispatching event {event}")

            # to make the bar more responsive to users we refresh the module
            # unless the on_click event called py3.prevent_refresh()
            if not module.prevent_refresh:
                self.py3_wrapper.refresh_modules(module_name)
                default_event = False

        if default_event:
            # default button 2 action is to clear this method's cache
            if self.config["debug"]:
                self.py3_wrapper.log(f"dispatching default event {event}")
            self.py3_wrapper.refresh_modules(module_name)

        # find container that holds the module and call its onclick
        module_groups = self.py3_config[".module_groups"]
        containers = module_groups.get(module_name, [])
        for container in containers:
            self.process_event(container, event)

    def dispatch_event(self, event):
        """
        Takes an event dict.  Logs the event if needed and cleans up the dict
        such as setting the index needed for composits.
        """
        if self.config["debug"]:
            self.py3_wrapper.log(f"received event {event}")

        # usage variables
        event["index"] = event.get("index", "")
        instance = event.get("instance", "")
        name = event.get("name", "")

        # composites have an index which is passed to i3bar with
        # the instance.  We need to separate this out here and
        # clean up the event.  If index
        # is an integer type then cast it as such.
        if " " in instance:
            instance, index = instance.split(" ", 1)
            try:
                index = int(index)
            except ValueError:
                pass
            event["index"] = index
            event["instance"] = instance

        if self.config["debug"]:
            self.py3_wrapper.log(
                'trying to dispatch event to module "{}"'.format(f"{name} {instance}".strip())
            )

        # guess the module config name
        module_name = f"{name} {instance}".strip()

        default_event = False
        module_info = self.output_modules.get(module_name)
        module = module_info["module"]
        # execute any configured i3-msg command
        # we do not do this for containers
        # modules that have failed do not execute their config on_click
        if module.allow_config_clicks:
            button = event.get("button", 0)
            on_click = self.on_click.get(module_name, {}).get(str(button))
            if on_click:
                task = EventClickTask(module_name, event, self, on_click)
                self.py3_wrapper.timeout_queue_add(task)
            # otherwise setup default action on button 2 press
            elif button == 2:
                default_event = True

        # do the work
        task = EventTask(module_name, event, default_event, self)
        self.py3_wrapper.timeout_queue_add(task)

    @profile
    def run(self):
        """
        Wait for an i3bar JSON event, then find the right module to dispatch
        the message to based on the 'name' and 'instance' of the event.

        In case the module does NOT support click_events, the default
        implementation is to clear the module's cache
        when the MIDDLE button (2) is pressed on it.

        Example event:
        {'y': 13, 'x': 1737, 'button': 1, 'name': 'empty', 'instance': 'first'}
        """
        try:
            while self.py3_wrapper.running:
                event_str = self.poller_inp.readline(timeout=None)
                if not event_str:
                    continue
                try:
                    # remove leading comma if present
                    if event_str[0] == ",":
                        event_str = event_str[1:]
                    event = loads(event_str)
                    self.dispatch_event(event)
                except Exception:
                    self.py3_wrapper.report_exception("Event failed")
        except:  # noqa e722
            err = "Events thread died, click events are disabled."
            self.py3_wrapper.report_exception(err, notify_user=False)
            self.py3_wrapper.notify_user(err, level="warning")



================================================
FILE: py3status/exceptions.py
================================================
class Py3Exception(Exception):
    """
    Base Py3 exception class.  All custom Py3 exceptions derive from this
    class.
    """


class CommandError(Py3Exception):
    """
    An error occurred running the given command.

    This exception provides some additional attributes

    ``error_code``: The error code returned from the call

    ``output``: Any output returned by the call

    ``error``: Any error output returned by the call
    """

    def __init__(self, msg=None, error_code=0, output="", error=""):
        Py3Exception.__init__(self, msg)
        self.error_code = error_code
        self.output = output
        self.error = error


class RequestException(Py3Exception):
    """
    A Py3.request() base exception.  This will catch any of the more specific
    exceptions.
    """


class RequestInvalidJSON(RequestException):
    """
    The request has not returned valid JSON
    """


class RequestTimeout(RequestException):
    """
    A timeout has occurred during a request made via Py3.request().
    """


class RequestURLError(RequestException):
    """
    A URL related error has occurred during a request made via Py3.request().
    """



================================================
FILE: py3status/formatter.py
================================================
import re
from html import escape
from math import ceil
from numbers import Number
from urllib.parse import parse_qsl

from py3status.composite import Composite
from py3status.constants import COLOR_NAMES, COLOR_NAMES_EXCLUDED


def expand_color(color, default=None, passthrough=False, block=None):
    """
    Expand various colors to #RRGGBB.
    """
    if color:
        if color[0] == "#":
            color = color[1:]
            try:
                int(color, 16)
            except ValueError:
                return block
            length = len(color)
            if length in [3, 4]:
                color = "".join(color[x] * 2 for x in range(length))
            elif length not in [6, 8]:
                return block
            return "#" + color.upper()
    elif block:
        return block
    return COLOR_NAMES.get(color, color if passthrough else default)


class Formatter:
    """
    Formatter for processing format strings via the format method.
    """

    TOKENS = [
        r"(?P<block_start>\[)"
        r"|(?P<block_end>\])"
        r"|(?P<switch>\|)"
        r"|(\\\?(?P<command>\S*)\s)"
        r"|(?P<escaped>(\\.|\{\{|\}\}))"
        r"|(?P<placeholder>(\{(?P<key>([^}\\\:\!]|\\.)*)(?P<format>([^}\\]|\\.)*)?\}))"
        r"|(?P<literal>([^\[\]\\\{\}\|])+)"
        r"|(?P<lost_brace>([{}]))"
    ]

    reg_ex = re.compile(TOKENS[0], re.M | re.I)

    block_cache = {}
    format_string_cache = {}

    def __init__(self, py3_wrapper=None):
        self.py3_wrapper = py3_wrapper

    def tokens(self, format_string):
        """
        Get the tokenized format_string.
        Tokenizing is resource intensive so we only do it once and cache it
        """
        if format_string not in self.format_string_cache:
            tokens = list(re.finditer(self.reg_ex, format_string))
            self.format_string_cache[format_string] = tokens
        return self.format_string_cache[format_string]

    def get_color_names(self, format_string):
        """
        Parses the format_string and returns a set of color names.
        """
        names = set()
        # Tokenize the format string and process them
        for token in self.tokens(format_string):
            if token.group("command"):
                name = dict(parse_qsl(token.group("command"))).get("color")
                if (
                    not name
                    or name in COLOR_NAMES_EXCLUDED
                    or name in COLOR_NAMES
                    or name[0] == "#"
                ):
                    continue
                names.add(name)
        return names

    def get_placeholders(self, format_string):
        """
        Parses the format_string and returns a set of placeholders.
        """
        placeholders = set()
        # Tokenize the format string and process them
        for token in self.tokens(format_string):
            if token.group("placeholder"):
                placeholders.add(token.group("key"))
            elif token.group("command"):
                # get any placeholders used in commands
                commands = dict(parse_qsl(token.group("command")))
                # placeholders only used in `if`
                if_ = commands.get("if")
                if if_:
                    placeholders.add(Condition(if_).variable)
        return placeholders

    def get_placeholder_formats_list(self, format_string):
        """
        Parses the format_string and returns a list of tuples
        (placeholder, format).
        """
        placeholders = []
        # Tokenize the format string and process them
        for token in self.tokens(format_string):
            if token.group("placeholder"):
                placeholders.append((token.group("key"), token.group("format")))
        return placeholders

    def update_placeholders(self, format_string, placeholders):
        """
        Update a format string renaming placeholders.
        """
        # Tokenize the format string and process them
        output = []
        for token in self.tokens(format_string):
            if token.group("key") in placeholders:
                output.append(
                    "{{{}{}}}".format(placeholders[token.group("key")], token.group("format"))
                )
                continue
            elif token.group("command"):
                # update any placeholders used in commands
                commands = parse_qsl(token.group("command"), keep_blank_values=True)
                # placeholders only used in `if`
                if "if" in [x[0] for x in commands]:
                    items = []
                    for key, value in commands:
                        if key == "if":
                            # we have to rebuild from the parts we have
                            condition = Condition(value)
                            variable = condition.variable
                            if variable in placeholders:
                                variable = placeholders[variable]
                                # negation via `!`
                                not_ = "!" if not condition.default else ""
                                condition_ = condition.condition or ""
                                # if there is no condition then there is no
                                # value
                                if condition_:
                                    value_ = condition.value
                                else:
                                    value_ = ""
                                value = "{}{}{}{}".format(not_, variable, condition_, value_)
                        if value:
                            items.append(f"{key}={value}")
                        else:
                            items.append(key)

                    # we cannot use urlencode because it will escape things
                    # like `!`
                    output.append(r"\?{} ".format("&".join(items)))
                    continue
            value = token.group(0)
            output.append(value)
        return "".join(output)

    def update_placeholder_formats(self, format_string, placeholder_formats):
        """
        Update a format string adding formats if they are not already present.
        """
        # Tokenize the format string and process them
        output = []
        for token in self.tokens(format_string):
            if (
                token.group("placeholder")
                and (not token.group("format"))
                and token.group("key") in placeholder_formats
            ):
                output.append(f"{{{token.group('key')}{placeholder_formats[token.group('key')]}}}")
                continue
            value = token.group(0)
            output.append(value)
        return "".join(output)

    def build_block(self, format_string):
        """
        Parse the format string into blocks containing Literals, Placeholders
        etc that we can cache and reuse.
        """
        first_block = Block(None, py3_wrapper=self.py3_wrapper)
        block = first_block

        # Tokenize the format string and process them
        for token in self.tokens(format_string):
            value = token.group(0)
            if token.group("block_start"):
                # Create new block
                block = block.new_block()
            elif token.group("block_end"):
                # Close block setting any valid state as needed
                # and return to parent block to continue
                if not block.parent:
                    raise Exception("Too many `]`")
                block = block.parent
            elif token.group("switch"):
                # a new option has been created
                block = block.switch()
            elif token.group("placeholder"):
                # Found a {placeholder}
                key = token.group("key")
                format = token.group("format")
                block.add(Placeholder(key, format))
            elif token.group("literal"):
                block.add(Literal(value))
            elif token.group("lost_brace"):
                # due to how parsing happens we can get a lonesome }
                # eg in format_string '{{something}' this fixes that issue
                block.add(Literal(value))
            elif token.group("command"):
                # a block command has been found
                block.set_commands(token.group("command"))
            elif token.group("escaped"):
                # escaped characters add unescaped values
                if value[0] in ["\\", "{", "}"]:
                    value = value[1:]
                block.add(Literal(value))

        if block.parent:
            raise Exception("Block not closed")
        # add to the cache
        self.block_cache[format_string] = first_block

    def format(
        self,
        format_string,
        module=None,
        param_dict=None,
        force_composite=False,
        attr_getter=None,
    ):
        """
        Format a string, substituting place holders which can be found in
        param_dict, attributes of the supplied module, or provided via calls to
        the attr_getter function.
        """
        if param_dict is None:
            param_dict = {}

        # if the processed format string is not in the cache then create it.
        if format_string not in self.block_cache:
            self.build_block(format_string)

        first_block = self.block_cache[format_string]

        def get_parameter(key):
            """
            function that finds and returns the value for a placeholder.
            """
            if key in param_dict:
                # was a supplied parameter
                param = param_dict.get(key)
            elif module and hasattr(module, key):
                param = getattr(module, key)
                if hasattr(param, "__call__"):
                    # we don't allow module methods
                    raise Exception()
            elif attr_getter:
                # get value from attr_getter function
                try:
                    param = attr_getter(key)
                except:  # noqa e722
                    raise Exception()
            else:
                raise Exception()
            if isinstance(param, Composite):
                if param.text():
                    param = param.copy()
                else:
                    param = ""
            return param

        # render our processed format
        valid, output = first_block.render(get_parameter, module)

        # clean things up a little
        if isinstance(output, list):
            output = Composite(output)
        if not output:
            if force_composite:
                output = Composite()
            else:
                output = ""

        return output


class Placeholder:
    """
    Class representing a {placeholder}
    """

    def __init__(self, key, format):
        self.key = key
        self.format = format

    def get(self, get_params, block):
        """
        return the correct value for the placeholder
        """
        value = f"{{{self.key}}}"
        try:
            value = value_ = get_params(self.key)
            if self.format.startswith(":"):
                # if a parameter has been set to be formatted as a numeric
                # type then we see if we can coerce it to be.  This allows
                # the user to format types that normally would not be
                # allowed eg '123' it also allows {:d} to be used as a
                # shorthand for {:.0f}.  Use {:g} to remove insignificant
                # trailing zeroes and the decimal point too if there are
                # no remaining digits following it.  If the parameter cannot
                # be successfully converted then the format will be removed.
                try:
                    if "escape" in self.format:
                        value = escape(value)
                    if "ceil" in self.format:
                        value = ceil(float(value))
                    if "f" in self.format:
                        value = float(value)
                    if "g" in self.format:
                        value = float(value)
                    if "d" in self.format:
                        value = int(float(value))
                    output = f"{{[{self.key}]{self.format}}}"
                    value = output.format({self.key: value})
                    value_ = float(value)
                except ValueError:
                    pass
            elif self.format.startswith("!"):
                output = f"{{{self.key}{self.format}}}"
                value = value_ = output.format(**{self.key: value})

            if block.commands.not_zero:
                valid = value_ not in ["", None, False, "0", "0.0", 0, 0.0]
            else:
                # '', None, and False are ignored
                # numbers like 0 and 0.0 are not.
                valid = not (value_ in ["", None] or value_ is False)
            enough = False
        except:  # noqa e722
            # Exception raised when we don't have the param
            enough = True
            valid = False

        return valid, value, enough

    def __repr__(self):
        return f"<Placeholder {{{self.repr()}}}>"

    def repr(self):
        if self.format:
            value = f"{self.key}{self.format}"
        else:
            value = self.key
        return f"{{{value}}}"


class Literal:
    """
    Class representing some text
    """

    def __init__(self, text):
        self.text = text

    def __repr__(self):
        return f"<Literal {self.text}>"

    def repr(self):
        return self.text


class Condition:
    """
    This class represents the if condition of a block It allows us to compare
    the value of a parameter to a chosen value or just to see if it equates to
    True
    """

    condition = None
    value = True
    variable = None

    def __init__(self, info):
        # are we negated?
        self.default = info[0] != "!"
        if not self.default:
            info = info[1:]

        if "=" in info:
            self.variable, self.value = info.split("=")
            self.condition = "="
            self.check_valid = self._check_valid_condition
        elif ">" in info:
            self.variable, self.value = info.split(">")
            self.condition = ">"
            self.check_valid = self._check_valid_condition
        elif "<" in info:
            self.variable, self.value = info.split("<")
            self.condition = "<"
            self.check_valid = self._check_valid_condition
        else:
            self.variable = info
            self.check_valid = self._check_valid_basic

    def _check_valid_condition(self, get_params):
        """
        Check if the condition has been met.
        We need to make sure that we are of the correct type.
        """
        try:
            variable = get_params(self.variable)
        except:  # noqa e722
            variable = None
        value = self.value

        # if None, return oppositely
        if variable is None:
            return not self.default

        # convert the value to a correct type
        if isinstance(variable, bool):
            value = bool(self.value)
        elif isinstance(variable, Number):
            try:
                value = int(self.value)
            except:  # noqa e722
                try:
                    value = float(self.value)
                except:  # noqa e722
                    # could not parse
                    return not self.default

        # compare and return the result
        if self.condition == "=":
            return (variable == value) == self.default
        elif self.condition == ">":
            return (variable > value) == self.default
        elif self.condition == "<":
            return (variable < value) == self.default

    def _check_valid_basic(self, get_params):
        """
        Simple check that the variable is set
        """
        try:
            if get_params(self.variable):
                return self.default
        except:  # noqa e722
            pass
        return not self.default


class BlockConfig:
    r"""
    Block commands eg [\?color=bad ...] are stored in this object
    """

    REGEX_COLOR = re.compile("#[0-9A-F]{6}")
    INHERITABLE = ["color", "not_zero", "show"]

    # defaults
    _if = None
    color = None
    max_length = None
    min_length = 0
    not_zero = False
    show = False
    soft = False

    def __init__(self, parent):
        # inherit any commands from the parent block
        # inheritable commands are in self.INHERITABLE
        if parent:
            parent_commands = parent.commands
            for attr in self.INHERITABLE:
                setattr(self, attr, getattr(parent_commands, attr))

    def update_commands(self, commands_str):
        """
        update with commands from the block
        """
        commands = dict(parse_qsl(commands_str, keep_blank_values=True))
        _if = commands.get("if", self._if)
        if _if:
            self._if = Condition(_if)
        self._set_int(commands, "max_length")
        self._set_int(commands, "min_length")
        self.color = expand_color(commands.get("color"), passthrough=True, block=self.color)

        self.not_zero = "not_zero" in commands or self.not_zero
        self.show = "show" in commands or self.show
        self.soft = "soft" in commands or self.soft

    def _set_int(self, commands, name):
        """
        set integer value from commands
        """
        if name in commands:
            try:
                value = int(commands[name])
                setattr(self, name, value)
            except ValueError:
                pass


class Block:
    """
    class representing a [block] of a format string
    """

    def __init__(self, parent, base_block=None, py3_wrapper=None):
        self.base_block = base_block
        self.commands = BlockConfig(parent)
        self.content = []
        self.next_block = None
        self.parent = parent
        self.py3_wrapper = py3_wrapper

    def set_commands(self, command_str):
        """
        set any commands for this block
        """
        self.commands.update_commands(command_str)

    def add(self, item):
        self.content.append(item)

    def new_block(self):
        """
        create a new sub block to the current block and return it.
        the sub block is added to the current block.
        """
        child = Block(self, py3_wrapper=self.py3_wrapper)
        self.add(child)
        return child

    def switch(self):
        """
        block has been split via | so we need to start a new block for that
        option and return it to the user.
        """
        base_block = self.base_block or self
        self.next_block = Block(self.parent, base_block=base_block, py3_wrapper=self.py3_wrapper)
        return self.next_block

    def __repr__(self):
        return f"<Block {self.repr()}>"

    def repr(self):
        my_repr = [x.repr() for x in self.content]
        if self.next_block:
            my_repr.extend(["|"] + self.next_block.repr())
        return my_repr

    def check_valid(self, get_params):
        """
        see if the if condition for a block is valid
        """
        if self.commands._if:
            return self.commands._if.check_valid(get_params)

    def render(self, get_params, module, _if=None):
        """
        render the block and return the output.
        """
        enough = False
        output = []
        valid = None

        if self.commands.show:
            valid = True
        if self.parent and self.commands.soft and _if is None:
            return None, self
        if _if:
            valid = True
        elif self.commands._if:
            valid = self.check_valid(get_params)
        if valid is not False:
            for item in self.content:
                if isinstance(item, Placeholder):
                    sub_valid, sub_output, enough = item.get(get_params, self)
                    output.append(sub_output)
                elif isinstance(item, Literal):
                    sub_valid = None
                    enough = True
                    output.append(item.text)
                elif isinstance(item, Block):
                    sub_valid, sub_output = item.render(get_params, module)
                    if sub_valid is None:
                        output.append(sub_output)
                    else:
                        output.extend(sub_output)
                valid = valid or sub_valid
        if not valid:
            if self.next_block:
                valid, output = self.next_block.render(get_params, module, _if=self.commands._if)
            elif self.parent is None and ((not self.next_block and enough) or self.base_block):
                valid = True
            else:
                output = []

        # clean
        color = self.commands.color
        if color and color[0] != "#":
            color_name = f"color_{color}"
            threshold_color_name = f"color_threshold_{color}"
            # substitute color
            color = (
                getattr(module, color_name, None)
                or getattr(module, threshold_color_name, None)
                or getattr(module.py3, color_name.upper(), None)
            )
            if color == "hidden":
                return False, []

        text = ""
        out = []
        if isinstance(output, str):
            output = [output]

        # merge as much output as we can.
        first = True
        last_block = None
        for index, item in enumerate(output):
            is_block = isinstance(item, Block)
            if not is_block and item:
                last_block = None
            if isinstance(item, (str, bool, int, float, bytes)) or item is None:
                text += str(item)
                continue
            elif text:
                if not first and (text == "" or out and out[-1].get("color") == color):
                    out[-1]["full_text"] += text
                else:
                    part = {"full_text": text}
                    if color:
                        part["color"] = color
                    out.append(part)
                text = ""
            if isinstance(item, Composite):
                if color:
                    item.composite_update(item, {"color": color}, soft=True)
                out.extend(item.get_content())
            elif is_block:
                # if this is a block then likely it is soft.
                if not out:
                    continue
                for other in output[index + 1 :]:
                    if other and not isinstance(other, Block):
                        valid, _output = item.render(get_params, module, _if=True)
                        if _output and _output != last_block:
                            last_block = _output
                            out.extend(_output)
                        break
            else:
                if item:
                    out.append(item)
            first = False

        # add any left over text
        if text:
            part = {"full_text": text}
            if color:
                part["color"] = color
            out.append(part)

        # process any min/max length commands
        max_length = self.commands.max_length
        min_length = self.commands.min_length

        if max_length or min_length:
            for item in out:
                if max_length is not None:
                    item["full_text"] = item["full_text"][:max_length]
                    max_length -= len(item["full_text"])
                if min_length:
                    min_length -= len(item["full_text"])
            if min_length > 0:
                out[0]["full_text"] = " " * min_length + out[0]["full_text"]
                min_length = 0

        return valid, out



================================================
FILE: py3status/helpers.py
================================================
import sys


def print_line(line):
    """
    Print given line to stdout (i3bar).
    """
    sys.__stdout__.write(f"{line}\n")
    sys.__stdout__.flush()


def print_stderr(line):
    """Print line to stderr"""
    print(line, file=sys.stderr)



================================================
FILE: py3status/i3status.py
================================================
import sys
import time
from copy import deepcopy
from datetime import datetime, timezone
from json import loads
from signal import SIG_IGN, SIGSTOP, SIGTSTP, SIGUSR1, signal
from subprocess import PIPE, Popen
from tempfile import NamedTemporaryFile
from threading import Thread

from py3status.constants import (
    I3S_ALLOWED_COLORS,
    I3S_COLOR_MODULES,
    TIME_FORMAT,
    TIME_MODULES,
    TZTIME_FORMAT,
)
from py3status.events import IOPoller
from py3status.profiling import profile
from py3status.py3 import Py3


class I3statusModule:
    """
    This a wrapper for i3status items so that they mirror some of the methods
    of the Module class.  It also helps encapsulate the auto time updating for
    `time` and `tztime`.
    """

    def __init__(self, module_name, i3status):
        self.module_name = module_name
        self.module_full_name = module_name

        # i3status modules always allow user defined click events in the config
        self.allow_config_clicks = True

        # i3status returns different name/instances than it is sent we want to
        # be able to restore the correct ones.
        try:
            name, instance = self.module_name.split()
        except:  # noqa e722
            name = self.module_name
            instance = ""
        self.name = name
        self.instance = instance

        # setup our output
        self.item = {"full_text": "", "name": name, "instance": instance}

        self.i3status = i3status
        py3_wrapper = i3status.py3_wrapper

        markup = py3_wrapper.config["py3_config"]["general"].get("markup")
        if markup:
            self.item["markup"] = markup

        # color map for if color good/bad etc are set for the module
        color_map = {}
        py3_config = py3_wrapper.config["py3_config"]
        for key, value in py3_config[module_name].items():
            if key in I3S_ALLOWED_COLORS:
                color_map[py3_config["general"][key]] = value
        self.color_map = color_map

        self.is_time_module = name in TIME_MODULES
        if self.is_time_module:
            self.setup_time_module()

    def setup_time_module(self):
        self.py3 = Py3()
        self.tz = None
        self.set_time_format()
        # we need to check the timezone this is when the check is next due
        self.time_zone_check_due = 0
        self.time_started = False

        time_format = self.time_format

        if "%f" in time_format:
            # microseconds
            time_delta = 0
        elif "%S" in time_format:
            # seconds
            time_delta = 1
        elif "%s" in time_format:
            # seconds since unix epoch start
            time_delta = 1
        elif "%T" in time_format:
            # seconds included in "%H:%M:%S"
            time_delta = 1
        elif "%c" in time_format or "%+" in time_format:
            # Locale's appropriate date and time representation
            time_delta = 1
        elif "%X" in time_format:
            # Locale's appropriate time representation
            time_delta = 1
        else:
            time_delta = 60
        self.time_delta = time_delta

    def __repr__(self):
        return f"<I3statusModule {self.module_name}>"

    def get_latest(self):
        return [self.item.copy()]

    def run(self):
        """
        updates the modules output.
        Currently only time and tztime need to do this
        """
        if self.update_time_value():
            self.i3status.py3_wrapper.notify_update(self.module_name)
        due_time = self.py3.time_in(sync_to=self.time_delta)

        self.i3status.py3_wrapper.timeout_queue_add(self, due_time)

    def update_from_item(self, item):
        """
        Update from i3status output. returns if item has changed.
        """
        if not self.is_time_module:
            # correct the output
            # Restore the name/instance.
            item["name"] = self.name
            item["instance"] = self.instance

            # change color good/bad is set specifically for module
            if "color" in item and item["color"] in self.color_map:
                item["color"] = self.color_map[item["color"]]

            # have we updated?
            is_updated = self.item != item
            self.item = item
        else:
            # If no timezone or a minute has passed update timezone
            t = time.monotonic()
            if self.time_zone_check_due < t:
                # If we are late for our timezone update then schedule the next
                # update to happen when we next get new data from i3status
                interval = self.i3status.update_interval
                if not self.set_time_zone(item):
                    # we had an issue with an invalid time zone probably due to
                    # suspending.  re check the time zone when we next can.
                    self.time_zone_check_due = 0
                elif self.time_zone_check_due and (t - self.time_zone_check_due > 5 + interval):
                    self.time_zone_check_due = 0
                else:
                    # Check again in 30 mins.  We do this in case the timezone
                    # used has switched to/from summer time
                    self.time_zone_check_due = ((int(t) // 1800) * 1800) + 1800
                if not self.time_started:
                    self.time_started = True
                    self.i3status.py3_wrapper.timeout_queue_add(self)
            is_updated = False
            # update time to be shown
        return is_updated

    def set_time_format(self):
        config = self.i3status.py3_config.get(self.module_name, {})
        time_format = config.get("format", TIME_FORMAT)
        # Handle format_time parameter if exists
        # Not sure if i3status supports this but docs say it does
        if "format_time" in config:
            time_format = time_format.replace("%time", config["format_time"])
        self.time_format = time_format

    def update_time_value(self):
        date = datetime.now(self.tz)
        # set the full_text with the correctly formatted date
        try:
            new_value = date.strftime(self.time_format)
        except:  # noqa e722
            # python 2 unicode
            new_value = date.strftime(self.time_format.encode("utf-8"))
            new_value = new_value.decode("utf-8")
        updated = self.item["full_text"] != new_value
        if updated:
            self.item["full_text"] = new_value
        return updated

    def set_time_zone(self, item):
        """
        Work out the time zone and create a shim tzinfo.

        We return True if all is good or False if there was an issue and we
        need to re check the time zone.  see issue #1375
        """
        # parse i3status date
        i3s_time = item["full_text"].encode("UTF-8", "replace")
        try:
            # python3 compatibility code
            i3s_time = i3s_time.decode()
        except:  # noqa e722
            pass

        # get datetime and time zone info
        parts = i3s_time.split()
        i3s_datetime = " ".join(parts[:2])
        # occasionally we do not get the timezone name
        if len(parts) < 3:
            return True
        else:
            i3s_time_tz = parts[2]

        date = datetime.strptime(i3s_datetime, TIME_FORMAT)
        # calculate the time delta
        utcnow = datetime.utcnow()
        delta = datetime(date.year, date.month, date.day, date.hour, date.minute) - datetime(
            utcnow.year, utcnow.month, utcnow.day, utcnow.hour, utcnow.minute
        )
        # create our custom timezone
        try:
            self.tz = timezone(delta, i3s_time_tz)
        except ValueError:
            return False
        return True


class I3status(Thread):
    """
    This class is responsible for spawning i3status and reading its output.
    """

    def __init__(self, py3_wrapper):
        """
        Our output will be read asynchronously from 'last_output'.
        """
        Thread.__init__(self)
        self.error = None
        self.i3modules = {}
        self.i3status_pipe = None
        self.i3status_path = py3_wrapper.config["i3status_path"]
        self.json_list = None
        self.json_list_ts = None
        self.last_output = None
        self.last_refresh_ts = time.monotonic()
        self.lock = py3_wrapper.lock
        self.new_update = False
        self.py3_config = py3_wrapper.config["py3_config"]
        self.py3_wrapper = py3_wrapper
        self.ready = False
        self.standalone = py3_wrapper.config["standalone"]
        self.time_modules = []
        self.tmpfile_path = None
        self.update_due = 0

        # the update interval is useful to know
        self.update_interval = self.py3_wrapper.get_config_attribute("general", "interval")
        # do any initialization
        self.setup()

    def setup(self):
        """
        Do any setup work needed to run i3status modules
        """
        for conf_name in self.py3_config["i3s_modules"]:
            module = I3statusModule(conf_name, self)
            self.i3modules[conf_name] = module
            if module.is_time_module:
                self.time_modules.append(module)

    def set_responses(self, json_list):
        """
        Set the given i3status responses on their respective configuration.
        """
        self.update_json_list()
        updates = []
        for index, item in enumerate(self.json_list):
            conf_name = self.py3_config["i3s_modules"][index]

            module = self.i3modules[conf_name]
            if module.update_from_item(item):
                updates.append(conf_name)
        if updates:
            self.py3_wrapper.notify_update(updates)

    def update_json_list(self):
        """
        Copy the last json list output from i3status so that any module
        can modify it without altering the original output.
        This is done so that any module's alteration of a i3status output json
        will not be overwritten when the next i3status output gets polled.
        """
        self.json_list = deepcopy(self.last_output)

    @staticmethod
    def write_in_tmpfile(text, tmpfile):
        """
        Write the given text in the given tmpfile in python2 and python3.
        """
        try:
            tmpfile.write(text)
        except TypeError:
            tmpfile.write(str.encode(text))
        except UnicodeEncodeError:
            tmpfile.write(text.encode("utf-8"))

    def write_tmp_i3status_config(self, tmpfile):
        """
        Given a temporary file descriptor, write a valid i3status config file
        based on the parsed one from 'i3status_config_path'.
        """
        # order += ...
        for module in self.py3_config["i3s_modules"]:
            self.write_in_tmpfile(f'order += "{module}"\n', tmpfile)
        self.write_in_tmpfile("\n", tmpfile)
        # config params for general section and each module
        for section_name in ["general"] + self.py3_config["i3s_modules"]:
            section = self.py3_config[section_name]
            self.write_in_tmpfile(f"{section_name} {{\n", tmpfile)
            for key, value in section.items():
                # don't include color values except in the general section
                if key.startswith("color"):
                    if (
                        section_name.split(" ")[0] not in I3S_COLOR_MODULES
                        or key not in I3S_ALLOWED_COLORS
                    ):
                        continue
                # Set known fixed format for time and tztime so we can work
                # out the timezone
                if section_name.split()[0] in TIME_MODULES:
                    if key == "format":
                        value = TZTIME_FORMAT
                    if key == "format_time":
                        continue
                # Set output_format to i3bar in general section so that we
                # receive predictable output from i3status, regardless of our
                # own output_format configuration
                if section_name == "general":
                    if key == "output_format":
                        value = "i3bar"
                if isinstance(value, bool):
                    value = f"{value}".lower()
                self.write_in_tmpfile(f'    {key} = "{value}"\n', tmpfile)
            self.write_in_tmpfile("}\n\n", tmpfile)
        tmpfile.flush()

    def suspend_i3status(self):
        # Put i3status to sleep
        if self.i3status_pipe:
            self.i3status_pipe.send_signal(SIGSTOP)

    def refresh_i3status(self):
        # refresh i3status.  This is rate limited
        if time.monotonic() > (self.last_refresh_ts + 0.1):
            if self.py3_wrapper.config["debug"]:
                self.py3_wrapper.log("refreshing i3status")
            if self.i3status_pipe:
                self.i3status_pipe.send_signal(SIGUSR1)
            self.last_refresh_ts = time.monotonic()

    @profile
    def run(self):
        # if the i3status process dies we want to restart it.
        # We give up restarting if we have died too often
        for _ in range(10):
            if not self.py3_wrapper.running:
                break
            self.spawn_i3status()
            # check if we never worked properly and if so quit now
            if not self.ready:
                break
            # limit restart rate
            self.lock.wait(5)

    def spawn_i3status(self):
        """
        Spawn i3status using a self generated config file and poll its output.
        """
        try:
            with NamedTemporaryFile(prefix="py3status_") as tmpfile:
                self.write_tmp_i3status_config(tmpfile)

                i3status_pipe = Popen(
                    [self.i3status_path, "-c", tmpfile.name],
                    stdout=PIPE,
                    stderr=PIPE,
                    # Ignore the SIGTSTP signal for this subprocess
                    preexec_fn=lambda: signal(SIGTSTP, SIG_IGN),
                )

                self.py3_wrapper.log(f"i3status spawned using config file {tmpfile.name}")

                self.poller_inp = IOPoller(i3status_pipe.stdout)
                self.poller_err = IOPoller(i3status_pipe.stderr)
                self.tmpfile_path = tmpfile.name

                # Store the pipe so we can signal it
                self.i3status_pipe = i3status_pipe

                try:
                    # loop on i3status output
                    while self.py3_wrapper.running:
                        line = self.poller_inp.readline()
                        if line:
                            # remove leading comma if present
                            if line[0] == ",":
                                line = line[1:]
                            if line.startswith("[{"):
                                json_list = loads(line)
                                self.last_output = json_list
                                self.set_responses(json_list)
                                self.ready = True
                        else:
                            err = self.poller_err.readline()
                            code = i3status_pipe.poll()
                            if code is not None:
                                msg = "i3status died"
                                if err:
                                    msg += f" and said: {err}"
                                else:
                                    msg += f" with code {code}"
                                raise OSError(msg)
                except OSError:
                    err = sys.exc_info()[1]
                    self.error = err
                    self.py3_wrapper.log(err, "error")
        except OSError:
            self.error = "Problem starting i3status maybe it is not installed"
        except Exception:
            self.py3_wrapper.report_exception("", notify_user=True)
        self.i3status_pipe = None

    def mock(self):
        """
        Mock i3status behavior, used in standalone mode.
        """
        # mock thread is_alive() method
        self.is_alive = lambda: True



================================================
FILE: py3status/module.py
================================================
import inspect
import time
from collections import OrderedDict
from importlib.machinery import SourceFileLoader
from pathlib import Path
from random import randint
from types import FunctionType

from py3status.composite import Composite
from py3status.constants import MARKUP_LANGUAGES, ON_ERROR_VALUES, POSITIONS
from py3status.formatter import Formatter
from py3status.profiling import profile
from py3status.py3 import ModuleErrorException, Py3


def make_quotes(options):
    x = [f"`{x}`" for x in options]
    if len(x) > 2:
        x = [", ".join(x[:-1]), x[-1]]
    return " or ".join(x)


class Module:
    """
    This class represents a user module (imported file).
    It is responsible for executing it every given interval and
    caching its output based on user will.
    """

    PARAMS_NEW = "new"
    PARAMS_LEGACY = "legacy"
    EXPECTED_CLASS = "Py3status"

    def __init__(self, module, user_modules, py3_wrapper, instance=None):
        """
        We need quite some stuff to occupy ourselves don't we ?
        """
        self.allow_config_clicks = True
        self.allow_urgent = None
        self.cache_time = None
        self.click_events = False
        self.config = py3_wrapper.config
        self.disabled = False
        self.enabled = False
        self.error_messages = None
        self.error_hide = False
        self.has_post_config_hook = False
        self.has_kill = False
        self.i3status_thread = py3_wrapper.i3status_thread
        self.last_output = []
        self.methods = OrderedDict()
        self.module_class = instance
        self.module_full_name = module
        self.module_inst = "".join(module.split(" ")[1:])
        self.module_name = module.split(" ")[0]
        self.new_update = False
        self.nagged = False
        self.on_error = None
        self.prevent_refresh = False
        self.sleeping = False
        self.terminated = False
        self.testing = self.config.get("testing")
        self.urgent = False
        self.i3bar_gaps_urgent_options = {}

        # create a nice name for the module that matches what the module is
        # called in the user config
        if self.module_inst.startswith("_anon_module_"):
            self.module_nice_name = self.module_name
        else:
            self.module_nice_name = self.module_full_name

        # py3wrapper this is private and any modules accessing their instance
        # should only use it on the understanding that it is not supported.
        self._py3_wrapper = py3_wrapper

        try:
            self.load_methods(module, user_modules)
        except Exception as e:
            # Import failed notify user in module error output
            self.disabled = True
            self.methods["error"] = {}
            self.error_index = 0
            self.error_messages = [
                self.module_nice_name,
                "{}: Import Error, {}".format(self.module_nice_name, str(e)),
            ]
            self.error_output(self.error_messages[0])
            # log the error
            msg = f"Module `{self.module_full_name}` could not be loaded ({e})"
            if isinstance(e, SyntaxError):
                # provide full traceback
                self._py3_wrapper.report_exception(msg, notify_user=False)
            else:
                # module import error we can just report the module that cannot
                # be imported
                self._py3_wrapper.log(msg)
                self._py3_wrapper.log(str(e))

        # check module/py3status config section
        if not self.disabled:
            self.set_module_options(module)

    def __repr__(self):
        return f"<Module {self.module_full_name}>"

    @classmethod
    def load_from_file(cls, filepath):
        """
        Return user-written class object from given path.
        """
        class_inst = None
        if filepath.suffix == ".py":
            py_mod = SourceFileLoader(filepath.stem, filepath.as_posix()).load_module()
            if hasattr(py_mod, cls.EXPECTED_CLASS):
                class_inst = py_mod.Py3status()
        return class_inst

    @staticmethod
    def load_from_namespace(module_name):
        """
        Load a py3status bundled module.
        """
        class_inst = None
        name = f"py3status.modules.{module_name}"
        py_mod = __import__(name)
        components = name.split(".")
        for comp in components[1:]:
            py_mod = getattr(py_mod, comp)
        class_inst = py_mod.Py3status()
        return class_inst

    def prepare_module(self):
        """
        Ready the module to get it ready to start.
        """
        # Modules can define a post_config_hook() method which will be run
        # after the module has had it config settings applied and before it has
        # its main method(s) called for the first time.  This allows modules to
        # perform any necessary setup.
        if self.has_post_config_hook:
            try:
                self.module_class.post_config_hook()
            except Exception as e:
                # An exception has been thrown in post_config_hook() disable
                # the module and show error in module output
                self.terminated = True
                self.error_index = 0

                self.error_messages = [
                    self.module_nice_name,
                    f"{e}",
                ]
                self.runtime_error(self.error_messages[1], "post_config_hook")
                msg = f"Exception in `{self.module_full_name}` post_config_hook() : {self.error_messages}"
                self._py3_wrapper.report_exception(msg, notify_user=False)
                self._py3_wrapper.log(f"terminating module {self.module_full_name}")
        self.enabled = True

    def runtime_error(self, msg, method):
        """
        Show the error in the bar
        """
        if self.testing:
            self._py3_wrapper.report_exception(msg)
            raise KeyboardInterrupt

        if self.on_error == "hide" or self.error_hide:
            self.hide_errors()
            return

        # only show first line of error
        msg = msg.splitlines()[0]

        errors = [self.module_nice_name, f"{self.module_nice_name}[{method}]: {msg}"]

        # if we have shown this error then keep in the same state
        if self.error_messages != errors:
            self.error_messages = errors
            self.error_index = 0
        self.error_output(self.error_messages[self.error_index], method)

    def error_output(self, message, method_affected=None):
        """
        Something is wrong with the module so we want to output the error to
        the i3bar
        """
        color_fn = self._py3_wrapper.get_config_attribute
        color = color_fn(self.module_full_name, "color_error")
        if hasattr(color, "none_setting"):
            color = color_fn(self.module_full_name, "color_bad")
        if hasattr(color, "none_setting"):
            color = None

        error = {
            "full_text": message,
            "color": color,
            "instance": self.module_inst,
            "name": self.module_name,
        }
        for method in self.methods.values():
            if (
                method_affected
                and method["method"] != method_affected
                and method_affected != "post_config_hook"
            ):
                continue

            method["last_output"] = [error]

        self.allow_config_clicks = False
        self.set_updated()

    def hide_errors(self):
        """
        hide the module in the i3bar
        """
        for method in self.methods.values():
            method["last_output"] = {}

        self.allow_config_clicks = False
        self.error_hide = True
        self.set_updated()

    def start_module(self):
        """
        Start the module running.
        """
        self.prepare_module()
        if not (self.disabled or self.terminated):
            # Start the module and call its output method(s)
            self._py3_wrapper.log(f"starting module {self.module_full_name}")
            self._py3_wrapper.timeout_queue_add(self)

    def force_update(self):
        """
        Forces an update of the module.
        """
        if self.disabled or self.terminated or not self.enabled:
            return
        # clear cached_until for each method to allow update
        for meth, my_method in self.methods.items():
            my_method["cached_until"] = time.monotonic()
            if self.config["debug"]:
                self._py3_wrapper.log(f"clearing cache for method {meth}")
        # set module to update
        self._py3_wrapper.timeout_queue_add(self)

    def sleep(self):
        self.sleeping = True

    def disable_module(self):
        # hide message
        self.disabled = True
        # purge from any container modules
        self._py3_wrapper.purge_module(self.module_full_name)
        self.error_output("")
        self._py3_wrapper.log(f"disabling module `{self.module_full_name}`")

    def wake(self):
        self.sleeping = False
        if self.disabled:
            # module is disabled so don't wake
            return
        if self.cache_time is None:
            return
        # new style modules can signal they want to cache forever
        if self.cache_time == Py3.CACHE_FOREVER:
            return
        # restart
        self._py3_wrapper.timeout_queue_add(self, self.cache_time)

    def set_updated(self):
        """
        Mark the module as updated.
        We check if the actual content has changed and if so we trigger an
        update in py3status.
        """
        # get latest output
        output = []
        for method in self.methods.values():
            data = method["last_output"]
            if isinstance(data, list):
                if self.testing and data:
                    data[0]["cached_until"] = method.get("cached_until")
                output.extend(data)
            else:
                # if the output is not 'valid' then don't add it.
                if data.get("full_text") or "separator" in data:
                    if self.testing:
                        data["cached_until"] = method.get("cached_until")
                    output.append(data)
        # if changed store and force display update.
        if output != self.last_output:
            # has the modules output become urgent?
            # we only care the update that this happens
            # not any after then.
            urgent = True in [x.get("urgent") for x in output]
            if urgent != self.urgent:
                self.urgent = urgent
            else:
                urgent = False
            self.last_output = output
            self._py3_wrapper.notify_update(self.module_full_name, urgent)

    def get_latest(self):
        """
        return latest output.
        """
        return self.last_output

    def set_module_options(self, module):
        """
        Set universal module options to be interpreted by i3bar
        https://i3wm.org/i3status/manpage.html#_universal_module_options
        """
        self.i3bar_module_options = {}
        self.i3bar_gaps_module_options = {}
        self.py3status_module_options = {}
        fn = self._py3_wrapper.get_config_attribute

        # i3bar
        min_width = fn(self.module_full_name, "min_width")
        if not hasattr(min_width, "none_setting"):
            if not isinstance(min_width, int):
                err = "Invalid `min_width` attribute, should be an int. "
                err += f"Got `{min_width}`."
                raise TypeError(err)
            self.i3bar_module_options["min_width"] = min_width

            align = fn(self.module_full_name, "align")
            if not hasattr(align, "none_setting"):
                if align not in POSITIONS:
                    err = "Invalid `align` attribute, should be "
                    err += make_quotes(POSITIONS)
                    err += f". Got `{align}`."
                    raise ValueError(err)
                self.i3bar_module_options["align"] = align

        separator = fn(self.module_full_name, "separator")
        if not hasattr(separator, "none_setting"):
            # HACK: separator is a valid setting in the general section
            # of the configuration. but it's a string, not a boolean.
            # revisit how i3status and py3status differ in this regard.
            # if not isinstance(separator, bool):

            #     err = "Invalid `separator` attribute, should be a boolean. "
            #     err += f"Got `{separator}`."
            #     raise TypeError(err)
            # self.i3bar_module_options["separator"] = separator
            if isinstance(separator, bool):
                self.i3bar_module_options["separator"] = separator

        separator_block_width = fn(self.module_full_name, "separator_block_width")
        if not hasattr(separator_block_width, "none_setting"):
            if not isinstance(separator_block_width, int):
                err = "Invalid `separator_block_width` attribute, "
                err += "should be an int. "
                err += f"Got `{separator_block_width}`."
                raise TypeError(err)
            self.i3bar_module_options["separator_block_width"] = separator_block_width

        # i3bar_gaps
        background = fn(self.module_full_name, "background")
        if not hasattr(background, "none_setting"):
            color = self.module_class.py3._get_color(background)
            if not color:
                err = "Invalid `background` attribute should be a color. "
                err += f"Got `{background}`."
                raise ValueError(err)
            self.i3bar_gaps_module_options["background"] = color

        border = fn(self.module_full_name, "border")
        if not hasattr(border, "none_setting"):
            color = self.module_class.py3._get_color(border)
            if not color:
                err = "Invalid `border` attribute, should be a color. "
                err += f"Got `{border}`."
                raise ValueError(err)
            self.i3bar_gaps_module_options["border"] = color

            borders = ["top", "right", "bottom", "left"]
            for name in ["border_" + x for x in borders]:
                param = fn(self.module_full_name, name)
                if hasattr(param, "none_setting"):
                    param = 1
                elif not isinstance(param, int):
                    err = f"Invalid `{name}` attribute, "
                    err += "should be an int. "
                    err += f"Got `{param}`."
                    raise TypeError(err)
                self.i3bar_gaps_module_options[name] = param

        # py3status
        min_length = fn(self.module_full_name, "min_length")
        if not hasattr(min_length, "none_setting"):
            if not isinstance(min_length, int):
                err = "Invalid `min_length` attribute, should be an int. "
                err += f"Got `{min_length}`."
                raise TypeError(err)
            self.py3status_module_options["min_length"] = min_length
            self.random_int = randint(0, 1)

            position = fn(self.module_full_name, "position")
            if not hasattr(position, "none_setting"):
                if position not in POSITIONS:
                    err = "Invalid `position` attribute, should be "
                    err += make_quotes(POSITIONS)
                    err += f". Got `{position}`."
                    raise ValueError(err)
                self.py3status_module_options["position"] = position

        # i3bar, py3status
        markup = fn(self.module_full_name, "markup")
        if not hasattr(markup, "none_setting"):
            if markup not in MARKUP_LANGUAGES:
                err = "Invalid `markup` attribute, should be "
                err += make_quotes(MARKUP_LANGUAGES)
                err += f". Got `{markup}`."
                raise ValueError(err)
            self.i3bar_module_options["markup"] = markup
            self.py3status_module_options["markup"] = markup

    def process_composite(self, response):
        """
        Process a composite response.
        composites do not have inter item separators as they appear joined.
        We need to respect the universal options too.
        """
        composite = response["composite"]

        # if the composite is of not Composite make it one so we can simplify
        # it.
        if not isinstance(composite, Composite):
            composite = Composite(composite)

        # simplify and get underlying list.
        composite = composite.simplify().get_content()
        response["composite"] = composite

        if not isinstance(composite, list):
            raise Exception('expecting "composite" key in response')
        # if list is empty nothing to do
        if not len(composite):
            return
        if "full_text" in response:
            err = 'conflicting "full_text" and "composite" in response'
            raise Exception(err)

        # set markup
        if "markup" in self.py3status_module_options:
            markup = self.py3status_module_options["markup"]
            for item in composite:
                item["markup"] = markup

        # set universal options on last component
        composite[-1].update(self.i3bar_module_options)
        # update all components
        color = response.get("color")
        urgent = response.get("urgent")
        composite_length = len(response["composite"]) - 1
        for index, item in enumerate(response["composite"]):
            # validate the response
            if "full_text" not in item:
                raise KeyError('missing "full_text" key in response')
            # make sure all components have a name
            if "name" not in item:
                instance_index = item.get("index", index)
                item["instance"] = f"{self.module_inst} {instance_index}"
                item["name"] = self.module_name
            # hide separator for all inner components unless existing
            if index != composite_length:
                if "separator" not in item:
                    item["separator"] = False
                    item["separator_block_width"] = 0
            # If a color was supplied for the composite and a composite
            # part does not supply a color, use the composite color.
            if color and "color" not in item:
                item["color"] = color
            # Remove any none color from our output
            if hasattr(item.get("color"), "none_setting"):
                del item["color"]

            # set background and border colors. set left/right border widths
            # only on first/last composites and no border width for inner
            # composites or we will see border lines between composites.
            for key, value in self.i3bar_gaps_module_options.items():
                if (key == "border_left" and index != 0) or (
                    key == "border_right" and index != composite_length
                ):
                    item[key] = 0
                else:
                    item[key] = value

            # set urgent based on available user-defined settings
            if not self.allow_urgent:
                if "urgent" in item:
                    del item["urgent"]
            elif urgent:
                if self.i3bar_gaps_urgent_options:
                    # set background and border colors. set left/right border widths
                    # only on first/last composites and no border width for inner
                    # composites or we will see border lines between composites.
                    for key, value in self.i3bar_gaps_urgent_options.items():
                        if (key == "border_left" and index != 0) or (
                            key == "border_right" and index != composite_length
                        ):
                            item[key] = 0
                        elif key == "foreground":
                            item["color"] = value
                        else:
                            item[key] = value
                    if "urgent" in item:
                        del item["urgent"]
                else:
                    item["urgent"] = urgent

        # set min_length
        if "min_length" in self.py3status_module_options:
            min_length = self.py3status_module_options["min_length"]

            # get length, skip if length exceeds min_length
            length = sum(len(x["full_text"]) for x in response["composite"])
            if length >= min_length:
                return

            # sometimes we go under min_length to pad both side evenly,
            # we will add extra space on either side to honor min_length
            padding = min_length // 2 - length // 2
            offset = min_length - ((padding * 2) + length)

            # set position
            position = self.py3status_module_options.get("position", "left")
            if position == "center":
                left = right = " " * padding
                if self.random_int:
                    left += " " * offset
                else:
                    right += " " * offset
            elif position == "left":
                left, right = "", " " * (padding * 2 + offset)
            elif position == "right":
                right, left = "", " " * (padding * 2 + offset)

            # padding
            if left:
                response["composite"][0]["full_text"] = left + response["composite"][0]["full_text"]
            if right:
                response["composite"][-1]["full_text"] += right

    def _params_type(self, method_name, instance):
        """
        Check to see if this is a legacy method or shiny new one

        legacy update method:
            def update(self, i3s_output_list, i3s_config):
                ...

        new update method:
            def update(self):
                ...

        Returns False if the method does not exist,
        else PARAMS_NEW or PARAMS_LEGACY
        """

        method = getattr(instance, method_name, None)
        if not method:
            return False

        # Check the parameters we simply count the number of args and don't
        # allow any extras like keywords.
        arg_count = 1
        # on_click method has extra events parameter
        if method_name == "on_click":
            arg_count = 2
        args, vargs, kw, defaults, _, _, _ = inspect.getfullargspec(method)
        if len(args) == arg_count and not vargs and not kw:
            return self.PARAMS_NEW
        else:
            return self.PARAMS_LEGACY

    def load_methods(self, module, user_modules):
        """
        Read the given user-written py3status class file and store its methods.
        Those methods will be executed, so we will deliberately ignore:
            - private methods starting with _
            - decorated methods such as @property or @staticmethod
            - 'on_click' methods as they'll be called upon a click_event
            - 'kill' methods as they'll be called upon this thread's exit
        """
        if not self.module_class:
            # user provided modules take precedence over py3status provided modules
            if self.module_name in user_modules:
                include_path, f_name = user_modules[self.module_name]
                module_path = Path(include_path) / f_name
                self._py3_wrapper.log(f'loading module "{module}" from {module_path}')
                self.module_class = self.load_from_file(module_path)
            # load from py3status provided modules
            else:
                self._py3_wrapper.log(
                    'loading module "{}" from py3status.modules.{}'.format(module, self.module_name)
                )
                self.module_class = self.load_from_namespace(self.module_name)

        class_inst = self.module_class
        if class_inst:
            try:
                # containers have items attribute set to a list of contained
                # module instance names.  If there are no contained items then
                # ensure that we have a empty list.
                if class_inst.Meta.container:
                    class_inst.items = []
            except AttributeError:
                pass

            # module configuration
            fn = self._py3_wrapper.get_config_attribute
            mod_config = self.config["py3_config"].get(module, {})

            # resources
            if self.config.get("resources"):
                module = self.module_full_name
                resources = fn(module, "resources")
                if not hasattr(resources, "none_setting"):
                    exception = True
                    if isinstance(resources, list):
                        exception = False
                        for resource in resources:
                            if not isinstance(resource, tuple) or len(resource) != 3:
                                exception = True
                                break
                    if exception:
                        err = "Invalid `resources` attribute, "
                        err += "should be a list of 3-tuples. "
                        raise TypeError(err)

                    from fnmatch import fnmatch

                    for resource in resources:
                        key, resource, value = resource
                        for setting in self.config["resources"]:
                            if fnmatch(setting, resource):
                                value = self.config["resources"][setting]
                                break
                        self.config["py3_config"][module][key] = value

            # process any deprecated configuration settings
            try:
                deprecated = class_inst.Meta.deprecated
            except AttributeError:
                deprecated = None

            if deprecated:

                def deprecation_log(item):
                    # log the deprecation
                    # currently this is just done to the log file as the user
                    # does not need to take any action.
                    if "msg" in item:
                        msg = item["msg"]
                        param = item.get("param")
                        if param:
                            msg = f"`{param}` {msg}"
                        msg = "DEPRECATION WARNING: {} {}".format(self.module_full_name, msg)
                        self._py3_wrapper.log(msg)

                if "rename" in deprecated:
                    # renamed parameters
                    for item in deprecated["rename"]:
                        param = item["param"]
                        new_name = item["new"]
                        if param in mod_config:
                            if new_name not in mod_config:
                                mod_config[new_name] = mod_config[param]
                                # remove from config
                                del mod_config[param]
                            deprecation_log(item)
                if "format_fix_unnamed_param" in deprecated:
                    # format update where {} was previously allowed
                    for item in deprecated["format_fix_unnamed_param"]:
                        param = item["param"]
                        placeholder = item["placeholder"]
                        if "{}" in mod_config.get(param, ""):
                            mod_config[param] = mod_config[param].replace(
                                "{}", f"{{{placeholder}}}"
                            )
                            deprecation_log(item)
                if "rename_placeholder" in deprecated:
                    # rename placeholders
                    placeholders = {}
                    for item in deprecated["rename_placeholder"]:
                        placeholders[item["placeholder"]] = item["new"]
                        format_strings = item["format_strings"]
                        for format_param in format_strings:
                            format_string = mod_config.get(format_param)
                            if not format_string:
                                continue
                            format = Formatter().update_placeholders(format_string, placeholders)
                            mod_config[format_param] = format

                if "update_placeholder_format" in deprecated:
                    # update formats for placeholders if a format is not set
                    for item in deprecated["update_placeholder_format"]:
                        placeholder_formats = item.get("placeholder_formats", {})
                        if "function" in item:
                            placeholder_formats.update(item["function"](mod_config))
                        format_strings = item["format_strings"]
                        for format_param in format_strings:
                            format_string = mod_config.get(format_param)
                            if not format_string:
                                continue
                            format = Formatter().update_placeholder_formats(
                                format_string, placeholder_formats
                            )
                            mod_config[format_param] = format
                if "substitute_by_value" in deprecated:
                    # one parameter sets the value of another
                    for item in deprecated["substitute_by_value"]:
                        param = item["param"]
                        value = item["value"]
                        substitute = item["substitute"]
                        substitute_param = substitute["param"]
                        substitute_value = substitute["value"]
                        if mod_config.get(param) == value and substitute_param not in mod_config:
                            mod_config[substitute_param] = substitute_value
                            deprecation_log(item)
                if "function" in deprecated:
                    # parameter set by function
                    for item in deprecated["function"]:
                        updates = item["function"](mod_config)
                        for name, value in updates.items():
                            if name not in mod_config:
                                mod_config[name] = value
                if "remove" in deprecated:
                    # obsolete parameters forcibly removed
                    for item in deprecated["remove"]:
                        param = item["param"]
                        if param in mod_config:
                            del mod_config[param]
                            deprecation_log(item)

            # apply module configuration
            for config, value in mod_config.items():
                # names starting with '.' are private
                if not config.startswith("."):
                    setattr(self.module_class, config, value)

            # process any update_config settings
            try:
                update_config = class_inst.Meta.update_config
            except AttributeError:
                update_config = None

            if update_config:
                if "update_placeholder_format" in update_config:
                    # update formats for placeholders if a format is not set
                    for item in update_config["update_placeholder_format"]:
                        placeholder_formats = item.get("placeholder_formats", {})
                        format_strings = item["format_strings"]
                        for format_param in format_strings:
                            format_string = getattr(class_inst, format_param, None)
                            if not format_string:
                                continue
                            format = Formatter().update_placeholder_formats(
                                format_string, placeholder_formats
                            )
                            setattr(class_inst, format_param, format)

            # Add the py3 module helper if modules self.py3 is not defined
            if not hasattr(self.module_class, "py3"):
                setattr(self.module_class, "py3", Py3(self))

            # Subscribe to udev events if on_udev_* dynamic variables are
            # configured on the module
            for param in dir(self.module_class):
                if param.startswith("on_udev_"):
                    trigger_action = getattr(self.module_class, param)
                    self.add_udev_trigger(trigger_action, param[8:])

            # allow_urgent
            param = fn(self.module_full_name, "allow_urgent")
            if hasattr(param, "none_setting"):
                param = True
            self.allow_urgent = param

            # on_error
            param = fn(self.module_full_name, "on_error")
            if hasattr(param, "none_setting"):
                param = "show"
            if param not in ON_ERROR_VALUES:
                err = "Invalid `on_error` attribute, should be one of "
                err += "{}. Got `{}`.".format(make_quotes(ON_ERROR_VALUES), param)
                raise ValueError(err)
            self.on_error = param

            # urgent background
            urgent_background = fn(self.module_full_name, "urgent_background")
            if not hasattr(urgent_background, "none_setting"):
                color = self.module_class.py3._get_color(urgent_background)
                if not color:
                    err = "Invalid `urgent_background` attribute, should be "
                    err += f"a color. Got `{urgent_background}`."
                    raise ValueError(err)
                self.i3bar_gaps_urgent_options["background"] = color

            # urgent foreground
            urgent_foreground = fn(self.module_full_name, "urgent_foreground")
            if not hasattr(urgent_foreground, "none_setting"):
                color = self.module_class.py3._get_color(urgent_foreground)
                if not color:
                    err = "Invalid `urgent_foreground` attribute, should be "
                    err += f"a color. Got `{urgent_foreground}`."
                    raise ValueError(err)
                self.i3bar_gaps_urgent_options["foreground"] = color

            # urgent urgent_borders
            urgent_border = fn(self.module_full_name, "urgent_border")
            if not hasattr(urgent_border, "none_setting"):
                color = self.module_class.py3._get_color(urgent_border)
                if not color:
                    err = "Invalid `urgent_border` attribute, should be a color. "
                    err += f"Got `{urgent_border}`."
                    raise ValueError(err)
                self.i3bar_gaps_urgent_options["border"] = color

                urgent_borders = ["top", "right", "bottom", "left"]
                for name in ["urgent_border_" + x for x in urgent_borders]:
                    param = fn(self.module_full_name, name)
                    if hasattr(param, "none_setting"):
                        param = 1
                    elif not isinstance(param, int):
                        err = f"Invalid `{name}` attribute, "
                        err += "should be an int. "
                        err += f"Got `{param}`."
                        raise TypeError(err)
                    self.i3bar_gaps_urgent_options[name[7:]] = param

            # get the available methods for execution
            for method in sorted(dir(class_inst)):
                if method.startswith("_"):
                    continue
                else:
                    m_attr = inspect.getattr_static(class_inst, method)
                    if isinstance(m_attr, FunctionType):
                        params_type = self._params_type(method, class_inst)
                        if method == "on_click":
                            self.click_events = params_type
                        elif method == "kill":
                            self.has_kill = params_type
                        elif method == "post_config_hook":
                            self.has_post_config_hook = True
                        else:
                            # the method_obj stores infos about each method
                            # of this module.
                            method_obj = {
                                "cached_until": time.monotonic(),
                                "call_type": params_type,
                                "instance": None,
                                "last_output": {"name": method, "full_text": ""},
                                "method": method,
                                "name": None,
                            }
                            self.methods[method] = method_obj

        # done, log some debug info
        if self.config["debug"]:
            self._py3_wrapper.log(
                'module "{}" click_events={} has_kill={} methods={}'.format(
                    module, self.click_events, self.has_kill, list(self.methods)
                )
            )

    def click_event(self, event):
        """
        Execute the 'on_click' method of this module with the given event.
        """
        # we can prevent request that a refresh after the event has happened
        # by setting this to True.  Modules should do this via
        # py3.prevent_refresh()
        self.prevent_refresh = False
        try:
            if self.error_messages:
                # we have error messages
                button = event["button"]
                if button == 1:
                    # cycle through to next message
                    self.error_index = (self.error_index + 1) % len(self.error_messages)
                    error = self.error_messages[self.error_index]
                    self.error_output(error)
                if button == 3:
                    self.hide_errors()
                if button != 2 or (self.terminated or self.disabled):
                    self.prevent_refresh = True

            elif self.click_events:
                click_method = getattr(self.module_class, "on_click")
                if self.click_events == self.PARAMS_NEW:
                    # new style modules
                    click_method(event)
                else:
                    # legacy modules had extra parameters passed
                    click_method(
                        self.i3status_thread.json_list,
                        self.config["py3_config"]["general"],
                        event,
                    )
                self.set_updated()
            else:
                # nothing has happened so no need for refresh
                self.prevent_refresh = True
        except Exception:
            msg = f"on_click event in `{self.module_full_name}` failed"
            self._py3_wrapper.report_exception(msg)

    @profile
    def run(self):
        """
        On a timely fashion, execute every method found for this module.
        We will respect and set a cache timeout for each method if the user
        didn't already do so.
        We will execute the 'kill' method of the module when we terminate.
        """
        if self._py3_wrapper.running:
            cache_time = None
            # execute each method of this module
            for meth, my_method in self.methods.items():
                # always check py3status is running
                if not self._py3_wrapper.running:
                    break

                # respect the cache set for this method
                if time.monotonic() < my_method["cached_until"]:
                    if not cache_time or my_method["cached_until"] < cache_time:
                        cache_time = my_method["cached_until"]
                    continue

                try:
                    # execute method and get its output
                    method = getattr(self.module_class, meth)
                    if my_method["call_type"] == self.PARAMS_NEW:
                        # new style modules
                        response = method()
                    else:
                        # legacy modules had parameters passed
                        response = method(
                            self.i3status_thread.json_list,
                            self.config["py3_config"]["general"],
                        )

                    if isinstance(response, dict):
                        # this is a shiny new module giving a dict response
                        result = response
                    elif isinstance(response, tuple):
                        # this is an old school module reporting its position
                        position, result = response
                        if not isinstance(result, dict):
                            raise TypeError("response should be a dict")
                    else:
                        raise TypeError("response should be a dict")

                    if isinstance(response.get("full_text"), (list, Composite)):
                        response["composite"] = response["full_text"]
                        del response["full_text"]
                    if "composite" in response:
                        self.process_composite(response)
                    else:
                        # validate the response
                        if "full_text" not in result:
                            err = 'missing "full_text" key in response'
                            raise KeyError(err)
                        # Remove any none color from our output
                        if hasattr(result.get("color"), "none_setting"):
                            del result["color"]
                        # remove urgent if not allowed
                        if not self.allow_urgent and "urgent" in result:
                            del result["urgent"]
                        # set universal module options in result
                        result.update(self.i3bar_module_options)

                    result["instance"] = self.module_inst
                    result["name"] = self.module_name

                    # initialize method object
                    if my_method["name"] is None:
                        my_method["name"] = result["name"]
                        if "instance" in result:
                            my_method["instance"] = result["instance"]
                        else:
                            my_method["instance"] = result["name"]

                    # update method object cache
                    if "cached_until" in result:
                        cached_until = result["cached_until"]
                        # remove this so we can check later for output changes
                        del result["cached_until"]
                    else:
                        # get module default cached_until
                        cached_until = self.module_class.py3.time_in()
                    my_method["cached_until"] = cached_until
                    if not cache_time or cached_until < cache_time:
                        cache_time = cached_until

                    # update method object output
                    if "composite" in response:
                        my_method["last_output"] = result["composite"]
                    else:
                        my_method["last_output"] = result

                    # debug info
                    if self.config["debug"]:
                        self._py3_wrapper.log(f"method {meth} returned {result} ")
                    # module working correctly so ensure module works as
                    # expected
                    self.allow_config_clicks = True
                    self.error_messages = None
                    self.error_hide = False

                    # mark module as updated
                    self.set_updated()

                except ModuleErrorException as e:
                    # module has indicated that it has an error
                    self.runtime_error(e.msg, meth)
                    if e.timeout:
                        if e.timeout is Py3.CACHE_FOREVER:
                            cache_time = Py3.CACHE_FOREVER
                        else:
                            cache_time = time.monotonic() + e.timeout
                    else:
                        cache_time = time.monotonic() + getattr(
                            self.module_class,
                            "cache_timeout",
                            self.config["cache_timeout"],
                        )

                except Exception as e:
                    msg = "Instance `{}`, user method `{}` failed"
                    msg = msg.format(self.module_full_name, meth)
                    if not self.testing:
                        self._py3_wrapper.report_exception(msg, notify_user=False)
                    # added error
                    self.runtime_error(str(e) or e.__class__.__name__, meth)
                    cache_time = time.monotonic() + getattr(
                        self.module_class, "cache_timeout", self.config["cache_timeout"]
                    )

            if cache_time is None:
                cache_time = time.monotonic() + self.config["cache_timeout"]
            self.cache_time = cache_time
            # new style modules can signal they want to cache forever
            if cache_time == Py3.CACHE_FOREVER:
                self._py3_wrapper.clear_timeout_due(self)
                return
            # don't be hasty mate
            # set timeout to do update next time one is needed
            if not cache_time:
                cache_time = time.monotonic() + self.config["minimum_interval"]

            self._py3_wrapper.timeout_queue_add(self, cache_time)

    def kill(self):
        # check and execute the 'kill' method if present
        if self.has_kill:
            try:
                kill_method = getattr(self.module_class, "kill")
                if self.has_kill == self.PARAMS_NEW:
                    kill_method()
                else:
                    # legacy call parameters
                    kill_method(
                        self.i3status_thread.json_list,
                        self.config["py3_config"]["general"],
                    )
            except Exception:
                # this would be stupid to die on exit
                pass

    def add_udev_trigger(self, trigger_action, subsystem):
        """
        Subscribe to the requested udev subsystem and apply the given action.
        """
        if self._py3_wrapper.udev_monitor.subscribe(self, trigger_action, subsystem):
            if trigger_action == "refresh_and_freeze":
                # FIXME: we may want to disable refresh instead of using cache_timeout
                self.module_class.cache_timeout = Py3.CACHE_FOREVER



================================================
FILE: py3status/module_test.py
================================================
import time
from ast import literal_eval
from sys import argv
from threading import Event

from py3status.core import Common, Module


class MockPy3statusWrapper:
    """ """

    class EventThread:
        def process_event(self, *arg, **kw):
            pass

    class UdevMonitor:
        def subscribe(self, *arg):
            pass

    def __init__(self, config):
        self.config = {
            "py3_config": config,
            "include_paths": [],
            "debug": False,
            "cache_timeout": 1,
            "minimum_interval": 0.1,
            "testing": True,
            "log_file": True,
            "wm": {"msg": "i3-msg", "nag": "i3-nagbar"},
        }
        self.events_thread = self.EventThread()
        self.udev_monitor = self.UdevMonitor()
        self.i3status_thread = None
        self.lock = Event()
        self.output_modules = {}
        self.running = True

        self.lock.set()

        # shared code
        common = Common(self)
        self.get_config_attribute = common.get_config_attribute
        self.report_exception = common.report_exception

    def notify_update(self, *arg, **kw):
        pass

    def notify_user(self, *arg, **kw):
        pass

    def timeout_queue_add(self, *arg, **kw):
        pass

    def clear_timeout_due(self, *arg, **kw):
        pass

    def log(self, *arg, **kw):
        print(arg[0])


def module_test(module_class, config=None):
    if not config:
        config = {}

    # config cli arguments
    arguments, term = argv[1:], False
    for index, arg in enumerate(arguments):
        if "--term" in arg:
            term = True
        elif arg[0:2] == "--":
            key = arguments[index][2:]
            value = arguments[index + 1]
            try:
                value = literal_eval(value)
            except (SyntaxError, ValueError):
                pass
            config[key] = value

    py3_config = {
        "general": {
            "color_bad": "#FF0000",
            "color_degraded": "#FFFF00",
            "color_good": "#00FF00",
        },
        "py3status": {},
        ".module_groups": {},
        "test_module": config,
    }

    mock = MockPy3statusWrapper(py3_config)

    module = module_class()
    m = Module("test_module", {}, mock, module)
    m.sleeping = True
    m.prepare_module()

    while not m.error_messages:
        try:
            for my_method in m.methods.values():
                my_method["cached_until"] = time.monotonic()
            m.run()
            output = m.get_latest()
            for item in output:
                if "instance" in item:
                    del item["instance"]
                if "name" in item:
                    del item["name"]

            if term:
                line = "\033[0m"
                for item in output:
                    if item.get("urgent"):
                        line += "\033[41m"
                    else:
                        color = item.get("color")
                        if color:
                            line += "\033[38;2;{};{};{}m".format(
                                *[int(color[1:][i : i + 2], 16) for i in (0, 2, 4)]
                            )
                    line += item["full_text"] + "\033[0m"
                print(line)
            else:
                if len(output) == 1:
                    output = output[0]
                print(output)

            time.sleep(1)
        except KeyboardInterrupt:
            m.kill()
            break



================================================
FILE: py3status/output.py
================================================
import sys
from json import dumps


class OutputFormat:
    """
    A base class for formatting the output of py3status for various
    different consumers
    """

    @classmethod
    def instance_for(cls, output_format):
        """
        A factory for OutputFormat objects
        """
        supported_output_formats = {
            "dzen2": Dzen2OutputFormat,
            "i3bar": I3barOutputFormat,
            "lemonbar": LemonbarOutputFormat,
            "none": NoneOutputFormat,
            "term": TermOutputFormat,
            "tmux": TmuxOutputFormat,
            "xmobar": XmobarOutputFormat,
        }

        if output_format in supported_output_formats:
            return supported_output_formats[output_format]()
        raise ValueError(
            f"Invalid `output_format` attribute, should be one of `{'`, `'.join(supported_output_formats.keys())}`. Got `{output_format}`."
        )

    def __init__(self):
        """
        Constructor
        """
        self.separator = None

    def format_separator(self, separator, color):
        """
        Produce a formatted and colorized separator for the output format,
        if the output_format requires it, and None otherwise.
        """
        pass

    def format(self, outputs):
        """
        Produce a line of output from a list of module output dictionaries
        """
        raise NotImplementedError()

    def write_header(self, header):
        """
        Write the header to output, if supported by the output_format
        """
        raise NotImplementedError()

    def write_line(self, output):
        """
        Write a line of py3status containing the given module output
        """
        raise NotImplementedError()


class I3barOutputFormat(OutputFormat):
    """
    Format the output for consumption by i3bar
    """

    def format(self, outputs):
        """
        Produce a line of output from a list of module outputs for
        consumption by i3bar. separator is ignored.
        """
        return ",".join(dumps(x) for x in outputs)

    def write_header(self, header):
        """
        Write the i3bar header to output
        """
        write = sys.__stdout__.write
        flush = sys.__stdout__.flush

        write(dumps(header))
        write("\n[[]\n")
        flush()

    def write_line(self, output):
        """
        Write a line of py3status output for consumption by i3bar
        """
        write = sys.__stdout__.write
        flush = sys.__stdout__.flush

        out = ",".join(x for x in output if x)
        write(f",[{out}]\n")
        flush()


class SeparatedOutputFormat(OutputFormat):
    """
    Base class for formatting output as an enriched string containing
    separators
    """

    def begin_color(self, color):
        """
        Produce a format string for a colorized output for the output format
        """
        raise NotImplementedError()

    def end_color(self):
        """
        Produce a format string for ending a colorized output for the output format
        """
        raise NotImplementedError()

    def end_color_quick(self):
        """
        Produce a format string for ending a colorized output, but only
        if it is syntactically required. (for example because a new color
        declaration immediately follows)
        """
        return self.end_color()

    def get_default_separator(self):
        """
        Produce the default separator for the output format
        """
        return " | "

    def format_separator(self, separator, color):
        """
        Format the given separator with the given color
        """
        if separator is None:
            separator = self.get_default_separator()
        if color is not None:
            separator = self.begin_color(color) + separator + self.end_color()
        self.separator = separator

    def format_color(self, block):
        """
        Format the given block of module output
        """
        full_text = block["full_text"]
        if "color" in block:
            full_text = self.begin_color(block["color"]) + full_text + self.end_color_quick()
        return full_text

    def format(self, outputs):
        """
        Produce a line of output from a list of module outputs by
        concatenating individual blocks of formatted output
        """
        return "".join(self.format_color(x) for x in outputs)

    def write_header(self, header):
        """
        Not supported in separated output formats
        """
        pass

    def write_line(self, output):
        """
        Write a line of py3status output separated by the formatted separator
        """
        write = sys.__stdout__.write
        flush = sys.__stdout__.flush

        out = self.separator.join(x for x in output if x)
        write(f"{out}\n")
        flush()


class Dzen2OutputFormat(SeparatedOutputFormat):
    """
    Format the output for consumption by dzen2
    """

    def begin_color(self, color):
        return f"^fg({color})"

    def end_color(self):
        return "^fg()"

    def end_color_quick(self):
        return ""

    def get_default_separator(self):
        """
        Produce the default separator for the output format
        """
        return "^p(5;-2)^ro(2)^p()^p(5)"


class XmobarOutputFormat(SeparatedOutputFormat):
    """
    Format the output for consumption by xmobar
    """

    def begin_color(self, color):
        return f"<fc={color}>"

    def end_color(self):
        return "</fc>"


class LemonbarOutputFormat(SeparatedOutputFormat):
    """
    Format the output for consumption by lemonbar
    """

    def begin_color(self, color):
        return f"%{{F{color}}}"

    def end_color(self):
        return "%{F-}"

    def end_color_quick(self):
        return ""


class TmuxOutputFormat(SeparatedOutputFormat):
    """
    Format the output for consumption by tmux
    """

    def begin_color(self, color):
        return f"#[fg={color.lower()}]"

    def end_color(self):
        return "#[default]"

    def end_color_quick(self):
        return ""


class TermOutputFormat(SeparatedOutputFormat):
    """
    Format the output using terminal escapes
    """

    def begin_color(self, color):
        col = int(color[1:], 16)
        r = (col & (0xFF << 0)) // 0x80
        g = (col & (0xFF << 8)) // 0x8000
        b = (col & (0xFF << 16)) // 0x800000
        col = (r << 2) | (g << 1) | b
        return f"\033[3{col};1m"

    def end_color(self):
        return "\033[0m"

    def end_color_quick(self):
        return ""


class NoneOutputFormat(SeparatedOutputFormat):
    """
    Format the output without colors
    """

    def begin_color(self, color):
        return ""

    def end_color(self):
        return ""



================================================
FILE: py3status/parse_config.py
================================================
import os
import re
from collections import OrderedDict
from importlib import util
from pathlib import Path
from string import Template
from subprocess import CalledProcessError, check_output

from py3status.constants import (
    CONFIG_FILE_SPECIAL_SECTIONS,
    ERROR_CONFIG,
    GENERAL_DEFAULTS,
    I3S_MODULE_NAMES,
    I3S_SINGLE_NAMES,
    MAX_NESTING_LEVELS,
    RETIRED_MODULES,
    TIME_FORMAT,
    TIME_MODULES,
    TZTIME_FORMAT,
)
from py3status.private import PrivateBase64, PrivateHide


class ParseException(Exception):
    """
    Exception raised when a parse exception occurs.
    This exception receives information on the error so that helpful error
    messages can be provided to the user.
    """

    def __init__(self, error, line, line_no, position, token):
        self.error = error
        self.line = line
        self.line_no = line_no
        self.position = position
        self.token = token.replace("\n", "\\n")

    def one_line(self, config_path):
        filename = config_path.name
        notif = "CONFIG ERROR: {} saw `{}` at line {} position {} in file {}"
        return notif.format(self.error, self.token, self.line_no, self.position, filename)

    def __str__(self):
        marker = " " * (self.position - 1) + "^"
        return "{}\n\nsaw `{}` at line {} position {}\n\n{}\n{}".format(
            self.error, self.token, self.line_no, self.position, self.line, marker
        )


class ModuleDefinition(OrderedDict):
    """Module definition in OrderedDict form"""

    pass


class ConfigParser:
    """
    A basic top down parser.

    We break the config into a list of tokens and travel through them to build
    up a dict that corresponds to the config.

    The parser allows:

    * containers

        container {
            included_module 1 {}
            included_module 2 {}
        }

    * nesting of containers

        container 1 {
            container 2 {
                included_module 1 {}
            }
            included_module 2 {}
        }

    * many types including lists, dict and tuple values

        my_module {
            my_str = 'hello'
            my_int = 23
            my_bool = true
            my_list = [1, 2, 3]
            my_dict = {'x': 1, 'y': 2}
            my_tuple = (1, 'something')
            my_complex = {
                'list' : [1, 2, 3],
                'dict' : {'x': 1, 'y': 2}
            }
        }

    * environment variable support

        order += env(ORDER_VAR)

        my_module {
            my_guessed_type = env(MY_VAR)
            my_str = env(MY_VAR, str)
            my_int = env(MY_INT_VAR, int)
            my_bool = env(MY_FLAG, bool)
            my_complex = {
                'list' : [1, 2, env(MY_LIST_ENTRY, int)],
                'dict' : {'x': env(MY_DICT_VAL), 'y': 2}
            }
        }

    * execute shell code

        my_module {
            my_guessed_type = shell(pass show git|head -n1)
            my_str = shell(pass show git|head -n1, str)
            my_int = shell(pass show git|head -n1, int)
            my_bool = shell(pass show git|head -n1, bool)
        }

        (shell code may not include any parenthesis!)

    * quality feedback on parse errors.
        details include error description, line number, position.

    """

    CONVERSIONS = "(auto|bool|int|float|str)"
    FUNCTIONS = "(base64|env|hide|shell)"

    TOKENS = [
        "#.*$"  # comments
        "|(?P<function>"  # functions of the form `name(payload[,type])`
        "" + FUNCTIONS + r"\(\s*(([^)\\]|\\.)*?)"  # nasty '' but flake8
        r"(\s*,\s*" + CONVERSIONS + r")?\s*\))"
        r"|(?P<operator>[()[\]{},:]|\+?=)"  # operators
        "|(?P<literal>"
        r'("(?:[^"\\]|\\.)*")'  # double quoted string
        r"|('(?:[^'\\]|\\.)*')"  # single quoted string
        r"|([a-z_][a-z0-9_\-]*(:[a-z0-9_]+)?)"  # token
        r"|(-?\d+\.\d*)|(-?\.\d+)"  # float
        r"|(-?\d+)"  # int
        ")"
        r"|(?P<newline>\n)"  # newline
        r"|(?P<unknown>\S+)"  # unknown token
    ]

    def __init__(self, config, py3_wrapper):
        self.tokenize(config)
        self.config = {}
        self.level = 0
        self.module_level = 0
        self.current_module = []
        self.current_token = 0
        self.line = 0
        self.line_start = 0
        self.py3_wrapper = py3_wrapper
        self.raw = config.split("\n")
        self.container_modules = []
        self.anon_count = 0

    def notify_user(self, error):
        if self.py3_wrapper:
            self.py3_wrapper.notify_user(error)
        else:
            print(error)

    class ParseEnd(Exception):
        """
        Used to signify the end of a dict, list, tuple, or module
        definition.
        """

        pass

    def check_child_friendly(self, name):
        """
        Check if a module is a container and so can have children
        """
        name = name.split()[0]
        if name in self.container_modules:
            return
        root = Path(__file__).resolve().parent
        module_path = root / "modules"
        info = util.find_spec(name, [module_path])
        if not info:
            return
        py_mod = util.exec_module(info)
        try:
            container = py_mod.Py3status.Meta.container
        except AttributeError:
            container = False
        # delete the module
        del py_mod
        if container:
            self.container_modules.append(name)
        else:
            self.error(f"Module `{name}` cannot contain others")

    def check_module_name(self, name, offset=0):
        """
        Checks a module name eg. some i3status modules cannot have an instance
        name.
        """
        if name in ["general"]:
            return
        split_name = name.split()
        if len(split_name) > 1 and split_name[0] in I3S_SINGLE_NAMES:
            self.current_token -= len(split_name) - 1 - offset
            self.error("Invalid name cannot have 2 tokens")
        if len(split_name) > 2:
            self.current_token -= len(split_name) - 2 - offset
            self.error("Invalid name cannot have more than 2 tokens")

    def error(self, msg, previous=False):
        """
        Raise a ParseException.
        We provide information to help locate the error in the config to allow
        easy config debugging for users.  previous indicates that the error
        actually occurred at the end of the previous line.
        """
        token = self.tokens[self.current_token - 1]
        line_no = self.line
        if previous:
            line_no -= 1
        line = self.raw[line_no]
        position = token["start"] - self.line_start
        if previous:
            position = len(line) + 2
        raise ParseException(msg, line, line_no + 1, position, token["value"])

    def tokenize(self, config):
        """
        Break the config into a series of tokens
        """
        tokens = []
        reg_ex = re.compile(self.TOKENS[0], re.M | re.I)

        for token in re.finditer(reg_ex, config):
            value = token.group(0)
            if token.group("operator"):
                t_type = "operator"
            elif token.group("literal"):
                t_type = "literal"
            elif token.group("newline"):
                t_type = "newline"
            elif token.group("function"):
                t_type = "function"
            elif token.group("unknown"):
                t_type = "unknown"
            else:
                continue
            tokens.append({"type": t_type, "value": value, "match": token, "start": token.start()})
        self.tokens = tokens

    def next(self):
        """
        Return the next token.  Keep track of our current position in the
        config for nice errors.
        """
        if self.current_token == len(self.tokens):
            return None
        token = self.tokens[self.current_token]
        if token["type"] == "newline":
            self.line += 1
            self.line_start = token["start"]
        self.current_token += 1
        if token["type"] == "unknown":
            self.error("Unknown token")
        return token

    def remove_quotes(self, value):
        """
        Remove any surrounding quotes from a value and unescape any contained
        quotes of that type.
        """
        # beware the empty string
        if not value:
            return value

        if value[0] == value[-1] == '"':
            return value[1:-1].replace('\\"', '"')
        if value[0] == value[-1] == "'":
            return value[1:-1].replace("\\'", "'")
        return value

    def unicode_escape_sequence_fix(self, value):
        """
        It is possible to define unicode characters in the config either as the
        actual utf-8 character or using escape sequences the following all will
        show the Greek delta character.
        Δ \N{GREEK CAPITAL LETTER DELTA} \U00000394  \u0394
        """

        def fix_fn(match):
            # we don't escape an escaped backslash
            if match.group(0) == r"\\":
                return r"\\"
            return match.group(0).encode("utf-8").decode("unicode-escape")

        return re.sub(r"\\\\|\\u\w{4}|\\U\w{8}|\\N{([^}\\]|\\.)+}", fix_fn, value)

    def make_value(self, value):
        """
        Converts to actual value, or remains as string.
        """
        # ensure any escape sequences are converted to unicode
        value = self.unicode_escape_sequence_fix(value)

        if value and value[0] in ['"', "'"]:
            return self.remove_quotes(value)

        try:
            return int(value)
        except ValueError:
            pass
        try:
            return float(value)
        except ValueError:
            pass
        if value.lower() == "true":
            return True
        if value.lower() == "false":
            return False
        if value.lower() == "none":
            return None
        return value

    def config_function(self, token):
        """
        Process a config function from a token
        """
        match = token["match"]
        function = match.group(2).lower()
        param = match.group(3) or ""
        value_type = match.group(6) or "auto"

        # fix any escaped closing parenthesis
        param = param.replace(r"\)", ")")

        CONFIG_FUNCTIONS = {
            "base64": self.make_function_value_private,
            "env": self.make_value_from_env,
            "hide": self.make_function_value_private,
            "shell": self.make_value_from_shell,
        }

        return CONFIG_FUNCTIONS[function](param, value_type, function)

    def value_convert(self, value, value_type):
        """
        convert string into type used by `config functions`
        """
        CONVERSION_OPTIONS = {
            "str": str,
            "int": int,
            "float": float,
            # Treat booleans specially
            "bool": (lambda val: val.lower() in ("true", "1")),
            # Auto-guess the type
            "auto": self.make_value,
        }

        try:
            return CONVERSION_OPTIONS[value_type](value)
        except (TypeError, ValueError):
            self.notify_user("Bad type conversion")
            return None

    def make_value_from_env(self, param, value_type, function):
        """
        get environment variable
        """
        value = os.getenv(param)
        if value is None:
            self.notify_user(f"Environment variable `{param}` undefined" % param)
        return self.value_convert(value, value_type)

    def make_value_from_shell(self, param, value_type, function):
        """
        run command in the shell
        """
        try:
            value = check_output(param, shell=True).rstrip()
        except CalledProcessError:
            # for value_type of 'bool' we return False on error code
            if value_type == "bool":
                value = False
            else:
                if self.py3_wrapper:
                    self.py3_wrapper.report_exception(msg=f"shell: called with command `{param}`")
                self.notify_user("shell script exited with an error")
                value = None
        else:
            # if the value_type is 'bool' then we return True for success
            if value_type == "bool":
                value = True
            else:
                # convert bytes to unicode
                value = value.decode("utf-8")
                value = self.value_convert(value, value_type)
        return value

    def make_function_value_private(self, value, value_type, function):
        """
        Wraps converted value so that it is hidden in logs etc.
        Note this is not secure just reduces leaking info

        Allows base 64 encode stuff using base64() or plain hide() in the
        config
        """
        # remove quotes
        value = self.remove_quotes(value)

        if function == "base64":
            try:
                import base64

                value = base64.b64decode(value).decode("utf-8")
            except TypeError as e:
                self.notify_user(f"base64(..) error {e}")

        # check we are in a module definition etc
        if not self.current_module:
            self.notify_user(f"{function}(..) used outside of module or section")
            return None

        module = self.current_module[-1].split()[0]
        if module in CONFIG_FILE_SPECIAL_SECTIONS + I3S_MODULE_NAMES:
            self.notify_user(
                f"{function}(..) cannot be used outside of py3status module configuration"
            )
            return None

        value = self.value_convert(value, value_type)
        module_name = self.current_module[-1]
        return PrivateHide(value, module_name)

    def separator(self, separator=",", end_token=None):
        """
        Read through tokens till the required separator is found.  We ignore
        newlines.  If an end token is supplied raise a ParseEnd exception if it
        is found.
        """
        while True:
            token = self.next()
            t_value = token["value"]
            if end_token and t_value == end_token:
                raise self.ParseEnd()
            if t_value == separator:
                return
            if t_value == "\n":
                continue
            self.error("Unexpected character")

    def make_list(self, end_token="]"):
        """
        We are in a list so get values until the end token.  This can also
        used to get tuples.
        """
        out = []
        while True:
            try:
                value = self.value_assign(end_token=end_token)
                out.append(value)
                self.separator(end_token=end_token)
            except self.ParseEnd:
                return out

    def dict_key(self):
        """
        Find the next key in a dict.  We skip any newlines and check for if the
        dict has ended.
        """
        while True:
            token = self.next()
            t_value = token["value"]
            if t_value == "\n":
                continue
            if t_value == "}":
                raise self.ParseEnd()
            if token["type"] == "literal":
                return self.make_value(t_value)
            self.error("Invalid Key")

    def make_dict(self):
        """
        We are in a dict so get key value pairs until the end token.
        """
        out = {}
        while True:
            try:
                key = self.dict_key()
                self.separator(separator=":")
                value = self.value_assign(end_token="]")
                out[key] = value
                self.separator(end_token="}")
            except self.ParseEnd:
                return out

    def value_assign(self, end_token=None):
        """
        We are expecting a value (literal, list, dict, tuple).
        If end_token then we are inside a list, dict or tuple so we are allow
        newlines and also check for the end token.
        """
        while True:
            token = self.next()
            t_value = token["value"]
            if end_token:
                if t_value == end_token:
                    raise self.ParseEnd()
                elif t_value == "\n":
                    continue
            if token["type"] == "literal":
                return self.make_value(t_value)
            if token["type"] == "function":
                return self.config_function(token)
            elif t_value == "[":
                return self.make_list()
            elif t_value == "{":
                return self.make_dict()
            elif t_value == "(":
                return tuple(self.make_list(end_token=")"))
            else:
                self.error("Value expected", previous=not end_token)

    def module_def(self):
        """
        This is a module definition so parse content till end.
        """
        if self.module_level == MAX_NESTING_LEVELS:
            self.error("Module nested too deep")
        self.module_level += 1
        module = ModuleDefinition()
        self.parse(module, end_token="}")
        self.module_level -= 1
        self.current_module.pop()
        return module

    def assignment(self, token):
        """
        We need to find a value to return.  If the token is `=` or `+=` we want
        a value.  If the token is `{` then we need to return a module
        definition.
        """
        if token["value"] in ["=", "+="]:
            return self.value_assign()
        elif token["value"] in ["{"]:
            return self.module_def()

    def process_value(self, name, value, module_name):
        """
        This method allow any encodings to be dealt with.
        Currently only base64 is supported.

        Note: If other encodings are added then this should be split so that
        there is a method for each encoding.
        """
        # if we have a colon in the name of a setting then it
        # indicates that it has been encoded.
        if ":" in name:
            if module_name.split(" ")[0] in I3S_MODULE_NAMES + ["general"]:
                self.error("Only py3status modules can use obfuscated")

            if type(value).__name__ not in ["str", "unicode"]:
                self.error("Only strings can be obfuscated")

            (name, scheme) = name.split(":")
            if scheme == "base64":
                value = PrivateBase64(value, module_name)
            elif scheme == "hide":
                value = PrivateHide(value, module_name)
            else:
                self.error(f"Unknown scheme {scheme} for data")

        return name, value

    def parse(self, dictionary=None, end_token=None):
        """
        Parse through the tokens. Finding names and values.
        This is called at the start of parsing the config but is
        also called to parse module definitions.
        """
        self.level += 1
        name = []
        if dictionary is None:
            dictionary = self.config
        while True:
            token = self.next()
            if token is None:
                # we have got to the end of the config
                break
            t_type = token["type"]
            t_value = token["value"]
            if t_type == "newline":
                continue
            elif t_value == end_token:
                self.level -= 1
                return
            elif t_type == "literal":
                value = self.remove_quotes(t_value)
                if not name and not re.match("[a-zA-Z_]", value):
                    self.error("Invalid name")
                name.append(value)
            elif t_type == "function":
                self.error("Name expected")
            elif t_type == "operator":
                name = " ".join(name)
                if not name:
                    self.error("Name expected")
                elif t_value == "+=" and name not in dictionary:
                    # deal with encoded names
                    if name.split(":")[0] not in dictionary:
                        # order is treated specially
                        if not (self.level == 1 and name == "order"):
                            self.error(f"{name} does not exist")
                if t_value in ["{"]:
                    if self.current_module:
                        self.check_child_friendly(self.current_module[-1])
                    self.check_module_name(name)
                    self.current_module.append(name)
                value = self.assignment(token)
                # order is treated specially to create a list
                if self.level == 1 and name == "order":
                    if not value:
                        self.error("Invalid module")
                    self.check_module_name(value, offset=1)
                    dictionary.setdefault(name, []).append(value)
                # assignment of  module definition
                elif t_value == "{":
                    # If this is an py3status module and in a container and has
                    # no instance name then give it an anon one.  This allows
                    # us to have multiple non-instance named modules defined
                    # without them clashing.
                    if self.level > 1 and " " not in name and name not in I3S_MODULE_NAMES:
                        name = f"{name} _anon_module_{self.anon_count}"
                        self.anon_count += 1
                    dictionary[name] = value
                # assignment of value
                elif t_value == "=":
                    try:
                        name, value = self.process_value(name, value, self.current_module[-1])
                    except IndexError:
                        self.error("Missing {", previous=True)
                    dictionary[name] = value
                # appending to existing values
                elif t_value == "+=":
                    dictionary[name] += value
                else:
                    self.error("Unexpected character")
                name = []


def process_config(config_path, py3_wrapper=None):
    """
    Parse i3status.conf so we can adapt our code to the i3status config.
    """

    def notify_user(error):
        if py3_wrapper:
            py3_wrapper.notify_user(error)
        else:
            print(error)

    def parse_config(config):
        """
        Parse text or file as a py3status config file.
        """

        if hasattr(config, "readlines"):
            config = "".join(config.readlines())
        parser = ConfigParser(config, py3_wrapper)
        parser.parse()
        parsed = parser.config
        del parser
        return parsed

    def parse_config_error(e, config_path):
        # There was a problem use our special error config
        error = e.one_line(config_path)
        notify_user(error)
        # to display correctly in i3bar we need to do some substitutions
        for char in ['"', "{", "|"]:
            error = error.replace(char, "\\" + char)
        error_config = Template(ERROR_CONFIG).substitute(error=error)
        return parse_config(error_config)

    config = {}

    # get the file encoding this is important with multi-byte unicode chars
    try:
        encoding = check_output(["file", "-b", "--mime-encoding", "--dereference", config_path])
        encoding = encoding.strip().decode("utf-8")
    except FileNotFoundError:
        # can be missing on NixOS (see #1961)
        notify_user("the 'file' command is missing, please install it.")
        encoding = "utf-8"
    except CalledProcessError:
        # bsd does not have the --mime-encoding so assume utf-8
        encoding = "utf-8"
    try:
        with config_path.open("r", encoding=encoding) as f:
            try:
                config_info = parse_config(f)
            except ParseException as e:
                config_info = parse_config_error(e, config_path)
    except LookupError:
        with config_path.open() as f:
            try:
                config_info = parse_config(f)
            except ParseException as e:
                config_info = parse_config_error(e, config_path)

    # update general section with defaults
    general_defaults = GENERAL_DEFAULTS.copy()
    if "general" in config_info:
        general_defaults.update(config_info["general"])
    config["general"] = general_defaults

    config["py3status"] = config_info.get("py3status", {})
    modules = {}
    on_click = {}
    i3s_modules = []
    py3_modules = []
    module_groups = {}

    def process_onclick(key, value, group_name):
        """
        Check on_click events are valid.  Store if they are good
        """
        button_error = False
        button = ""
        try:
            button = key.split()[1]
            if int(button) not in range(1, 20):
                button_error = True
        except (ValueError, IndexError):
            button_error = True

        if button_error:
            err = "Invalid on_click for `{}`. Number not in range 1-20: `{}`."
            notify_user(err.format(group_name, button))
            return False
        clicks = on_click.setdefault(group_name, {})
        clicks[button] = value
        return True

    def get_module_type(name):
        """
        i3status or py3status?
        """
        if name.split()[0] in I3S_MODULE_NAMES:
            return "i3status"
        return "py3status"

    def process_module(name, module, parent):
        if parent:
            modules[parent]["items"].append(name)
            mg = module_groups.setdefault(name, [])
            mg.append(parent)
            if get_module_type(name) == "py3status":
                module[".group"] = parent

        # check module content
        for k, v in list(module.items()):
            if k.startswith("on_click"):
                # on_click event
                process_onclick(k, v, name)
                # on_click should not be passed to the module via the config.
                del module[k]
            if isinstance(v, ModuleDefinition):
                # we are a container
                module["items"] = []
        return module

    def get_modules(data, parent=None):
        for k, v in data.items():
            if isinstance(v, ModuleDefinition):
                module = process_module(k, v, parent)
                modules[k] = module
                get_modules(v, parent=k)

    get_modules(config_info)

    config["order"] = []

    def remove_any_contained_modules(module):
        """
        takes a module definition and returns a dict without any modules that
        may be defined with it.
        """
        fixed = {}
        for k, v in module.items():
            if not isinstance(v, ModuleDefinition):
                fixed[k] = v
        return fixed

    def append_modules(item):
        module_type = get_module_type(item)
        if module_type == "i3status":
            if item not in i3s_modules:
                i3s_modules.append(item)
        else:
            if item not in py3_modules:
                py3_modules.append(item)

    def add_container_items(module_name):
        module = modules.get(module_name, {})
        items = module.get("items", [])
        for item in items:
            if item in config:
                continue

            append_modules(item)
            module = modules.get(item, {})
            config[item] = remove_any_contained_modules(module)
            # add any children
            add_container_items(item)

    # create config for modules in order
    for name in config_info.get("order", []):
        if name in module_groups:
            msg = "Module `{}` should not be listed in the 'order' directive, use"
            msg += " its parent group instead."
            notify_user(msg.format(name))
            continue
        module_name = name.split(" ")[0]
        if module_name in RETIRED_MODULES:
            old = f"`{module_name}`"
            new = ", ".join(f"`{x}`" for x in RETIRED_MODULES[module_name]["new"])
            msg = RETIRED_MODULES[module_name]["msg"].format(old=old, new=new)
            notify_user(msg)
            continue
        module = modules.get(name, {})
        config["order"].append(name)
        add_container_items(name)
        append_modules(name)

        config[name] = remove_any_contained_modules(module)

    config["on_click"] = on_click
    config["i3s_modules"] = i3s_modules
    config["py3_modules"] = py3_modules
    config[".module_groups"] = module_groups

    # time and tztime modules need a format for correct processing
    for name in config:
        if name.split()[0] in TIME_MODULES and "format" not in config[name]:
            if name.split()[0] == "time":
                config[name]["format"] = TIME_FORMAT
            else:
                config[name]["format"] = TZTIME_FORMAT

    if not config["order"]:
        notify_user(
            "Your configuration file does not list any module"
            ' to be loaded with the "order" directive.'
        )
    return config


if __name__ == "__main__":
    # process a config file and display output
    # file name user supplied or ~/.i3/i3status.conf
    import pprint
    import sys

    if len(sys.argv) > 1:
        file_name = sys.argv[1]
    else:
        file_name = Path.home() / ".i3/i3status.conf"
    print(f"\nPARSING CONFIG FILE {file_name}\n\n")
    pprint.pprint(process_config(file_name))



================================================
FILE: py3status/private.py
================================================
import base64
import inspect


class Private:
    """
    This class attempts to keep private information.

    Clearly this is python so we cannot actually achieve that aim.
    Any attacker could easily monkey patch out any of this code rendering it
    useless.

    The point of this is to make the code less likely to leak sensitive
    information for example via the logs, user notifications, displaying in
    i3bar.

    THIS IS NOT SECURE!
    """

    def __init__(self, encoded, module_name):
        self._decoded = False
        self._encoded = encoded
        self._module_name = module_name.split(" ")[0]
        self._private = "***"  # this is used when the user is untrusted
        self._value = "encrypted"

        # Try to decrypt data if possible
        self._decrypt()

    def _decrypt(self, key=None):
        """
        method called to decrypt the value
        """
        if not self._decoded:
            self._decode(key)

    def __setattr__(self, name, value):
        """
        Do not allow this object to be updated outside of this module
        """
        stack = inspect.stack()
        if inspect.getmodule(stack[1][0]).__name__ != __name__:
            return
        return object.__setattr__(self, name, value)

    def __getattribute__(self, name):
        """
        Check if user can access this attribute.
        """
        # allowed by all users
        if name in ["_decrypt", "_decode"]:
            return object.__getattribute__(self, name)

        # allow internal calls
        stack = inspect.stack()
        state = (not name.startswith("_")) or (
            inspect.getmodule(stack[1][0]).__name__ == __name__
            and stack[1][3] in ["_catch", "_decode"]
        )
        if state:
            return object.__getattribute__(self, name)
        return None


def catch_factory(attr):
    """
    Factory returning a catch function
    """

    def _catch(s, *args, **kw):
        """
        This is used to catch and process all calls.
        """

        def process(value):
            """
            return the actual value after processing
            """
            if attr.startswith("__"):
                # __repr__, __str__ etc
                return getattr(value, attr)(*args, **kw)
            else:
                # upper, lower etc
                return getattr("".__class__, attr)(value, *args, **kw)

        stack = inspect.stack()
        mod = inspect.getmodule(stack[1][0])
        # We are called from the owning module so allow
        if mod.__name__.split(".")[-1] == s._module_name:
            return process(s._value)
        # very shallow calling no stack
        if len(stack) < 3:
            return process(s._private)
        # Check if this is an internal or external module.  We need to allow
        # calls to modules like requests etc
        remote = not inspect.getmodule(stack[2][0]).__name__.startswith("py3status")
        valid = False
        # go through the stack to see how we came through the code
        for frame in stack[2:]:
            mod = inspect.getmodule(frame[0])
            if remote and mod.__name__.split(".")[-1] == s._module_name:
                # the call to an external module started in the correct module
                # so allow this usage
                valid = True
                break
            if mod.__name__ == "py3status.py3" and frame[3] == "request":
                # Py3.request has special needs due so it is allowed to access
                # private variables.
                valid = True
                break
            if mod.__name__.startswith("py3status"):
                # We were somewhere else in py3status than the module, maybe we
                # are doing some logging.  Prevent usage
                return process(s._private)
        if valid:
            return process(s._value)
        return process(s._private)

    return _catch


# We need to populate our base class with all the methods that unicode
# has.  We will implement them using the _catch function created by out
# factory.  We want to exclude a few select methods
EXCLUDE = [
    "__init__",
    "__getattribute__",
    "__new__",
    "__setattr__",
    "__init_subclass__",
]
for attr in dir(""):
    if attr.startswith("__") and attr in EXCLUDE:
        continue
    if "__call__" in dir(getattr("", attr)):
        setattr(Private, attr, catch_factory(attr))


class PrivateBase64(Private):
    """
    Simple base64 encoder
    """

    def _decode(self, key):
        if self._encoded is None:
            return
        try:
            new_value = base64.b64decode(self._encoded)
            self._value = new_value.decode("utf-8")
        except Exception:
            self._value = "Error"
        self._decoded = True


class PrivateHide(Private):
    """
    This does not encode the data in any way but it does keep it from being
    shown in the log files, i3bar etc
    """

    def _decode(self, key):
        if self._encoded is None:
            return
        self._value = self._encoded
        self._decoded = True


if __name__ == "__main__":
    # This module can read this
    x = PrivateHide("test", "__main__")
    print(x)
    print(x.upper())
    print(x.split("e"))
    # This module cannot read this
    x = PrivateHide("test", "xxx")
    print(x)
    print(x.upper())
    print(x.split("e"))



================================================
FILE: py3status/profiling.py
================================================
import cProfile

# Used in development
enable_profiling = False


def profile(thread_run_fn):
    if not enable_profiling:
        return thread_run_fn

    def wrapper_run(self):
        """Wrap the Thread.run() method"""
        profiler = cProfile.Profile()
        try:
            return profiler.runcall(thread_run_fn, self)
        finally:
            thread_id = getattr(self, "ident", "core")
            profiler.dump_stats(f"py3status-{thread_id}.profile")

    return wrapper_run



================================================
FILE: py3status/py3.py
================================================
import os
import re
import shlex
import sys
import time
from collections.abc import Mapping
from copy import deepcopy
from fnmatch import fnmatch
from math import log10
from pathlib import Path
from pprint import pformat
from shutil import which
from subprocess import PIPE, STDOUT, Popen
from time import sleep
from uuid import uuid4

from py3status import exceptions
from py3status.formatter import Composite, Formatter, expand_color
from py3status.request import HttpResponse
from py3status.storage import Storage
from py3status.util import Gradients
from py3status.version import version


class ModuleErrorException(Exception):
    """
    This exception is used to indicate that a module has returned an error
    """

    def __init__(self, msg, timeout):
        self.msg = msg if msg else "unknown error"
        self.timeout = timeout


class NoneColor:
    """
    This class represents a color that has explicitly been set as None by the user.
    We need this so that we can do things like

    color = self.py3.COLOR_MUTED or self.py3.COLOR_BAD

    Py3 provides a helper function is_color() that will treat a NoneColor as
    False, whereas a simple if would show True
    """

    # this attribute is used to identify that this is a none color
    none_setting = True

    def __repr__(self):
        # this is for output via module_test
        return "None"


class Py3:
    """
    Helper object that gets injected as ``self.py3`` into Py3status
    modules that have not got that attribute set already.

    This allows functionality like:

    -   User notifications
    -   Forcing module to update (even other modules)
    -   Triggering events for modules

    Py3 is also used for testing in which case it does not get a module when
    being created.  All methods should work in this situation.
    """

    CACHE_FOREVER = -1
    """
    Special constant that when returned for ``cached_until`` will cause the
    module to not update unless externally triggered.
    """

    LOG_ERROR = "error"
    """Show as Error"""
    LOG_INFO = "info"
    """Show as Informational"""
    LOG_WARNING = "warning"
    """Show as Warning"""

    # Shared by all Py3 Instances
    _formatter = None
    _gradients = Gradients()
    _none_color = NoneColor()
    _storage = Storage()

    # Exceptions
    Py3Exception = exceptions.Py3Exception
    CommandError = exceptions.CommandError
    RequestException = exceptions.RequestException
    RequestInvalidJSON = exceptions.RequestInvalidJSON
    RequestTimeout = exceptions.RequestTimeout
    RequestURLError = exceptions.RequestURLError

    def __init__(self, module=None):
        self._audio = None
        self._config_setting = {}
        self._english_env = dict(os.environ)
        self._english_env["LC_ALL"] = "C"
        self._english_env["LANGUAGE"] = "C"
        self._format_color_names = {}
        self._format_placeholders = {}
        self._format_placeholders_cache = {}
        self._module = module
        self._replacements = None
        self._report_exception_cache = set()
        self._thresholds = None
        self._threshold_gradients = {}
        self._uid = uuid4()

        if module:
            self._i3s_config = module._py3_wrapper.config["py3_config"]["general"]
            self._module_full_name = module.module_full_name
            self._output_modules = module._py3_wrapper.output_modules
            self._py3status_module = module.module_class
            self._py3_wrapper = module._py3_wrapper
            # create formatter we only if need one but want to pass py3_wrapper so
            # that we can do logging etc.
            if not self._formatter:
                self.__class__._formatter = Formatter(module._py3_wrapper)

    def __getattr__(self, name):
        """
        Py3 can provide COLOR constants
        eg COLOR_GOOD, COLOR_BAD, COLOR_DEGRADED
        but also any constant COLOR_XXX we find this color in the config
        if it exists
        """
        if not name.startswith("COLOR_"):
            raise AttributeError(f"Attribute `{name}` not in Py3")
        return self._get_config_setting(name.lower())

    def _get_config_setting(self, name, default=None):
        try:
            return self._config_setting[name]
        except KeyError:
            fn = self._py3_wrapper.get_config_attribute
            param = fn(self._module_full_name, name)

            # colors are special we want to make sure that we treat a color
            # that was explicitly set to None as a True value.  Ones that are
            # not set should be treated as None
            if name.startswith("color_"):
                _name = name[6:].lower()
                # use color "hidden" to hide blocks
                if _name == "hidden":
                    param = "hidden"
                # TODO: removing this statement does not fail "test_color_10()" but would fail
                # easily in the bar. the test is there to raise awareness about this.
                # TODO: "test_color_11()" shows how the tests can be incorrect as it does not print
                # everything correctly (i.e. orange vs ORaNgE) due to non composite/formatter code.
                elif hasattr(param, "none_setting"):
                    # see if named color and use if it is
                    param = expand_color(_name)
                elif param is None:
                    param = self._none_color
            # if a non-color parameter and was not set then set to default
            elif hasattr(param, "none_setting"):
                param = default
            self._config_setting[name] = param
        return self._config_setting[name]

    def _get_color(self, color):
        if color:
            if color[0] == "#":
                return expand_color(color)
            return self._get_config_setting("color_" + color)

    def _thresholds_init(self):
        """
        Initiate and check any thresholds set
        """
        thresholds = getattr(self._py3status_module, "thresholds", [])
        self._thresholds = {}
        if isinstance(thresholds, list):
            try:
                thresholds.sort()
            except TypeError:
                pass
            self._thresholds[None] = [(x[0], self._get_color(x[1])) for x in thresholds]

        elif isinstance(thresholds, dict):
            for key, value in thresholds.items():
                if isinstance(value, list):
                    try:
                        value.sort()
                    except TypeError:
                        pass
                    self._thresholds[key] = [(x[0], self._get_color(x[1])) for x in value]

    def _replacements_init(self):
        """
        Initiate and check any replacements set
        """
        replacements = getattr(self._py3status_module, "replacements", [])
        self._replacements = {}

        if isinstance(replacements, list):
            self._replacements[None] = [
                (re.compile(x[0], re.IGNORECASE), x[1]) for x in replacements
            ]

        elif isinstance(replacements, dict):
            for key, value in replacements.items():
                if isinstance(value, list):
                    self._replacements[key] = [
                        (re.compile(x[0], re.IGNORECASE), x[1]) for x in value
                    ]

    def _get_module_info(self, module_name):
        """
        THIS IS PRIVATE AND UNSUPPORTED.
        Get info for named module.  Info comes back as a dict containing.

        'module': the instance of the module,
        'position': list of places in i3bar, usually only one item
        'type': module type py3status/i3status
        """
        return self._output_modules.get(module_name)

    def _report_exception(self, msg, frame_skip=2):
        """
        THIS IS PRIVATE AND UNSUPPORTED.
        logs an exception that occurs inside of a Py3 method.  We only log the
        exception once to prevent spamming the logs and we do not notify the
        user.

        frame_skip is used to change the place in the code that the error is
        reported as coming from.  We want to show it as coming from the
        py3status module where the Py3 method was called.
        """
        # We use a hash to see if the message is being repeated.
        msg_hash = hash(msg)
        if msg_hash in self._report_exception_cache:
            return
        self._report_exception_cache.add(msg_hash)

        # If we just report the error the traceback will end in the try
        # except block that we are calling from.
        # We want to show the traceback originating from the module that
        # called the Py3 method so get the correct error frame and pass this
        # along.
        error_frame = sys._getframe(0)
        while frame_skip:
            error_frame = error_frame.f_back
            frame_skip -= 1
        self._py3_wrapper.report_exception(msg, notify_user=False, error_frame=error_frame)

    def error(self, msg, timeout=None):
        """
        Raise an error for the module.

        :param msg: message to be displayed explaining the error
        :param timeout: how long before we should retry.  For permanent errors
            `py3.CACHE_FOREVER` should be returned.  If not supplied then the
            modules `cache_timeout` will be used.
        """
        raise ModuleErrorException(msg, timeout)

    def flatten_dict(self, d, delimiter="-", intermediates=False, parent_key=None):
        """
        Flatten a dictionary.

        Values that are dictionaries are flattened using delimiter in between
        (eg. parent-child)

        Values that are lists are flattened using delimiter
        followed by the index (eg. parent-0)

        example:

        .. code-block:: python

            {
                'fish_facts': {
                    'sharks': 'Most will drown if they stop moving',
                    'skates': 'More than 200 species',
                },
                'fruits': ['apple', 'peach', 'watermelon'],
                'number': 52
            }

            # becomes

            {
                'fish_facts-sharks': 'Most will drown if they stop moving',
                'fish_facts-skates': 'More than 200 species',
                'fruits-0': 'apple',
                'fruits-1': 'peach',
                'fruits-2': 'watermelon',
                'number': 52
            }

            # if intermediates is True then we also get unflattened elements
            # as well as the flattened ones.

            {
                'fish_facts': {
                    'sharks': 'Most will drown if they stop moving',
                    'skates': 'More than 200 species',
                },
                'fish_facts-sharks': 'Most will drown if they stop moving',
                'fish_facts-skates': 'More than 200 species',
                'fruits': ['apple', 'peach', 'watermelon'],
                'fruits-0': 'apple',
                'fruits-1': 'peach',
                'fruits-2': 'watermelon',
                'number': 52
            }
        """
        items = []
        if isinstance(d, list):
            d = dict(enumerate(d))
        for k, v in d.items():
            if parent_key:
                k = f"{parent_key}{delimiter}{k}"
            if intermediates:
                items.append((k, v))
            if isinstance(v, list):
                v = dict(enumerate(v))
            if isinstance(v, Mapping):
                items.extend(self.flatten_dict(v, delimiter, intermediates, str(k)).items())
            else:
                items.append((str(k), v))
        return dict(items)

    def format_units(self, value, unit="B", optimal=5, auto=True, si=False):
        """
        Takes a value and formats it for user output, we can choose the unit to
        use eg B, MiB, kbits/second.  This is mainly for use with bytes/bits it
        converts the value into a human readable form.  It has various
        additional options but they are really only for special cases.

        The function returns a tuple containing the new value (this is a number
        so that the user can still format it if required) and a unit that is
        the units that we have been converted to.

        By supplying unit to the function we can force those units to be used
        eg ``unit=KiB`` would force the output to be in Kibibytes.  By default we
        use non-si units but if the unit is si eg kB then we will switch to si
        units.  Units can also be things like ``Mbit/sec``.

        If the auto parameter is False then we use the unit provided.  This
        only makes sense when the unit is singular eg 'Bytes' and we want the
        result in bytes and not say converted to MBytes.

        optimal is used to control the size of the output value.  We try to
        provide an output value of that number of characters (including decimal
        point), it may also be less due to rounding.  If a fixed unit is used
        the output may be more than this number of characters.
        """

        UNITS = "KMGTPEZY"
        DECIMAL_SIZE = 1000
        BINARY_SIZE = 1024
        CUTOFF = 1000

        can_round = False

        if unit:
            # try to guess the unit.  Do we have a known prefix too it?
            if unit[0].upper() in UNITS:
                index = UNITS.index(unit[0].upper()) + 1
                post = unit[1:]
                si = len(unit) > 1 and unit[1] != "i"
                if si:
                    post = post[1:]
                    if unit[1] == "b":
                        value *= 8
                auto = False
            else:
                index = 0
                post = unit
        if si:
            size = DECIMAL_SIZE
        else:
            size = BINARY_SIZE

        if auto:
            # we will try to use an appropriate prefix
            if value < CUTOFF:
                unit_out = post
            else:
                value /= size
                for prefix in UNITS:
                    if abs(value) < CUTOFF:
                        break
                    value /= size
                if si:
                    # si kilo is lowercase
                    if prefix == "K":
                        prefix = "k"
                else:
                    post = "i" + post

                unit_out = prefix + post
                can_round = True
        else:
            # we are using a fixed unit
            unit_out = unit
            size = pow(size, index)
            if size:
                value /= size
                can_round = True

        if can_round and optimal and value:
            # we will try to make the output value the desired size
            # we need to keep out value as a numeric type
            places = int(log10(abs(value)))
            if places >= optimal - 2:
                value = int(value)
            else:
                value = round(value, max(optimal - places - 2, 0))

        return value, unit_out

    def is_color(self, color):
        """
        Tests to see if a color is defined.
        Because colors can be set to None in the config and we want this to be
        respected in an expression like.

        color = self.py3.COLOR_MUTED or self.py3.COLOR_BAD

        The color is treated as True but sometimes we want to know if the color
        has a value set in which case the color should count as False.  This
        function is a helper for this second case.
        """
        return not (color is None or hasattr(color, "none_setting"))

    def i3s_config(self):
        """
        returns the i3s_config dict.
        """
        return self._i3s_config

    def is_my_event(self, event):
        """
        Checks if an event triggered belongs to the module receiving it.  This
        is mainly for containers who will also receive events from any children
        they have.

        Returns True if the event name and instance match that of the module
        checking.
        """

        return (
            event.get("name") == self._module.module_name
            and event.get("instance") == self._module.module_inst
        )

    def log(self, message, level=LOG_INFO):
        """
        Log the message.
        The level must be one of LOG_ERROR, LOG_INFO or LOG_WARNING
        """
        assert level in [
            self.LOG_ERROR,
            self.LOG_INFO,
            self.LOG_WARNING,
        ], "level must be LOG_ERROR, LOG_INFO or LOG_WARNING"

        # nicely format logs if we can using pretty print
        if isinstance(message, (dict, list, set, tuple)):
            message = pformat(message)
        # start on new line if multi-line output
        try:
            if "\n" in message:
                message = "\n" + message
        except:  # noqa e722
            pass
        message = f"Module `{self._module.module_full_name}`: {message}"
        self._py3_wrapper.log(message, level)

    def update(self, module_name=None):
        """
        Update a module.  If module_name is supplied the module of that
        name is updated.  Otherwise the module calling is updated.
        """
        if not module_name:
            return self._module.force_update()
        else:
            module_info = self._get_module_info(module_name)
            if module_info:
                module_info["module"].force_update()

    def get_wm_msg(self):
        """
        Return the control program of the current window manager.

        On i3, will return "i3-msg"
        On sway, will return "swaymsg"
        """
        return self._py3_wrapper.config["wm"]["msg"]

    def get_output(self, module_name):
        """
        Return the output of the named module.  This will be a list.
        """
        output = []
        module_info = self._get_module_info(module_name)
        if module_info:
            output = module_info["module"].get_latest()
        # we do a deep copy so that any user does not change the actual output
        # of the module.
        return deepcopy(output)

    def trigger_event(self, module_name, event):
        """
        Trigger an event on a named module.
        """
        if module_name:
            self._py3_wrapper.events_thread.process_event(module_name, event)

    def prevent_refresh(self):
        """
        Calling this function during the on_click() method of a module will
        request that the module is not refreshed after the event. By default
        the module is updated after the on_click event has been processed.
        """
        self._module.prevent_refresh = True

    def notify_user(self, msg, level="info", rate_limit=5, title=None, icon=None):
        """
        Send a notification to the user.
        level must be 'info', 'error' or 'warning'.
        rate_limit is the time period in seconds during which this message
        should not be repeated.
        icon must be an icon path or icon name.
        """
        module_name = self._module.module_full_name
        if isinstance(msg, Composite):
            msg = msg.text()
        if title is None:
            title = f"py3status: {module_name}"
        elif isinstance(title, Composite):
            title = title.text()
        if msg:
            self._py3_wrapper.notify_user(
                msg=msg,
                level=level,
                rate_limit=rate_limit,
                module_name=module_name,
                title=title,
                icon=icon,
            )

    def register_function(self, function_name, function):
        """
        Register a function for the module.

        The following functions can be registered


            ..  py:function:: content_function()

            Called to discover what modules a container is displaying.  This is
            used to determine when updates need passing on to the container and
            also when modules can be put to sleep.

            the function must return a set of module names that are being
            displayed.

            .. note::

                This function should only be used by containers.

            ..  py:function:: urgent_function(module_names)

            This function will be called when one of the contents of a container
            has changed from a non-urgent to an urgent state.  It is used by the
            group module to switch to displaying the urgent module.

            ``module_names`` is a list of modules that have become urgent

            .. note::

                This function should only be used by containers.
        """
        my_info = self._get_module_info(self._module.module_full_name)
        my_info[function_name] = function

    def time_in(self, seconds=None, sync_to=None, offset=0):
        """
        Returns the time a given number of seconds into the future.  Helpful
        for creating the ``cached_until`` value for the module output.

        .. note::

            from version 3.1 modules no longer need to explicitly set a
            ``cached_until`` in their response unless they wish to directly control
            it.

        :param seconds: specifies the number of seconds that should occur before the
            update is required.  Passing a value of ``CACHE_FOREVER`` returns
            ``CACHE_FOREVER`` which can be useful for some modules.

        :param sync_to: causes the update to be synchronized to a time period.  1 would
            cause the update on the second, 60 to the nearest minute. By default we
            synchronize to the nearest second. 0 will disable this feature.

        :param offset: is used to alter the base time used. A timer that started at a
            certain time could set that as the offset and any synchronization would
            then be relative to that time.
        """

        # if called with CACHE_FOREVER we just return this
        if seconds is self.CACHE_FOREVER:
            return self.CACHE_FOREVER

        if seconds is None:
            # If we have a sync_to then seconds can be 0
            if sync_to and sync_to > 0:
                seconds = 0
            else:
                try:
                    # use py3status modules cache_timeout
                    seconds = self._py3status_module.cache_timeout
                except AttributeError:
                    # use default cache_timeout
                    seconds = self._module.config["cache_timeout"]

        # Unless explicitly set we sync to the nearest second
        # Unless the requested update is in less than a second
        if sync_to is None:
            if seconds and seconds < 1:
                if 1 % seconds == 0:
                    sync_to = seconds
                else:
                    sync_to = 0
            else:
                sync_to = 1
                if seconds:
                    seconds -= 0.1

        current_time = time.time()
        requested = time.monotonic() + seconds - offset

        # if sync_to then we find the sync time for the requested time
        if sync_to:
            requested = (requested + sync_to) - (current_time % sync_to)

        return requested + offset

    def format_contains(self, format_string, names):
        """
        Determines if ``format_string`` contains a placeholder string ``names``
        or a list of placeholders ``names``.

        ``names`` is tested against placeholders using fnmatch so the following
        patterns can be used:

        .. code-block:: none

            * 	    matches everything
            ? 	    matches any single character
            [seq] 	matches any character in seq
            [!seq] 	matches any character not in seq

        This is useful because a simple test like
        ``'{placeholder}' in format_string``
        will fail if the format string contains placeholder formatting
        eg ``'{placeholder:.2f}'``
        """
        # We cache things to prevent parsing the format_string more than needed
        if isinstance(names, list):
            key = str(names)
        else:
            key = names
            names = [names]
        try:
            return self._format_placeholders_cache[format_string][key]
        except KeyError:
            pass

        if format_string not in self._format_placeholders:
            placeholders = self._formatter.get_placeholders(format_string)
            self._format_placeholders[format_string] = placeholders
        else:
            placeholders = self._format_placeholders[format_string]

        if format_string not in self._format_placeholders_cache:
            self._format_placeholders_cache[format_string] = {}

        for name in names:
            for placeholder in placeholders:
                if fnmatch(placeholder, name):
                    self._format_placeholders_cache[format_string][key] = True
                    return True
        self._format_placeholders_cache[format_string][key] = False
        return False

    def get_color_names_list(self, format_string, matches=None):
        """
        Returns a list of color names in ``format_string``.

        :param format_string: Accepts a format string.
        :param matches: Filter results with a string or a list of strings.

        If ``matches`` is provided then it is used to filter the result
        using fnmatch so the following patterns can be used:

        .. code-block:: none

            * 	    matches everything
            ? 	    matches any single character
            [seq] 	matches any character in seq
            [!seq] 	matches any character not in seq
        """
        if not getattr(self._py3status_module, "thresholds", None):
            return []
        elif not format_string:
            return []

        if format_string not in self._format_color_names:
            names = self._formatter.get_color_names(format_string)
            self._format_color_names[format_string] = names
        else:
            names = self._format_color_names[format_string]

        if not matches:
            return list(names)
        elif isinstance(matches, str):
            matches = [matches]
        # filter matches
        found = set()
        for match in matches:
            for name in names:
                if fnmatch(name, match):
                    found.add(name)
        return list(found)

    def get_replacements_list(self, format_string):
        """
        If possible, returns a list of filtered placeholders in ``format_string``.
        """
        replacements = getattr(self._py3status_module, "replacements", None)
        if not replacements or not format_string:
            return []

        if format_string not in self._format_placeholders:
            placeholders = self._formatter.get_placeholders(format_string)
            self._format_placeholders[format_string] = placeholders
        else:
            placeholders = self._format_placeholders[format_string]

        # filter placeholders
        found = set()
        for replacement in replacements:
            for placeholder in placeholders:
                if placeholder == replacement:
                    found.add(placeholder)
        return list(found or placeholders)

    def get_placeholders_list(self, format_string, matches=None):
        """
        Returns a list of placeholders in ``format_string``.

        If ``matches`` is provided then it is used to filter the result
        using fnmatch so the following patterns can be used:


        .. code-block:: none

            * 	    matches everything
            ? 	    matches any single character
            [seq] 	matches any character in seq
            [!seq] 	matches any character not in seq

        This is useful because we just get simple placeholder without any
        formatting that may be applied to them
        eg ``'{placeholder:.2f}'`` will give ``['{placeholder}']``
        """
        if format_string not in self._format_placeholders:
            placeholders = self._formatter.get_placeholders(format_string)
            self._format_placeholders[format_string] = placeholders
        else:
            placeholders = self._format_placeholders[format_string]

        if not matches:
            return list(placeholders)
        elif isinstance(matches, str):
            matches = [matches]
        # filter matches
        found = set()
        for match in matches:
            for placeholder in placeholders:
                if fnmatch(placeholder, match):
                    found.add(placeholder)
        return list(found)

    def get_placeholder_formats_list(self, format_string):
        """
        Parses the format_string and returns a list of tuples
        [(placeholder, format), ...].

        eg ``'{placeholder:.2f}'`` will give ``[('placeholder', ':.2f')]``
        """
        return self._formatter.get_placeholder_formats_list(format_string)

    def update_placeholder_formats(self, format_string, formats):
        """
        Update a format string adding formats if they are not already present.
        This is useful when for example a placeholder has a floating point
        value but by default we only want to show it to a certain precision.
        """

        return self._formatter.update_placeholder_formats(format_string, formats)

    def safe_format(
        self,
        format_string,
        param_dict=None,
        force_composite=False,
        attr_getter=None,
        max_width=None,
    ):
        r"""
        Parser for advanced formatting.

        Unknown placeholders will be shown in the output eg ``{foo}``.

        Square brackets ``[]`` can be used. The content of them will be removed
        from the output if there is no valid placeholder contained within.
        They can also be nested.

        A pipe (vertical bar) ``|`` can be used to divide sections the first
        valid section only will be shown in the output.

        A backslash ``\`` can be used to escape a character eg ``\[`` will show ``[``
        in the output.

        ``\?`` is special and is used to provide extra commands to the format
        string,  example ``\?color=#FF00FF``. Multiple commands can be given
        using an ampersand ``&`` as a separator, example ``\?color=#FF00FF&show``.

        ``\?if=<placeholder>`` can be used to check if a placeholder exists. An
        exclamation mark ``!`` after the equals sign ``=`` can be used to negate
        the condition.

        ``\?if=<placeholder>=<value>`` can be used to determine if {<placeholder>}
        would be replaced with <value>. ``[]`` in <value> don't need to be escaped.

        ``{<placeholder>}`` will be converted, or removed if it is None or empty.
        Formatting can also be applied to the placeholder Eg
        ``{number:03.2f}``.

        example format_string:

        ``"[[{artist} - ]{title}]|{file}"``
        This will show ``artist - title`` if artist is present,
        ``title`` if title but no artist,
        and ``file`` if file is present but not artist or title.

        param_dict is a dictionary of placeholders that will be substituted.
        If a placeholder is not in the dictionary then if the py3status module
        has an attribute with the same name then it will be used.

        .. note::

            Added in version 3.3

        Composites can be included in the param_dict.

        The result returned from this function can either be a string in the
        case of simple parsing or a Composite if more complex.

        If force_composite parameter is True a composite will always be
        returned.

        attr_getter is a function that will when called with an attribute name
        as a parameter will return a value.

        max_width lets you to control the total max width of 'full_text' the
        module is allowed to output on the bar.
        """
        try:
            result = self._formatter.format(
                format_string,
                self._py3status_module,
                param_dict,
                force_composite=force_composite,
                attr_getter=attr_getter,
            )
            if max_width is not None and max_width > 0:
                if isinstance(result, str):
                    result = result[:max_width]
                elif isinstance(result, Composite):
                    chars_left = max_width
                    for composite in result:
                        if "index" in composite:
                            continue
                        composite["full_text"] = composite["full_text"][:chars_left]
                        chars_left -= len(composite["full_text"])
                        chars_left = max(0, chars_left)
            return result
        except Exception as err:
            self._report_exception(f"Invalid format `{format_string}` ({err})")
            return f"invalid format ({err})"

    def build_composite(self, format_string, param_dict=None, composites=None, attr_getter=None):
        """
        .. note::
            deprecated in 3.3 use safe_format().

        Build a composite output using a format string.

        Takes a format_string and treats it the same way as ``safe_format()`` but
        also takes a composites dict where each key/value is the name of the
        placeholder and either an output eg ``{'full_text': 'something'}`` or a
        list of outputs.
        """

        if param_dict is None:
            param_dict = {}

        # merge any composites into the param_dict.
        # as they are no longer dealt with separately
        if composites:
            for key, value in composites.items():
                param_dict[key] = Composite(value)

        try:
            return self._formatter.format(
                format_string,
                self._py3status_module,
                param_dict,
                force_composite=True,
                attr_getter=attr_getter,
            )
        except Exception:
            self._report_exception(f"Invalid format `{format_string}`")
            return [{"full_text": "invalid format"}]

    def composite_update(self, item, update_dict, soft=False):
        """
        Takes a Composite (item) if item is a type that can be converted into a
        Composite then this is done automatically.  Updates all entries it the
        Composite with values from update_dict.  Updates can be soft in which
        case existing values are not overwritten.

        A Composite object will be returned.
        """
        return Composite.composite_update(item, update_dict, soft)

    def composite_join(self, separator, items):
        """
        Join a list of items with a separator.
        This is used in joining strings, responses and Composites.

        A Composite object will be returned.
        """
        return Composite.composite_join(separator, items)

    def composite_create(self, item):
        """
        Create and return a Composite.

        The item may be a string, dict, list of dicts or a Composite.
        """
        return Composite(item)

    def is_composite(self, item):
        """
        Check if item is a Composite and return True if it is.
        """
        return isinstance(item, Composite)

    def get_composite_string(self, format_string):
        """
        Return a string from a Composite.
        """
        if not isinstance(format_string, Composite):
            return ""
        return format_string.text()

    def check_commands(self, cmd_list):
        """
        Checks to see if commands in list are available using shutil.which().

        returns the first available command.

        If a string is passed then that command will be checked for.
        """
        # if a string is passed then convert it to a list.  This prevents an
        # easy mistake that could be made
        if isinstance(cmd_list, str):
            cmd_list = [cmd_list]

        for cmd in cmd_list:
            if which(cmd) is not None:
                return cmd

    def command_run(self, command):
        """
        Runs a command and returns the exit code.
        The command can either be supplied as a sequence or string.

        An Exception is raised if an error occurs
        """
        # convert the command to sequence if a string
        if isinstance(command, str):
            command = shlex.split(command)
        try:
            return Popen(command, stdout=PIPE, stderr=PIPE, close_fds=True).wait()
        except Exception as e:
            # make a pretty command for error loggings and...
            if isinstance(command, str):
                pretty_cmd = command
            else:
                pretty_cmd = " ".join(command)
            msg = f"Command `{pretty_cmd}` {e.errno}"
            raise exceptions.CommandError(msg, error_code=e.errno)

    def command_output(self, command, shell=False, capture_stderr=False, localized=False):
        """
        Run a command and return its output as unicode.
        The command can either be supplied as a sequence or string.

        :param command: command to run can be a str or list
        :param shell: if `True` then command is run through the shell
        :param capture_stderr: if `True` then STDERR is piped to STDOUT
        :param localized: if `False` then command is forced to use its default (English) locale

        A CommandError is raised if an error occurs
        """
        # make a pretty command for error loggings and...
        if isinstance(command, str):
            pretty_cmd = command
        else:
            pretty_cmd = " ".join(command)
        # convert the non-shell command to sequence if it is a string
        if not shell and isinstance(command, str):
            command = shlex.split(command)

        stderr = STDOUT if capture_stderr else PIPE
        env = self._english_env if not localized else None

        try:
            process = Popen(
                command,
                stdout=PIPE,
                stderr=stderr,
                close_fds=True,
                universal_newlines=True,
                shell=shell,
                env=env,
            )
        except Exception as e:
            msg = f"Command `{pretty_cmd}` {e}"
            self.log(msg)
            raise exceptions.CommandError(msg, error_code=e.errno)

        output, error = process.communicate()
        retcode = process.poll()
        if retcode:
            # under certain conditions a successfully run command may get a
            # return code of -15 even though correct output was returned see
            # #664.  This issue seems to be related to arch linux but the
            # reason is not entirely clear.
            if retcode == -15:
                msg = "Command `{cmd}` returned SIGTERM (ignoring)"
                self.log(msg.format(cmd=pretty_cmd))
            else:
                msg = "Command `{cmd}` returned non-zero exit status {error}"
                output_oneline = output.replace("\n", " ")
                if output_oneline:
                    msg += " ({output})"
                msg = msg.format(cmd=pretty_cmd, error=retcode, output=output_oneline)
                raise exceptions.CommandError(msg, error_code=retcode, error=error, output=output)
        return output

    def _storage_init(self):
        """
        Ensure that storage is initialized.
        """
        if not self._storage.initialized:
            self._storage.init(self._module._py3_wrapper)

    def storage_set(self, key, value):
        """
        Store a value for the module.
        """
        if not self._module:
            return
        self._storage_init()
        module_name = self._module.module_full_name
        return self._storage.storage_set(module_name, key, value)

    def storage_get(self, key):
        """
        Retrieve a value for the module.
        """
        if not self._module:
            return
        self._storage_init()
        module_name = self._module.module_full_name
        return self._storage.storage_get(module_name, key)

    def storage_del(self, key=None):
        """
        Remove the value stored with the key from storage.
        If key is not supplied then all values for the module are removed.
        """
        if not self._module:
            return
        self._storage_init()
        module_name = self._module.module_full_name
        return self._storage.storage_del(module_name, key=key)

    def storage_keys(self):
        """
        Return a list of the keys for values stored for the module.

        Keys will contain the following metadata entries:
        - '_ctime': storage creation timestamp
        - '_mtime': storage last modification timestamp
        """
        if not self._module:
            return []
        self._storage_init()
        module_name = self._module.module_full_name
        return self._storage.storage_keys(module_name)

    def storage_items(self):
        """
        Return key, value pairs of the stored data for the module.

        Keys will contain the following metadata entries:
        - '_ctime': storage creation timestamp
        - '_mtime': storage last modification timestamp
        """
        if not self._module:
            return {}.items()
        self._storage_init()
        items = []
        module_name = self._module.module_full_name
        for key in self._storage.storage_keys(module_name):
            value = self._storage.storage_get(module_name, key)
            items.add((key, value))
        return items

    def play_sound(self, sound_file):
        """
        Plays sound_file if possible.
        """
        self.stop_sound()
        if sound_file:
            cmd = self.check_commands(["ffplay", "paplay", "play"])
            if cmd:
                if cmd == "ffplay":
                    cmd = "ffplay -autoexit -nodisp -loglevel 0"
                sound_file = Path(sound_file).expanduser()
                c = shlex.split(f"{cmd} {sound_file}")
                self._audio = Popen(c)

    def stop_sound(self):
        """
        Stops any currently playing sounds for this module.
        """
        if self._audio:
            self._audio.kill()
            self._audio = None

    def threshold_get_color(self, value, name=None):
        """
        Obtain color for a value using thresholds.

        The value will be checked against any defined thresholds.  These should
        have been set in the i3status configuration.  If more than one
        threshold is needed for a module then the name can also be supplied.
        If the user has not supplied a named threshold but has defined a
        general one that will be used.

        If the gradients config parameter is True then rather than sharp
        thresholds we will use a gradient between the color values.

        :param value: numerical value to be graded
        :param name: accepts a string, otherwise 'threshold'
            accepts 3-tuples to allow name with different
            values eg ('name', 'key', 'thresholds')
        """
        # If first run then process the threshold data.
        if self._thresholds is None:
            self._thresholds_init()

        # allow name with different values
        if isinstance(name, tuple):
            name_used = "{}/{}".format(name[0], name[1])
            if name[2]:
                self._thresholds[name_used] = [(x[0], self._get_color(x[1])) for x in name[2]]
            name = name[0]
        else:
            # if name not in thresholds info then use defaults
            name_used = name
            if name_used not in self._thresholds:
                name_used = None

        # convert value to int/float
        thresholds = self._thresholds.get(name_used)
        color = None
        try:
            value = float(value)
        except (TypeError, ValueError):
            pass

        # skip on empty thresholds/values
        if not thresholds or value in [None, ""]:
            pass
        elif isinstance(value, str):
            # string
            for threshold in thresholds:
                if value == threshold[0]:
                    color = threshold[1]
                    break
        else:
            # int/float
            try:
                if self._get_config_setting("gradients"):
                    try:
                        colors, minimum, maximum = self._threshold_gradients[name_used]
                    except KeyError:
                        colors = self._gradients.make_threshold_gradient(self, thresholds)
                        minimum = min(thresholds)[0]
                        maximum = max(thresholds)[0]
                        self._threshold_gradients[name_used] = (
                            colors,
                            minimum,
                            maximum,
                        )

                    if value < minimum:
                        color = colors[0]
                    elif value > maximum:
                        color = colors[-1]
                    else:
                        value -= minimum
                        col_index = int(((len(colors) - 1) / (maximum - minimum)) * value)
                        color = colors[col_index]
                else:
                    color = thresholds[0][1]
                    for threshold in thresholds:
                        if value >= threshold[0]:
                            color = threshold[1]
                        else:
                            break
            except TypeError:
                color = None

        # save color so it can be accessed via safe_format()
        if name:
            color_name = f"color_threshold_{name}"
        else:
            color_name = "color_threshold"
        setattr(self._py3status_module, color_name, color)

        return color

    def replace(self, value, name=None):
        """
        Replace string using replacements.

        :param value: string value to be replaced
        :param name: accepts a name
        """
        # If first run, then process the replacements data.
        if self._replacements is None:
            self._replacements_init()

        if not value or not isinstance(value, str):
            return value

        name_used = name
        if name_used not in self._replacements:
            name_used = None

        for pattern, replacement in self._replacements.get(name_used, []):
            value = re.sub(pattern, replacement, value)

        return value

    def request(
        self,
        url,
        params=None,
        data=None,
        headers=None,
        timeout=None,
        auth=None,
        cookiejar=None,
        retry_times=None,
        retry_wait=None,
    ):
        """
        Make a request to a url and retrieve the results.

        If the headers parameter does not provide an 'User-Agent' key, one will
        be added automatically following the convention:

            py3status/<version> <per session random uuid>

        :param url: url to request eg `http://example.com`
        :param params: extra query string parameters as a dict
        :param data: POST data as a dict.  If this is not supplied the GET method will be used
        :param headers: http headers to be added to the request as a dict
        :param timeout: timeout for the request in seconds
        :param auth: authentication info as tuple `(username, password)`
        :param cookiejar: an object of a CookieJar subclass
        :param retry_times: how many times to retry the request
        :param retry_wait: how long to wait between retries in seconds

        :returns: HttpResponse
        """

        # The aim of this function is to be a limited lightweight replacement
        # for the requests library but using only pythons standard libs.

        # IMPORTANT NOTICE
        # This function is excluded from private variable hiding as it is
        # likely to need api keys etc which people may have obfuscated.
        # Therefore it is important that no logging is done in this function
        # that might reveal this information.

        if headers is None:
            headers = {}

        if timeout is None:
            timeout = getattr(self._py3status_module, "request_timeout", 10)

        if retry_times is None:
            retry_times = getattr(self._py3status_module, "request_retry_times", 3)

        if retry_wait is None:
            retry_wait = getattr(self._py3status_module, "request_retry_wait", 2)

        if "User-Agent" not in headers:
            headers["User-Agent"] = f"py3status/{version} {self._uid}"

        def get_http_response():
            return HttpResponse(
                url,
                params=params,
                data=data,
                headers=headers,
                timeout=timeout,
                auth=auth,
                cookiejar=cookiejar,
            )

        for n in range(1, retry_times):
            try:
                return get_http_response()
            except (self.RequestTimeout, self.RequestURLError):
                self.log(f"HTTP request retry {n}/{retry_times}")
                sleep(retry_wait)
        self.log(f"HTTP request retry {retry_times}/{retry_times}")
        sleep(retry_wait)
        return get_http_response()



================================================
FILE: py3status/request.py
================================================
import base64
import json
import socket
from urllib.error import HTTPError, URLError
from urllib.parse import parse_qsl, urlencode, urlsplit, urlunsplit
from urllib.request import HTTPCookieProcessor, Request, build_opener, install_opener, urlopen

from py3status.exceptions import RequestInvalidJSON, RequestTimeout, RequestURLError


class HttpResponse:
    """
    Simple encapsulation of a http response for a url

    The aim is to support both python 2 and 3 and be a simple as possible
    """

    def __init__(self, url, params, data, headers, timeout, auth, cookiejar):
        # fix the url if needed
        url_parts = urlsplit(url)
        if url_parts.query or params:
            # split into parts so we can update
            parts = list(url_parts)
            # Make sure the querystring params are correctly encoded
            url_params = parse_qsl(parts[3])
            if params:
                for key, value in params.items():
                    url_params.append((key, value))
            parts[3] = urlencode(url_params)
            # rebuild the url
            url = urlunsplit(parts)
        if auth:
            # we need to do the encode/decode to keep python 3 happy
            # TODO: make this straight for python 3
            auth_str = base64.b64encode(("%s:%s" % auth).encode("utf-8"))
            headers["Authorization"] = "Basic %s" % auth_str.decode("utf-8")
        if data:
            data = urlencode(data).encode()
        if cookiejar is not None:
            self._cookiejar = cookiejar
            opener = build_opener(HTTPCookieProcessor(cookiejar))
            install_opener(opener)

        request = Request(url, headers=headers)

        try:
            self._response = urlopen(request, data=data, timeout=timeout)
            self._error_message = None
        except URLError as e:
            reason = e.reason
            if isinstance(reason, socket.timeout):
                raise RequestTimeout("request timed out")
            elif isinstance(e, HTTPError):
                self._status_code = e.code
                self._error_message = reason
                # we return an HttpResponse but have no response
                # so create some 'fake' response data.
                self._text = ""
                self._json = {}
                self._headers = []
            else:
                # unknown exception, so just raise it
                raise RequestURLError(reason)
        except socket.timeout:
            raise RequestTimeout("request timed out")

    @property
    def status_code(self):
        """
        Get the http status code for the response
        """
        try:
            return self._status_code
        except AttributeError:
            self._status_code = self._response.getcode()
        return self._status_code

    @property
    def text(self):
        """
        Get the raw text for the response
        """
        try:
            return self._text
        except AttributeError:
            encoding = self._response.headers.get_content_charset("utf-8")
            self._text = self._response.read().decode(encoding or "utf-8")
        return self._text

    def json(self):
        """
        Return an object representing the return json for the request
        """
        try:
            return self._json
        except AttributeError:
            try:
                self._json = json.loads(self.text)
                return self._json
            except:  # noqa e722
                raise RequestInvalidJSON("Invalid JSON received")

    @property
    def headers(self):
        """
        Get the headers from the response.
        """
        try:
            return self._headers
        except AttributeError:
            self._headers = self._response.headers
            return self._headers

    @property
    def cookiejar(self):
        """
        Get the cookie jar
        """
        try:
            return self._cookiejar
        except AttributeError:
            return None

    @cookiejar.setter
    def cookiejar(self, cj):
        """
        Set the cookie jar in care we want to change it after object creation
        """
        self._cookiejar = cj



================================================
FILE: py3status/screenshots.py
================================================
"""
This file is used for the generation of screenshots for py3status
documentation.

outside of pythons standard library there are the following requirements:

    Pillow==3.4.2
    fonttools

PIL may work if installed but is not supported.
"""

import ast
import re
from hashlib import md5
from pathlib import Path

from fontTools.ttLib import TTFont
from PIL import Image, ImageDraw, ImageFont

WIDTH = 650
TOP_BAR_HEIGHT = 5
BAR_HEIGHT = 24
X_OFFSET = 5
PADDING = 4

SEP_PADDING_LEFT = 4
SEP_PADDING_RIGHT = SEP_PADDING_LEFT + 1

SEP_BORDER = 4

FONT = "DejaVuSansMono.ttf"

# Pillow does poor font rendering so we are best off creating huge text and
# then shrinking with anti-aliasing.  SCALE is how many times bigger we render
# the text
SCALE = 8

COLOR = "#FFFFFF"
COLOR_BG = "#000000"
COLOR_PY3STATUS = "#FFFFFF"
COLOR_SEP = "#666666"
COLOR_URGENT = "#FFFFFF"
COLOR_URGENT_BG = "#900000"

FONT_SIZE = BAR_HEIGHT - (PADDING * 2)
HEIGHT = TOP_BAR_HEIGHT + BAR_HEIGHT

SAMPLE_DATA_ERROR = dict(color="#990000", background="#FFFF00", full_text=" SAMPLE DATA ERROR ")

# font, glyph_data want caching for performance
font = None
glyph_data = None


def get_color_for_name(module_name):
    """
    Create a custom color for a given string.
    This allows the screenshots to each have a unique color but also for that
    color to be consistent.
    """
    # all screenshots of the same module should be a uniform color
    module_name = module_name.split("-")[0]

    saturation = 0.5
    value = 243.2
    try:
        # we must be bytes to allow the md5 hash to be calculated
        module_name = module_name.encode("utf-8")
    except AttributeError:
        pass
    hue = int(md5(module_name).hexdigest(), 16) / 16**32
    hue *= 6
    hue += 3.708
    r, g, b = (
        (
            value,
            value - value * saturation * abs(1 - hue % 2),
            value - value * saturation,
        )
        * 3
    )[5 ** int(hue) // 3 % 3 :: int(hue) % 2 + 1][:3]
    return f"#{int(r):02x}{int(g):02x}{int(b):02x}"


def contains_bad_glyph(glyph_data, data):
    """
    Pillow only looks for glyphs in the font used so we need to make sure our
    font has the glygh.  Although we could substitute a glyph from another font
    eg symbola but this adds more complexity and is of limited value.
    """

    def check_glyph(char):
        for cmap in glyph_data["cmap"].tables:
            if cmap.isUnicode():
                if char in cmap.cmap:
                    return True
        return False

    for part in data:
        text = part.get("full_text", "")

        for char in text:
            if not check_glyph(ord(char)):
                # we have not found a character in the font
                print("{} ({}) missing".format(char, ord(char)))
                return True
    return False


def create_screenshot(name, data, path, font, is_module):
    """
    Create screenshot of py3status output and save to path
    """
    desktop_color = get_color_for_name(name)

    # if this screenshot is for a module then add modules name etc
    if is_module:
        data.append({"full_text": name.split("-")[0], "color": desktop_color, "separator": True})
        data.append({"full_text": "py3status", "color": COLOR_PY3STATUS, "separator": True})

    img = Image.new("RGB", (WIDTH, HEIGHT), COLOR_BG)
    d = ImageDraw.Draw(img)

    # top bar
    d.rectangle((0, 0, WIDTH, TOP_BAR_HEIGHT), fill=desktop_color)
    x = X_OFFSET

    # add text and separators
    for part in reversed(data):
        text = part.get("full_text")
        color = part.get("color", COLOR)
        background = part.get("background")
        separator = part.get("separator")
        urgent = part.get("urgent")

        # urgent background
        if urgent:
            color = COLOR_URGENT
            background = COLOR_URGENT_BG

        size = font.getbbox(text)[-2:]

        if background:
            d.rectangle(
                (
                    WIDTH - x - (size[0] // SCALE),
                    TOP_BAR_HEIGHT + PADDING,
                    WIDTH - x - 1,
                    HEIGHT - PADDING,
                ),
                fill=background,
            )

        x += size[0] // SCALE

        txt = Image.new("RGB", size, background or COLOR_BG)
        d_text = ImageDraw.Draw(txt)
        d_text.text((0, 0), text, font=font, fill=color)
        # resize to actual size wanted and add to image
        txt = txt.resize((size[0] // SCALE, size[1] // SCALE), Image.LANCZOS)
        img.paste(txt, (WIDTH - x, TOP_BAR_HEIGHT + PADDING))

        if separator:
            x += SEP_PADDING_RIGHT
            d.line(
                (
                    (WIDTH - x, TOP_BAR_HEIGHT + PADDING),
                    (WIDTH - x, TOP_BAR_HEIGHT + 1 + PADDING + FONT_SIZE),
                ),
                fill=COLOR_SEP,
                width=1,
            )
            x += SEP_PADDING_LEFT

    img.save(path / f"{name}.png")
    print(f" {name}.png")


def parse_sample_data(sample_data, module_name):
    """
    Parse sample output definitions and return a dict
    {screenshot_name: sample_output}
    """
    samples = {}
    for index, chunk in enumerate(sample_data.split("\n\n")):
        chunk = f"{module_name}-{index}-{chunk}"
        name, sample = re.split("-?\n", chunk, 1)
        try:
            samples[name] = ast.literal_eval(sample)
        except SyntaxError:
            samples[name] = SAMPLE_DATA_ERROR
    return samples


def get_samples():
    """
    Look in all core modules and get any samples from the docstrings.
    return a dict {screenshot_name: sample_output}
    """
    samples = {}
    module_dir = Path(__file__).resolve().parent / "modules"
    for file in sorted(module_dir.iterdir()):
        if file.suffix == ".py" and file.name != "__init__.py":
            with file.open() as f:
                try:
                    module = ast.parse(f.read())
                except SyntaxError:
                    continue
                raw_docstring = ast.get_docstring(module)
                if raw_docstring is None:
                    continue
                parts = re.split("^SAMPLE OUTPUT$", raw_docstring, flags=re.M)
                if len(parts) == 1:
                    continue
                sample_data = parts[1]
                samples.update(parse_sample_data(sample_data, file.stem))
    return samples


def process(name, path, data, module=True):
    """
    Process data to create a screenshot which will be saved in
    docs/screenshots/<name>.png
    If module is True the screenshot will include the name and py3status.
    """
    # create dir if not exists
    try:
        path.mkdir(parents=True, exist_ok=True)
    except OSError:
        pass

    global font, glyph_data
    if font is None:
        font = ImageFont.truetype(FONT, FONT_SIZE * SCALE)
    if glyph_data is None:
        glyph_data = TTFont(font.path)

    # make sure that the data is in list form
    if not isinstance(data, list):
        data = [data]

    if contains_bad_glyph(glyph_data, data):
        print("** {} has characters not in {} **".format(name, font.getname()[0]))
    else:
        create_screenshot(name, data, path, font=font, is_module=module)


def create_screenshots(config):
    """
    create screenshots for all core modules.
    The screenshots directory will have all .png files deleted before new shots
    are created.
    """
    path = Path(f"{config['docs_dir']}/user-guide/screenshots")
    print(f"Creating screenshots in {path}...")
    samples = get_samples()
    for name, data in sorted(samples.items()):
        process(name, path, data)
        pass
    return config


if __name__ == "__main__":
    create_screenshots()



================================================
FILE: py3status/storage.py
================================================
import os
import time
from pathlib import Path
from pickle import dump, load
from tempfile import NamedTemporaryFile


class Storage:
    data = {}
    initialized = False

    def init(self, py3_wrapper):
        self.py3_wrapper = py3_wrapper
        self.config = py3_wrapper.config
        py3_config = self.config.get("py3_config", {})

        # check for legacy storage cache
        legacy_storage_path = self.get_legacy_storage_path()

        # cutting edge storage cache
        storage_config = py3_config.get("py3status", {}).get("storage")
        if storage_config:
            storage_file = os.path.expandvars(os.path.expanduser(storage_config))
            if "/" in storage_file:
                storage_dir = None
            else:
                storage_dir = os.environ.get("XDG_CACHE_HOME")
        else:
            storage_dir = os.environ.get("XDG_CACHE_HOME")
            storage_file = "py3status_cache.data"

        if not storage_dir:
            storage_dir = Path("~/.cache").expanduser()
        self.storage_path = Path(storage_dir, storage_file)

        # move legacy storage cache to new desired / default location
        if legacy_storage_path:
            self.py3_wrapper.log(
                "moving legacy storage_path {} to {}".format(legacy_storage_path, self.storage_path)
            )
            legacy_storage_path.rename(self.storage_path)

        try:
            with self.storage_path.open("rb") as f:
                self.data = load(f, encoding="bytes")
        except OSError:
            pass

        self.py3_wrapper.log(f"storage_path: {self.storage_path}")
        if self.data:
            self.py3_wrapper.log(f"storage_data: {self.data}")
        self.initialized = True

    def get_legacy_storage_path(self):
        """
        Detect and return existing legacy storage path.
        """
        config_dir = Path(self.py3_wrapper.config.get("i3status_config_path", "/tmp")).parent
        storage_path = config_dir / "py3status.data"
        if storage_path.exists():
            return storage_path
        else:
            return None

    def save(self):
        """
        Save our data to disk. We want to always have a valid file.
        """
        with NamedTemporaryFile(dir=self.storage_path.parent, delete=False) as f:
            # we use protocol=2 for python 2/3 compatibility
            dump(self.data, f, protocol=2)
            f.flush()
            os.fsync(f.fileno())
            tmppath = Path(f.name)
        tmppath.rename(self.storage_path)

    def storage_set(self, module_name, key, value):
        if key.startswith("_"):
            raise ValueError('cannot set keys starting with an underscore "_"')

        if self.data.get(module_name, {}).get(key) == value:
            return

        if module_name not in self.data:
            self.data[module_name] = {}
        self.data[module_name][key] = value
        ts = time.time()
        if "_ctime" not in self.data[module_name]:
            self.data[module_name]["_ctime"] = ts
        self.data[module_name]["_mtime"] = ts
        self.save()

    def storage_get(self, module_name, key):
        return self.data.get(module_name, {}).get(key, None)

    def storage_del(self, module_name, key=None):
        if module_name in self.data and key in self.data[module_name]:
            del self.data[module_name][key]
            self.save()

    def storage_keys(self, module_name):
        return list(self.data.get(module_name, {}))



================================================
FILE: py3status/udev_monitor.py
================================================
from collections import Counter, defaultdict
from datetime import datetime
from time import sleep

from py3status.constants import ON_TRIGGER_ACTIONS

try:
    import pyudev
except ImportError:
    pyudev = None


class UdevMonitor:
    """
    This class allows us to react to udev events.
    """

    def __init__(self, py3_wrapper):
        """
        The udev monitoring will be lazy loaded if a module uses it.
        """
        self.py3_wrapper = py3_wrapper
        self.pyudev_available = pyudev is not None
        self.throttle = defaultdict(Counter)
        self.udev_consumers = defaultdict(list)
        self.udev_observer = None

    def _setup_pyudev_monitoring(self):
        """
        Setup the udev monitor.
        """
        context = pyudev.Context()
        monitor = pyudev.Monitor.from_netlink(context)
        self.udev_observer = pyudev.MonitorObserver(monitor, self._udev_event)
        self.udev_observer.start()
        self.py3_wrapper.log("udev monitoring enabled")

    def _udev_event(self, action, device):
        """
        This is a callback method that will trigger a refresh on subscribers.
        """
        # self.py3_wrapper.log(
        #     f"detected udev action '{action}' on subsystem '{device.subsystem}'"
        # )
        if not self.py3_wrapper.i3bar_running:
            return
        self.trigger_actions(action, device.subsystem)

    def subscribe(self, py3_module, trigger_action, subsystem):
        """
        Subscribe the given module to the given udev subsystem.

        Here we will lazy load the monitor if necessary and return success or
        failure based on the availability of pyudev.
        """
        if self.pyudev_available:
            # lazy load the udev monitor
            if self.udev_observer is None:
                self._setup_pyudev_monitoring()
            if trigger_action not in ON_TRIGGER_ACTIONS:
                self.py3_wrapper.log(
                    f"module {py3_module.module_full_name}: invalid action "
                    f"{trigger_action} on udev events subscription"
                )
                return False
            self.udev_consumers[subsystem].append((py3_module, trigger_action))
            self.py3_wrapper.log(
                f"module {py3_module.module_full_name} subscribed to udev events on {subsystem}"
            )
            return True
        else:
            self.py3_wrapper.log(
                f"pyudev module not installed: module {py3_module.module_full_name} "
                f"not subscribed to events on {subsystem}"
            )
            return False

    def trigger_actions(self, action, subsystem):
        """
        Refresh all modules which subscribed to the given subsystem.
        """
        resolution = datetime.now().strftime("%S")[0]
        for py3_module, trigger_action in self.udev_consumers[subsystem]:
            if trigger_action in ON_TRIGGER_ACTIONS:
                event_key = f"{subsystem}.{action}"
                occurences = self.throttle[event_key][resolution]
                # we allow at most 5 events per 10 seconds window
                if occurences >= 5:
                    self.py3_wrapper.log(
                        f"udev event {event_key}: throttled after {occurences} occurences",
                        level="warning",
                    )
                    continue
                self.py3_wrapper.log(
                    f"{event_key} udev event: refresh consumer {py3_module.module_full_name}"
                )
                sleep(0.1)
                py3_module.force_update()
                self.throttle[event_key].clear()
                self.throttle[event_key][resolution] = occurences + 1



================================================
FILE: py3status/util.py
================================================
import re
from colorsys import hsv_to_rgb, rgb_to_hsv
from math import modf


class Gradients:
    """
    Create color gradients
    """

    RE_HEX = re.compile("#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})")

    _gradients_cache = {}

    def hex_2_rgb(self, color):
        """
        convert a hex color to rgb
        """
        if not self.RE_HEX.match(color):
            color = "#FFF"
        if len(color) == 7:
            return (int(color[i : i + 2], 16) / 255 for i in [1, 3, 5])
        return (int(c, 16) / 15 for c in color)

    def rgb_2_hex(self, r, g, b):
        """
        convert a rgb color to hex
        """
        return "#{:02X}{:02X}{:02X}".format(int(r * 255), int(g * 255), int(b * 255))

    def hex_2_hsv(self, color):
        """
        convert a hex color to hsv
        """
        return rgb_to_hsv(*self.hex_2_rgb(color))

    def hsv_2_hex(self, h, s, v):
        """
        convert a hsv color to hex
        """
        return self.rgb_2_hex(*hsv_to_rgb(h, s, v))

    def make_mid_color(self, color1, color2, distance, long_route=False):
        """
        Generate a mid color between color1 and color2.
        Colors should be a tuple (hue, saturation, value).

        distance is a float between 0.0 and 1.0 describing how far between
        color1 and color2 we want to return the color. 0.0 would return color1,
        1.0 color2, and 0.5 a color midway.

        long_route allows us to choose how we get from color1 to color2 around
        the color wheel if True we go the long way, through as many colors as
        we can, if False we go through the minimum number
        """

        def fade(a, b):
            x = b * distance
            x += a * (1 - distance)
            return x

        h1, s1, v1 = color1
        h2, s2, v2 = color2

        hue_diff = h1 - h2
        if long_route:
            if -0.5 < hue_diff < 0.5:
                h1 += 1
        else:
            if hue_diff > 0.5:
                h2 += 1
            elif hue_diff < -0.5:
                h1 += 1
        return (modf(fade(h1, h2))[0], fade(s1, s2), fade(v1, v2))

    def generate_gradient(self, color_list, size=101):
        """
        Create a gradient of size colors that passes through the colors
        give in the list (the resultant list may not be exactly size long).
        The gradient will be evenly distributed.
        colors should be in hex format eg '#FF00FF'
        """
        list_length = len(color_list)
        gradient_step = size / (list_length - 1)

        gradient_data = []
        for x in range(list_length):
            gradient_data.append((int(gradient_step * x), color_list[x]))

        data = []
        for (start, color1), (end, color2) in zip(gradient_data, gradient_data[1:]):
            color1 = self.hex_2_hsv(color1)
            color2 = self.hex_2_hsv(color2)

            steps = end - start
            for j in range(steps):
                data.append(self.hsv_2_hex(*self.make_mid_color(color1, color2, j / steps)))
        data.append(self.hsv_2_hex(*color2))
        return data

    def make_threshold_gradient(self, py3, thresholds, size=100):
        """
        Given a thresholds list, creates a gradient list that covers the range
        of the thresholds.
        The number of colors in the gradient is limited by size.
        Because of how the range is split the exact number of colors in the
        gradient cannot be guaranteed.
        """
        thresholds = sorted(thresholds)
        key = f"{thresholds}|{size}"
        try:
            return self._gradients_cache[key]
        except KeyError:
            pass
        minimum = min(thresholds)[0]
        maximum = max(thresholds)[0]
        if maximum - minimum > size:
            steps_size = size / (maximum - minimum)
        else:
            steps_size = 1
        colors = []
        for thres_a, thres_b in zip(thresholds, thresholds[1:]):
            color_list = [thres_a[1], thres_b[1]]
            num_colors = int((thres_b[0] - thres_a[0]) * steps_size)
            colors.extend(self.generate_gradient(color_list, num_colors))
        # cache gradient
        self._gradients_cache[key] = colors
        return colors



================================================
FILE: py3status/version.py
================================================
version = "3.62"



================================================
FILE: py3status/modules/README.md
================================================
# Modules documentation

Up to date modules documentation: https://ultrabug.github.io/py3status/user-guide/modules



================================================
FILE: py3status/modules/__init__.py
================================================
[Empty file]


================================================
FILE: py3status/modules/air_quality.py
================================================
r"""
Display air quality polluting in a given location.

An air quality index (AQI) is a number used by government agencies to communicate
to the public how polluted the air currently is or how polluted it is forecast to
become. As the AQI increases, an increasingly large percentage of the population
is likely to experience increasingly severe adverse health effects. Different
countries have their own air quality indices, corresponding to different national
air quality standards.

Configuration parameters:
    auth_token: Personal token required. See https://aqicn.org/data-platform/token
        for more information. (default 'demo')
    cache_timeout: refresh interval for this module. A message from the site:
        The default quota is max 1000 requests per minute (~16RPS) and with
        burst up to 60 requests. See https://aqicn.org/api/ for more information.
        (default 3600)
    format: display format for this module
        (default '[\?color=aqi {city_name}: {aqi} {category}]')
    format_datetime: specify strftime characters to format (default {})
    location: location or uid to query. To search for nearby stations in Kraków,
        try `https://api.waqi.info/search/?token=YOUR_TOKEN&keyword=kraków`
        For best results, use uid instead of name in location, eg `@8691`.
        (default 'Shanghai')
    quality_thresholds: specify a list of tuples, eg (number, 'color', 'name')
        *(default [(0, '#009966', 'Good'),
            (51, '#FFDE33', 'Moderate'),
            (101, '#FF9933', 'Sensitively Unhealthy'),
            (151, '#CC0033', 'Unhealthy'),
            (201, '#660099', 'Very Unhealthy'),
            (301, '#7E0023', 'Hazardous')])*
    thresholds: specify color thresholds to use (default {'aqi': True})

Notes:
    Your station may have individual scores for pollutants not listed below.
    See https://api.waqi.info/feed/@UID/?token=TOKEN (Replace UID and TOKEN)
    for a full list of placeholders to use.

Format placeholders:
    {aqi} air quality index
    {attributions_0_name} attribution name, there maybe more, change the 0
    {attributions_0_url} attribution url, there maybe more, change the 0
    {category} health risk category, eg Good, Moderate, Unhealthy, etc
    {city_geo_0} monitoring station latitude
    {city_geo_1} monitoring station longitude
    {city_name} monitoring station name
    {city_url} monitoring station url
    {dominentpol} dominant pollutant, eg pm25
    {idx} Unique ID for the city monitoring station, eg 7396
    {time} epoch timestamp, eg 1510246800
    {time_s} local timestamp, eg 2017-11-09 17:00:00
    {time_tz} local timezone, eg -06:00
    {iaqi_co}   individual score for pollutant carbon monoxide
    {iaqi_h}    individual score for pollutant h (?)
    {iaqi_no2}  individual score for pollutant nitrogen dioxide
    {iaqi_o3}   individual score for pollutant ozone
    {iaqi_pm25} individual score for pollutant particulates
                smaller than 2.5 μm in aerodynamic diameter
    {iaqi_pm10} individual score for pollutant particulates
                smaller than 10 μm in aerodynamic diameter
    {iaqi_pm15} individual score for pollutant particulates
                smaller than than 15 μm in aerodynamic diameter
    {iaqi_p}    individual score for pollutant particulates
    {iaqi_so2}  individual score for pollutant sulfur dioxide
    {iaqi_t}    individual score for pollutant t (?)
    {iaqi_w}    individual score for pollutant w (?)

    AQI denotes an air quality index. IQAI denotes an individual AQI score.
    Try https://en.wikipedia.org/wiki/Air_pollution#Pollutants for more
    information on the pollutants retrieved from your monitoring station.

format_datetime placeholders:
    key: epoch_placeholder, eg time, vtime
    value: % strftime characters to be translated, eg '%b %d' ----> 'Nov 11'

Color options:
    color_bad: print a color for error (if any) from the site

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Examples:
```
# show last updated time
air_quality {
    format = '{city_name}: {aqi} {category} - {time}'
    format_datetime = {'time': '%-I%P'}
}
```

@author beetleman, lasers
@license BSD

SAMPLE OUTPUT
{'color':'#009966', 'full_text':'Shanghai: 49 Good'}

aqi_moderate
{'color':'#FFDE33', 'full_text':'Shanghai: 65 Moderate'}

aqi_sensitively_unhealthy
{'color':'#FF9933', 'full_text':'Shanghai: 103 Sensitively Unhealthy'}

aqi_unhealthy
{'color':'#CC0033', 'full_text':'Shanghai: 165 Unhealthy'}

aqi_very_unhealthy
{'color':'#660099', 'full_text':'Shanghai: 220 Very Unhealthy'}

aqi_hazardous
{'color':'#7E0023', 'full_text':'Shanghai: 301 Hazardous'}
"""

from datetime import datetime


class Py3status:
    """ """

    # available configuration parameters
    auth_token = "demo"
    cache_timeout = 3600
    format = r"[\?color=aqi {city_name}: {aqi} {category}]"
    format_datetime = {}
    location = "Shanghai"
    quality_thresholds = [
        (0, "#009966", "Good"),
        (51, "#FFDE33", "Moderate"),
        (101, "#FF9933", "Sensitively Unhealthy"),
        (151, "#CC0033", "Unhealthy"),
        (201, "#660099", "Very Unhealthy"),
        (301, "#7E0023", "Hazardous"),
    ]
    thresholds = {"aqi": True}

    def post_config_hook(self):
        self.auth_token = {"token": self.auth_token}
        self.url = f"https://api.waqi.info/feed/{self.location}/"
        self.init_datetimes = []
        for word in self.format_datetime:
            if (self.py3.format_contains(self.format, word)) and (word in self.format_datetime):
                self.init_datetimes.append(word)

        if isinstance(self.thresholds, dict):
            if self.thresholds.get("aqi") is True:
                aqi = [(x[0], x[1]) for x in self.quality_thresholds]
                self.thresholds["aqi"] = aqi

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def _get_aqi_data(self):
        try:
            return self.py3.request(self.url, params=self.auth_token).json()
        except self.py3.RequestException:
            return None

    def _organize(self, data):
        new_data = {}
        for k, v in self.py3.flatten_dict(data, delimiter="_").items():
            new_data["".join(k.replace("data_", "", 1).rsplit("_v", 1))] = v
        return new_data

    def _manipulate(self, data):
        for index_aqi, index_color, index_category in self.quality_thresholds:
            if data["aqi"] >= index_aqi:
                data["category"] = index_category

        for x in self.thresholds_init:
            if x in data:
                self.py3.threshold_get_color(data[x], x)

        for k in self.init_datetimes:
            if k in data:
                data[k] = self.py3.safe_format(
                    datetime.strftime(datetime.fromtimestamp(data[k]), self.format_datetime[k])
                )
        return data

    def air_quality(self):
        aqi_data = self._get_aqi_data()
        if aqi_data:
            if aqi_data.get("status") == "ok":
                aqi_data = self._organize(aqi_data)
                aqi_data = self._manipulate(aqi_data)
            elif aqi_data.get("status") == "error":
                self.py3.error(aqi_data.get("data"))

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, aqi_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/apt_updates.py
================================================
r"""
Display number of pending updates for Debian based Distros.

Thanks to Iain Tatch <iain.tatch@gmail.com> for the script that this is based on.
This will display a count of how many 'apt' updates are waiting to be installed.

Configuration parameters:
    cache_timeout: How often we refresh this module in seconds (default 600)
    format: Display format to use
        (default 'UPD[\?not_zero : {apt}]')

Format placeholders:
    {apt} Number of pending apt updates

Requires:
    apt: Needed to display pending 'apt' updates

@author Joshua Pratt <jp10010101010000@gmail.com>
@license BSD

SAMPLE OUTPUT
{'color': '#FFFF00', 'full_text': 'UPD: 5'}
"""

import subprocess

LINE_SEPARATOR = "\\n"
STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 600
    format = r"UPD[\?not_zero : {apt}]"

    def post_config_hook(self):
        if not self.py3.check_commands("apt"):
            raise Exception(STRING_NOT_INSTALLED)

    def apt_updates(self):
        apt_updates = self._check_apt_updates()

        color = self.py3.COLOR_DEGRADED
        if apt_updates == 0:
            color = self.py3.COLOR_GOOD
        full_text = self.py3.safe_format(self.format, {"apt": apt_updates})
        return {
            "color": color,
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": full_text,
        }

    def _check_apt_updates(self):
        """
        This method will use the 'checkupdates' command line utility
        to determine how many updates are waiting to be installed via
        'apt list --upgradeable'.
        """
        output = str(subprocess.check_output(["apt", "list", "--upgradeable"]))
        output = output.split(LINE_SEPARATOR)
        return len(output[1:-1])


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/arch_updates.py
================================================
"""
Display number of pending updates for Arch Linux.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 3600)
    format: display format for this module, otherwise auto (default None)
    hide_if_zero: don't show on bar if True (default False)

Format placeholders:
    {aur} Number of pending aur updates
    {pacman} Number of pending pacman updates
    {total} Total updates pending

Requires:
    pacman-contrib: contributed scripts and tools for pacman systems
    auracle: a flexible command line client for arch linux's user repository
    trizen: lightweight pacman wrapper and AUR helper
    yay: yet another yogurt. pacman wrapper and aur helper written in go
    paru: feature packed AUR helper
    pikaur: pacman wrapper and AUR helper written in python

Note:
    py3status for Arch-based distributions should include an alpm hook
    to refresh this module after packages and/or files being modified.

@author Iain Tatch <iain.tatch@gmail.com>
@license BSD

SAMPLE OUTPUT
{'full_text': 'UPD: 5'}

aur
{'full_text': 'UPD: 15/4'}
"""

STRING_NOT_INSTALLED = "{} not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 3600
    format = None
    hide_if_zero = False

    class Meta:
        deprecated = {"remove": [{"param": "include_aur", "msg": "obsolete"}]}

    def post_config_hook(self):
        helper = {
            "pacman": self.py3.check_commands(["checkupdates"]),
            "aur": self.py3.check_commands(["auracle", "trizen", "yay", "paru", "pikaur"]),
        }
        if self.format:
            placeholders = self.py3.get_placeholders_list(self.format)
            if "total" in placeholders:
                pass
            elif not any(helper.values()):
                raise Exception(STRING_NOT_INSTALLED.format("pacman, aur"))
            else:
                for name in helper:
                    if name not in placeholders:
                        helper[name] = None
                    elif not helper[name]:
                        raise Exception(STRING_NOT_INSTALLED.format(name))
        elif all(helper.values()):
            self.format = "UPD: {pacman}/{aur}"
        elif helper["pacman"]:
            self.format = "UPD: {pacman}"
        elif helper["aur"]:
            self.format = "UPD: ?/{aur}"
        else:
            raise Exception(STRING_NOT_INSTALLED.format("pacman, aur"))

        for key in helper:
            value = getattr(self, "_get_{}_updates".format(helper[key]), None)
            setattr(self, f"_get_{key}_updates", value)

    def _get_checkupdates_updates(self):
        try:
            updates = self.py3.command_output(["checkupdates"])
            return len(updates.splitlines())
        except self.py3.CommandError as ce:
            return None if ce.error else 0

    def _get_auracle_updates(self):
        try:
            updates = self.py3.command_output(["auracle", "outdated"])
            return len(updates.splitlines())
        except self.py3.CommandError as ce:
            return None if ce.error else 0

    def _get_trizen_updates(self):
        try:
            updates = self.py3.command_output(["trizen", "-Suaq"])
            return len(updates.splitlines())
        except self.py3.CommandError:
            return None

    def _get_yay_updates(self):
        try:
            updates = self.py3.command_output(["yay", "-Qua"])
            return len(updates.splitlines())
        except self.py3.CommandError as ce:
            # yay returns 1 if there are no updates.
            return 0 if ce.error_code == 1 else None

    def _get_paru_updates(self):
        try:
            updates = self.py3.command_output(["paru", "-Qua"])
            return len(updates.splitlines())
        except self.py3.CommandError as ce:
            return None if ce.error else 0

    def _get_pikaur_updates(self):
        try:
            updates = self.py3.command_output(["pikaur", "-Qua"])
            return len(updates.splitlines())
        except self.py3.CommandError as ce:
            return None if ce.error else 0

    def arch_updates(self):
        pacman, aur, total, full_text = None, None, None, ""

        if self._get_pacman_updates:
            pacman = self._get_pacman_updates()
        if self._get_aur_updates:
            aur = self._get_aur_updates()
        if pacman is not None or aur is not None:
            total = (pacman or 0) + (aur or 0)

        if not (self.hide_if_zero and not total):
            arch_data = {"aur": aur, "pacman": pacman, "total": total}
            full_text = self.py3.safe_format(self.format, arch_data)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": full_text,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/async_script.py
================================================
"""
Display output of a given script asynchronously.

Always displays the last line of output from a given script, set by
`script_path`. If a line contains only a color (/^#[0-F]{6}$/), it is used
as such (set force_nocolor to disable). The script may have parameters.

Configuration parameters:
    force_nocolor: if true, won't check if a line contains color
        (default False)
    format: see placeholders below (default '{output}')
    script_path: script you want to show output of (compulsory)
        (default None)
    strip_output: shall we strip leading and trailing spaces from output
        (default False)

Format placeholders:
    {output} output of script given by "script_path"

Examples:
```
async_script {
    format = "{output}"
    script_path = "ping 127.0.0.1"
}
```

@author frimdo ztracenastopa@centrum.cz, girst

SAMPLE OUTPUT
{'full_text': 'script output'}

example
{'full_text': '[193957.380605] wlp3s0: authenticated'}
"""

import re
import shlex
from subprocess import PIPE, Popen
from threading import Thread


class Py3status:
    """ """

    # available configuration parameters
    force_nocolor = False
    format = "{output}"
    script_path = None
    strip_output = False

    def post_config_hook(self):
        # class variables:
        self.command_thread = Thread()
        self.command_output = None
        self.command_color = None
        self.command_error = None  # cannot throw self.py3.error from thread

        if not self.script_path:
            self.py3.error("script_path is mandatory")

    def async_script(self):
        response = {}
        response["cached_until"] = self.py3.CACHE_FOREVER

        if self.command_error is not None:
            self.py3.log(self.command_error, level=self.py3.LOG_ERROR)
            self.py3.error(self.command_error, timeout=self.py3.CACHE_FOREVER)
        if not self.command_thread.is_alive():
            self.command_thread = Thread(target=self._command_start)
            self.command_thread.daemon = True
            self.command_thread.start()

        if self.command_color is not None:
            response["color"] = self.command_color

        response["full_text"] = self.py3.safe_format(self.format, {"output": self.command_output})
        return response

    def _command_start(self):
        try:
            command = Popen(shlex.split(self.script_path), stdout=PIPE)
            while True:
                if command.poll() is not None:  # script has exited/died; restart it
                    command = Popen(shlex.split(self.script_path), stdout=PIPE)

                output = command.stdout.readline().decode().strip()

                if re.search(r"^#[0-9a-fA-F]{6}$", output) and not self.force_nocolor:
                    self.command_color = output
                else:
                    if output != self.command_output:
                        self.command_output = output
                        self.py3.update()
        except Exception as e:
            self.command_error = str(e)
            self.py3.update()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status, config={"script_path": "ping 127.0.0.1"})



================================================
FILE: py3status/modules/audiosink.py
================================================
r"""
Display and toggle default audiosink.

Configuration parameters:
    cache_timeout: How often we refresh this module in seconds
        (default 10)
    display_name_mapping: dictionary mapping devices names to display names
        (default {})
    format: display format for this module
        (default '{audiosink}')
    sinks_to_ignore: list of devices names to ignore
        (default [])

Format placeholders:
    {audiosink} comma seperated list of (display) names of default sink(s)

Requires:
    pulseaudio: networked sound server

Examples:
```
audiosink {
    display_name_mapping = {"Family 17h/19h HD Audio Controller Analog Stereo": "Int", "ThinkPad Dock USB Audio Analog Stereo": "Dock"}
    format = r"{audiosink}"
    sinks_to_ignore = ["Renoir Radeon High Definition Audio Controller Digital Stereo (HDMI)"]
}
```

@author Jens Brandt <py3status@brandt-george.de>
@license BSD

SAMPLE OUTPUT
{'full_text': 'Dock'}

int
{'full_text': 'Int'}
"""

import os


class Py3status:
    # available configuration parameters
    cache_timeout = 10
    display_name_mapping = {}
    format = r"{audiosink}"
    sinks_to_ignore = []

    def _get_display_name(self, name):
        if name in self.display_name_mapping:
            return self.display_name_mapping[name]
        return name

    # returns list of (not ignored) audiosinks
    # each audiosink is given by the dictionary keys:
    # - id: pulseaudio id of the device
    # - name: device name
    # - display_name: display name as given by display_name_mapping
    # - is_active: boolean, if the device is currently the default output device
    def _get_state(self):
        # The following two commands are a very dirty way of getting the required information from the pacmd text output.
        # I'd love to see pulseaudio / pacmd support in jc, so this can be done more pretty.
        pacmd_output = (
            os.popen("pacmd list-sinks | grep -e 'device.description' -e 'index:'")
            .read()
            .split("\n")
        )
        state = [
            {
                "id": int(pacmd_output[i][-1]),
                "name": pacmd_output[i + 1].split('"')[1],
                "is_active": ("*" in pacmd_output[i]),
            }
            for i in range(0, len(pacmd_output) - 1, 2)
        ]
        # filter for not ignored (or active) devices
        state = list(
            filter(
                lambda d: (d["name"] not in self.sinks_to_ignore) or d["is_active"],
                state,
            )
        )
        for d in state:
            d["display_name"] = self._get_display_name(d["name"])
        return state

    def _to_string(self, state):
        return ", ".join([s["display_name"] for s in state if s["is_active"]])

    def _activate_input(self, input_id):
        os.popen(f"pacmd set-default-sink {input_id}")

    # activates the next devices following the first currently active device
    def _toggle(self, state):
        for i in range(len(state)):
            if state[i]["is_active"]:
                input_to_activate_index = (i + 1) % len(state)
                self._activate_input(state[input_to_activate_index]["id"])
                return

    def audiosink(self):
        composites = [
            {"full_text": self._to_string(self._get_state())},
        ]
        audiosink = self.py3.composite_create(composites)
        cached_until = self.py3.time_in(self.cache_timeout)
        return {
            "cached_until": cached_until,
            "full_text": self.py3.safe_format(self.format, {"audiosink": audiosink}),
        }

    def on_click(self, event):
        button = event["button"]
        if button == 1:
            self._toggle(self._get_state())


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/aws_bill.py
================================================
"""
Display bill for Amazon Web Services.

**WARNING: This module generate some costs on the AWS bill.
Take care about the cache_timeout to limit these fees!**

Configuration parameters:
    aws_access_key_id: Your AWS access key (default '')
    aws_account_id: The root ID of the AWS account
        Can be found here` https://console.aws.amazon.com/billing/home#/account
        (default '')
    aws_secret_access_key: Your AWS secret key (default '')
    billing_file: Csv file location (default '/tmp/.aws_billing.csv')
    cache_timeout: How often we refresh this module in seconds (default 3600)
    format: string that formats the output. See placeholders below.
        (default '{bill_amount}$')
    s3_bucket_name: The bucket where billing files are sent by AWS.
        Follow this article to activate this feature:
        https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/billing-reports.html
        (default '')

Format placeholders:
    {bill_amount} AWS bill amount

Color options:
    color_good: Balance available
    color_bad: An error has occurred

Requires:
    boto: a python interface to amazon web services (aws)

@author nawadanp

SAMPLE OUTPUT
{'full_text': u'108.78$'}
"""

import csv
import datetime
from pathlib import Path

import boto
from boto.s3.connection import Key


class Py3status:
    """ """

    # available configuration parameters
    aws_access_key_id = ""
    aws_account_id = ""
    aws_secret_access_key = ""
    billing_file = "/tmp/.aws_billing.csv"
    cache_timeout = 3600
    format = "{bill_amount}$"
    s3_bucket_name = ""

    def _get_bill_amount(self):
        # Billing file name, generated by Amazon itself
        # Format : 123456789012-aws-billing-csv-yyyy-mm.csv
        s3_file_key = "{}-aws-billing-csv-{}-{}.csv".format(
            self.aws_account_id,
            datetime.datetime.now().strftime("%Y"),
            datetime.datetime.now().strftime("%m"),
        )
        i = 0

        # Connection to s3 service
        try:
            conn = boto.connect_s3(self.aws_access_key_id, self.aws_secret_access_key)
        except:  # noqa e722
            return "conn_error"

        # Connection to the bucket
        try:
            bucket = conn.get_bucket(self.s3_bucket_name)
        except:  # noqa e722
            return "bucket_error"

        # Fetch the objects keys and get the billing file
        try:
            k = Key(bucket)
            k.key = s3_file_key
            k.get_contents_to_filename(self.billing_file)
            k.close
        except:  # noqa e722
            return "key_error"

        # Parse the file and get the InvoiceTotal amount
        try:
            with Path(self.billing_file).open("rb") as f:
                reader = csv.reader(f)
                for row in reader:
                    if "".join(row).find("InvoiceTotal") == -1:
                        continue
                    i = i + 1
                    return row[-1]
        except:  # noqa e722
            return "csv_error"

        return False

    def aws_bill(self):
        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": self.py3.COLOR_BAD,
            "full_text": "",
        }

        bill_amount = self._get_bill_amount()

        if bill_amount == "csv_error":
            response["full_text"] = "Bad CSV file"
        elif bill_amount == "key_error":
            response["full_text"] = "Key not found in the bucket"
        elif bill_amount == "bucket_error":
            response["full_text"] = "Check the bucket name or your AWS keys"
        elif bill_amount == "conn_error":
            response["full_text"] = "Check your internet access"
        elif bill_amount is not False:
            response["full_text"] = self.py3.safe_format(self.format, {"bill_amount": bill_amount})
            response["color"] = self.py3.COLOR_GOOD
        else:
            response["full_text"] = "Global error - WTF exception"

        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/backlight.py
================================================
"""
Adjust screen backlight brightness.

Configuration parameters:
    brightness_delta: Change the brightness by this step.
        (default 8)
    brightness_initial: Set brightness to this value on start.
        (default None)
    brightness_minimal: Don't go below this brightness to avoid black screen
        (default 1)
    button_down: Button to click to decrease brightness. Setting to 0 disables.
        (default 5)
    button_up: Button to click to increase brightness. Setting to 0 disables.
        (default 4)
    cache_timeout: How often we refresh this module in seconds (default 10)
    command: The program to use to change the backlight.
        Currently xbacklight, light and brightnessctl are supported. The program needs
        to be installed and on your path. If no program is installed, this
        module will attempt to use logind support instead
        (default 'xbacklight')
    device: Device name or full path to use, eg, acpi_video0 or
        /sys/class/backlight/acpi_video0, otherwise automatic
        (default None)
    format: Display brightness, see placeholders below
        (default '☼: {level}%')
    hide_when_unavailable: Hide if no backlight is found
        (default False)
    low_tune_threshold: If current brightness value is below this threshold,
        the value is changed by a minimal value instead of the brightness_delta.
        (default 0)

Format placeholders:
    {level} brightness

Requires: one of
    xbacklight: need for changing brightness, not detection
    light: program to easily change brightness on backlight-controllers
    brightnessctl: change brightness wayland compatible
    dbus-python + logind v243: logind to change brightness without X

@author Tjaart van der Walt (github:tjaartvdwalt), Jérémy Rosen (github:boucman)
@license BSD

SAMPLE OUTPUT
{'full_text': u'\u263c: 100%'}
"""

from pathlib import Path

import dbus

STRING_NOT_AVAILABLE = "no available device"


def get_device():
    for path in Path("/sys/class/backlight").rglob("*"):
        if path.is_dir():
            children = {child.name for child in path.iterdir()}
            if children >= {"brightness", "max_brightness"}:
                return path


commands = {
    "xbacklight": {
        "get": lambda: ["xbacklight", "-get"],
        "get_percent": True,
        "set": lambda level: ["xbacklight", "-time", "0", "-set", str(level)],
    },
    "light": {
        "get": lambda: ["light", "-G"],
        "get_percent": True,
        "set": lambda level: ["light", "-S", str(level)],
    },
    "brightnessctl": {
        "get": lambda: ["brightnessctl", "g"],
        "get_percent": False,
        "set": lambda level: ["brightnessctl", "s", str(level) + "%"],
    },
}


class Py3status:
    """ """

    # available configuration parameters
    brightness_delta = 8
    brightness_initial = None
    brightness_minimal = 1
    button_down = 5
    button_up = 4
    cache_timeout = 10
    command = "xbacklight"
    device = None
    format = "☼: {level}%"
    hide_when_unavailable = False
    low_tune_threshold = 0

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "device_path",
                    "new": "device",
                    "msg": "obsolete parameter use `device`",
                }
            ]
        }

    def post_config_hook(self):
        try:
            bus = dbus.SystemBus()
            self._logind_proxy = bus.get_object(
                "org.freedesktop.login1", "/org/freedesktop/login1/session/self"
            )
        except NameError:
            self._logind_proxy = None

        if not self.device:
            self.device = get_device()
        elif "/" not in self.device:
            self.device = f"/sys/class/backlight/{self.device}"
        if self.device is None:
            if self.hide_when_unavailable:
                return
            else:
                raise Exception(STRING_NOT_AVAILABLE)

        self.format = self.py3.update_placeholder_formats(self.format, {"level": ":.0f"})
        # check for an error code and an output
        self.command_available = False
        try:
            output = self.py3.command_output(self._command_get())
            try:
                float(output)
                self.command_available = True
            except ValueError:
                pass
        except self.py3.CommandError:
            pass

        if self.brightness_initial:
            self._set_backlight_level(self.brightness_initial)

    def on_click(self, event):
        level = self._get_backlight_level()
        button = event["button"]
        if button == self.button_up:
            delta = self.brightness_delta if level >= self.low_tune_threshold else 1
            level += delta
            if level > 100:
                level = 100
            self._set_backlight_level(level)
        elif button == self.button_down:
            delta = self.brightness_delta if level > self.low_tune_threshold else 1
            level -= delta
            if level < self.brightness_minimal:
                level = self.brightness_minimal
            self._set_backlight_level(level)

    def _set_backlight_level(self, level):
        if self.command_available:
            self.py3.command_run(self._command_set(level))
            return
        if self._logind_proxy:
            brightness_max = int(Path(f"{self.device}/max_brightness").read_text())
            brightness = brightness_max * level / 100
            self._logind_proxy.SetBrightness("backlight", self.device.name, brightness)

    def _get_backlight_level(self):
        if self.command_available:
            brightness = float(self.py3.command_output(self._command_get()))
        else:
            brightness = int(Path(f"{self.device}/brightness").read_text())

        if not self.command_available or (not commands[self.command]["get_percent"]):
            brightness_max = int(Path(f"{self.device}/max_brightness").read_text())
            return brightness * 100 / brightness_max
        else:
            return brightness

    # Returns the string array for the command to get the current backlight level
    def _command_get(self):
        return commands[self.command]["get"]()

    # Returns the string array for the command to set the current backlight level
    def _command_set(self, level):
        return commands[self.command]["set"](level)

    def backlight(self):
        full_text = ""
        if self.device is not None:
            level = self._get_backlight_level()
            full_text = self.py3.safe_format(self.format, {"level": level})

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": full_text,
        }
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/battery_level.py
================================================
"""
Display battery information.

Configuration parameters:
    battery_id: id of the battery to be displayed
        set to 'all' for combined display of all batteries
        (default 0)
    blocks: a string, where each character represents battery level
        especially useful when using icon fonts (e.g. FontAwesome)
        (default "_▁▂▃▄▅▆▇█")
    cache_timeout: a timeout to refresh the battery state
        (default 60)
    charging_character: a character to represent charging battery
        especially useful when using icon fonts (e.g. FontAwesome)
        set to 'None' if you want to hide the charging state of your battery
        (default "⚡")
    format: string that formats the output. See placeholders below.
        (default "{icon}")
    format_notify_charging: format of the notification received when you click
        on the module while your computer is plugged in
        (default 'Charging ({percent}%)')
    format_notify_discharging: format of the notification received when you
        click on the module while your computer is not plugged in
        (default "{time_remaining}")
    format_status_bad: a string to put in {status} when bad
        (default "CRIT")
    format_status_charging: a string to put in {status} when charging
        (default "CHG")
    format_status_degraded: a string to put in {status} when degraded
        (default "LOW")
    format_status_discharging: a string to put in {status} when discharging
        (default "BAT")
    format_status_full: a string to put in {status} when full
        (default "FULL")
    hide_seconds: hide seconds in remaining time
        (default False)
    hide_when_full: hide any information when battery is fully charged (when
        the battery level is greater than or equal to 'threshold_full')
        (default False)
    measurement_mode: either 'acpi' or 'sys', or None to autodetect. 'sys'
        should be more robust and does not have any extra requirements, however
        the time measurement may not work in some cases
        (default None)
    notification: show current battery state as notification on click
        (default False)
    notify_low_level: display notification when battery is running low (when
        the battery level is less than 'threshold_degraded')
        (default False)
    on_udev_power_supply: dynamic variable to watch for `power_supply` udev subsystem
        events to trigger specified action.
        (default "refresh")
    sys_battery_path: set the path to your battery(ies), without including its
        number
        (default "/sys/class/power_supply/")
    threshold_bad: a percentage below which the battery level should be
        considered bad
        (default 10)
    threshold_degraded: a percentage below which the battery level should be
        considered degraded
        (default 30)
    threshold_full: a percentage at or above which the battery level should
        should be considered full
        (default 100)

Format placeholders:
    {ascii_bar} - a string of ascii characters representing the battery level,
        an alternative visualization to '{icon}' option
    {icon} - a character representing the battery level,
        as defined by the 'blocks' and 'charging_character' parameters
    {percent} - the remaining battery percentage (previously '{}')
    {time_remaining} - the remaining time until the battery is empty
    {power} - the current power consumption in Watts. Not working with acpi.
    {status} - the current battery status string as defined by 'format_status_*'

Color options:
    color_bad: Battery level is below threshold_bad
    color_charging: Battery is charging (default "#FCE94F")
    color_degraded: Battery level is below threshold_degraded
    color_good: Battery level is above thresholds

Requires:
    - the `acpi` the acpi command line utility (only if
        `measurement_mode='acpi'`)

@author shadowprince, AdamBSteele, maximbaz, 4iar, m45t3r
@license Eclipse Public License

SAMPLE OUTPUT
{'color': '#FCE94F', 'full_text': u'\u26a1'}

discharging
{'color': '#FF0000', 'full_text': u'\u2340'}
"""

import itertools
import math
from pathlib import Path
from re import findall

BLOCKS = "_▁▂▃▄▅▆▇█"
CHARGING_CHARACTER = "⚡"
EMPTY_BLOCK_CHARGING = "|"
EMPTY_BLOCK_DISCHARGING = "⍀"
FULL_BLOCK = "█"
FORMAT = "{icon}"
FORMAT_NOTIFY_CHARGING = "Charging ({percent}%)"
FORMAT_NOTIFY_DISCHARGING = "{time_remaining}"
FORMAT_STATUS_BAD = "CRIT"
FORMAT_STATUS_CHARGING = "CHG"
FORMAT_STATUS_DEGRADED = "LOW"
FORMAT_STATUS_DISCHARGING = "BAT"
FORMAT_STATUS_FULL = "FULL"
SYS_BATTERY_PATH = "/sys/class/power_supply/"
MEASUREMENT_MODE = None
FULLY_CHARGED = "?"


class Py3status:
    """"""

    # available configuration parameters
    battery_id = 0
    blocks = BLOCKS
    cache_timeout = 60
    charging_character = CHARGING_CHARACTER
    format = FORMAT
    format_notify_charging = FORMAT_NOTIFY_CHARGING
    format_notify_discharging = FORMAT_NOTIFY_DISCHARGING
    format_status_bad = FORMAT_STATUS_BAD
    format_status_charging = FORMAT_STATUS_CHARGING
    format_status_degraded = FORMAT_STATUS_DEGRADED
    format_status_discharging = FORMAT_STATUS_DISCHARGING
    format_status_full = FORMAT_STATUS_FULL
    hide_seconds = False
    hide_when_full = False
    measurement_mode = MEASUREMENT_MODE
    notification = False
    notify_low_level = False
    on_udev_power_supply = "refresh"
    sys_battery_path = SYS_BATTERY_PATH
    threshold_bad = 10
    threshold_degraded = 30
    threshold_full = 100

    class Meta:
        deprecated = {
            "format_fix_unnamed_param": [
                {
                    "param": "format",
                    "placeholder": "percent",
                    "msg": "{} should not be used in format use `{percent}`",
                }
            ],
            "substitute_by_value": [
                {
                    "param": "mode",
                    "value": "ascii_bar",
                    "substitute": {"param": "format", "value": "{ascii_bar}"},
                    "msg": 'obsolete parameter use `format = "{ascii_bar}"`',
                },
                {
                    "param": "mode",
                    "value": "text",
                    "substitute": {"param": "format", "value": "Battery: {percent}"},
                    "msg": 'obsolete parameter use `format = "{percent}"`',
                },
                {
                    "param": "show_percent_with_blocks",
                    "value": True,
                    "substitute": {"param": "format", "value": "{icon} {percent}%"},
                    "msg": 'obsolete parameter use `format = "{icon} {percent}%"`',
                },
            ],
        }

    def post_config_hook(self):
        self.last_known_status = ""
        # Guess mode if not set
        if self.measurement_mode is None:
            if Path(self.sys_battery_path).is_dir():
                self.measurement_mode = "sys"
            elif self.py3.check_commands(["acpi"]):
                self.measurement_mode = "acpi"

        msg = f"measurement_mode `{self.measurement_mode}`"
        if self.measurement_mode == "sys":
            self.get_battery_info = self._extract_battery_info_from_sys
        elif self.measurement_mode == "acpi":
            self.get_battery_info = self._extract_battery_info_from_acpi
        else:
            raise NameError(f"invalid {msg}")
        self.py3.log(f"selected {msg}")

    def battery_level(self):
        battery_list = self.get_battery_info()
        if not battery_list:
            return {
                "full_text": "",
                "cached_until": self.py3.time_in(self.cache_timeout),
            }

        self._refresh_battery_info(battery_list)
        self._update_icon()
        self._update_ascii_bar()
        self._update_status()
        self._update_full_text()

        return self._build_response()

    def on_click(self, event):
        """
        Display a notification following the specified format
        """
        if not self.notification:
            return

        if self.charging:
            format = self.format_notify_charging
        else:
            format = self.format_notify_discharging

        message = self.py3.safe_format(
            format,
            dict(
                ascii_bar=self.ascii_bar,
                icon=self.icon,
                percent=self.percent_charged,
                time_remaining=self.time_remaining,
            ),
        )

        if message:
            self.py3.notify_user(message, "info")

    def _extract_battery_info_from_acpi(self):
        """
        Get the battery info from acpi

        # Example acpi -bi raw output (Discharging):
        Battery 0: Discharging, 94%, 09:23:28 remaining
        Battery 0: design capacity 5703 mAh, last full capacity 5283 mAh = 92%
        Battery 1: Unknown, 98%
        Battery 1: design capacity 1880 mAh, last full capacity 1370 mAh = 72%

        # Example Charging
        Battery 0: Charging, 96%, 00:20:40 until charged
        Battery 0: design capacity 5566 mAh, last full capacity 5156 mAh = 92%
        Battery 1: Unknown, 98%
        Battery 1: design capacity 1879 mAh, last full capacity 1370 mAh = 72%
        """

        def _parse_battery_info(acpi_battery_lines):
            battery = {}
            battery["percent_charged"] = int(findall(r"(?<= )(\d+)(?=%)", acpi_battery_lines[0])[0])
            battery["charging"] = "Charging" in acpi_battery_lines[0]
            battery["capacity"] = int(findall(r"(?<= )(\d+)(?= mAh)", acpi_battery_lines[1])[1])

            # ACPI only shows time remaining if battery is discharging or
            # charging
            try:
                battery["time_remaining"] = "".join(
                    findall(
                        r"(?<=, )(\d+:\d+:\d+)(?= remaining)|" r"(?<=, )(\d+:\d+:\d+)(?= until)",
                        acpi_battery_lines[0],
                    )[0]
                )
            except IndexError:
                battery["time_remaining"] = FULLY_CHARGED

            # TODO: Not implemented yet
            battery["power"] = 0.0

            return battery

        acpi_list = self.py3.command_output(["acpi", "-b", "-i"]).splitlines()

        # Separate the output because each pair of lines corresponds to a
        # single battery.  Now the list index will correspond to the index of
        # the battery we want to look at
        temporary = {}
        for line in acpi_list:
            number = line.split(":", 1)[0].strip("Battery ")
            temporary.setdefault(number, []).append(line)

        new_acpi = {}
        for k, v in temporary.items():
            if "rate information unavailable" not in "|".join(v):
                new_acpi[k] = v

        return [_parse_battery_info(battery) for battery in new_acpi.values()]

    def _extract_battery_info_from_sys(self):
        """
        Extract the percent charged, charging state, time remaining,
        and capacity for a battery, using Linux's kernel /sys interface

        Only available in kernel 2.6.24(?) and newer. Before kernel provided
        a similar, yet incompatible interface in /proc
        """

        if not any(Path(self.sys_battery_path).iterdir()):
            return []

        def _parse_battery_info(sys_path):
            """
            Extract battery information from uevent file, already convert to
            int if necessary
            """
            raw_values = {}
            with (sys_path / "uevent").open() as f:
                for var in f.read().splitlines():
                    k, v = var.split("=")
                    try:
                        raw_values[k] = int(v)
                    except ValueError:
                        raw_values[k] = v
            return raw_values

        battery_list = []

        bglobs = ["BAT*", "*bat*"]
        path_its = itertools.chain(*[Path(self.sys_battery_path).glob(bglob) for bglob in bglobs])

        for path in path_its:
            r = _parse_battery_info(path)

            if not r:
                continue

            capacity = r.get("POWER_SUPPLY_ENERGY_FULL", r.get("POWER_SUPPLY_CHARGE_FULL"))
            present_rate = r.get(
                "POWER_SUPPLY_POWER_NOW",
                r.get("POWER_SUPPLY_CURRENT_NOW", r.get("POWER_SUPPLY_VOLTAGE_NOW")),
            )
            remaining_energy = r.get("POWER_SUPPLY_ENERGY_NOW", r.get("POWER_SUPPLY_CHARGE_NOW"))
            current_now = r.get("POWER_SUPPLY_CURRENT_NOW", r.get("POWER_SUPPLY_POWER_NOW", 0))
            voltage_now = r.get("POWER_SUPPLY_VOLTAGE_NOW", 0)

            # missing values may indicate this is not a battery and should be skipped
            if (
                capacity is None
                or present_rate is None
                or remaining_energy is None
                or current_now is None
                or voltage_now is None
            ):
                continue

            battery = {}
            battery["capacity"] = capacity
            battery["charging"] = "Charging" in r["POWER_SUPPLY_STATUS"]
            battery["percent_charged"] = math.floor(remaining_energy / capacity * 100)
            if present_rate == 0:
                # Battery is either full charged or is not discharging
                battery["time_remaining"] = FULLY_CHARGED
            else:
                if battery["charging"]:
                    time_in_secs = (capacity - remaining_energy) / present_rate * 3600
                else:
                    time_in_secs = remaining_energy / present_rate * 3600
                battery["time_remaining"] = self._seconds_to_hms(time_in_secs)

            battery["power"] = current_now * voltage_now / 10**12

            battery_list.append(battery)
        return battery_list

    def _hms_to_seconds(self, t):
        h, m, s = [int(i) for i in t.split(":")]
        return 3600 * h + 60 * m + s

    def _seconds_to_hms(self, secs):
        m, s = divmod(secs, 60)
        h, m = divmod(m, 60)
        return f"{int(h):2d}:{int(m):02d}:{int(s):02d}"

    def _refresh_battery_info(self, battery_list):
        if isinstance(self.battery_id, int):
            battery = battery_list[self.battery_id]
            self.percent_charged = battery["percent_charged"]
            self.charging = battery["charging"]
            self.time_remaining = battery["time_remaining"]
            self.power_now = battery["power"]

        elif self.battery_id == "all":
            total_capacity = sum(battery["capacity"] for battery in battery_list)

            # Average and weigh % charged by the capacities of the batteries so
            # that self.percent_charged properly represents batteries that have
            # different capacities.
            self.percent_charged = int(
                sum(
                    battery["capacity"] / total_capacity * battery["percent_charged"]
                    for battery in battery_list
                )
            )

            self.charging = any(battery["charging"] for battery in battery_list)

            # Assumes a system has at max two batteries
            active_battery = None
            inactive_battery = battery_list[:]
            for battery_id, battery in enumerate(battery_list):
                if battery["time_remaining"] and battery["time_remaining"] != FULLY_CHARGED:
                    active_battery = battery
                    del inactive_battery[battery_id]

            # Only one battery will be discharging or charging at a time.
            # Therefore, ACPI does not provide a time remaining value for the
            # other battery.  So the time remaining for the other battery is
            # calculated using the time remaining of the first battery and the
            # capacity values for both batteries.
            if active_battery and inactive_battery:
                inactive_battery = inactive_battery[0]

                time_remaining_seconds = self._hms_to_seconds(active_battery["time_remaining"])
                try:
                    rate_second_per_mah = time_remaining_seconds / (
                        active_battery["capacity"] * (active_battery["percent_charged"] / 100)
                    )
                    time_remaining_seconds += (
                        inactive_battery["capacity"]
                        * inactive_battery["percent_charged"]
                        / 100
                        * rate_second_per_mah
                    )
                except ZeroDivisionError:
                    # Either active or inactive battery has 0% charge
                    time_remaining_seconds = 0
                    rate_second_per_mah = 0

                self.time_remaining = self._seconds_to_hms(time_remaining_seconds)

            elif active_battery:
                self.time_remaining = active_battery["time_remaining"]

            else:
                self.time_remaining = None

            self.power_now = sum(battery["power"] for battery in battery_list)

        if self.time_remaining and self.hide_seconds:
            self.time_remaining = self.time_remaining[:-3]

    def _update_ascii_bar(self):
        self.ascii_bar = FULL_BLOCK * int(self.percent_charged / 10)
        if self.charging:
            self.ascii_bar += EMPTY_BLOCK_CHARGING * (10 - self.percent_charged // 10)
        else:
            self.ascii_bar += EMPTY_BLOCK_DISCHARGING * (10 - self.percent_charged // 10)

    def _update_status(self):
        if self.charging:
            self.status = self.format_status_charging
        elif self.percent_charged < self.threshold_bad:
            self.status = self.format_status_bad
        elif self.percent_charged < self.threshold_degraded:
            self.status = self.format_status_degraded
        elif self.percent_charged >= self.threshold_full:
            self.status = self.format_status_full
        else:
            self.status = self.format_status_discharging

    def _update_icon(self):
        if self.charging and self.charging_character is not None:
            self.icon = self.charging_character
        else:
            self.icon = self.blocks[
                min(
                    len(self.blocks) - 1,
                    int(math.ceil(self.percent_charged / 100 * (len(self.blocks) - 1))),
                )
            ]

    def _update_full_text(self):
        self.full_text = self.py3.safe_format(
            self.format,
            dict(
                ascii_bar=self.ascii_bar,
                icon=self.icon,
                percent=self.percent_charged,
                time_remaining=self.time_remaining,
                power=self.power_now,
                status=self.status,
            ),
        )

    def _build_response(self):
        self.response = {}

        self._set_bar_text()
        self._set_bar_color()
        self._set_cache_timeout()

        return self.response

    def _set_bar_text(self):
        self.response["full_text"] = (
            ""
            if self.hide_when_full and self.percent_charged >= self.threshold_full
            else self.full_text
        )

    def _set_bar_color(self):
        notify_msg = None
        if self.charging:
            self.response["color"] = self.py3.COLOR_CHARGING or "#FCE94F"
            battery_status = "charging"
        elif self.percent_charged < self.threshold_bad:
            self.response["color"] = self.py3.COLOR_BAD
            battery_status = "bad"
            notify_msg = {
                "msg": "Battery level is critically low ({}%)",
                "level": "error",
            }
        elif self.percent_charged < self.threshold_degraded:
            self.response["color"] = self.py3.COLOR_DEGRADED
            battery_status = "degraded"
            notify_msg = {
                "msg": "Battery level is running low ({}%)",
                "level": "warning",
            }
        elif self.percent_charged >= self.threshold_full:
            self.response["color"] = self.py3.COLOR_GOOD
            battery_status = "full"
        else:
            battery_status = "good"

        if notify_msg and self.notify_low_level and self.last_known_status != battery_status:
            self.py3.notify_user(
                notify_msg["msg"].format(self.percent_charged), notify_msg["level"]
            )

        self.last_known_status = battery_status

    def _set_cache_timeout(self):
        self.response["cached_until"] = self.py3.time_in(self.cache_timeout)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/bluetooth.py
================================================
r"""
Display bluetooth status.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default "{format_adapter}")
    format_adapter: display format for adapters (default "{format_device}")
    format_adapter_separator: show separator if more than one (default " ")
    format_device: display format for devices
        (default "\?if=connected&color=connected {alias}")
    format_device_separator: show separator if more than one (default " ")
    thresholds: specify color thresholds to use
        (default [(False, "bad"), (True, "good")])

Format placeholders:
    {format_adapter}      format for adapters
    {adapter}             number of adapters, eg 1

format_adapter placeholders:
    {format_device}       format for devices
    {device}              number of devices, eg 5
    {address}             eg, 00:00:00:00:00:00
    {addresstype}         eg, public
    {alias}               eg, thinkpad
    {class}               eg, 123456
    {discoverable}        eg, False
    {discoverabletimeout} eg, 0
    {discovering}         eg, False
    {modalias}            eg, usb:v1D68234ABCDEF5
    {name}                eg, z420
    {pairable}            eg, True
    {pairabletimeout}     eg, 0
    {path}                eg, /org/bluez/hci0
    {powered}             eg, True
    {uuids}               eg, []

format_device placeholders:
    {adapter}          eg, /org/bluez/hci0
    {address}          eg, 00:00:00:00:00:00
    {addresstype}      eg, public
    {alias}            eg, MSFT Mouse
    {battery}          eg, 95
    {class}            eg, 1234
    {connected}        eg, False
    {icon}             eg, input-mouse
    {legacypairing}    eg, False
    {modalias}         eg, usb:v1D68234ABCDEF5
    {name}             eg, Microsoft Bluetooth Notebook Mouse 5000
    {paired}           eg, True
    {servicesresolved} eg, False
    {trusted}          eg, True
    {uuids}            eg, []

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    pygobject: Python bindings for GObject Introspection

Examples:
```
# always display devices
bluetooth {
    format_device = "\?color=connected {alias}"
}

# set an alias via blueman-manager or bluetoothctl
# $ bluetoothctl
# [bluetooth] # devices
# [bluetooth] # connect 00:00:00:00:00:00
# [bluetooth] # set-alias "MSFT Mouse"

# display missing adapter (feat. request)
bluetooth {
    format = "\?if=adapter {format_adapter}|\?color=darkgray No Adapter"
}

# legacy default
bluetooth {
    format = "\?color=good BT: {format_adapter}|\?color=bad BT"
    format_device_separator = "\|"
}
```

@author jmdana, lasers
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'Microsoft Bluetooth Notebook Mouse 5000'}
"""

from gi.repository import Gio, GLib


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{format_adapter}"
    format_adapter = "{format_device}"
    format_adapter_separator = " "
    format_device = r"\?if=connected&color=connected {alias}"
    format_device_separator = " "
    thresholds = [(False, "bad"), (True, "good")]

    def post_config_hook(self):
        self._dbus_init()
        self.names_and_matches = [
            ("adapters", "org.bluez.Adapter1"),
            ("devices", "org.bluez.Device1"),
        ]

        self.thresholds_init = {}
        for name in ["format", "format_adapter", "format_device"]:
            self.thresholds_init[name] = self.py3.get_color_names_list(getattr(self, name))

    def _dbus_init(self):
        bus = Gio.bus_get_sync(Gio.BusType.SYSTEM, None)
        iface = "org.freedesktop.DBus.ObjectManager"
        self.bluez_manager = Gio.DBusProxy.new_sync(
            bus, Gio.DBusProxyFlags.NONE, None, "org.bluez", "/", iface, None
        )

    def _get_bluez_data(self):
        try:
            objects = self.bluez_manager.GetManagedObjects()
        except GLib.Error as err:
            if err.matches(Gio.dbus_error_quark(), Gio.DBusError.SERVICE_UNKNOWN):
                self._dbus_init()
                objects = self.bluez_manager.GetManagedObjects()
            else:
                raise

        temporary = {}

        for path, interfaces in sorted(objects.items()):
            interface_keys = interfaces.keys()
            for name, match in self.names_and_matches:
                if match in interface_keys:
                    interface = {k.lower(): v for k, v in interfaces[match].items()}
                    battery = interfaces.get("org.bluez.Battery1", {}).get("Percentage")
                    interface.update({"path": path, "uuids": [], "battery": battery})
                    temporary.setdefault(name, []).append(interface)
                    break

        for device in temporary.pop("devices", []):
            for index, adapter in enumerate(temporary["adapters"]):
                if device["adapter"] == adapter["path"]:
                    temporary["adapters"][index].setdefault("devices", []).append(device)
                    break

        return temporary

    def bluetooth(self):
        bluez_data = self._get_bluez_data()
        adapters = bluez_data.pop("adapters", [])
        new_adapter = []

        for adapter in adapters:
            devices = adapter.pop("devices", [])
            new_device = []

            for device in devices:
                for x in self.thresholds_init["format_device"]:
                    if x in device:
                        self.py3.threshold_get_color(device[x], x)

                new_device.append(self.py3.safe_format(self.format_device, device))

            format_device_separator = self.py3.safe_format(self.format_device_separator)
            format_device = self.py3.composite_join(format_device_separator, new_device)

            adapter.update({"format_device": format_device, "device": len(devices)})

            for x in self.thresholds_init["format_adapter"]:
                if x in adapter:
                    self.py3.threshold_get_color(adapter[x], x)

            new_adapter.append(self.py3.safe_format(self.format_adapter, adapter))

        format_adapter_separator = self.py3.safe_format(self.format_adapter_separator)
        format_adapter = self.py3.composite_join(format_adapter_separator, new_adapter)

        bluetooth_data = {"format_adapter": format_adapter, "adapter": len(adapters)}

        for x in self.thresholds_init["format"]:
            if x in bluetooth_data:
                self.py3.threshold_get_color(bluetooth_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, bluetooth_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/check_tcp.py
================================================
"""
Display status of a TCP port on a given host.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default '{host}:{port} {state}')
    host: name of host to check for (default 'localhost')
    icon_off: show this when unavailable (default 'DOWN')
    icon_on: show this when available (default 'UP')
    port: number of port to check for (default 22)

Format placeholders:
    {state} port state

Color options:
    color_down: Closed, default to color_bad
    color_up: Open, default to color_good

@author obb, Moritz Lüdecke

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'localhost:22 UP'}

down
{'color': '#FF0000', 'full_text': u'localhost:22 DOWN'}
"""

import socket


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{host}:{port} {state}"
    host = "localhost"
    icon_off = "DOWN"
    icon_on = "UP"
    port = 22

    def post_config_hook(self):
        self.color_on = self.py3.COLOR_UP or self.py3.COLOR_GOOD
        self.color_off = self.py3.COLOR_DOWN or self.py3.COLOR_BAD

    def check_tcp(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            result = sock.connect_ex((self.host, self.port))
        except socket.gaierror:
            sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
            result = sock.connect_ex((self.host, self.port))

        if result:
            color = self.color_off
            state = self.icon_off
        else:
            color = self.color_on
            state = self.icon_on

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"state": state}),
            "color": color,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/clock.py
================================================
"""
Display date and time.

This module allows one or more datetimes to be displayed.
All datetimes share the same format_time but can set their own timezones.
Timezones are defined in the `format` using the TZ name in squiggly brackets eg
`{GMT}`, `{Portugal}`, `{Europe/Paris}`, `{America/Argentina/Buenos_Aires}`.

See https://docs.python.org/3/library/zoneinfo.html for supported formats.

`{Local}` can be used for the local settings of your computer.

Note: Timezones are case sensitive!

A full list of timezones can be found at
https://en.wikipedia.org/wiki/List_of_tz_database_time_zones

Configuration parameters:
    block_hours: length of time period for all blocks in hours (default 12)
    blocks: a string, where each character represents time period
        from the start of a time period.
        (default '🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦')
    button_change_format: button that switches format used setting to None
        disables (default 1)
    button_change_time_format: button that switches format_time used. Setting
        to None disables (default 2)
    button_reset: button that switches display to the first timezone. Setting
        to None disables (default 3)
    cycle: If more than one display then how many seconds between changing the
        display (default 0)
    format: defines the timezones displayed. This can be a single string or a
        list.  If a list is supplied then the formats can be cycled through
        using `cycle` or by button click.  (default '{Local}')
    format_time: format to use for the time, strftime directives such as `%H`
        can be used this can be either a string or to allow multiple formats as
        a list.  The one used can be changed by button click.
        *(default ['[{name_unclear} ]%c', '[{name_unclear} ]%x %X',
        '[{name_unclear} ]%a %H:%M', '[{name_unclear} ]{icon}'])*
    locale: Override the system locale. Examples:
        when set to 'fr_FR' %a on Tuesday is 'mar.'.
        (default None)
    round_to_nearest_block: defines how a block icon is chosen. Examples:
        when set to True,  '13:14' is '🕐', '13:16' is '🕜' and '13:31' is '🕜';
        when set to False, '13:14' is '🕐', '13:16' is '🕐' and '13:31' is '🕜'.
        (default True)

Format placeholders:
    {icon} a character representing the time from `blocks`
    {name} friendly timezone name eg `Buenos Aires`
    {name_unclear} friendly timezone name eg `Buenos Aires` but is empty if
        only one timezone is provided
    {timezone} full timezone name eg `America/Argentina/Buenos_Aires`
    {timezone_unclear} full timezone name eg `America/Argentina/Buenos_Aires`
        but is empty if only one timezone is provided

Examples:
```
# cycling through London, Warsaw, Tokyo
clock {
    cycle = 30
    format = ["{Europe/London}", "{Europe/Warsaw}", "{Asia/Tokyo}"]
    format_time = "{name} %H:%M"
}

# Show the time and date in New York
clock {
   format = "Big Apple {America/New_York}"
   format_time = "%Y-%m-%d %H:%M:%S"
}

# wall clocks
clock {
    format = "{Asia/Calcutta} {Africa/Nairobi} {Asia/Bangkok}"
    format_time = "{name} {icon}"
}
```

@author tobes ultrabug
@license BSD

SAMPLE OUTPUT
{'full_text': 'Sun 15 Jan 2017 23:27:17 GMT'}

london
{'full_text': 'Thursday Feb 23 1:42 AM London'}
"""

import locale
import re
import time
from datetime import datetime

try:
    import zoneinfo
# Fall back for python 3.7 and python 3.8
except ImportError:
    from backports import zoneinfo

CLOCK_BLOCKS = "🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦"


class Py3status:
    """ """

    # available configuration parameters
    block_hours = 12
    blocks = CLOCK_BLOCKS
    button_change_format = 1
    button_change_time_format = 2
    button_reset = 3
    cycle = 0
    format = "{Local}"
    format_time = [
        "[{name_unclear} ]%c",
        "[{name_unclear} ]%x %X",
        "[{name_unclear} ]%a %H:%M",
        "[{name_unclear} ]{icon}",
    ]
    locale = None
    round_to_nearest_block = True

    def post_config_hook(self):
        if self.locale is not None:
            locale.setlocale(locale.LC_TIME, self.locale)

        # Multiple clocks are possible that can be cycled through
        if not isinstance(self.format, list):
            self.format = [self.format]
        # if only one item we don't need to cycle
        if len(self.format) == 1:
            self.cycle = 0
        # find any declared timezones eg {Europe/London}
        self._fmts = set()
        for fmt in self.format:
            self._fmts.update(self.py3.get_placeholders_list(fmt))

        self.multiple_tz = len(self._fmts) > 1

        if not isinstance(self.format_time, list):
            self.format_time = [self.format_time]

        # workout how often in seconds we will need to do an update to keep the
        # display fresh
        self.time_deltas = []
        for format in self.format_time:
            format_time = re.sub(r"{([^}]*)}", "", format)
            format_time = format_time.replace("%%", "")
            if "%f" in format_time:
                # microseconds
                time_delta = 0
            elif "%S" in format_time:
                # seconds
                time_delta = 1
            elif "%s" in format_time:
                # seconds since unix epoch start
                time_delta = 1
            elif "%T" in format_time:
                # seconds included in "%H:%M:%S"
                time_delta = 1
            elif "%c" in format_time:
                # Locale’s appropriate date and time representation
                time_delta = 1
            elif "%X" in format_time:
                # Locale’s appropriate time representation
                time_delta = 1
            else:
                time_delta = 60
            self.time_deltas.append(time_delta)

        # If we have saved details we use them.
        saved_format = self.py3.storage_get("time_format")
        if saved_format in self.format_time:
            self.active_time_format = self.format_time.index(saved_format)
        else:
            self.active_time_format = 0

        saved_timezone = self.py3.storage_get("timezone")
        if saved_timezone in self.format:
            self.active = self.format.index(saved_timezone)
        else:
            self.active = 0

        # reset the cycle time
        self._cycle_time = time.time() + self.cycle

    def _get_timezone(self, tz):
        """
        Find and return the time zone if possible
        """
        # special Local timezone
        if tz == "Local":
            return None
        # get the timezone
        try:
            zone = zoneinfo.ZoneInfo(tz)
        except zoneinfo.ZoneInfoNotFoundError:
            return "?"
        return zone

    def _change_active(self, diff):
        self.active = (self.active + diff) % len(self.format)
        # reset the cycle time
        self._cycle_time = time.time() + self.cycle
        # save the active format
        timezone = self.format[self.active]
        self.py3.storage_set("timezone", timezone)

    def on_click(self, event):
        """
        Switch the displayed module or pass the event on to the active module
        """
        if event["button"] == self.button_reset:
            self._change_active(0)
        elif event["button"] == self.button_change_time_format:
            self.active_time_format += 1
            if self.active_time_format >= len(self.format_time):
                self.active_time_format = 0
            # save the active format_time
            time_format = self.format_time[self.active_time_format]
            self.py3.storage_set("time_format", time_format)
        elif event["button"] == self.button_change_format:
            self._change_active(1)

    def clock(self):
        # cycling
        if self.cycle and time.time() >= self._cycle_time:
            self._change_active(1)
            self._cycle_time = time.time() + self.cycle

        # update our times
        times = {}
        for name in self._fmts:
            zone = self._get_timezone(name)
            if zone == "?":
                times[name] = "?"
            else:
                t = datetime.now(zone)
                format_time = self.format_time[self.active_time_format]
                icon = None
                if self.py3.format_contains(format_time, "icon"):
                    # calculate the decimal hour
                    h = t.hour + t.minute / 60
                    if self.round_to_nearest_block:
                        h += self.block_hours / len(self.blocks) / 2
                    # make 12 hourly etc
                    h = h % self.block_hours
                    idx = int(h / self.block_hours * len(self.blocks))
                    icon = self.blocks[idx]

                # special case for handling Local timezone
                if zone is None:
                    t = t.astimezone()
                    timezone = t.tzname()
                else:
                    timezone = zone.key
                tzname = timezone.split("/")[-1].replace("_", " ")

                if self.multiple_tz:
                    name_unclear = tzname
                    timezone_unclear = timezone
                else:
                    name_unclear = ""
                    timezone_unclear = ""

                format_time = self.py3.safe_format(
                    format_time,
                    dict(
                        icon=icon,
                        name=tzname,
                        name_unclear=name_unclear,
                        timezone=timezone,
                        timezone_unclear=timezone_unclear,
                    ),
                )

                if self.py3.is_composite(format_time):
                    for item in format_time:
                        item["full_text"] = t.strftime(item["full_text"])
                else:
                    format_time = t.strftime(format_time)
                times[name] = format_time

        # work out when we need to update
        timeout = self.py3.time_in(sync_to=self.time_deltas[self.active_time_format])

        # if cycling we need to make sure we update when they are needed
        if self.cycle:
            cycle_timeout = self._cycle_time
            timeout = min(timeout, cycle_timeout)

        return {
            "full_text": self.py3.safe_format(self.format[self.active], times),
            "cached_until": timeout,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/cmus.py
================================================
r"""
Display song currently playing in cmus.

cmus (C* Music Player) is a small, fast and powerful console audio player
which supports most major audio formats. Various features include gapless
playback, ReplayGain support, MP3 and Ogg streaming, live filtering, instant
startup, customizable key-bindings, and vi-style default key-bindings.

Configuration parameters:
    button_next: mouse button to skip next track (default None)
    button_pause: mouse button to pause/play the playback (default 1)
    button_previous: mouse button to skip previous track (default None)
    button_stop: mouse button to stop the playback (default 3)
    cache_timeout: refresh interval for this module (default 5)
    format: display format for this module
        *(default '[\?if=is_started [\?if=is_playing > ][\?if=is_paused \|\| ]'
        '[\?if=is_stopped .. ][[{artist}][\?soft  - ][{title}]'
        '|\?show cmus: waiting for user input]]')*
    replacements: specify a list/dict of string placeholders to modify (default None)
    sleep_timeout: sleep interval for this module. when cmus is not running,
        this interval will be used. this allows some flexible timing where one
        might want to refresh constantly with some placeholders... or to refresh
        only once every minute rather than every few seconds. (default 20)

Control placeholders:
    {is_paused} a boolean based on cmus status
    {is_playing} a boolean based on cmus status
    {is_started} a boolean based on cmus status
    {is_stopped} a boolean based on cmus status
    {continue} a boolean based on data status
    {play_library} a boolean based on data status
    {play_sorted} a boolean based on data status
    {repeat} a boolean based on data status
    {repeat_current} a boolean based on data status
    {replaygain} a boolean based on data status
    {replaygain_limit} a boolean based on data status
    {shuffle} a boolean based on data status
    {softvol} a boolean based on data status
    {stream} a boolean based on data status

Format placeholders:
    {aaa_mode} shuffle mode, eg artist, album, all
    {albumartist} album artist, eg (new output here)
    {album} album name, eg (new output here)
    {artist} artist name, eg (new output here)
    {bitrate} audio bitrate, eg 229
    {comment} comment, eg URL
    {date} year number, eg 2015
    {duration} length time in seconds, eg 171
    {durationtime} length time in [HH:]MM:SS, eg 02:51
    {file} file location, eg /home/user/Music...
    {position} elapsed time in seconds, eg 17
    {positiontime} elapsed time in [HH:]MM:SS, eg 00:17
    {replaygain_preamp} replay gain preamp, eg 0.000000
    {status} playback status, eg playing, paused, stopped
    {title} track title, eg (new output here)
    {tracknumber} track number, eg 0
    {vol_left} left volume number, eg 90
    {vol_right} right volume number, eg 90

    Placeholders are retrieved directly from `cmus-remote --query` command.
    The list was harvested only once and should not represent a full list.

Color options:
    color_paused: Paused, defaults to color_degraded
    color_playing: Playing, defaults to color_good
    color_stopped: Stopped, defaults to color_bad

Requires:
    cmus: a small feature-rich ncurses-based music player

@author lasers

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': '> Music For Programming - Big War'}

paused
{'color': '#FFFF00', 'full_text': '|| Music For Programming - Big War'}

stopped
{'color': '#FF0000', 'full_text': '.. Music For Programming - Big War'}

waiting
{'color': '#FF0000', 'full_text': '.. cmus: waiting for user input'}
"""

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    button_next = None
    button_pause = 1
    button_previous = None
    button_stop = 3
    cache_timeout = 5
    format = (
        r"[\?if=is_started [\?if=is_playing > ][\?if=is_paused \|\| ]"
        r"[\?if=is_stopped .. ][[{artist}][\?soft  - ][{title}]"
        r"|\?show cmus: waiting for user input]]"
    )
    replacements = None
    sleep_timeout = 20

    def post_config_hook(self):
        if not self.py3.check_commands("cmus-remote"):
            raise Exception(STRING_NOT_INSTALLED)

        self.color_stopped = self.py3.COLOR_STOPPED or self.py3.COLOR_BAD
        self.color_paused = self.py3.COLOR_PAUSED or self.py3.COLOR_DEGRADED
        self.color_playing = self.py3.COLOR_PLAYING or self.py3.COLOR_GOOD
        self.replacements_init = self.py3.get_replacements_list(self.format)

    def _seconds_to_time(self, value):
        m, s = divmod(int(value), 60)
        h, m = divmod(m, 60)
        time = f"{h}:{m:02d}:{s:02d}"
        return time.lstrip("0").lstrip(":")

    def _get_cmus_data(self):
        try:
            data = self.py3.command_output(["cmus-remote", "--query"])
            is_started = True
        except self.py3.CommandError:
            data = {}
            is_started = False
        return is_started, data

    def _organize_data(self, data):
        temporary = {}
        for line in data.splitlines():
            category, _, value = line.partition(" ")
            if category in ("set", "tag"):
                key, _, value = value.partition(" ")
                temporary[key] = value
            else:
                temporary[category] = value
        return temporary

    def _manipulate_data(self, data):
        temporary = {}
        for key, value in data.items():
            # seconds to time
            if key in ("duration", "position"):
                new_key = "{}{}".format(key, "time")
                temporary[new_key] = self._seconds_to_time(value)
                temporary[key] = value
            # values to boolean
            elif value in ("true", "enabled"):
                temporary[key] = True
            elif value in ("false", "disabled"):
                temporary[key] = False
            # string not modified
            else:
                temporary[key] = value

        # stream to boolean
        if "stream" in data:
            temporary["stream"] = True

        return temporary

    def cmus(self):
        """ """
        is_paused = is_playing = is_stopped = None
        cached_until = self.sleep_timeout
        color = self.py3.COLOR_BAD

        is_started, cmus_data = self._get_cmus_data()

        if is_started:
            cached_until = self.cache_timeout
            cmus_data = self._organize_data(cmus_data)
            cmus_data = self._manipulate_data(cmus_data)

            status = cmus_data.get("status")
            if status == "playing":
                is_playing = True
                color = self.color_playing
            elif status == "paused":
                is_paused = True
                color = self.color_paused
            elif status == "stopped":
                is_stopped = True
                color = self.color_stopped

        for x in self.replacements_init:
            if x in cmus_data:
                cmus_data[x] = self.py3.replace(cmus_data[x], x)

        cmus_data.update(
            {
                "is_paused": is_paused,
                "is_playing": is_playing,
                "is_started": is_started,
                "is_stopped": is_stopped,
            }
        )

        return {
            "cached_until": self.py3.time_in(cached_until),
            "color": color,
            "full_text": self.py3.safe_format(self.format, cmus_data),
        }

    def on_click(self, event):
        """
        Control cmus with mouse clicks.
        """
        button = event["button"]
        if button == self.button_pause:
            self.py3.command_run("cmus-remote --pause")
        elif button == self.button_stop:
            self.py3.command_run("cmus-remote --stop")
        elif button == self.button_next:
            self.py3.command_run("cmus-remote --next")
        elif button == self.button_previous:
            self.py3.command_run("cmus-remote --prev")
        else:
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/coin_balance.py
================================================
"""
Display balances of diverse crypto-currencies.

This module grabs your current balance of different crypto-currents from a
wallet server. The server must conform to the bitcoin RPC specification.
Currently Bitcoin, Dogecoin, and Litecoin are supported.

Configuration parameters:
    cache_timeout: An integer specifying the cache life-time of the output in
        seconds (default 30)
    coin_password: A string containing the password for the server for
        'coin'. The 'coin' part must be replaced by a supported coin identifier
        (see below for a list of identifiers). If no value is supplied,
        the value of 'password' (see below) will be used.  If 'password' too is
        not set, the value will be retrieved from the standard 'coin' daemon
        configuration file. (default None)
    coin_username: A string containing the username for the server for
        'coin'. The 'coin' part must be replaced by a supported coin identifier
        (see below for a list of identifiers). If no value is supplied,
        the value of 'username' (see below) will be used.  If 'username' too is
        not set, the value will be retrieved from the standard 'coin' daemon
        configuration file. (default None)
    credentials: (default None)
    format: A string describing the output format for the module. The {<coin>}
        placeholder (see below) will be used to determine how to fetch the
        coin balance. Multiple placeholders are allowed, but all balances will
        be fetched from the same host. (default 'LTC: {litecoin}')
    host: The coin-server hostname. Note that all coins will use the same host
        for their queries. (default 'localhost')
    password: A string containing the password for all coin-servers. If neither
        this setting, nor a specific coin_password (see above) is specified,
        the password for each coin will be read from the respective standard
        daemon configuration file. (default None)
    protocol: A string to select the server communication protocol.
        (default 'http')
    username: A string containing the username for all coin-servers. If neither
        this setting, nor a specific coin_username (see above) is specified,
        the username for each coin will be read from the respective standard
        daemon configuration file. (default None)

Format placeholders:
    {<coin>} Your balance for the coin <coin> where <coin> is one of:
        - bitcoin
        - dogecoin
        - litecoin

Requires:
    requests: python module from pypi https://pypi.python.org/pypi/requests
        At least version 2.4.2 is required.

Examples:
```
# Get your Bitcoin balance using automatic credential detection
coin_balance {
    cache_timeout = 45
    format = "My BTC: {bitcoin}"
    host = "localhost"
    protocol = "http"
}

# Get your Bitcoin, Dogecoin and Litecoin balances using specific credentials
# for Bitcoin and automatic detection for Dogecoin and Litecoin
coin_balance {
    # ...
    format = "{bitcoin} BTC {dogecoin} XDG {litecoin} LTC"
    bitcoin_username = "lcdata"
    bitcoin_password = "omikron-theta"
    # ...
}

# Get your Dogecoin and Litecoin balances using 'global' credentials
coin_balance {
    # ...
    format = "XDG: {dogecoin} LTC: {litecoin}"
    username = "crusher_b"
    password = "WezRulez"
    # ...
}

# Get you Dogecoin, Litecoin, and Bitcoin balances by using 'global'
# credentials for Bitcoin and Dogecoin but specific credentials for
# Litecoin.
coin_balance {
    # ...
    format = "XDG: {dogecoin} LTC: {litecoin} BTC: {bitcoin}"
    username = "zcochrane"
    password = "sunny_islands"
    litecoin_username = 'locutus'
    litecoin_password = 'NCC-1791-D'
    # ...
}
```

@author Felix Morgner <felix.morgner@gmail.com>
@license 3-clause-BSD

SAMPLE OUTPUT
{'full_text': 'LTC: 90.6428'}
"""

from errno import ENOENT
from pathlib import Path
from string import Formatter

import requests

COIN_PORTS = {"bitcoin": 8332, "dogecoin": 22555, "litecoin": 9332}

REQUEST = {"method": "getbalance"}


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 30
    coin_password = None
    coin_username = None
    credentials = None
    format = "LTC: {litecoin}"
    host = "localhost"
    password = None
    protocol = "http"
    username = None

    def post_config_hook(self):
        self._active_coins = []
        self._config = None
        self._credential_cache = {}

    def coin_balance(self, outputs, config):
        self._config = config

        self._active_coins = [e[1] for e in Formatter().parse(self.format)]
        balances = {}
        for coin in self._active_coins:
            balances[coin] = self._get_balance(coin)

        return {
            "full_text": self.py3.safe_format(self.format, balances),
            "cached_until": self.py3.time_in(self.cache_timeout),
        }

    def _get_daemon_config_value(self, coin, key):
        try:
            with (Path.home() / f".{coin}" / coin).open() as cfg:
                for line in cfg.readlines():
                    line = line.strip()
                    if line.startswith("#"):
                        continue
                    fields = line.split("=", 1)
                    if len(fields) == 2 and fields[0].strip() == key:
                        return fields[1].strip()
        except OSError as err:
            if err.errno == ENOENT:
                return
            raise

    def _get_credentials(self, coin):
        if coin not in self._credential_cache:
            username = getattr(self, f"{coin}_username", None)
            if username is None:
                username = getattr(self, "username", None)
            if username is None:
                username = self._get_daemon_config_value(coin, "rpcuser")

            password = getattr(self, f"{coin}_password", None)
            if password is None:
                password = getattr(self, "password", None)
            if password is None:
                password = self._get_daemon_config_value(coin, "rpcpassword")

            self._credential_cache[coin] = {"username": username, "password": password}

        return self._credential_cache[coin]

    def _get_balance(self, coin):
        if coin not in COIN_PORTS:
            return "Unsupported coin"

        credentials = self._get_credentials(coin)

        try:
            auth_data = requests.auth.HTTPBasicAuth(**credentials)
            url = "{protocol}://{host}:{port}".format(
                protocol=self.protocol, host=self.host, port=COIN_PORTS[coin]
            )

            res = requests.post(url=url, auth=auth_data, json=REQUEST)

            if res.status_code == requests.codes.ok:
                return res.json().get("result", None)
            elif res.status_code == requests.codes.unauthorized:
                return "Authentication failed"
            else:
                return "Request Error"
        except:  # noqa e722
            return "Connection to '" + url + "' failed"


if __name__ == "__main__":
    from py3status.module_test import module_test

    config = {
        "litecoin_username": "geordi",
        "litecoin_password": "WarpByBrahms",
        "username": "leah",
        "password": "IDontLikeLaForge",
        "format": "LTC {litecoin} / BTC {bitcoin} / XDG {dogecoin} / {uknwn}",
    }
    module_test(Py3status, config)



================================================
FILE: py3status/modules/coin_market.py
================================================
r"""
Display cryptocurrency coins.

The site offer various types of data such as name, symbol, price, volume, total
supply, et cetera for a wide range of cryptocurrencies in various currencies.
For more information, visit https://coinmarketcap.com

Configuration parameters:
    api_key: specify CoinMarketCap api key (default None)
    cache_timeout: refresh interval for this module. a message from the site:
        please limit requests to no more than 30 calls per minute. (default 600)
    format: display format for this module (default '{format_coin}')
    format_coin: display format for coins
        *(default '{name} ${usd_price:.2f} '
        '[\?color=usd_percent_change_24h {usd_percent_change_24h:.1f}%]')*
    format_coin_separator: show separator if more than one (default ' ')
    markets: specify a list of markets (default ['btc', 'eth'])
    thresholds: specify color thresholds to use
        (default [(-100, 'bad'), (0, 'good')])

Format placeholders:
    {format_coin} format for cryptocurrency coins

format_coin placeholders:
    {circulating_supply}     eg 17906012
    {cmc_rank}               eg 1
    {date_added}             eg 2013-04-28T00:00:00.000Z
    {id}                     eg 1
    {is_active}              eg 1
    {is_fiat}                eg 0
    {is_market_cap_included_in_calc} eg 1
    {last_updated}           eg 2019-08-30T18:51:28.000Z
    {max_supply}             eg 21000000
    {name}                   eg Bitcoin
    {num_market_pairs}       eg 7919
    {platform}               eg None
    {slug}                   eg bitcoin
    {symbol}                 eg BTC
    {tags}                   eg ['mineable']
    {total_supply}           eg 17906012

    Placeholders are retrieved directly from the URL.
    The list was harvested once and should not represent a full list.

    To print coins in different currencies, replicate the placeholders
    below with valid options (eg '{gbp_price:.2f}'):

    {xxx_last_updated}       eg 2019-08-30T18:51:28.000Z'
    {xxx_market_cap}         eg 171155540318.86005
    {xxx_percent_change_1h}  eg -0.127291
    {xxx_percent_change_24h} eg 0.328918
    {xxx_percent_change_7d}  eg -8.00576
    {xxx_price}              eg 9558.55163723
    {xxx_volume_24h}         eg 13728947008.2722

    See https://coinmarketcap.com/api/documentation/v1/#section/Standards-and-Conventions
    for valid options, otherwise USD... in lowercase.

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Examples:
```
# view coins in GBP and EUR
coin_market {
    format_coin = "{name} £{gbp_price:.2f} €{eur_price:.2f}"
}

# colorize market names + symbols
coin_market {
    format_coin = "[\?color=name {name}] "
    format_coin += "[\?color=symbol {symbol}] ${usd_price:.2f} "
    format_coin += "[\?color=usd_percent_change_24h {usd_percent_change_24h}%]"
    markets = ["btc", "eth", "ltc", "doge"]
    thresholds = {
        "name": [
            ("Bitcoin", "greenyellow"),
            ("Ethereum", "deepskyblue"),
            ("Litecoin", "crimson"),
            ("Dogecoin", "orange"),
        ],
        "symbol": [
            ("BTC", "darkgray"),
            ("ETH", "darkgray"),
            ("LTC", "darkgray"),
            ("DOGE", "darkgray"),
        ],
        "usd_percent_change_24h": [(-100, "bad"), (0, "good")],
    }
}
```

@author lasers, x86kernel

SAMPLE OUTPUT
[
    {'color': '#FFFFFF', 'full_text': 'Bitcoin $2735.77 '},
    {'color': '#00FF00', 'full_text': '2.27%'},
]

losers
[
    {'color': '#FFFFFF', 'full_text': 'Bitcoin $2701.70 '},
    {'color': '#FF0000', 'full_text': '-0.42%'},
]
"""

INVALID_API_KEY = "invalid api_key"


class Py3status:
    """"""

    # available configuration parameters
    api_key = None
    cache_timeout = 600
    format = "{format_coin}"
    format_coin = (
        r"{name} ${usd_price:.2f} [\?color=usd_percent_change_24h {usd_percent_change_24h:.1f}%]"
    )
    format_coin_separator = " "
    markets = ["btc", "eth"]
    thresholds = [(-100, "bad"), (0, "good")]

    def post_config_hook(self):
        if not self.api_key:
            self.py3.error(INVALID_API_KEY)

        currency_options = [
            "_last_updated",
            "_market_cap",
            "_percent_change_1h",
            "_percent_change_24h",
            "_percent_change_7d",
            "_price",
            "_volume_24h",
        ]

        convert = set()
        for item in self.py3.get_placeholders_list(self.format_coin):
            if item[3:].endswith(tuple(currency_options)):
                convert.add(item.split("_", 1)[0])
        convert, markets = ",".join(convert), ",".join(self.markets)

        self.headers = {
            "Accepts": "applications/json",
            "X-CMC_PRO_API_KEY": self.api_key,
        }
        self.url = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes"
        self.url += f"/latest?convert={convert}&symbol={markets}"

        self.thresholds_init = self.py3.get_color_names_list(self.format_coin)

    def _get_coin_data(self):
        try:
            cmc_data = self.py3.request(self.url, headers=self.headers).json()
            data = []

            for name, currency_data in cmc_data.get("data", {}).items():
                quotes = currency_data.pop("quote", {})
                quotes = {k.lower(): v for k, v in quotes.items()}
                currency_data.update(self.py3.flatten_dict(quotes, delimiter="_"))
                data.append(currency_data)

        except self.py3.RequestException:
            data = []
        return data

    def coin_market(self):
        coin_data = self._get_coin_data()
        new_coin = []

        for market in coin_data:
            for x in self.thresholds_init:
                if x in market:
                    self.py3.threshold_get_color(market[x], x)

            new_coin.append(self.py3.safe_format(self.format_coin, market))

        format_coin_separator = self.py3.safe_format(self.format_coin_separator)
        format_coin = self.py3.composite_join(format_coin_separator, new_coin)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"format_coin": format_coin}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/conky.py
================================================
r"""
Display Conky objects/variables on the bar.

Configuration parameters:
    config: specify configuration settings for conky (default {})
    format: display format for this module (default None)
    thresholds: specify color thresholds to use (default [])

Format placeholders:
    According to man page, Conky has more than 250 built-in objects/variables.

    See `man -P 'less -p OBJECTS/VARIABLES' conky` for a full list of Conky
    objects/variables to use. Not all of Conky objects/variables will be
    supported or usable.

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder
         Replace spaces with periods.

Examples:
```
# add conky config options
# See `man -P "less -p 'CONFIGURATION SETTINGS'" conky` for a full list
# of Conky configuration options. Not all of Conky configuration options
# will be supported or usable.
conky {
    config = {
        'update_interval': 10             # update interval for conky
        'update_interval_on_battery': 60  # update interval when on battery
        'format_human_readable': True,    # if False, print in bytes
        'short_units': True,              # shortens units, eg kiB->k, GiB->G
        'uppercase': True,                # upper placeholders
    }
}

# display ip address
order += "conky addr"
conky addr {
    format = 'IP [\?color=orange {addr eno1}]'
}

# display load averages
order += "conky loadavg"
conky loadavg {
    format = 'Loadavg '
    format += '[\?color=lightgreen {loadavg 1} ]'
    format += '[\?color=lightgreen {loadavg 2} ]'
    format += '[\?color=lightgreen {loadavg 3}]'
}

# exec commands at different intervals, eg 5s, 60s, and 3600s
order += "conky date"
conky date {
    format = 'Exec '
    format += '[\?color=good {execi 5 "date"}] '
    format += '[\?color=degraded {execi 60 "uptime -p"}] '
    format += '[\?color=bad {execi 3600 "uptime -s"}]'
}

# display diskio read, write, etc
order += "conky diskio"
conky diskio {
    format = 'Disk IO [\?color=darkgray&show sda] '
    format += '[\?color=lightskyblue '
    format += '{diskio_read sda}/{diskio_write sda} '
    format += '({diskio sda})]'

    # format += ' '
    # format += '[\?color=darkgray&show sdb] '
    # format += '[\?color=lightskyblue '
    # format += '{diskio_read sdb}/{diskio_write sdb} '
    # format += '({diskio sdb})]'
    config = {'short_units': True}
}

# display total number of processes and running processes
order += "conky proc"
conky proc {
    format = 'Processes [\?color=cyan {processes}/{running_processes}]'
}

# display top 3 cpu (+mem_res) processes
order += "conky top_cpu" {
conky top_cpu {
    format = 'Top [\?color=darkgray '
    format += '{top name 1} '
    format += '[\?color=deepskyblue {top mem_res 1}] '
    format += '[\?color=lightskyblue {top cpu 1}%] '

    format += '{top name 2} '
    format += '[\?color=deepskyblue {top mem_res 2}] '
    format += '[\?color=lightskyblue {top cpu 2}%] '

    format += '{top name 3} '
    format += '[\?color=deepskyblue {top mem_res 3}] '
    format += '[\?color=lightskyblue {top cpu 3}%]]'
    config = {'short_units': True}
}

# display top 3 memory processes
order += "conky top_mem"
conky top_mem {
    format = 'Top Mem [\?color=darkgray '
    format += '{top_mem name 1} '
    format += '[\?color=yellowgreen {top_mem mem_res 1}] '
    format += '[\?color=lightgreen {top_mem mem 1}%] '

    format += '{top_mem name 2} '
    format += '[\?color=yellowgreen {top_mem mem_res 2}] '
    format += '[\?color=lightgreen {top_mem mem 2}%] '

    format += '{top_mem name 3} '
    format += '[\?color=yellowgreen {top_mem mem_res 3}] '
    format += '[\?color=lightgreen {top_mem mem 3}%]]'
    config = {'short_units': True}
}

# display memory, memperc, membar + thresholds
order += "conky memory"
conky memory {
    format = 'Memory [\?color=lightskyblue {mem}/{memmax}] '
    format += '[\?color=memperc {memperc}% \[{membar}\]]'
    thresholds = [
        (0, 'darkgray'), (0.001, 'good'), (50, 'degraded'),
        (75, 'orange'), (85, 'bad')
    ]
}

# display swap, swapperc, swapbar + thresholds
order += "conky swap"
conky swap {
    format = 'Swap [\?color=lightcoral {swap}/{swapmax}] '
    format += '[\?color=swapperc {swapperc}% \[{swapbar}\]]'
    thresholds = [
        (0, 'darkgray'), (0.001, 'good'), (50, 'degraded'),
        (75, 'orange'), (85, 'bad')
    ]
}

# display up/down speed and up/down total
order += "conky network"
conky network {
    format = 'Speed [\?color=title {upspeed eno1}/{downspeed eno1}] '
    format += 'Total [\?color=title {totalup eno1}/{totaldown eno1}]'
    color_title = '#ff6699'
}

# display file systems + thresholds
order += "conky filesystem"
conky filesystem {
    # home filesystem
    format = 'Home [\?color=violet {fs_used /home}/{fs_size /home} '
    format += '[\?color=fs_used_perc./home '
    format += '{fs_used_perc /home}% \[{fs_bar /home}\]]]'

    # hdd filesystem
    # format += ' HDD [\?color=violet {fs_used '
    # format += '/run/media/user/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
    # format += '}/{fs_size '
    # format += '/run/media/user/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
    # format += '}[\?color=fs_used_perc.'
    # format += '/run/media/user/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
    # format += ' {fs_used_perc '
    # format += '/run/media/user/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
    # format += '}% \[{fs_bar '
    # format += '/run/media/user/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
    # format += '}\]]]'

    thresholds = [
        (0, 'darkgray'), (0.001, 'good'), (50, 'degraded'),
        (75, 'orange'), (85, 'bad')
    ]
}

# show cpu percents/bars + thresholds
order += "conky cpu"
conky cpu {
    format = 'CPU '
    format += '[\?color=cpu.cpu0 {cpu cpu0}% {cpubar cpu0}] '
    format += '[\?color=cpu.cpu1 {cpu cpu1}% {cpubar cpu1}] '
    format += '[\?color=cpu.cpu2 {cpu cpu2}% {cpubar cpu2}] '
    format += '[\?color=cpu.cpu3 {cpu cpu3}% {cpubar cpu3}]'

    thresholds = [
        (0, 'darkgray'), (0.001, 'good'), (50, 'degraded'),
        (75, 'orange'), (85, 'bad')
    ]
}

# show more examples, many outputs
order += "conky info"
conky info {
    format = '[\?color=title&show OS] [\?color=output {distribution}] '
    format += '[\?color=title&show CPU] [\?color=output {cpu cpu0}%] '
    format += '[\?color=title&show MEM] '
    format += '[\?color=output {mem}/{memmax} ({memperc}%)] '
    format += '[\?color=title&show HDD] [\?color=output {fs_used_perc}%] '
    format += '[\?color=title&show Kernel] [\?color=output {kernel}] '
    format += '[\?color=title&show Loadavg] [\?color=output {loadavg 1}] '
    format += '[\?color=title&show Uptime] [\?color=output {uptime}] '
    format += '[\?color=title&show Freq GHZ] [\?color=output {freq_g}]'
    color_title = '#ffffff'
    color_output = '#00bfff'
}

# change console bars - shoutout to su8 for adding this
conky {
    config = {
        'console_bar_fill': "'#'",
        'console_bar_unfill': "'_'",
        'default_bar_width': 10,
    }
}

# display nvidia stats - shoutout to brndnmtthws for fixing this
# See `man -P 'less -p nvidia\ argument' conky` for more nvidia variables.
order += "conky nvidia"
conky nvidia {
    format = 'GPU Temp [\?color=greenyellow {nvidia temp}] '
    format += 'GPU Freq [\?color=greenyellow {nvidia gpufreq}] '
    format += 'Mem Freq [\?color=greenyellow {nvidia memfreq}] '
    format += 'MTR Freq [\?color=greenyellow {nvidia mtrfreq}] '
    format += 'Perf [\?color=greenyellow {nvidia perflevel}] '
    format += 'Mem Perc [\?color=greenyellow {nvidia memperc}]'
    config = {
        'nvidia_display': "':0'"
    }
}
```

@author lasers

SAMPLE OUTPUT
[{'full_text': 'IP '}, {'full_text': u'192.168.1.113', 'color': '#ffa500'}]

diskio
[
    {'full_text': 'Disk IO '},
    {'full_text': 'sda ', 'color': '#a9a9a9'},
    {'full_text': '0B/285K (285K) ', 'color': '#87cefa'},
    {'full_text': 'sdb ', 'color': '#a9a9a9'},
    {'full_text': '40K/116K (156K)', 'color': '#87cefa'},
]

processes
[
    {'full_text': 'Processes '}, {'full_text': u'342/0', 'color': '#00ffff'}
]

top
[
    {'full_text': 'Top '},
    {'full_text': 'firefox-esr ', 'color': '#a9a9a9'},
    {'full_text': '512M ', 'color': '#00bfff'},
    {'full_text': '0.25% ', 'color': '#87cefa'},
    {'full_text': 'htop ', 'color': '#a9a9a9'},
    {'full_text': '2.93M ', 'color': '#00bfff'},
    {'full_text': '0.17%', 'color': '#87cefa'},
]

top_mem
[
    {'full_text': 'Top Mem '},
    {'full_text': 'chrome ', 'color': '#a9a9a9'},
    {'full_text': '607M ', 'color': '#006400'},
    {'full_text': '7.86% ', 'color': '#90ee90'},
    {'full_text': 'thunderbird ', 'color': '#a9a9a9'},
    {'full_text': '449M ', 'color': '#006400'},
    {'full_text': '5.82%', 'color': '#90ee90'},
]

network
[
    {'full_text': 'Speed '},
    {'color': '#ff6699', 'full_text': '15B/84B '},
    {'full_text': 'Total '},
    {'color': '#ff6699', 'full_text': '249MiB/4.27GiB'},
]

memory
[
    {'full_text': 'Memory '},
    {'full_text': '2.68G/7.72G ', 'color': '#87cefa'},
    {'full_text': '34% [###.......]', 'color': '#8ae234'}
]

swap
[
    {'full_text': 'Swap '},
    {'full_text': '4.5MiB/7.72GiB ', 'color': '#f08080'},
    {'full_text': '0% [..........]', 'color': '#a9a9a9'}
]

disk
[
    {'full_text': 'Home '},
    {'full_text': '167G/431G ', 'color': '#ee82ee'},
    {'full_text': '38% [####......]', 'color': '#8ae234'},
]

nvidia
[
    {'full_text': 'GPU Temp '}, {'full_text': '64 ', 'color': '#adff2f'},
    {'full_text': 'GPU Freq '}, {'full_text': '460 ', 'color': '#adff2f'},
    {'full_text': 'Mem Freq '}, {'full_text': '695', 'color': '#adff2f'},
]

nvidia
[
    {'full_text': 'MTR Freq '}, {'full_text': '1390 ', 'color': '#adff2f'},
    {'full_text': 'Perf '}, {'full_text': '1 ', 'color': '#adff2f'},
    {'full_text': 'Mem Perc '}, {'full_text': '61', 'color': '#adff2f'},
]

bar
[
    {'full_text': '#.... ', 'color': '#ffffff'},
    {'full_text': '##... ', 'color': '#00FF00'},
    {'full_text': '###.. ', 'color': '#FFA500'},
    {'full_text': '####. ', 'color': '#FFFF00'},
    {'full_text': '#####', 'color': '#FF0000'},
]
"""

from json import dumps
from pathlib import Path
from subprocess import PIPE, STDOUT, Popen
from tempfile import NamedTemporaryFile
from threading import Thread

STRING_NOT_INSTALLED = "not installed"
STRING_MISSING_FORMAT = "missing format"


class Py3status:
    """ """

    # available configuration parameters
    config = {}
    format = None
    thresholds = []

    def post_config_hook(self):
        if not self.py3.check_commands("conky"):
            raise Exception(STRING_NOT_INSTALLED)
        elif not self.format:
            raise Exception(STRING_MISSING_FORMAT)

        # placeholders
        placeholders = self.py3.get_placeholders_list(self.format)
        _placeholders = [x.replace(".", " ") for x in placeholders]
        colors = self.py3.get_color_names_list(self.format)
        _colors = []
        for color in colors:
            if not getattr(self, f"color_{color}", None):
                _colors.append(color.replace(".", " "))
        self.placeholders = placeholders + colors
        conky_placeholders = _placeholders + _colors

        # init
        self.cache_names = {}
        self.thresholds_init = colors
        self.config.update({"out_to_x": False, "out_to_console": True})
        self.separator = "|SEPARATOR|"  # must be upper

        # make an output
        config = dumps(self.config, separators=(",", "=")).replace('"', "")
        text = self.separator.join([f"${{{x}}}" for x in conky_placeholders])
        tmp = f"conky.config = {config}\nconky.text = [[{text}]]"

        # write tmp output to '/tmp/py3status-conky_*', make a command
        try:
            # python 3.12+
            self.tmpfile = NamedTemporaryFile(
                prefix="py3status_conky-", suffix=".conf", delete_on_close=False
            )
        except TypeError:
            self.tmpfile = NamedTemporaryFile(
                prefix="py3status_conky-", suffix=".conf", delete=False
            )
        self.tmpfile.write(str.encode(tmp))
        self.tmpfile.close()
        self.conky_command = f"conky -c {self.tmpfile.name}".split()

        # skip invalid conky errors
        self.ignored_conky_outputs = [
            "conky: invalid setting of type 'table'",
            "conky: FOUND:",
            "x11 session running",
        ]

        # thread
        self.line = ""
        self.error = None
        self.process = None
        self.t = Thread(target=self._start_loop)
        self.t.daemon = True
        self.t.start()

    def _cleanup(self):
        self.process.kill()
        Path(self.tmpfile.name).unlink()
        self.py3.update()

    def _start_loop(self):
        try:
            self.process = Popen(self.conky_command, stdout=PIPE, stderr=STDOUT)
            while True:
                line = self.process.stdout.readline().decode()
                if self.process.poll() is not None or "conky:" in line:
                    if any(x in line for x in self.ignored_conky_outputs):
                        continue
                    raise Exception(line)
                if self.line != line:
                    self.line = line
                    self.py3.update()
        except Exception as err:
            self.error = " ".join(format(err).split()[1:])
        finally:
            self._cleanup()

    def conky(self):
        if self.error:
            self.py3.error(self.error, self.py3.CACHE_FOREVER)

        conky_data = map(str.strip, self.line.split(self.separator))
        conky_data = dict(zip(self.placeholders, conky_data))

        if self.thresholds_init:
            for k in list(conky_data):
                try:
                    conky_data[self.cache_names[k]] = conky_data[k]
                except KeyError:
                    self.cache_names[k] = k.replace(" ", ".")
                    conky_data[self.cache_names[k]] = conky_data[k]

            for x in self.thresholds_init:
                if x in conky_data:
                    self.py3.threshold_get_color(conky_data[x], x)

        return {
            "cached_until": self.py3.CACHE_FOREVER,
            "full_text": self.py3.safe_format(self.format, conky_data),
        }

    def kill(self):
        self._cleanup()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/deadbeef.py
================================================
"""
Display songs currently playing in DeaDBeeF.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 5)
    format: display format for this module (default '[{artist} - ][{title}]')
    replacements: specify a list/dict of string placeholders to modify (default None)
    sleep_timeout: when deadbeef is not running, this interval will be used
        to allow faster refreshes with time-related placeholders and/or
        to refresh few times per minute rather than every few seconds
        (default 20)

Format placeholders:
    {album} name of the album
    {artist} name of the artist
    {length} length time in [HH:]MM:SS
    {playback_time} elapsed time in [HH:]MM:SS
    {title} title of the track
    {tracknumber} track number in two digits
    {year} year in four digits

    For more placeholders, see title formatting 2.0 in 'deadbeef --help'
    or https://github.com/DeaDBeeF-Player/deadbeef/wiki/Title-formatting-2.0
    Not all of Foobar2000 remapped metadata fields will work with deadbeef and
    a quick reminder about using {placeholders} here instead of %placeholder%.

Color options:
    color_paused: Paused, defaults to color_degraded
    color_playing: Playing, defaults to color_good
    color_stopped: Stopped, defaults to color_bad

Requires:
    deadbeef: a GTK+ audio player for GNU/Linux

Examples:
```
# see 'deadbeef --help' for more buttons
deadbeef {
    on_click 1 = 'exec deadbeef --play-pause'
    on_click 8 = 'exec deadbeef --random'
}
```

@author mrt-prodz

SAMPLE OUTPUT
{'color': '#00ff00', 'full_text': 'Music For Programming - Lackluster'}

paused
{'color': '#ffff00', 'full_text': 'Music For Programming - Lackluster'}
"""

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 5
    format = "[{artist} - ][{title}]"
    replacements = None
    sleep_timeout = 20

    class Meta:
        deprecated = {
            "remove": [{"param": "delimiter", "msg": "obsolete parameter"}],
            "rename_placeholder": [
                {
                    "placeholder": "elapsed",
                    "new": "playback_time",
                    "format_strings": ["format"],
                },
                {
                    "placeholder": "tracknum",
                    "new": "tracknumber",
                    "format_strings": ["format"],
                },
            ],
        }

    def post_config_hook(self):
        if not self.py3.check_commands("deadbeef"):
            raise Exception(STRING_NOT_INSTALLED)

        self.separator = "|SEPARATOR|"
        self.placeholders = list(set(self.py3.get_placeholders_list(self.format) + ["isplaying"]))
        self.deadbeef_command = 'deadbeef --nowplaying-tf "{}"'.format(
            self.separator.join(f"%{x}%" for x in self.placeholders)
        )
        self.color_paused = self.py3.COLOR_PAUSED or self.py3.COLOR_DEGRADED
        self.color_playing = self.py3.COLOR_PLAYING or self.py3.COLOR_GOOD
        self.color_stopped = self.py3.COLOR_STOPPED or self.py3.COLOR_BAD
        self.replacements_init = self.py3.get_replacements_list(self.format)

    def _is_running(self):
        try:
            self.py3.command_output(["pgrep", "deadbeef"])
            return True
        except self.py3.CommandError:
            return False

    def _get_deadbeef_data(self):
        # Deadbeef can generate lot of startup noises with or without error
        # codes. Running command sometimes change how things behaves onscreen
        # too. We used subprocess in the past to ignore error codes. We also
        # use pgrep and hidden placeholders to dictate how status output and
        # color should look... mainly to stay consistency in multiple versions
        # (e.g., Python2.7 to Python3+ and nonstop deadbeef-git commits).
        try:
            return self.py3.command_output(self.deadbeef_command)
        except self.py3.CommandError as ce:
            return ce.output

    def deadbeef(self):
        beef_data = {}
        cached_until = self.sleep_timeout
        color = self.color_stopped

        if self._is_running():
            line = self._get_deadbeef_data()
            beef_data = dict(zip(self.placeholders, line.split(self.separator)))
            cached_until = self.cache_timeout

            if beef_data["isplaying"]:
                color = self.color_playing
            else:
                color = self.color_paused

        for x in self.replacements_init:
            if x in beef_data:
                beef_data[x] = self.py3.replace(beef_data[x], x)

        return {
            "cached_until": self.py3.time_in(cached_until),
            "full_text": self.py3.safe_format(self.format, beef_data),
            "color": color,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/dexcom.py
================================================
r"""

Display glucose readings from your Dexcom CGM system.

Dexcom CGM systems provide glucose readings up to every five minutes. Designed
to help diabetes patients keep track of their blood glucose levels with ease.

Configuration parameters:
    format: display format for this module
        *(default "Dexcom [\?color=mg_dl {mg_dl} mg/dL {trend_arrow}] [\?color=darkgrey {datetime}]")*
    format_datetime: specify strftime characters to format (default {"datetime": "%-I:%M %p"})
    ous: specify whether if the Dexcom Share user is outside of the US (default False)
    password: specify password for the Dexcom Share user (default None)
    thresholds: specify color thresholds to use
        *(default {
            "mg_dl": [(55, "bad"), (70, "degraded"), (80, "good"), (130, "degraded"), (180, "bad")],
            "mmol_l": [(3.1, "bad"), (3.9, "degraded"), (4.4, "good"), (7.2, "degraded"), (10.0, "bad")],
        })*
    username: specify username for the Dexcom Share user, not follower (default None)

Format placeholders:
    {mg_dl} blood glucose value in mg/dL, eg 80
    {mmol_l} blood glucose value in mmol/L, eg 4.4
    {trend} blood glucose trend information, eg 4
    {trend_direction} blood glucose trend direction, eg Flat
    {trend_description} blood glucose trend information description, eg steady
    {trend_arrow} blood glucose trend as unicode arrow, eg →
    {datetime} glucose reading recorded time as datetime

format_datetime placeholders:
    key: epoch_placeholder, eg {datetime}
    value: % strftime characters to be translated, eg '%b %d' ----> 'Jan 1'

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    pydexcom: A simple Python API to interact with Dexcom Share service

Notes:
    IF GLUCOSE ALERTS AND CGM READINGS DO NOT MATCH SYMPTOMS OR EXPECTATIONS,
    USE A BLOOD GLUCOSE METER TO MAKE DIABETES TREATMENT DECISIONS.

Examples:
```
# compact
dexcom {
    format = "[\?color=mg_dl {mg_dl} {trend_arrow}][\?color=darkgrey {datetime}]"
    format_datetime = {"datetime": "%-I:%M"}
}
```

@author lasers

SAMPLE OUTPUT
[
    {"full_text": "Dexcom "},
    {"full_text": "80 mg/dL →", "color": "#00FF00"},
    {"full_text": "7:15 PM", "color": "#A9A9A9"}
]
"""

from datetime import datetime, timedelta

from pydexcom import Dexcom

STRING_ERROR = "no glucose reading"
CACHE_TIMEOUT = 5 * 60


class Py3status:
    """ """

    # available configuration parameters
    format = r"Dexcom [\?color=mg_dl {mg_dl} mg/dL {trend_arrow}] [\?color=darkgrey {datetime}]"
    format_datetime = {"datetime": "%-I:%M %p"}
    ous = False
    password = None
    thresholds = {
        "mg_dl": [
            (55, "bad"),
            (70, "degraded"),
            (80, "good"),
            (130, "degraded"),
            (180, "bad"),
        ],
        "mmol_l": [
            (3.1, "bad"),
            (3.9, "degraded"),
            (4.4, "good"),
            (7.2, "degraded"),
            (10.0, "bad"),
        ],
    }
    username = None

    def post_config_hook(self):
        for x in ["username", "password"]:
            if not getattr(self, x):
                raise Exception(f"missing `{x}`")

        self.init = {"datetimes": []}
        for x in ["datetime"]:
            if self.py3.format_contains(self.format, x) and x in self.format_datetime:
                self.init["datetimes"].append(x)

        self.seconds = CACHE_TIMEOUT + getattr(self, "cached_delay", 10)
        self.placeholders = ["value", "datetime", "mg_dl", "mmol_l", "trend"]
        self.placeholders += ["trend_arrow", "trend_description", "trend_direction"]
        self.thresholds_init = self.py3.get_color_names_list(self.format)
        self.dexcom_class = Dexcom(self.username, self.password, ous=self.ous)

    def _get_glucose_data(self):
        glucose_reading = self.dexcom_class.get_current_glucose_reading()
        if not glucose_reading:
            self.py3.error(STRING_ERROR, timeout=self.seconds)

        data = {x: getattr(glucose_reading, x) for x in self.placeholders}
        data["datetime"] = data["datetime"].isoformat()
        return data

    def _get_next_datetime(self, data):
        last_datetime = datetime.fromisoformat(data["datetime"])
        next_datetime = last_datetime + timedelta(seconds=self.seconds)
        return (next_datetime - datetime.now()).total_seconds()

    def dexcom(self):
        glucose_data = self._get_glucose_data()
        cached_until = self._get_next_datetime(glucose_data)

        for x in self.init["datetimes"]:
            if x in glucose_data:
                obj = datetime.fromisoformat(glucose_data[x])
                date_format = datetime.strftime(obj, self.format_datetime[x])
                glucose_data[x] = self.py3.safe_format(date_format)

        for x in self.thresholds_init:
            if x in glucose_data:
                self.py3.threshold_get_color(glucose_data[x], x)

        return {
            "cached_until": self.py3.time_in(cached_until),
            "full_text": self.py3.safe_format(self.format, glucose_data),
        }

    def on_click(self, event):
        self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from os import getenv

    from py3status.module_test import module_test

    config = {"username": getenv("DEXCOM_USERNAME"), "password": getenv("DEXCOM_PASSWORD")}
    module_test(Py3status, config)



================================================
FILE: py3status/modules/diskdata.py
================================================
r"""
Display disk information.

Configuration parameters:
    cache_timeout: refresh interval for this module. (default 10)
    disk: show stats for disk or partition, i.e. `sda1`. None for all disks.
        (default None)
    format: display format for this module.
        (default "{disk}: {used_percent}%[ ({total})]")
    format_rate: display format for rates value
        (default "[\?min_length=11 {value:.1f} {unit}]")
    format_space: display format for disk space values
        (default "[\?min_length=5 {value:.1f}]")
    sector_size: size of the disk's sectors.
        (default 512)
    si_units: use SI units
        (default False)
    thresholds: specify color thresholds to use
        *(default {'free': [(0, 'bad'), (10, 'degraded'), (100, 'good')],
        'total': [(0, 'good'), (1024, 'degraded'), (1024 * 1024, 'bad')],
        'used_percent': [(0, 'good'), (40, 'degraded'), (75, 'bad')]})*
    unit: unit to use. If the unit contains a multiplier prefix, only this
        exact unit will ever be used
        (default "B/s")

Format placeholders:
    {disk} the selected disk
    {free} free space on disk in GB
    {used} used space on disk in GB
    {total_space} total space on disk in GB
    {used_percent} used space on disk in %
    {read} reading rate
    {total} total IO rate
    {write} writing rate

format_rate placeholders:
    {unit} name of the unit
    {value} numeric value of the rate

format_space placeholders:
    {value} numeric value of the free/used space on the device

Color thresholds:
    {free} Change color based on the value of free
    {used} Change color based on the value of used
    {used_percent} Change color based on the value of used_percent
    {read} Change color based on the value of read
    {total} Change color based on the value of total
    {write} Change color based on the value of write

@author guiniol
@license BSD

SAMPLE OUTPUT
{'full_text': 'all:  34.4% ( 82.0 KiB/s)'}
"""

import time
from pathlib import Path


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    disk = None
    format = "{disk}: {used_percent}%[ ({total})]"
    format_rate = r"[\?min_length=11 {value:.1f} {unit}]"
    format_space = r"[\?min_length=5 {value:.1f}]"
    sector_size = 512
    si_units = False
    thresholds = {
        "free": [(0, "bad"), (10, "degraded"), (100, "good")],
        "total": [(0, "good"), (1024, "degraded"), (1024 * 1024, "bad")],
        "used_percent": [(0, "good"), (40, "degraded"), (75, "bad")],
    }
    unit = "B/s"

    def post_config_hook(self):
        self.disk_name = self.disk or "all"
        names_and_matches = [
            ("df", ["free", "used", "used_percent", "total_space"]),
            ("diskstats", ["read", "write", "total"]),
        ]
        self.init = {x[0]: {} for x in names_and_matches}
        for name, match in names_and_matches:
            placeholders = self.py3.get_placeholders_list(self.format, match)
            if placeholders:
                self.init[name] = {"placeholders": placeholders, "keys": match}

        if self.init["diskstats"]:
            try:
                self.last_diskstats = self._get_diskstats(self.disk)
                self.last_time = time.monotonic()
            except Exception:
                self.init["diskstats"] = {}

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def _get_df_usages(self, disk):
        try:
            df_usages = self.py3.command_output(["df", "-k"])
        except self.py3.CommandError as ce:
            df_usages = ce.output
        total, used, free, devs = 0, 0, 0, []

        disk_dev = None

        if disk:
            disk_dev = "/dev/" + disk

        for line in df_usages.splitlines():
            if (
                (disk and line.startswith(disk))
                or (disk_dev and line.startswith(disk_dev))
                or (disk is None and line.startswith("/dev/"))
            ):
                data = line.split()
                if data[0] in devs:
                    # Make sure to count each block device only one time
                    # some filesystems eg btrfs have multiple entries
                    continue
                total += int(data[1]) / 1024 / 1024
                used += int(data[2]) / 1024 / 1024
                free += int(data[3]) / 1024 / 1024
                devs.append(data[0])

        if total == 0:
            return free, used, "err", total

        return free, used, 100 * used / total, total

    def _get_diskstats(self, disk):
        read, write = 0, 0

        if disk and disk.startswith("/dev/"):
            disk = disk[5:]

        with Path("/proc/diskstats").open() as fd:
            for line in fd:
                data = line.split()
                if disk:
                    if data[2] == disk:
                        read += int(data[5]) * self.sector_size
                        write += int(data[9]) * self.sector_size
                else:
                    if data[1] == "0":
                        read += int(data[5]) * self.sector_size
                        write += int(data[9]) * self.sector_size

        return read, write

    def _calc_diskstats(self, diskstats):
        current_time = time.monotonic()
        timedelta = current_time - self.last_time
        read = (diskstats[0] - self.last_diskstats[0]) / timedelta
        write = (diskstats[1] - self.last_diskstats[1]) / timedelta
        total = read + write
        self.last_diskstats = diskstats
        self.last_time = current_time

        return read, write, total

    def diskdata(self):
        disk_data = {"disk": self.disk_name}
        threshold_data = disk_data.copy()

        if self.init["df"]:
            df_usages = self._get_df_usages(self.disk)
            data = dict(zip(self.init["df"]["keys"], df_usages))
            threshold_data.update(data)

            for x in self.init["df"]["placeholders"]:
                disk_data[x] = self.py3.safe_format(self.format_space, {"value": data[x]})

        if self.init["diskstats"]:
            diskstats = self._calc_diskstats(self._get_diskstats(self.disk))
            data = dict(zip(self.init["diskstats"]["keys"], diskstats))
            threshold_data.update(data)

            for x in self.init["diskstats"]["placeholders"]:
                value, unit = self.py3.format_units(data[x], unit=self.unit, si=self.si_units)
                disk_data[x] = self.py3.safe_format(
                    self.format_rate, {"value": value, "unit": unit}
                )

        for x in self.thresholds_init:
            if x in threshold_data:
                self.py3.threshold_get_color(threshold_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, disk_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/do_not_disturb.py
================================================
r"""
Turn on and off desktop notifications.

Configuration parameters:
    cache_timeout: refresh interval for this module; for xfce4-notifyd
        (default 30)
    format: display format for this module
        (default '{name} [\?color=state&show DND]')
    pause: specify whether to pause or kill processes; for dunst
        see `Dunst Miscellaneous` section for more information
        (default True)
    server: specify server to use, eg mako, dunst or xfce4-notifyd, otherwise auto
        (default None)
    state: specify state to use on startup, otherwise last
        False: disable Do Not Disturb on startup
        True: enable Do Not Disturb on startup
        last: toggle last known state on startup
        None: query current state from notification manager (doesn't work on dunst<1.5.0)
        (default 'last')
    thresholds: specify color thresholds to use
        (default [(0, 'bad'), (1, 'good')])

Format placeholders:
    {name} name, eg Mako, Dunst, Xfce4-notifyd
    {state} do not disturb state, eg 0, 1

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Dunst Miscellaneous:
    When paused, dunst will not display any notifications but keep all
    notifications in a queue. This can for example be wrapped around a screen
    locker (i3lock, slock) to prevent flickering of notifications through the
    lock and to read all missed notifications after returning to the computer.
    This means that by default (pause = False), all notifications sent while
    DND is active will NOT be queued and displayed when DND is deactivated.

Mako Miscellaneous:
    Mako requires that you manually create a 'do-not-disturb' mode as shown
    in https://man.voidlinux.org/mako.5#MODES.
    This module expects this mode to be configured by the user as suggested by
    the mako documentation:
    [mode=do-not-disturb]
    invisible=1


Examples:
```
# display ON/OFF
do_not_disturb {
    format = '{name} [\?color=state [\?if=state  ON|OFF]]'
}

# display 1/0
do_not_disturb {
    format = '{name} [\?color=state {state}]'
}

# display DO NOT DISTURB/DISTURB
do_not_disturb {
    format = '[\?color=state [\?if=state DO NOT DISTURB|DISTURB]]'
    thresholds = [(0, "darkgray"), (1, "good")]
}
```

@author Maxim Baz https://github.com/maximbaz (dunst)
@author Robert Ricci https://github.com/ricci (xfce4-notifyd)
@author Cyrinux https://github.com/cyrinux (mako)
@license BSD

SAMPLE OUTPUT
[{'full_text': 'Dunst '}, {'color': '#00FF00', 'full_text': 'DND'}]

off
[{'full_text': 'Dunst '}, {'color': '#FF0000', 'full_text': 'DND'}]
"""

STRING_NOT_INSTALLED = "server `{}` not installed"
STRING_INVALID_SERVER = "invalid server `{}`"
STRING_INVALID_STATE = "invalid state `{}`"


class Notification:
    def __init__(self, parent):
        self.parent = parent
        self.setup(parent)

    def setup(self, parent):
        pass

    def get_state(self):
        return self.parent.state


class Dunst(Notification):
    """
    Dunst Notification.
    """

    def setup(self, parent):
        self.has_dunstctl = bool(self.parent.py3.check_commands(["dunstctl"]))

    def get_state(self):
        if self.has_dunstctl:
            state = self.parent.py3.command_output("dunstctl is-paused")
            return state.strip() == "true"
        else:
            return self.parent.state

    def toggle(self, state):
        if self.has_dunstctl:
            self.parent.py3.command_run("dunstctl set-paused {}".format(str(state).lower()))
        elif state:
            # pause
            self.parent.py3.command_run("pkill -SIGUSR1 dunst")
        else:
            if self.parent.pause:
                # resume
                self.parent.py3.command_run("pkill -SIGUSR2 dunst")
            else:
                # delete all pending notifications and resume
                self.parent.py3.command_run("pkill -SIGTERM dunst")


class Mako(Notification):
    """
    Mako Notification.
    """

    # From version mako 1.7 we can use "makoctl mode"
    def setup(self, parent):
        self.has_makoctl_mode = bool(
            self.parent.py3.check_commands(["makoctl"])
        ) and not self.parent.py3.command_run("makoctl mode")

    def get_state(self):
        if self.has_makoctl_mode:
            state = self.parent.py3.command_output("makoctl mode")
            return state.strip() == "do-not-disturb"
        else:
            return self.parent.state

    def toggle(self, state):
        if state is True:
            self.parent.py3.command_run("makoctl set-mode do-not-disturb")
        else:
            self.parent.py3.command_run("makoctl set-mode default")


class Xfce4_notifyd(Notification):
    """
    XFCE4 Notification.
    """

    def setup(self, parent):
        from dbus import Interface, SessionBus

        self.iface = Interface(
            SessionBus().get_object("org.xfce.Xfconf", "/org/xfce/Xfconf"),
            "org.xfce.Xfconf",
        )

    def get_state(self):
        return self.iface.GetProperty("xfce4-notifyd", "/do-not-disturb")

    def toggle(self, state):
        self.iface.SetProperty("xfce4-notifyd", "/do-not-disturb", state)


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 30
    format = r"{name} [\?color=state&show DND]"
    pause = True
    server = None
    state = "last"
    thresholds = [(0, "bad"), (1, "good")]

    def post_config_hook(self):
        servers = ["dunst", "mako", "xfce4-notifyd", None]
        if not self.server:
            for server in servers:
                if server:
                    try:
                        if self.py3.command_output(["pgrep", "-x", server]):
                            self.server = server
                            break
                    except self.py3.CommandError:
                        pass
            else:
                self.server = self.py3.check_commands(servers[:-1]) or "dunst"
        elif self.server not in servers:
            raise Exception(STRING_INVALID_SERVER.format(self.server))
        else:
            command = self.server.replace("notifyd", "notifyd-config")
            if not self.py3.check_commands(command):
                raise Exception(STRING_NOT_INSTALLED.format(command))

        if self.server == "dunst":
            self.backend = Dunst(self)
        elif self.server == "mako":
            self.backend = Mako(self)
        elif self.server == "xfce4-notifyd":
            self.backend = Xfce4_notifyd(self)

        if self.state is not None:
            if self.state == "last":
                self.state = self.py3.storage_get("state") or 0
            if self.state in [False, True]:
                self.backend.toggle(self.state)
            else:
                raise Exception(STRING_INVALID_STATE.format(self.state))
        elif self.server == "dunst" and not self.backend.has_dunstctl:
            raise Exception(STRING_INVALID_STATE.format(self.state))

        self.name = self.server.capitalize()
        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def do_not_disturb(self):
        self.state = self.backend.get_state()
        dnd_data = {"state": int(self.state), "name": self.name}

        for x in self.thresholds_init:
            if x in dnd_data:
                self.py3.threshold_get_color(dnd_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, dnd_data),
        }

    def on_click(self, event):
        self.state = not self.state
        self.py3.storage_set("state", self.state)
        self.backend.toggle(self.state)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/dpms.py
================================================
"""
Turn on and off DPMS and screen saver blanking.

Configuration parameters:
    button_off: mouse button to turn off screen (default None)
    button_toggle: mouse button to toggle DPMS (default 1)
    cache_timeout: refresh interval for this module (default 15)
    format: display format for this module (default '{icon}')
    icon_off: show when DPMS is disabled (default 'DPMS')
    icon_on: show when DPMS is enabled (default 'DPMS')

Format placeholders:
    {icon} DPMS icon

Color options:
    color_on: Enabled, defaults to color_good
    color_off: Disabled, defaults to color_bad

@author Andre Doser <dosera AT tf.uni-freiburg.de>

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'DPMS'}

off
{'color': '#FF0000', 'full_text': 'DPMS'}
"""


class Py3status:
    """ """

    # available configuration parameters
    button_off = None
    button_toggle = 1
    cache_timeout = 15
    format = "{icon}"
    icon_off = "DPMS"
    icon_on = "DPMS"

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "format_on",
                    "new": "icon_on",
                    "msg": "obsolete parameter use `icon_on`",
                },
                {
                    "param": "format_off",
                    "new": "icon_off",
                    "msg": "obsolete parameter use `icon_off`",
                },
            ]
        }

    def post_config_hook(self):
        self.color_on = self.py3.COLOR_ON or self.py3.COLOR_GOOD
        self.color_off = self.py3.COLOR_OFF or self.py3.COLOR_BAD

    def dpms(self):
        """
        Display a colorful state of DPMS.
        """
        if "DPMS is Enabled" in self.py3.command_output("xset -q"):
            _format = self.icon_on
            color = self.color_on
        else:
            _format = self.icon_off
            color = self.color_off

        icon = self.py3.safe_format(_format)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"icon": icon}),
            "color": color,
        }

    def on_click(self, event):
        """
        Control DPMS with mouse clicks.
        """
        if event["button"] == self.button_toggle:
            if "DPMS is Enabled" in self.py3.command_output("xset -q"):
                self.py3.command_run("xset -dpms s off")
            else:
                self.py3.command_run("xset +dpms s on")

        if event["button"] == self.button_off:
            self.py3.command_run("xset dpms force off")


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/dropboxd_status.py
================================================
"""
Display status of Dropbox daemon.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default "Dropbox: {status}")
    status_busy: text for placeholder {status} when Dropbox is busy
        (default None)
    status_off: text for placeholder {status} when Dropbox isn't running
        (default "isn't running")
    status_on: text for placeholder {status} when Dropbox is up to date
        (default "Up to date")

Value for `status_off` if not set:
    - Dropbox isn't running!

Value for `status_on` if not set:
    - Up to date

Values for `status_busy` if not set:
    - Connecting...
    - Starting...
    - Downloading file list...
    - Syncing "filename"

Format placeholders:
    {status} Dropbox status

Color options:
    color_bad: Not running
    color_degraded: Busy
    color_good: Up to date

Requires:
    dropbox-cli: command line interface for dropbox

Notes:
    Some distributions offer an option to install dropbox-cli. If you don't see
    one for your distribution, then you need to download CLI Python script,
    https://www.dropbox.com/help/desktop-web/linux-commands#commands, rename
    it to `dropbox-cli`, make the script executable and available in your PATH.

@author Tjaart van der Walt (github:tjaartvdwalt)
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'Dropbox: Up to date'}

busy
{'color': '#FFFF00', 'full_text': 'Dropbox: Syncing "Calorie_Counting.ods"'}

off
{'color': '#FF0000', 'full_text': "Dropbox: isn't running"}
"""

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "Dropbox: {status}"
    status_busy = None
    status_off = "isn't running"
    status_on = "Up to date"

    class Meta:
        deprecated = {
            "format_fix_unnamed_param": [
                {
                    "param": "format",
                    "placeholder": "status",
                    "msg": "{} should not be used in format use `{status}`",
                }
            ]
        }

    def post_config_hook(self):
        if not self.py3.check_commands("dropbox-cli"):
            raise Exception(STRING_NOT_INSTALLED)

    def dropboxd_status(self):
        status = self.py3.command_output("dropbox-cli status", localized=True).splitlines()[0]

        if status == "Dropbox isn't running!":
            color = self.py3.COLOR_BAD
            status = self.status_off
        elif status == "Up to date":
            color = self.py3.COLOR_GOOD
            status = self.status_on
        else:
            color = self.py3.COLOR_DEGRADED
            if self.status_busy is not None:
                status = self.status_busy

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": color,
            "full_text": self.py3.safe_format(self.format, {"status": status}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/emerge_status.py
================================================
r"""
Display information about the currently running emerge process.

Configuration parameters:
    cache_timeout: how often we refresh this module in second.
        NOTE: when emerge is running, we will refresh this module every second.
        (default 30)
    emerge_log_file: path to the emerge log file.
        (default '/var/log/emerge.log')
    format: display format for this module
        *(default '{prefix}[\?if=is_running : [\?if=!total=0 '
        '[{current}/{total} {action} {category}/{pkg}]'
        '|calculating...]|: stopped 0/0]')*
    prefix: prefix in statusbar
        (default "emrg")

Format placeholders:
    {action} current emerge action
    {category} category of the currently emerged package
    {current} number of package that is currently emerged
    {pkg} name of the currently emerged packaged
    {total} total number of packages that will be emerged

Examples:
```
# Hide if not running
emerge_status {
    format = "[\?if=is_running {prefix}: [\?if=!total=0 "
    format += "{current}/{total} {action} {category}/{pkg}"
    format += "|calculating...]]"
}

# Minimalistic
emerge_status {
    format = "[\?if=is_running [\?if=!total=0 {current}/{total}]]"
}

# Minimalistic II
emerge_status {
    format = "[\?if=is_running {current}/{total}]"
}
```

@author AnwariasEu

SAMPLE OUTPUT
{'full_text': 'emrg : 0/0'}
"""

import copy
import re

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 30
    emerge_log_file = "/var/log/emerge.log"
    format = (
        r"{prefix}[\?if=is_running : [\?if=!total=0 [{current}/{total}"
        " {action} {category}/{pkg}]|calculating...]|: stopped 0/0]"
    )
    prefix = "emrg"

    def _emerge_running(self):
        """
        Check if emerge is running.
        Returns true if at least one instance of emerge is running.
        """
        try:
            self.py3.command_output(["pgrep", "emerge"])
            return True
        except Exception:
            return False

    def post_config_hook(self):
        if not self.py3.check_commands("emerge"):
            raise Exception(STRING_NOT_INSTALLED)
        self.ret_default = {
            "action": "",
            "category": "",
            "current": 0,
            "is_running": False,
            "pkg": "",
            "total": 0,
        }

    def _get_progress(self):
        """
        Get current progress of emerge.
        Returns a dict containing current and total value.
        """
        input_data = []
        ret = {}

        # traverse emerge.log from bottom up to get latest information
        last_lines = self.py3.command_output(["tail", "-50", self.emerge_log_file])
        input_data = last_lines.split("\n")
        input_data.reverse()

        for line in input_data:
            if "*** terminating." in line:
                # copy content of ret_default, not only the references
                ret = copy.deepcopy(self.ret_default)
                break
            else:
                status_re = re.compile(
                    r"\((?P<cu>[\d]+) of (?P<t>[\d]+)\) "
                    r"(?P<a>[a-zA-Z/]+( [a-zA-Z]+)?) "
                    r"\((?P<ca>[\w\-]+)/(?P<p>[\w.]+)"
                )
                res = status_re.search(line)
                if res is not None:
                    ret["action"] = res.group("a").lower()
                    ret["category"] = res.group("ca")
                    ret["current"] = res.group("cu")
                    ret["pkg"] = res.group("p")
                    ret["total"] = res.group("t")
                    break
        return ret

    def emerge_status(self):
        """ """
        response = {}
        ret = copy.deepcopy(self.ret_default)
        if self._emerge_running():
            ret = self._get_progress()
            ret["is_running"] = True
            response["cached_until"] = self.py3.time_in(0)
        else:
            response["cached_until"] = self.py3.time_in(self.cache_timeout)
        response["full_text"] = self.py3.safe_format(self.format, ret)
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/exchange_rate.py
================================================
"""
Display foreign exchange rates.

Configuration parameters:
    api_key: the exchangeratesapi.io API access key (default None)
    base: specify base currency to use for exchange rates (default 'EUR')
    cache_timeout: refresh interval for this module (default 600)
    format: display format for this module (default '${USD} £{GBP} ¥{JPY}')

Format placeholders:
    See https://api.exchangeratesapi.io/latest for a full list of foreign
    exchange rates published by the European Central Bank. Not all of exchange
    rates will be available. Also, see https://en.wikipedia.org/wiki/ISO_4217

@author tobes
@license BSD

SAMPLE OUTPUT
{'full_text': u'$1.061 \xa30.884 \xa5121.538'}
"""


class Py3status:
    """ """

    # available configuration parameters
    api_key = None
    base = "EUR"
    cache_timeout = 600
    format = "${USD} £{GBP} ¥{JPY}"

    def post_config_hook(self):
        # Verify the API key
        if self.api_key is None:
            raise Exception(
                "API Key for ExchangeRatesApi.io cannot be empty!"
                " Go to https://exchangeratesapi.io/pricing/"
                " get an API Key."
            )
        self.url = f"http://api.exchangeratesapi.io/v1/latest?base={self.base}"
        self.url += f"&access_key={self.api_key}"
        placeholders = self.py3.get_placeholders_list(self.format)
        formats = dict.fromkeys(placeholders, ":.3f")
        self.format = self.py3.update_placeholder_formats(self.format, formats)
        self.rate_data = dict.fromkeys(placeholders, "?")

    def _get_exchange_rates(self):
        try:
            response = self.py3.request(self.url)
        except self.py3.RequestException:
            return {}
        data = response.json()
        if data and data["success"]:
            data = data.get("rates", {})
        else:
            error = data.get("error")
            if error:
                self.py3.error(error["info"])
        return data

    def exchange_rate(self):
        self.rate_data.update(self._get_exchange_rates())

        return {
            "full_text": self.py3.safe_format(self.format, self.rate_data),
            "cached_until": self.py3.time_in(self.cache_timeout),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/external_script.py
================================================
"""
Display output of a given script.

Display output of any executable script set by `script_path`. Only the first
two lines of output will be used. The first line is used as the displayed
text. If the output has two or more lines, the second line contains additional
information as whitespace separated tokens.  Valid tokens are:
    `#rrggbb`: the text color as a hex color code (eg. `#FF0000` for red)
    `urgent`: the word `urgent` to set the urgent flag
The script should not have any parameters, but it could work.

Configuration parameters:
    button_show_notification: button to show notification with full output
        (default None)
    cache_timeout: how often we refresh this module in seconds
        (default 15)
    convert_numbers: convert decimal numbers to a numeric type
        (default True)
    format: see placeholders below (default '{output}')
    localize: should script output be localized (if available)
        (default True)
    script_path: script you want to show output of (compulsory)
        (default None)
    strip_output: shall we strip leading and trailing spaces from output
        (default False)

Format placeholders:
    {lines} number of lines in the output
    {output} output of script given by "script_path"
    {composite} composite output of script given by "script_path"

Examples:
```
external_script {
    format = "my name is {output}"
    script_path = "/usr/bin/whoami"
}
```

@author frimdo ztracenastopa@centrum.cz

SAMPLE OUTPUT
{'full_text': 'script output'}

example
{'full_text': 'It is now: Wed Feb 22 22:24:13'}
"""

import re

STRING_ERROR = "missing script_path"


class Py3status:
    """ """

    # available configuration parameters
    button_show_notification = None
    cache_timeout = 15
    convert_numbers = True
    format = "{output}"
    localize = True
    script_path = None
    strip_output = False

    def post_config_hook(self):
        if not self.script_path:
            raise Exception(STRING_ERROR)

    def external_script(self):
        output_lines = None
        response = {}
        response["cached_until"] = self.py3.time_in(self.cache_timeout)
        try:
            self.output = self.py3.command_output(
                self.script_path, shell=True, localized=self.localize
            )
            output_lines = self.output.splitlines()
            if len(output_lines) > 1:
                words = output_lines[1].split()
                for word in words:
                    if re.search(r"^#[0-9a-fA-F]{6}$", word):
                        response["color"] = word
                    elif word == "urgent":
                        response["urgent"] = True
        except self.py3.CommandError as e:
            # something went wrong show error to user
            output = e.output or e.error
            self.py3.error(output)

        if output_lines:
            output = output_lines[0]
            if self.strip_output:
                output = output.strip()
            # If we get something that looks numeric then we convert it
            # to a numeric type because this can be helpful. for example:
            #
            # external_script {
            #     format = "file is [\?if=output>10 big|small]"
            #     script_path = "cat /tmp/my_file | wc -l"
            # }
            if self.convert_numbers is True:
                try:
                    output = int(output)
                except ValueError:
                    try:
                        output = float(output)
                    except ValueError:
                        pass
        else:
            output = ""

        script_data = {
            "output": output,
            "lines": len(output_lines),
            "composite": self.py3.safe_format(output),
        }
        response["full_text"] = self.py3.safe_format(self.format, script_data)
        return response

    def on_click(self, event):
        button = event["button"]
        if button == self.button_show_notification:
            self.py3.notify_user(self.output)
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/fedora_updates.py
================================================
"""
Display number of pending updates for Fedora Linux.

This will display a count of how many `dnf` updates are waiting
to be installed. Additionally check for update security notices.

Configuration parameters:
    cache_timeout: How often we refresh this module in seconds
        (default 600)
    check_security: Check for security updates
        (default True)
    format: Display format to use
        (default 'DNF: {updates}')

Format placeholders:
    {updates} number of pending dnf updates

Color options:
    color_bad: Security notice
    color_degraded: Upgrade available
    color_good: No upgrades needed

@author tobes
@license BSD

SAMPLE OUTPUT
{'color': '#FFFF00', 'full_text': 'DNF: 14'}
"""

import re
import subprocess


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 600
    check_security = True
    format = "DNF: {updates}"

    def post_config_hook(self):
        self._reg_ex_sec = re.compile(r"\d+(?=\s+Security)")
        self._reg_ex_pkg = re.compile(b"^\\S+\\.", re.M)
        self._first = True
        self._updates = 0
        self._security_notice = False

    def fedora_updates(self):
        if self._first:
            self._first = False
            response = {
                "cached_until": self.py3.time_in(0),
                "full_text": self.py3.safe_format(self.format, {"updates": "?"}),
            }
            return response

        output, error = subprocess.Popen(
            ["dnf", "check-update"], stdout=subprocess.PIPE, stderr=subprocess.PIPE
        ).communicate()

        updates = len(self._reg_ex_pkg.findall(output))

        if updates == 0:
            color = self.py3.COLOR_GOOD
            self._updates = 0
            self._security_notice = False
        else:
            if self._updates > updates:
                # we have installed some updates so re-check security
                self._security_notice = False
            if self.check_security and not self._security_notice and self._updates != updates:
                output, error = subprocess.Popen(
                    ["dnf", "updateinfo"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                ).communicate()
                notices = str(output)
                self._security_notice = len(self._reg_ex_sec.findall(notices))
                self._updates = updates
            if self.check_security and self._security_notice:
                color = self.py3.COLOR_BAD
            else:
                color = self.py3.COLOR_DEGRADED

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": color,
            "full_text": self.py3.safe_format(self.format, {"updates": updates}),
        }
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/file_status.py
================================================
"""
Display if files or directories exists.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module
        (default '\\?color=path [\\?if=path ●|■]')
    format_path: format for paths (default '{basename}')
    format_path_separator: show separator if more than one (default ' ')
    paths: specify a string or a list of paths to check (default None)
    thresholds: specify color thresholds to use
        (default [(0, 'bad'), (1, 'good')])

Format placeholders:
    {format_path} format for paths
    {path} number of paths, eg 1, 2, 3

format_path placeholders:
    {basename} basename of pathname
    {pathname} pathname

Color options:
    color_bad: files or directories does not exist
    color_good: files or directories exists

Color thresholds:
    format:
        path: print a color based on the number of paths

Examples:
```
# add multiple paths with wildcard or with pathnames
file_status {
    paths = ['/tmp/test*', '~user/test1', '~/Videos/*.mp4']
}

# colorize basenames
file_status {
    paths = ['~/.config/i3/modules/*.py']
    format = '{format_path}'
    format_path = '\\?color=good {basename}'
    format_path_separator = ', '
}
```

@author obb, Moritz Lüdecke, Cyril Levis (@cyrinux)

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'\u25cf'}

missing
{'color': '#FF0000', 'full_text': u'\u25a0'}
"""

from pathlib import Path

STRING_NO_PATHS = "missing paths"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "\\?color=path [\\?if=path \u25cf|\u25a0]"
    format_path = "{basename}"
    format_path_separator = " "
    paths = None
    thresholds = [(0, "bad"), (1, "good")]

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "format_available",
                    "new": "icon_available",
                    "msg": "obsolete parameter use `icon_available`",
                },
                {
                    "param": "format_unavailable",
                    "new": "icon_unavailable",
                    "msg": "obsolete parameter use `icon_unavailable`",
                },
                {
                    "param": "path",
                    "new": "paths",
                    "msg": "obsolete parameter use `paths`",
                },
            ],
            "rename_placeholder": [
                {"placeholder": "paths", "new": "path", "format_strings": ["format"]}
            ],
        }

    def post_config_hook(self):
        if not self.paths:
            raise Exception(STRING_NO_PATHS)

        # icon deprecation
        on = getattr(self, "icon_available", "\u25cf")
        off = getattr(self, "icon_unavailable", "\u25a0")
        new_icon = rf"\?color=path [\?if=path {on}|{off}]"
        self.format = self.format.replace("{icon}", new_icon)

        # convert str to list + expand path
        if not isinstance(self.paths, list):
            self.paths = [self.paths]
        self.paths = [Path(path).expanduser() for path in self.paths]

        self.init = {"format_path": []}
        if self.py3.format_contains(self.format, "format_path"):
            self.init["format_path"] = self.py3.get_placeholders_list(self.format_path)

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def file_status(self):
        # init data
        paths = sorted(files for path in self.paths for files in path.parent.glob(path.name))
        count_path = len(paths)
        format_path = None

        # format paths
        if self.init["format_path"]:
            new_data = []
            format_path_separator = self.py3.safe_format(self.format_path_separator)

            for pathname in paths:
                path = {}
                for key in self.init["format_path"]:
                    if key == "basename":
                        value = pathname.name
                    elif key == "pathname":
                        value = pathname
                    else:
                        continue
                    path[key] = self.py3.safe_format(value)
                new_data.append(self.py3.safe_format(self.format_path, path))

            format_path = self.py3.composite_join(format_path_separator, new_data)

        for x in self.thresholds_init:
            if x in ["path", "paths"]:
                self.py3.threshold_get_color(count_path, x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(
                self.format,
                {"path": count_path, "paths": count_path, "format_path": format_path},
            ),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/frame.py
================================================
"""
Group modules and treat them as a single one.

This can be useful for example when adding modules to a group and you wish two
modules to be shown at the same time.

By adding the `{button}` placeholder in the format you can enable a toggle
button to hide or show the content.

Configuration parameters:
    button_toggle: Button used to toggle if one in format.
        Setting to None disables (default 1)
    format: Display format to use (default '{output}')
    format_button_closed: Format for the button when frame open (default '+')
    format_button_open: Format for the button when frame closed (default '-')
    format_separator: Specify separator between contents.
        If this is None then the default i3bar separator will be used
        (default None)
    open: If button then the frame can be set to be open or close
        (default True)

Format placeholders:
    {button} If used a button will be used that can be clicked to hide/show
        the contents of the frame.
    {output} The output of the modules in the frame
    {output_xxx} The output of the module xxx (even if the button is currently
        toggled off).

Examples:
```
# A frame showing times in different cities.
# We also have a button to hide/show the content
frame time {
    format = '{output}{button}'
    format_separator = ' '  # have space instead of usual i3bar separator

    tztime la {
        format = "LA %H:%M"
        timezone = "America/Los_Angeles"
    }
    tztime ny {
        format = "NY %H:%M"
        timezone = "America/New_York"
    }
    tztime du {
        format = "DU %H:%M"
        timezone = "Asia/Dubai"
    }
}

# Define a group which shows volume and battery info or the current time.
# The frame, volume_status and battery_level modules are named to prevent
# them clashing with any other defined modules of the same type.
group {
    frame {
        volume_status {}
        battery_level {}
    }
    time {}
}

# Define a group where the button is colored only if sub module has some output
frame ipv6 {
    format = "[\\?if=output_ipv6 {output}{button}|\\?color=#bad {output}{button}]"
    open = false

    ipv6 {
        format_up = "%ip"
        format_down = ""
    }
}
```

@author tobes

SAMPLE OUTPUT
[
    {'full_text': u'module 1', 'separator': True},
    {'full_text': u'module 2', 'separator': True},
    {'full_text': u'module 3', 'separator': True},
    {'full_text': u'-', 'separator': True}
]

closed
{'full_text': u'+'}

"""


class Py3status:
    """ """

    # available configuration parameters
    button_toggle = 1
    format = "{output}"
    format_button_closed = "+"
    format_button_open = "-"
    format_separator = None
    open = True

    class Meta:
        container = True

    def post_config_hook(self):
        self.urgent = False
        if not self.py3.format_contains(self.format, "button"):
            self.open = True
        self.py3.register_function("urgent_function", self._urgent_function)

    def _urgent_function(self, module_list):
        self.urgent = True

    def frame(self):
        if not self.items:
            return {"full_text": "", "cached_until": self.py3.CACHE_FOREVER}

        # get the child modules output.
        composites = {}
        output = []
        if self.format_separator:
            format_separator = self.py3.safe_format(self.format_separator)
        for item in self.items:
            out = self.py3.get_output(item)[:]
            for o in out:
                composites["output_" + o["name"]] = o["full_text"]
            if self.format_separator is None:
                if out and "separator" not in out[-1]:
                    # we copy the item as we do not want to change the
                    # original.
                    last_item = out[-1].copy()
                    last_item["separator"] = True
                    out[-1] = last_item
            elif self.format_separator:
                out += format_separator
            output += out

        # Remove last separator
        if self.format_separator:
            output = output[:-1]
        if self.open:
            urgent = False
        else:
            urgent = self.urgent

        if self.py3.format_contains(self.format, "button"):
            if self.open:
                format_control = self.format_button_open
            else:
                format_control = self.format_button_closed

            button = {"full_text": format_control, "index": "button"}
        else:
            button = None

        composites.update(
            {
                "output": self.py3.composite_create(output if self.open else []),
                "button": self.py3.composite_create(button),
            }
        )
        output = self.py3.safe_format(self.format, composites)
        response = {"cached_until": self.py3.CACHE_FOREVER, "full_text": output}

        if urgent:
            response["urgent"] = urgent

        return response

    def on_click(self, event):
        """
        Switch the displayed module or pass the event on to the active module
        """
        if event["button"] == self.button_toggle:
            # we only toggle if button was used
            if event.get("index") == "button" and self.py3.is_my_event(event):
                self.urgent = False
                self.open = not self.open


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/getjson.py
================================================
"""
Display JSON data fetched from a URL.

This module gets the given `url` configuration parameter and assumes the
response is a JSON object. The keys of the JSON object are used as the format
placeholders. The format placeholders are replaced by the value. Objects that
are nested can be accessed by using the `delimiter` configuration parameter
in between.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 30)
    delimiter: the delimiter between parent and child objects (default '-')
    format: display format for this module (default None)
    password: basic auth password information (default None)
    url: specify URL to fetch JSON from (default None)
    username: basic auth user information (default None)

Format placeholders:
    Placeholders will be replaced by the JSON keys.

    Placeholders for objects with sub-objects are flattened using 'delimiter'
    in between (eg. {'parent': {'child': 'value'}} will use placeholder
    {parent-child}).

    Placeholders for list elements have 'delimiter' followed by the index
    (eg. {'parent': ['this', 'that']) will use placeholders {parent-0}
    for 'this' and {parent-1} for 'that'.

Examples:
```
# straightforward key replacement
getjson {
    url = "https://ifconfig.co/json"
    format = "{latitude}, {longitude}"
}

# access child objects
getjson {
    url = 'https://api.icndb.com/jokes/random'
    format = '{value-joke}'
}

# access title from 0th element of articles list
getjson {
    url = 'https://newsapi.org/v1/articles?source=bbc-news&sortBy=top&apiKey={KEY}'
    format = '{articles-0-title}'
}

# access if top-level object is a list
getjson {
    url = 'https://jsonplaceholder.typicode.com/posts/1/comments'
    format = '{0-name}'
}
```

@author vicyap

SAMPLE OUTPUT
{'full_text': 'Github: Everything operating normally'}
"""

STRING_ERROR = "missing url"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 30
    delimiter = "-"
    format = None
    password = None
    url = None
    username = None

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "timeout",
                    "new": "request_timeout",
                    "msg": "obsolete parameter use `request_timeout`",
                }
            ]
        }

    def post_config_hook(self):
        if not self.url:
            raise Exception(STRING_ERROR)

    def getjson(self):
        """ """
        try:
            if self.username is not None and self.password is not None:
                auth = (self.username, self.password)
            else:
                auth = None
            json_data = self.py3.request(self.url, auth=auth).json()
            json_data = self.py3.flatten_dict(json_data, self.delimiter, True)
        except self.py3.RequestException:
            json_data = None

        if json_data:
            full_text = self.py3.safe_format(self.format, json_data)
        else:
            full_text = ""

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": full_text,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/github.py
================================================
"""
Display Github notifications and issue/pull requests for a repo.

To check notifications a Github `username` and `personal access token` are
required.  You can create a personal access token at
https://github.com/settings/tokens/new?scopes=notifications&description=py3status
The only `scope` needed is `notifications` is selected automatically for you,
which provides readonly access to notifications.

The Github API is rate limited so setting `cache_timeout` too small may cause
issues see https://developer.github.com/v3/#rate-limiting for details

Configuration parameters:
    auth_token: Github personal access token, needed to check notifications
        see above.
        (default None)
    button_action: Button that when clicked opens the Github notification page
        if notifications, else the project page for the repository if there is
        one (otherwise the github home page). Setting to `None` disables.
        (default 3)
    button_refresh: Button that when clicked refreshes module.
        Setting to `None` disables.
        (default 2)
    cache_timeout: How often we refresh this module in seconds
        (default 60)
    format: display format for this module, see Examples below (default None)
    format_notifications: Format of `{notification}` status placeholder.
        (default ' N{notifications_count}')
    notifications: Type of notifications can be `all` for all notifications or
        `repo` to only get notifications for the repo specified.  If repo is
        not provided then all notifications will be checked.
        (default 'all')
    repo: Github repo to check
        (default 'ultrabug/py3status')
    url_api: Change only if using Enterprise Github, example https://github.domain.com/api/v3.
        (default 'https://api.github.com')
    url_base: Change only if using Enterprise Github, example https://github.domain.com.
        (default 'https://github.com')
    username: Github username, needed to check notifications.
        (default None)

Format placeholders:
    {issues} Number of open issues.
    {notifications} Notifications.  If no notifications this will be empty.
    {notifications_count} Number of notifications.  This is also the __Only__
        placeholder available to `format_notifications`.
    {pull_requests} Number of open pull requests
    {repo} short name of the repository being checked. eg py3status
    {repo_full} full name of the repository being checked. eg ultrabug/py3status

Examples:
```
# default formats
github {
    # with username and auth_token, this will be used
    format = '{repo} {issues}/{pull_requests}{notifications}'

    # otherwise, this will be used
    format '{repo} {issues}/{pull_requests}'
}

# set github access credentials
github {
    auth_token = '40_char_hex_access_token'
    username = 'my_username'
}

# just check for any notifications
github {
    auth_token = '40_char_hex_access_token'
    username = 'my_username'
    format = 'Github {notifications_count}'
}
```

@author tobes

SAMPLE OUTPUT
{'full_text': 'py3status 34/24'}

notification
{'full_text': 'py3status 34/24 N3', 'urgent': True}
"""

import urllib.parse as urlparse


class Py3status:
    """ """

    # available configuration parameters
    auth_token = None
    button_action = 3
    button_refresh = 2
    cache_timeout = 60
    format = None
    format_notifications = " N{notifications_count}"
    notifications = "all"
    repo = "ultrabug/py3status"
    url_api = "https://api.github.com"
    url_base = "https://github.com"
    username = None

    def post_config_hook(self):
        self.notification_warning = False
        self.repo_warning = False
        self._issues = "?"
        self._pulls = "?"
        self._notify = "?"
        # remove a trailing slash in the urls
        self.url_api = self.url_api.strip("/")
        self.url_base = self.url_base.strip("/")

        # Set format if user has not configured it.
        if not self.format:
            if self.username and self.auth_token:
                # include notifications
                self.format = "{repo} {issues}/{pull_requests}{notifications}"
            else:
                self.format = "{repo} {issues}/{pull_requests}"

    def _github_count(self, url):
        """
        Get counts for requests that return 'total_count' in the json response.
        """
        url = self.url_api + url + "&per_page=1"
        # if we have authentication details use them as we get better
        # rate-limiting.
        if self.username and self.auth_token:
            auth = (self.username, self.auth_token)
        else:
            auth = None
        try:
            info = self.py3.request(url, auth=auth)
        except self.py3.RequestException:
            return
        if info and info.status_code == 200:
            return int(info.json()["total_count"])
        if info.status_code == 422:
            if not self.repo_warning:
                self.py3.notify_user("Github repo cannot be found.")
                self.repo_warning = True
        return "?"

    def _notifications(self):
        """
        Get the number of unread notifications.
        """
        if not self.username or not self.auth_token:
            if not self.notification_warning:
                self.py3.notify_user(
                    "Github module needs username and " "auth_token to check notifications."
                )
                self.notification_warning = True
            return "?"
        if self.notifications == "all" or not self.repo:
            url = self.url_api + "/notifications"
        else:
            url = self.url_api + "/repos/" + self.repo + "/notifications"
        url += "?per_page=100"
        try:
            info = self.py3.request(url, auth=(self.username, self.auth_token))
        except self.py3.RequestException:
            return
        if info.status_code == 200:
            links = info.headers.get("Link")

            if not links:
                return len(info.json())

            last_page = 1
            for link in links.split(","):
                if 'rel="last"' in link:
                    last_url = link[link.find("<") + 1 : link.find(">")]
                    parsed = urlparse.urlparse(last_url)
                    last_page = int(urlparse.parse_qs(parsed.query)["page"][0])

            if last_page == 1:
                return len(info.json())
            try:
                last_page_info = self.py3.request(last_url, auth=(self.username, self.auth_token))
            except self.py3.RequestException:
                return

            return len(info.json()) * (last_page - 1) + len(last_page_info.json())

        if info.status_code == 404:
            if not self.repo_warning:
                self.py3.notify_user("Github repo cannot be found.")
                self.repo_warning = True

    def github(self):
        status = {}
        urgent = False
        # issues
        if self.repo and self.py3.format_contains(self.format, "issues"):
            url = "/search/issues?q=state:open+type:issue+repo:" + self.repo
            self._issues = self._github_count(url) or self._issues
        status["issues"] = self._issues
        # pull requests
        if self.repo and self.py3.format_contains(self.format, "pull_requests"):
            url = "/search/issues?q=state:open+type:pr+repo:" + self.repo
            self._pulls = self._github_count(url) or self._pulls
        status["pull_requests"] = self._pulls
        # notifications
        if self.py3.format_contains(self.format, "notifications*"):
            count = self._notifications()
            # if we don't have a notification count, then use the last value
            # that we did have.
            if count is None:
                count = self._notify
            self._notify = count
            if count and count != "?":
                notify = self.py3.safe_format(
                    self.format_notifications, {"notifications_count": count}
                )
                urgent = True
            else:
                notify = ""
            status["notifications"] = notify
            status["notifications_count"] = count
        # repo
        try:
            status["repo"] = self.repo.split("/")[1]
        except IndexError:
            status["repo"] = "Error"
        status["repo_full"] = self.repo

        cached_until = self.py3.time_in(self.cache_timeout)

        return {
            "full_text": self.py3.safe_format(self.format, status),
            "cached_until": cached_until,
            "urgent": urgent,
        }

    def on_click(self, event):
        button = event["button"]
        if button == self.button_action:
            # open github in browser
            if self._notify and self._notify != "?":
                # open github notifications page
                url = self.url_base + "/notifications"
            else:
                if self.notifications == "all" and not self.repo:
                    # open github.com if there are no unread notifications and no repo
                    url = self.url_base
                else:
                    # open repo page if there are no unread notifications
                    url = self.url_base + "/" + self.repo
            # open url in default browser
            self.py3.command_run(f"xdg-open {url}")
            self.py3.prevent_refresh()
        elif button != self.button_refresh:
            # only refresh the module if needed
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/gitlab.py
================================================
r"""
Display number of issues, requests and more from a GitLab project.

A token is required. See https://gitlab.com/profile/personal_access_tokens
to make one. Make a name, eg py3status, and enable api in scopes. Save.

Configuration parameters:
    auth_token: specify a personal access token to use (default None)
    button_open: mouse button to open project url (default 1)
    button_refresh: mouse button to refresh this module (default 2)
    cache_timeout: refresh interval for this module (default 900)
    format: display format for this module
        *(default '[{name} ][[{open_issues_count}][\?soft /]'
        '[{open_merge_requests_count}]]')*
    project: specify a project to use (default 'gitlab-org/gitlab-ce')
    thresholds: specify color thresholds to use (default [])

Format placeholders:
    See `sp` below for a full list of supported GitLab placeholders to use.
    Not all of GitLab placeholders will be usable.

    single_project:
        {name}                      project name, eg py3status
        {star_count}                number of stars, eg 2
        {forks_count}               number of forks, eg 3
        {open_issues_count}         number of open issues, eg 4
        {statistics_commit_count}   number of commits, eg 5678
    merge_requests:
        {open_merge_requests_count} number of open merge requests, eg 9
    todos:
        {todos_count}               number of todos, eg 4
    pipelines:
        {pipelines_status}          project status of pipelines, eg success

Notes:
    sp: https://docs.gitlab.com/ee/api/projects.html#get-single-project
    mr: https://docs.gitlab.com/ee/api/merge_requests.html
    td: https://docs.gitlab.com/ee/api/todos.html
    pipe: https://docs.gitlab.com/ee/api/pipelines.html

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Examples:
```
# follow a fictional project, add an icon
gitlab {
    auth_token = 'abcdefghijklmnopq-a4'
    project = 'https://gitlab.com/ultrabug/py3status'

    format = '[\?if=name [\?color=orangered&show ] {name} ]'
    format += '[[{open_issues_count}][\?soft /]'
    format += '[{open_merge_requests_count}][\?soft /]'
    format += '[{pipelines_status}]]'
}
```

@author lasers, Cyril Levis (@cyrinux)

SAMPLE OUTPUT
{'full_text': 'py3status 48/49'}
"""

STRING_ERROR_AUTH = "missing auth_token"


class Py3status:
    """ """

    # available configuration parameters
    auth_token = None
    button_open = 1
    button_refresh = 2
    cache_timeout = 900
    format = r"[{name} ][[{open_issues_count}][\?soft /]" "[{open_merge_requests_count}]]"
    project = "gitlab-org/gitlab-ce"
    thresholds = []

    def post_config_hook(self):
        if not self.auth_token:
            raise Exception(STRING_ERROR_AUTH)
        if not self.project.startswith("http"):
            self.project = "https://gitlab.com/" + self.project

        # make urls
        self.project = self.project.strip("/")
        base_api = self.project.rsplit("/", 2)[0] + "/api/v4/"
        uuid = "/" + "%2F".join(self.project.rsplit("/", 2)[1:])
        single_project = base_api + "projects" + uuid
        merge_requests = "/merge_requests?state=opened&view=simple&per_page=1"
        pipelines = "/pipelines"
        # url stuffs. header, timeout, dict, etc
        self.headers = {"PRIVATE-TOKEN": self.auth_token}
        self.url = {
            "single_project": single_project,
            "merge_requests": single_project + merge_requests,
            "todos": base_api + "todos",
            "pipelines": single_project + pipelines,
        }
        # add statistics to url too?
        if self.py3.format_contains(self.format, "statistics_*"):
            self.url["single_project"] += "/?statistics=true"

        # init placeholders
        self.init = {"thresholds": self.py3.get_color_names_list(self.format)}
        placeholders = self.py3.get_placeholders_list(self.format)
        for x in ["open_merge_requests_count", "todos_count", "pipelines_status"]:
            self.init[x] = x in placeholders
            if self.init[x]:
                placeholders.remove(x)
        self.init["single_project"] = bool(placeholders)

    def _get_data(self, url):
        try:
            return self.py3.request(url, headers=self.headers)
        except self.py3.RequestException:
            return {}

    def gitlab(self):
        gitlab_data = {}

        if self.init["single_project"]:
            data = self._get_data(self.url["single_project"])
            if data:
                gitlab_data.update(self.py3.flatten_dict(data.json(), "_"))

        if self.init["open_merge_requests_count"]:
            data = self._get_data(self.url["merge_requests"])
            if data:
                gitlab_data["open_merge_requests_count"] = data.headers.get("X-Total")

        if self.init["todos_count"]:
            data = self._get_data(self.url["todos"])
            if data:
                gitlab_data["todos_count"] = len(data.json())

        if self.init["pipelines_status"]:
            data = self._get_data(self.url["pipelines"])
            if data:
                gitlab_data["pipelines_status"] = data.json()[0]["status"]

        for x in self.init["thresholds"]:
            if x in gitlab_data:
                self.py3.threshold_get_color(gitlab_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, gitlab_data),
        }

    def on_click(self, event):
        button = event["button"]
        if button == self.button_open:
            self.py3.command_run(f"xdg-open {self.project}")
        if button != self.button_refresh:
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/glpi.py
================================================
"""
Display number of open tickets from GLPI.

It features thresholds to colorize the output and forces a low timeout to
limit the impact of a server connectivity problem on your i3bar freshness.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds (default 300)
    critical: set bad color above this threshold (default 20)
    db: database to use (default '')
    format: format of the module output (default '{tickets_open} tickets')
    host: database host to connect to (default '')
    password: login password (default '')
    timeout: timeout for database connection (default 5)
    user: login user (default '')
    warning: set degraded color above this threshold (default 15)

Format placeholders:
    {tickets_open} The number of open tickets

Color options:
    color_bad: Open ticket above critical threshold
    color_degraded: Open ticket above warning threshold

Requires:
    MySQL-python: https://pypi.org/project/MySQL-python/

@author ultrabug

SAMPLE OUTPUT
{'full_text': '53 tickets'}
"""

import MySQLdb


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 300
    critical = 20
    db = ""
    format = "{tickets_open} tickets"
    host = ""
    password = ""
    timeout = 5
    user = ""
    warning = 15

    def glpi(self):
        response = {"full_text": ""}

        mydb = MySQLdb.connect(
            host=self.host,
            user=self.user,
            passwd=self.password,
            db=self.db,
            connect_timeout=self.timeout,
        )
        mycr = mydb.cursor()
        mycr.execute(
            """select count(*)
                        from glpi_tickets
                        where closedate is NULL and solvedate is NULL;"""
        )
        row = mycr.fetchone()
        if row:
            open_tickets = int(row[0])
            if open_tickets > self.critical:
                response.update({"color": self.py3.COLOR_BAD})
            elif open_tickets > self.warning:
                response.update({"color": self.py3.COLOR_DEGRADED})
            response["full_text"] = self.py3.safe_format(
                self.format, {"tickets_open": open_tickets}
            )
        mydb.close()
        response["cached_until"] = self.py3.time_in(self.cache_timeout)

        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/google_calendar.py
================================================
"""
Display upcoming Google Calendar events.

This module will display information about upcoming Google Calendar events
in one of two formats which can be toggled with a button press. The event
URL may also be opened in a web browser with a button press.

Some events details can be retreived in the Google Calendar API Documentation.
https://developers.google.com/calendar/v3/reference/events

Configuration parameters:
    auth_token: The path to where the access/refresh token will be saved
        after successful credential authorization.
        (default '~/.config/py3status/google_calendar.auth_token')
    blacklist_events: Event names in this list will not be shown in the module
        (case insensitive).
        (default [])
    browser_invocation: Command to run to open browser. Curly braces stands for URL opened.
        (default "xdg-open {}")
    button_open: Opens the event URL in the default web browser.
        (default 3)
    button_refresh: Refreshes the module and updates the list of events.
        (default 2)
    button_toggle: Toggles a boolean to hide/show the data for each event.
        (default 1)
    cache_timeout: How often the module is refreshed in seconds
        (default 60)
    calendar_id: The ID of the calendar to display.
        (default "primary")
    client_secret: the path to your client_secret file which
        contains your OAuth 2.0 credentials.
        (default '~/.config/py3status/google_calendar.client_secret')
    events_within_hours: Select events within the next given hours.
        (default 12)
    force_lowercase: Sets whether to force all event output to lower case.
        (default False)
    format: The format for module output.
        (default '{events}|\\?color=event \u2687')
    format_date: The format for date related format placeholders.
        May be any Python strftime directives for dates.
        (default '%a %d-%m')
    format_event: The format for each event. The information can be toggled
        with 'button_toggle' based on the value of 'is_toggled'.
        *(default '[\\?color=event {summary}][\\?if=is_toggled  ({start_time}'
        ' - {end_time}, {start_date})|[ ({location})][ {format_timer}]]')*
    format_notification: The format for event warning notifications.
        (default '{summary} {start_time} - {end_time}')
    format_separator: The string used to separate individual events.
        (default ' \\| ')
    format_time: The format for time-related placeholders except `{format_timer}`.
        May use any Python strftime directives for times.
        (default '%I:%M %p')
    format_timer: The format used for the {format_timer} placeholder to display
        time until an event starts or time until an event in progress is over.
        *(default '\\?color=time ([\\?if=days {days}d ][\\?if=hours {hours}h ]'
        '[\\?if=minutes {minutes}m])[\\?if=is_current  left]')*
    ignore_all_day_events: Sets whether to display all day events or not.
        (default False)
    num_events: The maximum number of events to display.
        (default 3)
    preferred_event_link: link to open in the browser.
        accepted values :
        hangoutLink (open the VC room associated with the event),
        htmlLink (open the event's details in Google Calendar)
        fallback to htmlLink if the preferred_event_link does not exist it the event.
        (default "htmlLink")
    response: Only display events for which the response status is
        on the list.
        Available values in the Google Calendar API's documentation,
        look for the attendees[].responseStatus.
        (default ['accepted'])
    thresholds: Thresholds for events. The first entry is the color for event 1,
        the second for event 2, and so on.
        (default [])
    time_to_max: Threshold (in minutes) for when to display the `{format_timer}`
        string; e.g. if time_to_max is 60, `{format_timer}` will only be
        displayed for events starting in 60 minutes or less.
        (default 180)
    warn_threshold: The number of minutes until an event starts before a
        warning is displayed to notify the user; e.g. if warn_threshold is 30
        and an event is starting in 30 minutes or less, a notification will be
        displayed. disabled by default.
        (default 0)
    warn_timeout: The number of seconds before a warning should be issued again.
        (default 300)


Control placeholders:
    {is_toggled} a boolean toggled by button_toggle

Format placeholders:
    {events} All the events to display.

format_event and format_notification placeholders:
    {description} The description for the calendar event.
    {end_date} The end date for the event.
    {end_time} The end time for the event.
    {location} The location for the event.
    {start_date} The start date for the event.
    {start_time} The start time for the event.
    {summary} The summary (i.e. title) for the event.
    {format_timer} The time until the event starts (or until it is over
        if already in progress).

format_timer placeholders:
    {days} The number of days until the event.
    {hours} The number of hours until the event.
    {minutes} The number of minutes until the event.

Color options:
    color_event: Color for a single event.
    color_time: Color for the time associated with each event.

Requires:
    1. Python library google-api-python-client.
    2. Python library python-dateutil.
    3. OAuth 2.0 credentials for the Google Calendar api.

    Follow Step 1 of the guide here to obtain your OAuth 2.0 credentials:
    https://developers.google.com/google-apps/calendar/quickstart/python

    Download the client_secret.json file which contains your client ID and
    client secret. In your config file, set configuration parameter
    client_secret to the path to your client_secret.json file.

    The first time you run the module, a browser window will open asking you
    to authorize access to your calendar. After authorization is complete,
    an access/refresh token will be saved to the path configured in
    auth_token, and i3status will be restarted. This restart will
    occur only once after the first time you successfully authorize.

Examples:
```
# add color gradients for events and dates/times
google_calendar {
    thresholds = {
        'event': [(1, '#d0e6ff'), (2, '#bbdaff'), (3, '#99c7ff'),
            (4, '#86bcff'), (5, '#62a9ff'), (6, '#8c8cff'), (7, '#7979ff')],
        'time': [(1, '#ffcece'), (2, '#ffbfbf'), (3, '#ff9f9f'),
            (4, '#ff7f7f'), (5, '#ff5f5f'), (6, '#ff3f3f'), (7, '#ff1f1f')]
    }
}
```

@author Igor Grebenkov
@license BSD

SAMPLE OUTPUT
[
   {'full_text': "Homer's Birthday (742 Evergreen Terrace) (1h 23m) | "},
   {'full_text': "Doctor's Appointment | Lunch with John"},
]
"""

import datetime
import time
from pathlib import Path

import httplib2

try:
    from googleapiclient import discovery
except ImportError:
    from apiclient import discovery

from dateutil import parser
from dateutil.tz import tzlocal
from httplib2 import ServerNotFoundError
from oauth2client import client, clientsecrets, tools
from oauth2client.file import Storage

SCOPES = "https://www.googleapis.com/auth/calendar.readonly"
APPLICATION_NAME = "py3status google_calendar module"


class Py3status:
    """ """

    # available configuration parameters
    auth_token = "~/.config/py3status/google_calendar.auth_token"
    blacklist_events = []
    browser_invocation = "xdg-open {}"
    button_open = 3
    button_refresh = 2
    button_toggle = 1
    cache_timeout = 60
    calendar_id = "primary"
    client_secret = "~/.config/py3status/google_calendar.client_secret"
    events_within_hours = 12
    force_lowercase = False
    format = "{events}|\\?color=event \u2687"
    format_date = "%a %d-%m"
    format_event = (
        r"[\?color=event {summary}][\?if=is_toggled  ({start_time}"
        " - {end_time}, {start_date})|[ ({location})][ {format_timer}]]"
    )
    format_notification = "{summary} {start_time} - {end_time}"
    format_separator = r" \| "
    format_time = "%I:%M %p"
    format_timer = (
        r"\?color=time ([\?if=days {days}d ][\?if=hours {hours}h ]"
        r"[\?if=minutes {minutes}m])[\?if=is_current  left]"
    )
    ignore_all_day_events = False
    num_events = 3
    preferred_event_link = "htmlLink"
    response = ["accepted"]
    thresholds = []
    time_to_max = 180
    warn_threshold = 0
    warn_timeout = 300

    def post_config_hook(self):
        self.button_states = [False] * self.num_events
        self.events = None
        self.no_update = False

        self.client_secret = Path(self.client_secret).expanduser()
        self.auth_token = Path(self.auth_token).expanduser()

        self.credentials = self._get_credentials()
        self.is_authorized = False

    def _get_credentials(self):
        """
        Gets valid user credentials from storage.

        If nothing has been stored, or if the stored credentials are invalid,
        the OAuth2 flow is completed to obtain the new credentials.

        Returns: Credentials, the obtained credential.
        """
        client_secret_path = self.client_secret.parent
        auth_token_path = self.auth_token.parent

        auth_token_path.mkdir(parents=True, exist_ok=True)
        client_secret_path.mkdir(parents=True, exist_ok=True)

        flags = tools.argparser.parse_args(args=[])
        store = Storage(self.auth_token)
        credentials = store.get()

        if not credentials or credentials.invalid:
            try:
                flow = client.flow_from_clientsecrets(self.client_secret, SCOPES)
                flow.user_agent = APPLICATION_NAME
                if flags:
                    credentials = tools.run_flow(flow, store, flags)
                else:  # Needed only for compatibility with Python 2.6
                    credentials = tools.run(flow, store)
            except clientsecrets.InvalidClientSecretsError:
                raise Exception("missing client_secret")
            """
            Have to restart i3 after getting credentials to prevent bad output.
            This only has to be done once on the first run of the module.
            """
            self.py3.command_run(f"{self.py3.get_wm_msg()} restart")

        return credentials

    def _authorize_credentials(self):
        """
        Fetches an access/refresh token by authorizing OAuth 2.0 credentials.

        Returns: True, if the authorization was successful.
                 False, if a ServerNotFoundError is thrown.
        """
        try:
            http = self.credentials.authorize(httplib2.Http())
            self.service = discovery.build("calendar", "v3", http=http)
            return True
        except ServerNotFoundError:
            return False

    def _get_events(self):
        """
        Fetches events from the calendar into a list.

        Returns: The list of events.
        """
        self.last_update = time.monotonic()
        time_min = datetime.datetime.utcnow()
        time_max = time_min + datetime.timedelta(hours=self.events_within_hours)
        events = []

        try:
            eventsResult = (
                self.service.events()
                .list(
                    calendarId=self.calendar_id,
                    timeMax=time_max.isoformat() + "Z",  # 'Z' indicates UTC time
                    timeMin=time_min.isoformat() + "Z",  # 'Z' indicates UTC time
                    singleEvents=True,
                    orderBy="startTime",
                )
                .execute(num_retries=5)
            )
        except Exception:
            return self.events or events
        else:
            for event in eventsResult.get("items", []):
                # filter out events that we did not accept (default)
                # unless we organized them with no attendees
                i_organized = event.get("organizer", {}).get("self", False)
                has_attendees = event.get("attendees", [])
                for attendee in event.get("attendees", []):
                    if attendee.get("self") is True:
                        if attendee["responseStatus"] in self.response:
                            break
                else:
                    # we did not organize the event or we did not accept it
                    if not i_organized or has_attendees:
                        continue

                # strip and lower case output if needed
                for key in ["description", "location", "summary"]:
                    event[key] = event.get(key, "").strip()
                    if self.force_lowercase is True:
                        event[key] = event[key].lower()

                # ignore all day events if configured
                if event["start"].get("date") is not None:
                    if self.ignore_all_day_events:
                        continue

                # filter out blacklisted event names
                if event["summary"] is not None:
                    if event["summary"].lower() in (e.lower() for e in self.blacklist_events):
                        continue

                events.append(event)

        return events[: self.num_events]

    def _check_warn_threshold(self, time_to, event_dict):
        """
        Checks if the time until an event starts is less than or equal to the
        warn_threshold. If True, issue a warning with self.py3.notify_user.
        """
        if time_to["total_minutes"] <= self.warn_threshold:
            warn_message = self.py3.safe_format(self.format_notification, event_dict)
            self.py3.notify_user(warn_message, "warning", self.warn_timeout)

    def _gstr_to_date(self, date_str):
        """Returns a dateime object from calendar date string."""
        return parser.parse(date_str).replace(tzinfo=tzlocal())

    def _gstr_to_datetime(self, date_time_str):
        """Returns a datetime object from calendar date/time string."""
        return parser.parse(date_time_str)

    def _datetime_to_str(self, date_time, dt_format):
        """Returns a strftime formatted string from a datetime object."""
        return date_time.strftime(dt_format)

    def _delta_time(self, date_time):
        """
        Returns in a dict the number of days/hours/minutes and total minutes
        until date_time.
        """
        now = datetime.datetime.now(tzlocal())
        diff = date_time - now

        days = int(diff.days)
        hours = int(diff.seconds / 3600)
        minutes = int((diff.seconds / 60) - (hours * 60)) + 1
        total_minutes = int((diff.seconds / 60) + (days * 24 * 60)) + 1

        return {
            "days": days,
            "hours": hours,
            "minutes": minutes,
            "total_minutes": total_minutes,
        }

    def _format_timedelta(self, index, time_delta, is_current):
        """
        Formats the dict time_to containing days/hours/minutes until an
        event starts into a composite according to time_to_formatted.

        Returns: A formatted composite.
        """
        time_delta_formatted = ""

        if time_delta["total_minutes"] <= self.time_to_max:
            time_delta_formatted = self.py3.safe_format(
                self.format_timer,
                {
                    "days": time_delta["days"],
                    "hours": time_delta["hours"],
                    "minutes": time_delta["minutes"],
                    "is_current": is_current,
                },
            )

        return time_delta_formatted

    def _build_response(self):
        """
        Builds the composite response to be output by the module by looping
        through all events and formatting the necessary strings.

        Returns: A composite containing the individual response for each event.
        """
        responses = []
        self.event_urls = []

        for index, event in enumerate(self.events):
            self.py3.threshold_get_color(index + 1, "event")
            self.py3.threshold_get_color(index + 1, "time")

            event_dict = {}

            event_dict["summary"] = event.get("summary")
            event_dict["location"] = event.get("location")
            event_dict["description"] = event.get("description")
            self.event_urls.append(event.get(self.preferred_event_link, event.get("htmlLink")))

            if event["start"].get("date") is not None:
                start_dt = self._gstr_to_date(event["start"].get("date"))
                end_dt = self._gstr_to_date(event["end"].get("date"))
            else:
                start_dt = self._gstr_to_datetime(event["start"].get("dateTime"))
                end_dt = self._gstr_to_datetime(event["end"].get("dateTime"))

            if end_dt < datetime.datetime.now(tzlocal()):
                continue

            event_dict["start_time"] = self._datetime_to_str(start_dt, self.format_time)
            event_dict["end_time"] = self._datetime_to_str(end_dt, self.format_time)

            event_dict["start_date"] = self._datetime_to_str(start_dt, self.format_date)
            event_dict["end_date"] = self._datetime_to_str(end_dt, self.format_date)

            time_delta = self._delta_time(start_dt)
            if time_delta["days"] < 0:
                time_delta = self._delta_time(end_dt)
                is_current = True
            else:
                is_current = False

            event_dict["format_timer"] = self._format_timedelta(index, time_delta, is_current)

            if self.warn_threshold > 0:
                self._check_warn_threshold(time_delta, event_dict)

            event_formatted = self.py3.safe_format(
                self.format_event,
                {
                    "is_toggled": self.button_states[index],
                    "summary": event_dict["summary"],
                    "location": event_dict["location"],
                    "description": event_dict["description"],
                    "start_time": event_dict["start_time"],
                    "end_time": event_dict["end_time"],
                    "start_date": event_dict["start_date"],
                    "end_date": event_dict["end_date"],
                    "format_timer": event_dict["format_timer"],
                },
            )

            self.py3.composite_update(event_formatted, {"index": index})
            responses.append(event_formatted)

            self.no_update = False

        format_separator = self.py3.safe_format(self.format_separator)
        self.py3.composite_update(format_separator, {"index": "sep"})
        responses = self.py3.composite_join(format_separator, responses)

        return {"events": responses}

    def google_calendar(self):
        """
        The method that outputs the response.

        First, we check credential authorization. If no authorization, we
        display an error message, and try authorizing again in 5 seconds.

        Otherwise, we fetch the events, build the response, and output
        the resulting composite.
        """
        composite = {}

        if not self.is_authorized:
            cached_until = 0
            self.is_authorized = self._authorize_credentials()
        else:
            if not self.no_update:
                self.events = self._get_events()

            composite = self._build_response()
            cached_until = self.cache_timeout

        return {
            "cached_until": self.py3.time_in(cached_until),
            "composite": self.py3.safe_format(self.format, composite),
        }

    def on_click(self, event):
        if self.is_authorized and self.events is not None:
            """
            If button_refresh is clicked, we allow the events to be updated
            if the last event update occurred at least 1 second ago. This
            prevents a bug that can crash py3status since refreshing the
            module too fast results in incomplete event information being
            fetched as _get_events() is called repeatedly.

            Otherwise, we disable event updates.
            """
            self.no_update = True
            button = event["button"]
            button_index = event["index"]

            if button_index == "sep":
                self.py3.prevent_refresh()
            elif button == self.button_refresh:
                # wait before the next refresh
                if time.monotonic() - self.last_update > 1:
                    self.no_update = False
            elif button == self.button_toggle:
                self.button_states[button_index] = not self.button_states[button_index]
            elif button == self.button_open:
                if self.event_urls:
                    self.py3.command_run(
                        self.browser_invocation.format(self.event_urls[button_index])
                    )
                self.py3.prevent_refresh()
            else:
                self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/graphite.py
================================================
"""
Display Graphite metrics.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds.
        (default 120)
    datapoint_selection: when multiple data points are returned,
        use "max" or "min" to determine which one to display.
        (default "max")
    format: you MUST use placeholders here to display data, see below.
        (default '')
    graphite_url: URL to your graphite server. (default '')
    http_timeout: HTTP query timeout to graphite.
        (default 10)
    proxy: You can configure the proxy with HTTP or HTTPS.
        examples:
            proxy = 'https://myproxy.example.com:1234/'
            proxy = 'http://user:passwd@myproxy.example.com/'
            proxy = 'socks5://user:passwd@host:port'
        (proxy_socks is available after an 'pip install requests[socks]')
        (default None)
    targets: semicolon separated list of targets to query graphite for.
        (default '')
    threshold_bad: numerical threshold,
        if set will send a notification and colorize the output.
        (default None)
    threshold_degraded: numerical threshold,
        if set will send a notification and colorize the output.
        (default None)
    timespan: time range to query graphite for.
        (default "-2minutes")
    value_comparator: choose between "max" and "min" to compare thresholds
        to the data point value.
        (default "max")
    value_format: pretty format long numbers with "K", "M" etc.
        (default True)
    value_round: round values so they're not displayed as floats.
        (default True)

Dynamic format placeholders:
        The "format" parameter placeholders are dynamically based on the data
        points names returned by the "targets" query to graphite.

    For example if your target is `"carbon.agents.localhost-a.memUsage"`,
    you'd get a JSON result like this:

        ```
        {
            "target": "carbon.agents.localhost-a.memUsage",
            "datapoints": [[19693568.0, 1463663040]]
        }
        ```

    So the placeholder you could use on your "format" config is:
        `format = "{carbon.agents.localhost-a.memUsage}"`

    TIP: use aliases !
        ```
        targets = "alias(carbon.agents.localhost-a.memUsage, 'local_memuse')"
        format = "local carbon mem usage: {local_memuse} bytes"
        ```

Color options:
    color_bad: threshold_bad has been exceeded
    color_degraded: threshold_degraded has been exceeded

@author ultrabug

SAMPLE OUTPUT
{'full_text': '412 req/s'}
"""

from syslog import LOG_INFO, syslog

from requests import get


def format_value(num, value_round=True):
    for unit in ["", "K", "M", "G", "T", "P", "E", "Z"]:
        if abs(num) < 1000:
            if value_round:
                return f"{num:1.0f}{unit}"
            else:
                return f"{num:3.1f}{unit}"
        num /= 1000
    if value_round:
        return "{:.0f}{}".format(num, "Y")
    else:
        return "{:.1f}{}".format(num, "Y")


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 120
    datapoint_selection = "max"
    format = ""
    graphite_url = ""
    http_timeout = 10
    proxy = None
    targets = ""
    threshold_bad = None
    threshold_degraded = None
    timespan = "-2minutes"
    value_comparator = "max"
    value_format = True
    value_round = True

    def post_config_hook(self):
        self._validate_config()

    def _validate_config(self):
        if not self.format:
            raise ValueError('missing "format" configuration')
        if not self.graphite_url:
            raise ValueError('missing "graphite_url" configuration')
        if not self.targets:
            raise ValueError('missing "targets" configuration')
        if self.datapoint_selection not in ["max", "min"]:
            raise ValueError('invalid "datapoint_selection" configuration')
        if self.value_comparator not in ["max", "min"]:
            raise ValueError('invalid "value_comparator" configuration')

    def _render_graphite_json(self):
        params = [("format", "json"), ("from", self.timespan)]
        for target in self.targets.split(";"):
            params.append(("target", target))

        proxies = {}
        if self.proxy:
            if self.proxy.startswith("https"):
                proxies["https"] = self.proxy
            else:
                proxies["http"] = self.proxy

        r = get(
            f"{self.graphite_url}/render",
            params,
            timeout=self.http_timeout,
            proxies=proxies,
        )
        if r.status_code != 200:
            raise Exception(f"HTTP error {r.status_code}")
        else:
            color_key = "good"
            r_json = {}
            for metric in r.json():
                value = None
                target = metric["target"]
                for datapoint_list in metric["datapoints"]:
                    point, timestamp = datapoint_list
                    if point is not None:
                        if value is None:
                            value = point
                        elif self.datapoint_selection == "max":
                            value = max(value, point)
                        elif self.datapoint_selection == "min":
                            value = min(value, point)

                if value is None:
                    syslog(
                        LOG_INFO,
                        "graphite module: no data for target {} with configuration {}".format(
                            target, self.targets
                        ),
                    )
                    continue

                if self.value_format:
                    displayed_value = format_value(value, self.value_round)
                else:
                    displayed_value = value

                # compare this value to the configured thresholds
                # and use the worst color to display
                _color = self._check_threshold_and_get_color(displayed_value, target, value)
                if _color == "bad":
                    color_key = "bad"
                elif _color == "degraded" and color_key != "bad":
                    color_key = "degraded"

                r_json[target] = displayed_value
            return color_key, r_json

    def _reset_notifications(self):
        self.notification_level = "info"
        self.notifications = []

    def _store_notification(self, target, threshold, value):
        if self.value_comparator == "max":
            msg = f"{target}: {value} > {threshold}"
        elif self.value_comparator == "min":
            msg = f"{target}: {value} < {threshold}"
        self.notifications.append(msg)

    def _notify_user(self):
        if self.notifications:
            self.py3.notify_user("\n".join(self.notifications), level=self.notification_level)

    def _check_threshold_and_get_color(self, displayed_value, target, value):
        func = {"max": max, "min": min}
        if self.threshold_bad:
            test = func[self.value_comparator](self.threshold_bad, value)
            if test == value:
                self._store_notification(target, self.threshold_bad, displayed_value)
                self.notification_level = "error"
                return "bad"
        if self.threshold_degraded:
            test = func[self.value_comparator](self.threshold_degraded, value)
            if test == value:
                self._store_notification(target, self.threshold_degraded, displayed_value)
                return "degraded"
        return "good"

    def graphite(self):
        self._reset_notifications()

        color_key, r_json = self._render_graphite_json()
        self._notify_user()

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": getattr(self.py3, f"COLOR_{color_key.upper()}"),
            "full_text": self.py3.safe_format(self.format, r_json),
        }
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/group.py
================================================
"""
Group modules and switch between them.

Groups can be configured in your config. The active one of these groups is
shown in the i3bar.  The active group can be changed by a user click.  If the
click is not used by the group module then it will be passed down to the
displayed module.

Modules can be i3status core modules or py3status modules.  The active group
can be cycled through automatically.

The group can handle clicks by reacting to any that are made on it or its
content or it can use a button and only respond to clicks on that.
The way it does this is selected via the `click_mode` option.

Configuration parameters:
    align: Text alignment when fixed_width is set
        can be 'left', 'center' or 'right' (default 'center')
    button_next: Button that when clicked will switch to display next module.
        Setting to `0` will disable this action. (default 5)
    button_prev: Button that when clicked will switch to display previous
        module.  Setting to `0` will disable this action. (default 4)
    button_toggle: Button that when clicked toggles the group content being
        displayed between open and closed.
        This action is ignored if `{button}` is not in the format.
        Setting to `0` will disable this action (default 1)
    click_mode: This defines how clicks are handled by the group.
        If set to `all` then the group will respond to all click events.  This
        may cause issues with contained modules that use the same clicks that
        the group captures.  If set to `button` then only clicks that are
        directly on the `{button}` are acted on.  The group
        will need `{button}` in its format.
        (default 'all')
    cycle: Time in seconds till changing to next module to display.
        Setting to `0` will disable cycling. (default 0)
    fixed_width: Reduce the size changes when switching to new group
        (default False)
    format: display format for this module, see Examples below (default None)
    format_button_closed: Format for the button when group open
        (default  '+')
    format_button_open: Format for the button when group closed
        (default '-')
    format_closed: Format for module output when closed.
        (default "{button}")
    open: Is the group open and displaying its content. Has no effect if
        `{button}` not in format (default True)

Format placeholders:
    {button} The button to open/close or change the displayed group
    {output} Output of current active module

Examples:
```
# default formats
group {
    format = '{output}'           # if click_mode is 'all'
    format = '{output} {button}'  # if click_mode is 'button'
}

# Create a disks group that will show space on '/' and '/home'
# Change between disk modules every 30 seconds
order += "group disks"
group disks {
    cycle = 30
    format = "Disks: {output} {button}"
    click_mode = "button"

    disk "/" {
        format = "/ %avail"
    }
    disk "/home" {
        format = "/home %avail"
    }
}
```

@author tobes

SAMPLE OUTPUT
{'full_text': 'module 1'}

cycle
{'full_text': 'module 2'}

cycle_again
{'full_text': 'module 3'}
"""

import time

# maximum wait for initial content at startup
MAX_NO_CONTENT_WAIT = 5
STRING_ERROR = "missing modules"


class Py3status:
    """ """

    # available configuration parameters
    align = "center"
    button_next = 5
    button_prev = 4
    button_toggle = 1
    click_mode = "all"
    cycle = 0
    fixed_width = False
    format = None
    format_button_closed = "+"
    format_button_open = "-"
    format_closed = "{button}"
    open = True

    class Meta:
        container = True

    def post_config_hook(self):
        if not self.items:
            raise Exception(STRING_ERROR)

        self.first_run = True
        self.active = 0
        self.cycle_time = time.monotonic() + self.cycle
        self.cycle_timeout = self.cycle
        self.last_active = 0
        self.urgent = False
        self.urgent_history = {}

        # set default format etc based on click_mode
        if self.format is None:
            if self.click_mode == "button":
                self.format = "{output} {button}"
            else:
                self.format = "{output}"
        # if no button then force open
        if not self.py3.format_contains(self.format, "button"):
            self.open = True
        self.py3.register_function("content_function", self._content_function)
        self.py3.register_function("urgent_function", self._urgent_function)

    def _content_function(self):
        """
        This returns a set containing the actively shown module.
        This is so we only get update events triggered for these modules.
        """
        # ensure that active is valid
        self.active = self.active % len(self.items)

        return {self.items[self.active]}

    def _urgent_function(self, module_list):
        """
        A contained module has become urgent.
        We want to display it to the user.
        """
        for module in module_list:
            if module in self.items:
                self.active = self.items.index(module)
                self.urgent = True

    def _get_output(self):
        if not self.fixed_width:
            return self.py3.get_output(self.items[self.active])
        # fixed width we need to find the width of all outputs
        # and then pad with spaces to make correct width.
        current = []
        widths = []
        for i, item in enumerate(self.items):
            output = self.py3.get_output(item)
            if not output:
                widths.append(0)
            else:
                widths.append(sum(len(x["full_text"]) for x in output))
            if i == self.active:
                current = output
                current_width = widths[-1]
        if widths and current:
            width = max(widths)
            padding = " " * (width - current_width)
            if self.align == "right":
                current[0]["full_text"] = padding + current[0]["full_text"]
            elif self.align == "center":
                cut = len(padding) // 2
                current[0]["full_text"] = padding[:cut] + current[0]["full_text"]
                current[-1]["full_text"] += padding[cut:]
            else:
                current[-1]["full_text"] += padding
        return current

    def _change_active(self, delta):
        # we want to skip empty outputs. to prevent endless cycling,
        # we limit ourselves to only going through the outputs once.
        self.active = (self.active + delta) % len(self.items)
        if not self._get_output() and self.last_active != self.active:
            self._change_active(delta)
        self.last_active = self.active

    def _get_output_and_time(self):
        # get an output. again if empty (twice).
        for _ in range(3):
            output = self._get_output()
            if output:
                update_time = None
                break
            elif not self.first_run:
                self._change_active(1)
        else:
            update_time = MAX_NO_CONTENT_WAIT

        return output, update_time

    def group(self):
        output, update_time = self._get_output_and_time()

        # check for urgents
        urgent = output and output[0].get("urgent")
        self.urgent_history[self.active] = urgent
        mod_urgent = any(self.urgent_history.values())

        # keep cycling if defined and no urgent
        self.cycle = 0
        if self.first_run:
            self.first_run = False
            update_time = 1
        elif self.cycle_timeout and not urgent:
            current_time = time.monotonic()
            if current_time >= self.cycle_time - 0.1:
                self._change_active(1)
                output, update_time = self._get_output_and_time()
                self.cycle = self.cycle_timeout
                self.cycle_time = current_time + self.cycle
            else:
                self.cycle = self.cycle_time - current_time

        # time
        cached_until = update_time or self.cycle or self.py3.CACHE_FOREVER

        if self.open:
            format_control = self.format_button_open
            current_format = self.format
            urgent = False
        else:
            format_control = self.format_button_closed
            current_format = self.format_closed
            urgent = mod_urgent or self.urgent

        button = {"full_text": format_control, "index": "button"}
        response = {
            "cached_until": self.py3.time_in(cached_until),
            "full_text": self.py3.safe_format(
                current_format,
                {
                    "output": self.py3.composite_create(output),
                    "button": self.py3.composite_create(button),
                },
            ),
        }
        if urgent:
            response["urgent"] = urgent
            self.urgent = False
        return response

    def on_click(self, event):
        """
        Switch the displayed module or pass the event on to the active module
        """
        button = event["button"]
        index = event["index"]

        # if click_mode is button, prevent the contents from changing when
        # if the events are not registered on the button index. this allow
        # the users to interact with the modules via scrolling or clicking
        # without group getting in the way of the contents.
        if self.click_mode == "button":
            if not self.py3.is_my_event(event) or index != "button":
                return

        self.cycle = self.cycle_timeout
        self.cycle_time = time.monotonic() + self.cycle

        if button == self.button_next:
            if self.open:
                self._change_active(+1)
        elif button == self.button_prev:
            if self.open:
                self._change_active(-1)
        elif button == self.button_toggle:
            if index == "button":
                self.open = not self.open


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/hamster.py
================================================
"""
Display time tracking activities from Hamster.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds (default 10)
    format: see placeholders below (default '{current}')

Format placeholders:
    {current} current activity

Requires:
    hamster: time tracking application

@author Aaron Fields (spirotot [at] gmail.com)
@license BSD

SAMPLE OUTPUT
{'full_text': 'Watering flowers@Day-to-day (00:03)'}

inactive
{'full_text': 'No activity'}
"""

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{current}"

    def post_config_hook(self):
        if not self.py3.check_commands("hamster"):
            raise Exception(STRING_NOT_INSTALLED)

    def hamster(self):
        activity = self.py3.command_output("hamster current").strip()
        if activity != "No activity":
            activity = activity.split()
            time_elapsed = activity[-1]
            activity = activity[2:-1]
            activity = "{} ({})".format(" ".join(activity), time_elapsed)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"current": activity}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/hddtemp.py
================================================
r"""
Display hard drive temperatures.

hddtemp is a small utility with daemon that gives the hard drive temperature
via S.M.A.R.T. (Self-Monitoring, Analysis, and Reporting Technology). This
module requires the user-defined hddtemp daemon to be running at all times.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default '{format_hdd}')
    format_hdd: display format for hard drives
        (default '{name} [\?color=temperature {temperature}°{unit}]')
    format_separator: show separator if more than one (default ' ')
    thresholds: specify color thresholds to use
        *(default [(19, 'skyblue'), (24, 'deepskyblue'), (25, 'lime'),
        (41, 'yellow'), (46, 'orange'), (51, 'red'), (56, 'tomato')])*

Format placeholders:
    {format_hdd} format for hard drives

format_hdd placeholders:
    {name}        name, eg ADATA SP550
    {path}        path, eg /dev/sda
    {temperature} temperature, eg 32
    {unit}        temperature unit, eg C

Temperatures:
    Less than 25°C: Too cold     (color deepskyblue)
    25°C to 40°C: Ideal          (color good)
    41°C to 50°C: Acceptable     (color degraded)
    46°C to 50°C: Almost too hot (color orange)
    More than 50°C: Too hot      (color bad)

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    hddtemp: utility to monitor hard drive temperatures
    nc: netcat / ncat is command-line utility for reading data from hddtemp
         telnet interface

Bible of HDD failures:
    Hard disk temperatures higher than 45°C led to higher failure rates.
    Temperatures lower than 25°C led to higher failure rates as well.
    Aging hard disk drives (3 years and older) were much more prone to
    failure when their average temperatures were 40°C and higher.

    Hard disk manufacturers often state the operating temperatures of
    their hard disk drives to be between 0°C to 60°C. This can be misleading
    because what they mean is that your hard disk will function at these
    temperatures, but it doesn't tell you anything about how long they are
    going to survive at this range.
    http://www.buildcomputers.net/hdd-temperature.html

Backblaze:
    Overall, there is not a correlation between operating temperature and
    failure rates The one exception is the Seagate Barracuda 1.5TB drives,
    which fail slightly more when they run warmer. As long as you run drives
    well within their allowed range of operating temperatures, keeping them
    cooler doesn’t matter.
    https://www.backblaze.com/blog/hard-drive-temperature-does-it-matter/

Examples:
```
# compact the format
hddtemp {
    format = 'HDD {format_hdd}'
    format_hdd = '\?color=temperature {temperature}°C'
}

# show paths instead of names
hddtemp {
    format_hdd = '{path} [\?color=temperature {temperature}°{unit}]'
}

# show more colors
hddtemp {
    gradients = True
}
```

@author lasers

SAMPLE OUTPUT
[
    {'full_text': u'ADATA SP550 '},
    {'full_text': u'25°C ', 'color': '#00FF00'},
    {'full_text': u'SanDisk SDSSDA240 '},
    {'full_text': u'41°C', 'color': '#FFFF00'},
]

path
[
    {'full_text': '/dev/sda '}, {'color': '#00BFFF', u'full_text': '24°C '},
    {'full_text': '/dev/sdb '}, {'color': '#00FF00', u'full_text': '25°C '},
    {'full_text': '/dev/sdc '}, {'color': '#FF0000', u'full_text': '51°C'},
]

compact
[
    {'full_text': 'HDD '},
    {'color': '#87CEEB', u'full_text': '19°C '},
    {'color': '#00BFFF', u'full_text': '24°C '},
    {'color': '#00FF00', u'full_text': '25°C '},
    {'color': '#FFFF00', u'full_text': '41°C '},
    {'color': '#FFA500', u'full_text': '46°C '},
    {'color': '#FF0000', u'full_text': '51°C '},
    {'color': '#FF6347', u'full_text': '56°C'},
]
"""

from string import printable

STRING_NOT_INSTALLED = "shell command {} not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{format_hdd}"
    format_hdd = r"{name} [\?color=temperature {temperature}°{unit}]"
    format_separator = " "
    thresholds = [
        (19, "skyblue"),
        (24, "deepskyblue"),
        (25, "lime"),
        (41, "yellow"),
        (46, "orange"),
        (51, "red"),
        (56, "tomato"),
    ]

    def post_config_hook(self):
        if not self.py3.check_commands("hddtemp"):
            raise Exception(STRING_NOT_INSTALLED.format("hddtemp"))
        if not self.py3.check_commands("nc"):
            raise Exception(STRING_NOT_INSTALLED.format("netcat / ncat"))

        self.keys = ["path", "name", "temperature", "unit"]
        self.cache_names = {}
        self.thresholds_init = self.py3.get_color_names_list(self.format_hdd)

    def hddtemp(self):
        line = self.py3.command_output("nc localhost 7634")
        new_data = []

        for chunk in line[1:-1].split("||"):
            hdd = dict(zip(self.keys, chunk.split("|")))
            # workaround for hddtemp byte bug
            try:
                hdd["name"] = self.cache_names[hdd["name"]]
            except KeyError:
                key = "".join(x for x in hdd["name"] if x in printable).strip()
                if key.endswith("G B") and key[-4].isdigit():
                    key = "GB".join(key.rsplit("G B", 1))
                hdd["name"] = self.cache_names[hdd["name"]] = key

            for x in self.thresholds_init:
                if x in hdd:
                    self.py3.threshold_get_color(hdd[x], x)

            new_data.append(self.py3.safe_format(self.format_hdd, hdd))

        format_separator = self.py3.safe_format(self.format_separator)
        format_hdd = self.py3.composite_join(format_separator, new_data)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"format_hdd": format_hdd}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/hueshift.py
================================================
"""
Shift color temperature on the screen.

Configuration parameters:
    button_down: mouse button to decrease color temperature (default 5)
    button_toggle: mouse button to toggle color temperature (default 1)
    button_up: mouse button to increase color temperature (default 4)
    command: specify blueshift, redshift, or sct to use, otherwise auto
        (default None)
    delta: specify interval value to change color temperature (default 100)
    format: display format for this module
        *(default '{name} [\\?if=enabled&color=darkgray disabled'
        '|[\\?color=color_temperature {color_temperature}K]]')*
    maximum: specify maximum color temperature to use (default 25000)
    minimum: specify minimum color temperature to use (default 1000)
    thresholds: specify color thresholds to use
        (default [(6499, '#f6c'), (6500, '#ff6'), (6501, '#6cf')])

Control placeholders:
    {enabled} a boolean based on pgrep processing data, eg False, True

Format placeholders:
    {color_temperature} color temperature, eg 6500
    {name} name, eg Blueshift, Redshift, Sct

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    blueshift: an extensible and highly configurable alternative to redshift
    redshift: program to adjust the color temperature of your screen
    sct: set color temperature with about 40 lines of C or so

Suggestions:
    campfire: 4500
    dust storm on mars: 2000
    coffee free all nighter: 8000

Notes:
    hueshift can be disabled due to enabled running processes.
    sct and blueshift shifts only on one monitor, ideal for laptops.
    redshift shifts more than one, ideal for multi-monitors setups.

Examples:
```
# different theme
hueshift {
    format = '\\?color=color_temperature \u263c {color_temperature}K'
}

# for best results, add some limitations
hueshift {
    minimum = 3000
    maximum = 10000
}
```

@author lasers

SAMPLE OUTPUT
[{'full_text': 'Redshift '}, {'full_text': '3000K', 'color': '#ff33cc'}]

neutral
[{'full_text': 'Sct '},{'full_text': '6500K', 'color': '#ffff33'}]

cool
[{'full_text': 'Blueshift '}, {'full_text': '10000K', 'color': '#33ccff'}]
"""

STRING_BAD_COMMAND = "invalid command `{}`"
STRING_NOT_INSTALLED = "command `{}` not installed"
STRING_NOT_AVAILABLE = "no available command"


class Py3status:
    """ """

    # available configuration parameters
    button_down = 5
    button_toggle = 1
    button_up = 4
    command = None
    delta = 100
    format = (
        r"{name} [\?if=enabled&color=darkgray disabled"
        r"|[\?color=color_temperature {color_temperature}K]]"
    )
    maximum = 25000
    minimum = 1000
    thresholds = [(6499, "#f6c"), (6500, "#ff6"), (6501, "#6cf")]

    def post_config_hook(self):
        hueshift_commands = ["sct", "blueshift", "redshift"]
        self.pgrep_command = ["pgrep", "-x", "|".join(hueshift_commands)]
        if not self.command:
            self.command = self.py3.check_commands(hueshift_commands)
        elif self.command not in hueshift_commands:
            raise Exception(STRING_BAD_COMMAND.format(self.command))
        elif not self.py3.check_commands(self.command):
            raise Exception(STRING_NOT_INSTALLED.format(self.command))
        if not self.command:
            raise Exception(STRING_NOT_AVAILABLE)

        self.hue = {
            "blueshift": lambda v: ["blueshift", "-p", "-t", format(v)],
            "redshift": lambda v: ["redshift", "-r", "-P", "-O", format(v)],
            "sct": lambda v: ["sct", format(v)],
        }
        self.name = self.command.capitalize()
        self.default = 6500
        self.maximum = min(self.maximum, 25000)
        self.minimum = max(self.minimum, 1000)
        if self.command == "sct":
            self.maximum = min(self.maximum, 10000)

        self.color_temperature = self.last_value = (
            self.py3.storage_get("color_temperature") or self.default
        )
        self.last_command = None
        self._set_color_setter_boolean()
        if not self.is_color_setter_running:
            self._set_color_temperature(delta=0)

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def _set_color_setter_boolean(self):
        # to improve user experience, we prevent users from shifting color
        # temperature when there are running processes that can also shift
        # color temperature, eg blueshift, redshift, and sct.
        try:
            self.py3.command_output(self.pgrep_command)
            self.is_color_setter_running = True
        except self.py3.CommandError:
            self.is_color_setter_running = False

    def _set_color_temperature(self, delta=None):
        value = self.color_temperature
        if delta is None:  # toggle
            if value != self.default:
                self.last_value = value
                value = self.default
            else:
                value = self.last_value
        elif delta > 0:  # scroll up
            value = min(value + self.delta, self.maximum)
        elif delta < 0:  # scroll down
            value = max(value - self.delta, self.minimum)
        command = self.hue[self.command](value)
        # skip updating at end of range
        if command != self.last_command:
            self.last_command = command
            self.py3.command_run(command)
            self.color_temperature = value
        else:
            self.py3.prevent_refresh()

    def hueshift(self):
        hue_data = {
            "name": self.name,
            "color_temperature": self.color_temperature,
            "enabled": self.is_color_setter_running,
        }

        for x in self.thresholds_init:
            if x in hue_data:
                self.py3.threshold_get_color(hue_data[x], x)

        return {
            "cached_until": self.py3.CACHE_FOREVER,
            "full_text": self.py3.safe_format(self.format, hue_data),
        }

    def kill(self):
        self.py3.storage_set("color_temperature", self.color_temperature)

    def on_click(self, event):
        self._set_color_setter_boolean()
        if self.is_color_setter_running:
            return
        button = event["button"]
        if button == self.button_up:
            self._set_color_temperature(+1)
        elif button == self.button_down:
            self._set_color_temperature(-1)
        elif button == self.button_toggle:
            self._set_color_temperature()
        else:
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/i3block.py
================================================
"""
Support i3blocks blocklets in py3status.

i3blocks, https://github.com/vivien/i3blocks, is a project to allow simple
scripts to provide output to the i3bar. This module allows these blocklets to
run under py3status. The configuration of the blocklets is similar to how they
are configured in i3blocks.

Configuration parameters:
    cache_timeout: How often the blocklet should be called (in seconds).
        This is similar to cache_timeout used by standard modules. However it
        can also take the following values; `once` the blocklet will be called
        once, `repeat` the blocklet will be called constantly, or `persist`
        where the command will be expected to keep providing new data. If this
        is not set or is `None` then the blocklet will not be called unless
        clicked on. To simplify i3block compatibility, this configuration
        parameter can also be provided as `interval`.
        (default None)
    command: Path to blocklet or command (default None)
    format: What to display on the bar (default '{output}')
    instance: Will be provided to the blocklet as $BLOCK_INSTANCE (default '')
    label: Will be prepended to the blocklets output (default '')
    name: Name of the blocklet - passed as $BLOCK_NAME (default '')

Format placeholders:
    {output} The output of the blocklet

Notes:
    i3blocks and i3blocklets are subject to their respective licenses.

    This support is experimental and done for convenience to users so they
    can benefit from both worlds, issues or PRs regarding i3blocks related
    blocklets should not be raised.

    Some blocklets may return pango markup eg `<span ...` if so set
    `markup = pango` in the config for that module.

    `format` configuration parameter is used as is standard in py3status, not
    as in i3blocks configuration. Currently blocklets must provide responses
    in the standard i3blocks manner of one line per value (not as json).

Examples:
```
# i3blocks config
[time]
command=date '+%D %T'
interval=5

[wifi]
instance=wls1
label='wifi:'
command=~/i3blocks/wifi.sh
interval=5

# py3status config
order += 'i3block time'
i3block time {
    command = "date '+%D %T'"
    interval = 5
}

# different py3status config
order += 'i3block wifi'
i3block wifi {
    instance = wls1
    label = 'wifi:'
    command = '~/i3blocks/wifi.sh'
    interval = 5
}
```

@author tobes

SAMPLE OUTPUT
{'full_text': 'wifi:100%', 'color': '#00FF00'}

bandwidth
{'full_text': 'bandwidth: 334 / 113 kB/s'}
"""

import fcntl
import os
import re
from os import environ
from subprocess import PIPE, Popen
from threading import Thread

RESPONSE_FIELDS = [
    "full_text",
    "short_text",
    "color",
    "min_width",
    "align",
    "urgent",
    "separator",
    "separator_block_width",
    "markup",
]


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = None
    command = None
    format = "{output}"
    instance = ""
    label = ""
    name = ""

    def post_config_hook(self):
        # set interval.  If cache_timeout is used it takes precedence
        if self.cache_timeout:
            self.interval = self.cache_timeout
        self.interval = getattr(self, "interval", None)
        # implement i3block interval rules
        self.first_run = True
        self.cache_forever = False
        if self.interval in ["once", "persist"] or not self.interval:
            self.cache_forever = True
        if self.interval == "repeat":
            self.cache_timeout = 1
        else:
            self.cache_timeout = self.interval
        # no button has been pressed
        self.x = ""
        self.y = ""
        self.button = ""

        # set our environ
        self.env = {
            "BLOCK_INTERVAL": str(self.interval),
            "BLOCK_INSTANCE": self.instance,
            "BLOCK_NAME": self.name,
        }
        self.env.update(environ)

        # allow chained commands
        # this allows support for pseudo click support
        # echo "Click me"; [[ -z "${BLOCK_BUTTON}" ]] || echo "clicked"
        # pattern finds unquoted ; to split command on
        pattern = re.compile(r"""((?:[^;"']|"[^"]*"|'[^']*')+)""")
        self.commands = pattern.split(self.command or "")[1::2]
        self.errors = []

        if self.interval == "persist":
            self.persistent_output = ""
            self.thread = Thread(target=self._persist)
            self.thread.daemon = True
            self.thread.start()
        else:
            self.thread = None

    def _persist(self):
        """
        Run the command inside a thread so that we can catch output for each
        line as it comes in and display it.
        """
        # run the block/command
        for command in self.commands:
            try:
                process = Popen(
                    [command],
                    stdout=PIPE,
                    stderr=PIPE,
                    universal_newlines=True,
                    env=self.env,
                    shell=True,
                )
            except Exception as e:
                retcode = process.poll()
                msg = "Command '{cmd}' {error} retcode {retcode}"
                self.py3.log(msg.format(cmd=command, error=e, retcode=retcode))

            # persistent blocklet output can be of two forms.  Either each row
            # of the output is on a new line this is much easier to deal with)
            # or else the output can be continuous and just flushed when ready.
            # The second form is more tricky, if we find newlines then we
            # switch to easy parsing of the output.

            # When we have output we store in self.persistent_output and then
            # trigger the module to update.

            fd = process.stdout.fileno()
            fl = fcntl.fcntl(fd, fcntl.F_GETFL)
            has_newlines = False
            while True:
                line = process.stdout.read(1)
                # switch to a non-blocking read as we do not know the output
                # length
                fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
                line += process.stdout.read(1024)
                # switch back to blocking so we can wait for the next output
                fcntl.fcntl(fd, fcntl.F_SETFL, fl)
                if process.poll():
                    break
                self.persistent_output = line
                self.py3.update()
                if line[-1] == "\n":
                    has_newlines = True
                    break
                if line == "":
                    break
            if has_newlines:
                msg = "Switch to newline persist method {cmd}"
                self.py3.log(msg.format(cmd=command))
                # just read the output in a sane manner
                for line in iter(process.stdout.readline, b""):
                    if process.poll():
                        break
                    self.persistent_output = line
                    self.py3.update()
        self.py3.log(f"command exited {command}")
        self.persistent_output = "Error\nError\n{}".format(
            self.py3.COLOR_ERROR or self.py3.COLOR_BAD
        )
        self.py3.update()

    def _run_command(self, env):
        """
        Run command(s) and return output and urgency.
        """
        output = ""
        urgent = False
        # run the block/command
        for command in self.commands:
            try:
                process = Popen(
                    command,
                    stdout=PIPE,
                    stderr=PIPE,
                    universal_newlines=True,
                    env=env,
                    shell=True,
                )
            except Exception as e:
                msg = "Command '{cmd}' {error}"
                raise Exception(msg.format(cmd=command, error=e))

            _output, _error = process.communicate()
            retcode = process.poll()

            # return code of 33 means urgent
            _urgent = retcode == 33

            if retcode and retcode != 33 or _error:
                msg = "i3block command '{cmd}' had an error see log for details."
                msg = msg.format(cmd=command)
                self.py3.notify_user(msg, rate_limit=None)
                msg = "i3block command '{cmd}' had error {error} returned {retcode}"
                msg = msg.format(cmd=command, error=_error, retcode=retcode)
                if hash(msg) not in self.errors:
                    self.py3.log(msg, level=self.py3.LOG_ERROR)
                    self.errors.append(hash(msg))
                _output = "Error\nError\n{}".format(self.py3.COLOR_ERROR or self.py3.COLOR_BAD)
            # we have got output so update the received output
            # this provides support for i3blocks pseudo click support
            if _output:
                output = _output
                urgent = _urgent
        return output, urgent

    def i3block(self):
        # no command
        if not self.command:
            return {"cached_until": self.py3.CACHE_FOREVER, "full_text": ""}

        # If an interval is not given then we do not want to create output
        # initially as we should only be reacting to clicks.
        # We just use provided fields
        if not self.interval and self.first_run:
            self.first_run = False
            block_response = {"full_text": ""}
            for field in RESPONSE_FIELDS:
                if hasattr(self, field):
                    block_response[field] = getattr(self, field)
            i3block = self.py3.composite_create(block_response)
            full_text = self.py3.safe_format(self.format, {"output": i3block})
            return {"cached_until": self.py3.CACHE_FOREVER, "full_text": full_text}

        if self.interval == "persist":
            output = self.persistent_output
            urgent = False
        else:
            # set any buttons if they have been pressed
            env = {"BLOCK_BUTTON": self.button, "BLOCK_X": self.x, "BLOCK_Y": self.y}
            env.update(self.env)

            # reset button click info
            self.x = ""
            self.y = ""
            self.button = ""

            output, urgent = self._run_command(env)

        output = output.splitlines()

        if self.cache_forever:
            cached_until = self.py3.CACHE_FOREVER
        else:
            # we use sync_to to ensure that any time related blocklets update
            # at nice times eg on the second, minute etc
            cached_until = self.py3.time_in(sync_to=self.cache_timeout)

        block_response = {"full_text": ""}  # in  case we have no response

        # i3blocks output fields one per line in a set order
        response_lines = len(output)
        for index, field in enumerate(RESPONSE_FIELDS):
            if index < response_lines and output[index]:
                block_response[field] = output[index]
            elif hasattr(self, field):
                block_response[field] = getattr(self, field)

        # blocklet label gets prepended
        if self.label:
            block_response["full_text"] = "{}{}".format(self.label, block_response["full_text"])
            if "short_text" in block_response:
                block_response["short_text"] = "{}{}".format(
                    self.label, block_response["short_text"]
                )

        # we can now use the blocklet output in our py3status format
        i3block = self.py3.composite_create(block_response)
        full_text = self.py3.safe_format(self.format, {"output": i3block})

        # if urgent then set this for the full output
        if urgent:
            if self.py3.is_composite(full_text):
                for item in full_text:
                    item["urgent"] = True

        # finally output our response
        response = {"cached_until": cached_until, "full_text": full_text}

        if urgent:
            response["urgent"] = True

        return response

    def on_click(self, event):
        # Store button info so we can pass to the blocklet script
        # they are expected to be strings
        self.x = str(event["x"])
        self.y = str(event["y"])
        self.button = str(event["button"])


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    config = {"command": "date '+%D %T'", "interval": 1}
    module_test(Py3status, config)



================================================
FILE: py3status/modules/i3pystatus.py
================================================
"""
Support i3pystatus modules in py3status.

i3pystatus, https://github.com/enkore/i3pystatus, is an alternative to
py3status and provides a variety of modules. This py3status module allows
these modules to run and be display inside py3status.

Configuration parameters:
    module: specify i3pystatus module to use (default None)

Requires:
    i3pystatus: i3status replacement written in python

Examples:
```
# the modules parameters are provided as such
i3pystatus clock {
    module = 'clock'
    format = [('%a %b %-d %b %X', 'America/New_York'), ('%X', 'Etc/GMT+9')]
}

# if backend(s) are provided they should be given as a dict with the key being
# the backend name and the value being a dict of the backend settings
i3pystatus weather {
    module = 'weather'
    format = '{condition} {current_temp}{temp_unit}[ {icon}]'
    format += '[ Hi: {high_temp}][ Lo: {low_temp}][ {update_error}]'
    backend = {
        'weathercom.Weathercom': {
            'location_code': '94107:4:US',
            'units': 'imperial',
        }
    }
}

# backends that have no configuration should be defined as shown here
i3pystatus updates{
    module = 'updates'
    backends = {'dnf.Dnf': {}}
}
```

@author tobes

SAMPLE OUTPUT
{'full_text': 'i3pystatus module'}
"""

from importlib import import_module
from pathlib import Path
from threading import Timer

try:
    import i3pystatus
except ImportError:
    i3pystatus = None


MIN_CHECK_INTERVAL = 15  # the minimum time between checking the modules output
MAX_AUTO_TIMEOUT = 30  # the longest we'll leave it without checking the output

CLICK_EVENTS = [
    "on_leftclick",
    "on_middleclick",
    "on_rightclick",
    "on_upscroll",
    "on_downscroll",
    "on_unhandledclick",
]

DBL_CLICK_EVENTS = [
    "on_doubleleftclick",
    "on_doublemiddleclick",
    "on_doublerightclick",
    "on_doubleupscroll",
    "on_doubledownscroll",
    "on_doubleunhandledclick",
]

# we can only have one status running ever
status = None
backends = None


def get_backends():
    """
    Get backends info so that we can find the correct one.
    We just look in the directory structure to find modules.
    """
    IGNORE_DIRS = ["core", "tools", "utils"]

    global backends
    if backends is None:
        backends = {}
        i3pystatus_dir = Path(i3pystatus.__file__).parent
        for subdir in i3pystatus_dir.iterdir():
            if (
                subdir.is_dir()
                and not subdir.name.startswith("_")
                and subdir.name not in IGNORE_DIRS
            ):
                for path in subdir.glob("*.py"):
                    if not path.stem.startswith("_"):
                        backends[path.stem] = f"i3pystatus.{subdir.name}.{path.stem}"
    return backends


class ClickTimer:
    """
    i3pystatus support double clicks that py3status does not
    therefore we have to add this functionality.

    Although double clicks are a simple concept double clicks on the mouse
    wheel do not make much sense as when we are scrolling it could easily be
    interpreted as multiple double clicks.  For this reason we only worry about
    double clicks if the mouse button has a double click event.  If it dies not
    then we just count the click as a single click. more than 2 clicks are also
    viewed as a double click.

    Additionally all buttons 6 and more use the unhandled click event but each
    button is treated independently.
    """

    def __init__(self, parent, callbacks):
        self.callbacks = callbacks
        self.parent = parent
        self.last_button = None
        self.clicks = 0
        self.click_time = getattr(self.parent.module, "multi_click_timeout", 0.25)
        self.timer = None

    def trigger(self):
        """
        Actually trigger the event
        """
        if self.last_button:
            button_index = min(self.last_button, len(self.callbacks)) - 1
            click_style = 0 if self.clicks == 1 else 1
            callback = self.callbacks[button_index][click_style]
            if callback:
                # we can do test for str as only python > 3 is supported
                if isinstance(callback, str):
                    # no parameters
                    callback_name = callback
                    callback_args = []
                else:
                    # has parameters
                    callback_name = callback[0]
                    callback_args = callback[1:]
                callback_function = getattr(self.parent.module, callback_name)
                callback_function(*callback_args)
                # We want to ensure that the module has the latest output.  The
                # best way is to call the run method of the module
                self.parent.module.run()
            else:
                self.parent.py3.prevent_refresh()
        self.last_button = None
        self.clicks = 0

    def event(self, button):
        """
        button has been clicked
        """
        # cancel any pending timer
        if self.timer:
            self.timer.cancel()
        if self.last_button != button:
            if self.last_button:
                # new button clicked process the one before.
                self.trigger()
            self.clicks = 1
        else:
            self.clicks += 1
        # do we accept double clicks on this button?
        # if not then just process the click
        button_index = min(button, len(self.callbacks)) - 1
        if not self.callbacks[button_index][1]:
            # set things up correctly for the trigger
            self.clicks = 1
            self.last_button = button
            self.trigger()
        else:
            # set a timeout to trigger the click
            # this will be cancelled if we click again before it runs
            self.last_button = button
            self.timer = Timer(self.click_time, self.trigger)
            self.timer.start()


STRING_NOT_SUPPORTED = "python2 not supported"
STRING_NOT_INSTALLED = "not installed"
STRING_MISSING_MODULE = "missing module"
SKIP_ATTRS = [
    "align",
    "allow_urgent",
    "background",
    "border",
    "border_bottom",
    "border_left",
    "border_right",
    "border_top",
    "markup",
    "min_length",
    "min_width",
    "module",
    "on_click",
    "position",
    "post_config_hook",
    "py3",
    "run",
    "separator",
    "separator_block_width",
    "urgent_border",
    "urgent_border_bottom",
    "urgent_border_left",
    "urgent_border_right",
    "urgent_border_top",
]


class Py3status:
    """"""

    # available configuration parameters
    module = None

    def post_config_hook(self):
        if not i3pystatus:
            raise Exception(STRING_NOT_INSTALLED)
        elif not self.module:
            raise Exception(STRING_MISSING_MODULE)

        settings = {}
        for attribute in dir(self):
            if attribute.startswith("__") or attribute in SKIP_ATTRS:
                continue
            settings[attribute] = getattr(self, attribute)

        # backends
        backend_type = None
        if "backend" in settings:
            backend_type = "backend"
        elif "backends" in settings:
            backend_type = "backends"

        if backend_type:
            backends = settings[backend_type]
            backends_initiated = []
            for key, value in backends.items():
                mod_info = key.split(".")
                backend_module = import_module(get_backends().get(mod_info[0]))
                try:
                    backend = getattr(backend_module, mod_info[1])(**value)
                except i3pystatus.core.exceptions.ConfigMissingError as e:
                    msg = e.message
                    msg = (
                        "i3pystatus module `{}` backend `{}`" "missing configuration options {}"
                    ).format(self.module, key, msg[msg.index("{") :])
                    self.py3.notify_user(msg)
                    raise Exception("Missing configuration options")
                backends_initiated.append(backend)
            if backend_type == "backend":
                settings["backend"] = backends_initiated[0]
            else:
                settings["backends"] = backends_initiated

        # i3pystatus.Status can only exist once
        # so create it and share
        global status

        if status is None:
            status = i3pystatus.Status(standalone=False)

        # create the module and register it
        finder = status.modules.finder
        try:
            module = finder.instanciate_class_from_module(self.module, **settings)
        except i3pystatus.core.exceptions.ConfigMissingError as e:
            msg = e.message
            msg = "i3pystatus module `{}` missing configuration options {}".format(
                self.module, msg[msg.index("{") :]
            )
            self.py3.notify_user(msg)
            raise Exception("Missing configuration options")
        status.register(module)
        self.module = module

        self.is_interval_module = isinstance(module, i3pystatus.IntervalModule)
        # modules update their output independently so we need to periodically
        # check if it has been updated. For modules with long intervals it is
        # important to do output check much more regularly than the interval.
        self._cache_timeout = min(
            getattr(module, "interval", MIN_CHECK_INTERVAL), MIN_CHECK_INTERVAL
        )

        # get callbacks available, useful for deciding if double clicks exist
        callbacks = []
        for click_event, dbl_click_event in zip(CLICK_EVENTS, DBL_CLICK_EVENTS):
            click = getattr(module, click_event, None)
            dbclick = getattr(module, dbl_click_event, None)
            callbacks.append((click, dbclick))

        self._click_timer = ClickTimer(self, callbacks)
        self._last_content = {}
        self._timeout = 1

    def run(self):
        output = self.module.output or {"full_text": ""}

        variables = []
        for var in [output, self._last_content]:
            if "composite" in var:
                var = var["composite"][0]
            for key in ["name", "instance"]:
                if key in var:
                    del var[key]
            variables.append(var)
        output, self._last_content = variables

        if self._last_content != output:
            self._last_content = output
            self._timeout = 1
            full_text = output.get("full_text", "")
            # which modules return tuples?
            if isinstance(full_text, tuple):
                full_text = full_text[0]
            if full_text:
                output["full_text"] = self.py3.safe_format(full_text)
        else:
            self._timeout *= 2
            if self._timeout > MAX_AUTO_TIMEOUT:
                self._timeout = MAX_AUTO_TIMEOUT

        if self.is_interval_module:
            interval = min(self._cache_timeout, self._timeout)
        else:
            interval = self._timeout

        output["cached_until"] = self.py3.time_in(sync_to=interval)

        return output

    def on_click(self, event):
        self._click_timer.event(event["button"])



================================================
FILE: py3status/modules/icinga2.py
================================================
"""
Display service status for Icinga2.

Configuration parameters:
    base_url: the base url to the icinga-web2 services list (default '')
    ca: (default True)
    cache_timeout: how often the data should be updated (default 60)
    disable_acknowledge: enable or disable counting of acknowledged
        service problems (default False)
    format: define a format string like "CRITICAL: %d"
        (default '{status_name}: {count}')
    password: password to authenticate against the icinga-web2 interface
        (default '')
    status: set the status you want to obtain
        (0=OK,1=WARNING,2=CRITICAL,3=UNKNOWN)
        (default 0)
    url_parameters: (default '?service_state={service_state}&format=json')
    user: username to authenticate against the icinga-web2 interface
        (default '')

Format placeholders:
    {status_name} status name, eg OK, WARNING, CRITICAL
    {count} count, eg 0, 1, 2

@author Ben Oswald <ben.oswald@root-space.de>
@license BSD License <https://opensource.org/licenses/BSD-2-Clause>
@source https://github.com/nazco/i3status-modules

SAMPLE OUTPUT
{'full_text': 'OK: 0'}

warning
{'full_text': 'WARNING: 1'}

critical
{'full_text': 'CRITICAL: 2'}

unknown
{'full_text': 'UNKNOWN: 3'}
"""

import requests

STATUS_NAMES = {0: "OK", 1: "WARNING", 2: "CRITICAL", 3: "UNKNOWN"}
STRING_NOT_CONFIGURED = "not configured"


class Py3status:
    """ """

    # available configuration parameters
    base_url = ""
    ca = True
    cache_timeout = 60
    disable_acknowledge = False
    format = "{status_name}: {count}"
    password = ""
    status = 0
    url_parameters = "?service_state={service_state}&format=json"
    user = ""

    def post_config_hook(self):
        if not self.base_url:
            raise Exception(STRING_NOT_CONFIGURED)

    def icinga2(self):
        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(
                self.format,
                dict(
                    status_name=STATUS_NAMES.get(self.status, "INVALID STATUS"),
                    count=self._query_service_count(self.status),
                ),
            ),
        }
        return response

    def _query_service_count(self, state):
        url_parameters = self.url_parameters
        if self.disable_acknowledge:
            url_parameters = url_parameters + "&service_handled=0"
        result = requests.get(
            self.base_url + url_parameters.format(service_state=state),
            auth=(self.user, self.password),
            verify=self.ca,
        )
        return len(result.json())


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/imap.py
================================================
"""
Display number of unread messages from IMAP account.

Configuration parameters:
    allow_urgent: display urgency on unread messages (default False)
    auth_scope: scope to use with OAuth2 (default 'https://mail.google.com/')
    auth_token: path to where the pickled access/refresh token will be saved
        after successful credential authorization.
        (default '~/.config/py3status/imap_auth_token.pickle')
    cache_timeout: refresh interval for this module (default 60)
    client_secret: the path to the client secret file with OAuth 2.0
        credentials (if None then OAuth not used) (default None)
    criterion: status of emails to check for (default 'UNSEEN')
    debug: log warnings (default False)
    degraded_when_stale: color as degraded when updating failed (default True)
    format: display format for this module (default 'Mail: {unseen}')
    hide_if_zero: hide this module when no new mail (default False)
    mailbox: name of the mailbox to check (default 'INBOX')
    password: login password (default None)
    port: number to use (default '993')
    read_timeout: timeout for read(2) syscalls (default 5)
    security: login authentication method: 'ssl' or 'starttls'
        (startssl needs python 3.2 or later) (default 'ssl')
    server: server to connect (default None)
    use_idle: use IMAP4 IDLE instead of polling; requires compatible
        server; uses cache_timeout for IDLE's timeout; will auto detect
        when set to None (default None)
    user: login user (default None)

Format placeholders:
    {unseen} number of unread emails

Color options:
    color_new_mail: use color when new mail arrives, default to color_good

OAuth:
    OAuth2 will be used for authentication instead of a password if the
    client_secret path is set.

    To create a client_secret for your Google account, visit
    https://console.developers.google.com/ and create an "OAuth client ID" from
    the credentials tab.

    This client secret enables the app (in this case, the IMAP py3status module)
    to request access to a user's email. Therefore the client secret doesn't
    have to be for the same Google account as the email account being accessed.

    When the IMAP module first tries to access your email account a browser
    window will open asking for authorization to access your email.
    After authorization is complete, an access/refresh token will be saved to
    the path configured in auth_token.

    Requires: Using OAuth requires the google-auth and google-auth-oauthlib
    libraries to be installed.

    Note: the same client secret file can be used as with the py3status Google
    Calendar module.

@author obb, girst

SAMPLE OUTPUT
{'full_text': 'Mail: 36', 'color': '#00FF00'}
"""

import imaplib
from pathlib import Path
from socket import error as socket_error
from socket import setdefaulttimeout
from ssl import create_default_context
from threading import Thread
from time import sleep

STRING_UNAVAILABLE = "N/A"
NO_DATA_YET = -1


class Py3status:
    """"""

    # available configuration parameters
    allow_urgent = False
    auth_scope = "https://mail.google.com/"
    auth_token = "~/.config/py3status/imap_auth_token.pickle"
    cache_timeout = 60
    client_secret = None
    criterion = "UNSEEN"
    debug = False
    degraded_when_stale = True
    format = "Mail: {unseen}"
    hide_if_zero = False
    mailbox = "INBOX"
    password = None
    port = "993"
    read_timeout = 5
    security = "ssl"
    server = None
    use_idle = None
    user = None

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "new_mail_color",
                    "new": "color_new_mail",
                    "msg": "obsolete parameter use `color_new_mail`",
                },
                {
                    "param": "imap_server",
                    "new": "server",
                    "msg": "obsolete parameter use `server`",
                },
            ]
        }

    def post_config_hook(self):
        # class variables:
        self.mail_count = NO_DATA_YET
        self.connection = None
        self.mail_error = None  # cannot throw self.py3.error from thread
        self.network_error = None
        self.command_tag = 0  # IMAPcommands are tagged, so responses can be matched up to requests
        self.idle_thread = Thread()

        if self.client_secret:
            self.client_secret = Path(self.client_secret).expanduser()
        self.auth_token = Path(self.auth_token).expanduser()

        if self.security not in ["ssl", "starttls"]:
            raise ValueError("Unknown security protocol")

    def imap(self):
        # I -- acquire mail_count
        if self.use_idle is not False:
            if not self.idle_thread.is_alive():
                sleep(self.read_timeout)  # rate-limit thread-restarting (when network is offline)
                self.idle_thread = Thread(target=self._get_mail_count)
                self.idle_thread.daemon = True
                self.idle_thread.start()
        else:
            self._get_mail_count()
        response = {"cached_until": self.py3.time_in(self.cache_timeout)}
        if self.mail_error is not None:
            self.py3.log(self.mail_error, level=self.py3.LOG_ERROR)
            self.py3.error(self.mail_error)
            self.mail_error = None

        # II -- format response
        response["full_text"] = self.py3.safe_format(self.format, {"unseen": self.mail_count})

        if self.mail_count is None:
            response["color"] = (self.py3.COLOR_BAD,)
            response["full_text"] = self.py3.safe_format(
                self.format, {"unseen": STRING_UNAVAILABLE}
            )
        elif self.mail_count == NO_DATA_YET:
            response["full_text"] = ""
        elif self.mail_count == 0 and self.hide_if_zero:
            response["full_text"] = ""
        elif self.mail_count > 0:
            response["color"] = self.py3.COLOR_NEW_MAIL or self.py3.COLOR_GOOD
            response["urgent"] = self.allow_urgent
        if self.network_error is not None and self.degraded_when_stale:
            response["color"] = self.py3.COLOR_DEGRADED

        return response

    def _check_if_idle(self, connection):
        supports_idle = "IDLE" in connection.capabilities

        self.use_idle = supports_idle
        self.py3.log("Will use {}".format("idling" if self.use_idle else "polling"))
        if self.use_idle and not supports_idle:
            self.py3.error("Server does not support IDLE")

    def _get_creds(self):
        import pickle

        from google.auth.exceptions import TransportError
        from google.auth.transport.requests import Request
        from google_auth_oauthlib.flow import InstalledAppFlow

        self.creds = None

        # Open pickle file with access and refresh tokens if it exists
        if self.auth_token.exists():
            with self.auth_token.open("rb") as token:
                self.creds = pickle.load(token)

        if not self.creds or not self.creds.valid:
            try:
                if self.creds and self.creds.expired and self.creds.refresh_token:
                    # Credentials expired but contain refresh token
                    self.creds.refresh(Request())
                else:
                    # No valid credentials so open authorisation URL in browser
                    flow = InstalledAppFlow.from_client_secrets_file(
                        self.client_secret, [self.auth_scope]
                    )
                    self.creds = flow.run_local_server(port=0)
                # Save the credentials for the next run
                with self.auth_token.open("wb") as token:
                    pickle.dump(self.creds, token)
            except TransportError as e:
                # Treat the same as a socket_error
                raise socket_error(e)

    def _connection_ssl(self):
        if self.client_secret:
            # Use OAUTH
            self._get_creds()
        setdefaulttimeout(self.read_timeout)
        connection = imaplib.IMAP4_SSL(self.server, int(self.port))
        return connection

    def _connection_starttls(self):
        setdefaulttimeout(self.read_timeout)
        connection = imaplib.IMAP4(self.server, int(self.port))
        connection.starttls(create_default_context())
        return connection

    def _connect(self):
        if self.security == "ssl":
            self.connection = self._connection_ssl()
        elif self.security == "starttls":
            self.connection = self._connection_starttls()
        if self.use_idle is None:
            self._check_if_idle(self.connection)

        # trigger a socket.timeout if any IMAP request isn't completed in time:
        self.connection.socket().settimeout(self.read_timeout)

    def _disconnect(self):
        try:
            if self.connection is not None:
                if self.connection.state == "SELECTED":
                    self.connection.close()
                self.connection.logout()
        except:  # noqa e722
            pass
        finally:
            self.connection = None

    def _idle(self):
        """
        since imaplib doesn't support IMAP4r1 IDLE, we'll do it by hand
        """
        socket = None

        try:
            # build a new command tag (Xnnn) as bytes:
            self.command_tag = (self.command_tag + 1) % 1000
            command_tag = b"X" + bytes(str(self.command_tag).zfill(3), "ascii")

            # make sure we have selected anything before idling:
            directories = self.mailbox.split(",")
            self.connection.select(directories[0])

            socket = self.connection.socket()

            # send IDLE command and check response:
            socket.write(command_tag + b" IDLE\r\n")
            try:
                response = socket.read(4096).decode("ascii")
            except socket_error:
                raise imaplib.IMAP4.abort("Server didn't respond to 'IDLE' in time")
            # Dovecot will responde with "+ idling", courier will return "+ entering idle mode"
            # RFC 2177 (https://tools.ietf.org/html/rfc2177) only requires the "+" character.
            if not response.lower().startswith("+"):
                raise imaplib.IMAP4.abort(f"While initializing IDLE: {response}")

            # wait for changes (EXISTS, EXPUNGE, etc.):
            socket.settimeout(self.cache_timeout)
            while True:
                try:
                    response = socket.read(4096).decode("ascii")
                    if response.upper().startswith("* OK"):
                        continue  # ignore '* OK Still here'
                    else:
                        break
                except socket_error:  # IDLE timed out
                    break

        finally:  # terminate IDLE command gracefully
            if socket is None:
                return

            socket.settimeout(self.read_timeout)
            socket.write(b"DONE\r\n")  # important! Can't query IMAP again otherwise
            try:
                response = socket.read(4096).decode("ascii")
            except socket_error:
                raise imaplib.IMAP4.abort("Server didn't respond to 'DONE' in time")

            # sometimes, more messages come in between reading and DONEing; so read them again:
            if response.startswith("* "):
                try:
                    response = socket.read(4096).decode("ascii")
                except socket_error:
                    raise imaplib.IMAP4.abort("Server sent more continuations, but no 'DONE' ack")

            expected_response = (command_tag + b" OK").decode("ascii")
            if not response.lower().startswith(expected_response.lower()):
                raise imaplib.IMAP4.abort("While terminating IDLE: " + response)

    def _get_mail_count(self):
        retry_counter = 0
        retry_max = 3
        while True:
            try:
                if self.connection is None:
                    self._connect()
                if self.connection.state == "NONAUTH":
                    if self.client_secret:
                        # Authenticate using OAUTH
                        auth_string = "user={}\1auth=Bearer {}\1\1".format(
                            self.user, self.creds.token
                        )
                        self.connection.authenticate("XOAUTH2", lambda x: auth_string)
                    else:
                        # Login with user and password
                        self.connection.login(self.user, self.password)

                tmp_mail_count = 0
                directories = self.mailbox.split(",")

                for directory in directories:
                    self.connection.select(directory)
                    unseen_response = self.connection.search(None, self.criterion)
                    mails = unseen_response[1][0].split()
                    tmp_mail_count += len(mails)

                self.mail_count = tmp_mail_count
                self.network_error = None

                if self.use_idle:
                    self.py3.update()
                    self._idle()
                    retry_counter = 0
                else:
                    return
            except (socket_error, imaplib.IMAP4.abort, imaplib.IMAP4.readonly) as e:
                if "didn't respond to 'DONE'" in str(e) or isinstance(e, socket_error):
                    self.network_error = str(e)
                    error_type = "Network"
                else:
                    error_type = "Recoverable"
                    # Note: we don't reset network_error, as we want this to persist
                    # until we either run into a permanent error or successfully receive
                    # another response from the IMAP server.

                if self.debug:
                    self.py3.log(
                        f"{error_type} error - {e}",
                        level=self.py3.LOG_WARNING,
                    )
                self._disconnect()

                retry_counter += 1
                if retry_counter <= retry_max:
                    if self.debug:
                        self.py3.log(
                            f"Retrying ({retry_counter}/{retry_max})",
                            level=self.py3.LOG_INFO,
                        )
                    continue
                break
            except (imaplib.IMAP4.error, Exception) as e:
                self.mail_error = f"Fatal error - {e}"
                self._disconnect()
                self.mail_count = None

                retry_counter += 1
                if retry_counter <= retry_max:
                    if self.debug:
                        self.py3.log(
                            "Will retry after 60 seconds ({}/{})".format(retry_counter, retry_max),
                            level=self.py3.LOG_INFO,
                        )
                    sleep(60)
                    continue
                break
            finally:
                self.py3.update()  # to propagate mail_error


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/insync.py
================================================
"""
Display Insync status.

Thanks to Iain Tatch <iain.tatch@gmail.com> for the script that this is based on.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default '{status} {queued}')
    status_offline: show when Insync is offline (default 'OFFLINE')
    status_paused: show when Insync is paused (default 'PAUSED')
    status_share: show when Insync is sharing (default 'SHARE')
    status_synced: show when Insync has finished syncing (default 'SYNCED')
    status_syncing: show when Insync is syncing (default 'SYNCING')

Format placeholders:
    {status} Insync status
    {queued} Number of files queued

Color options:
    color_bad: Offline
    color_degraded: Default (e.g. Paused/Syncing)
    color_good: Synced

Requires:
    insync: an unofficial Google Drive client with support for various desktops

@author Joshua Pratt <jp10010101010000@gmail.com>
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'INSYNC 3'}

busy
{'color': '#FFFF00', 'full_text': u'PAUSED 3'}

offline
{'color': '#FF0000', 'full_text': u'OFFLINE 3'}
"""

STRING_ERROR = "Insync: isn't running"
STRING_NOT_INSTALLED = "not installed"
STRING_UNEXPECTED = "Insync: N/A"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{status} {queued}"
    status_offline = "OFFLINE"
    status_paused = "PAUSED"
    status_share = "SHARE"
    status_synced = "SYNCED"
    status_syncing = "SYNCING"

    def post_config_hook(self):
        if not self.py3.check_commands("insync"):
            raise Exception(STRING_NOT_INSTALLED)

    def insync(self):
        # sync progress
        try:
            queued = self.py3.command_output(["insync", "get_sync_progress"]).splitlines()
        except Exception:
            return {
                "cached_until": self.py3.time_in(self.cache_timeout),
                "color": self.py3.COLOR_ERROR or self.py3.COLOR_BAD,
                "full_text": STRING_UNEXPECTED,
            }
        queued = [q for q in queued if q != ""]
        if len(queued) > 0 and "queued" in queued[-1]:
            queued = queued[-1]
            queued = queued.split(" ")[0]
        else:
            queued = ""

        # status
        try:
            status = self.py3.command_output(["insync", "get_status"]).strip()
        except Exception:
            return {
                "cached_until": self.py3.time_in(self.cache_timeout),
                "color": self.py3.COLOR_ERROR or self.py3.COLOR_BAD,
                "full_text": STRING_UNEXPECTED,
            }

        color = self.py3.COLOR_DEGRADED
        format = self.format
        if status == "Insync doesn't seem to be running. Start it first.":
            self.py3.error(STRING_ERROR)
        elif status == "OFFLINE":
            color = self.py3.COLOR_BAD
            status = self.status_offline
        elif status == "SYNCED":
            color = self.py3.COLOR_GOOD
            status = self.status_synced
        elif status == "SHARE":
            status = self.status_share
        elif status == "PAUSED":
            status = self.status_paused
        elif status == "SYNCING":
            status = self.status_syncing

        return {
            "color": color,
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(format, {"status": status, "queued": queued}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/kdeconnector.py
================================================
"""
Display information about your smartphone with KDEConnector.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds (default 30)
    device: the device name, you need this if you have more than one device
        connected to your PC (default None)
    device_id: alternatively to the device name you can set your device id here
        (default None)
    format: see placeholders below
        (default '{name}{notif_status} {bat_status} {charge}%')
    format_disconnected: text if device is disconnected
        (default 'device disconnected')
    low_threshold: percentage value when text is twitch to color_bad
        (default 20)
    status_bat: text when battery is discharged (default '⬇')
    status_chr: text when device is charged (default '⬆')
    status_full: text when battery is full (default '☻')
    status_no_notif: text when you have no notifications (default '')
    status_notif: text when notifications are available (default ' ✉')

Format placeholders:
    {bat_status} battery state
    {charge} the battery charge
    {name} name of the device
    {notif_size} number of notifications
    {notif_status} shows if a notification is available or not
    {net_type} shows cell network type
    {net_strength} shows cell network strength

Color options:
    color_bad: Device unknown, unavailable
        or battery below low_threshold and not charging
    color_degraded: Connected and battery not charging
    color_good: Connected and battery charging

Requires:
    kdeconnect: adds communication between kde and your smartphone
    dbus-python: Python bindings for dbus
    PyGObject: Python bindings for GObject Introspectiom

Examples:
```
kdeconnector {
    device_id = "aa0844d33ac6ca03"
    format = "{name} {charge} {bat_status}"
    low_battery = "10"
}
```

@author Moritz Lüdecke, valdur55

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'Samsung Galaxy S6 \u2709 \u2b06 97%'}

charging
{'color': '#00FF00', 'full_text': u'Samsung Galaxy S6 \u2b06 97%'}

transition
{'color': '#FFFF00', 'full_text': u'Samsung Galaxy S6 \u2b07 93%'}

not-plugged
{'color': '#FF0000', 'full_text': u'Samsung Galaxy S6 \u2b07 92%'}

disconnected
{'color': '#FF0000', 'full_text': u'device disconnected'}

unknown
{'color': '#FF0000', 'full_text': u'unknown device'}
"""

import sys
from threading import Thread

from dbus import Interface, SessionBus
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GLib

STRING_NOT_INSTALLED = "{} not installed"

MOD_BATTERY = "battery"
MOD_NOTIFICATIONS = "notifications"
MOD_CONNECTIVITY_REPORT = "connectivity_report"

SERVICE_BUS = "org.kde.kdeconnect"
INTERFACE = SERVICE_BUS + ".device"
INTERFACE_DAEMON = SERVICE_BUS + ".daemon"
INTERFACE_BATTERY = INTERFACE + "." + MOD_BATTERY
INTERFACE_NOTIFICATIONS = INTERFACE + "." + MOD_NOTIFICATIONS
INTERFACE_CONN_REPORT = INTERFACE + "." + MOD_CONNECTIVITY_REPORT
PATH = "/modules/kdeconnect"
DEVICE_PATH = PATH + "/devices"
BATTERY_SUBPATH = "/" + MOD_BATTERY
NOTIFICATIONS_SUBPATH = "/" + MOD_NOTIFICATIONS
CONN_REPORT_SUBPATH = "/" + MOD_CONNECTIVITY_REPORT
UNKNOWN = "Unknown"
UNKNOWN_DEVICE = "unknown device"
UNKNOWN_SYMBOL = "?"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 30
    device = None
    device_id = None
    format = "{name}{notif_status} {bat_status} {charge}%"
    format_disconnected = "device disconnected"
    low_threshold = 20
    status_bat = "⬇"
    status_chr = "⬆"
    status_full = "☻"
    status_no_notif = ""
    status_notif = " ✉"

    def post_config_hook(self):
        if not self.py3.check_commands("kdeconnect-cli"):
            raise Exception(STRING_NOT_INSTALLED.format("kdeconnect"))

        self._bat = None
        self._con = None
        self._dev = None
        self._not = None

        self._result = {}

        self._signal_reachable_changed = None
        self._signal_battery = None
        self._signal_notifications = None
        self._signal_conn_report = None

        self._format_contains_notifications = self.py3.format_contains(
            self.format, ["notif_size", "notif_status"]
        )

        self._format_contains_connection_status = self.py3.format_contains(
            self.format, ["net_type", "net_strength"]
        )

        # start last
        self._kill = False
        self._dbus_loop = DBusGMainLoop()
        self._dbus = SessionBus(mainloop=self._dbus_loop)
        self._bus_initialized = self._init_dbus()
        self._start_listener()

        if self._bus_initialized:
            self._update_conn_info()
            self._update_notif_info()
            self._update_battery_info()

    def _start_loop(self):
        self._loop = GLib.MainLoop()
        GLib.timeout_add(1000, self._timeout)
        try:
            self._loop.run()
        except KeyboardInterrupt:
            # This branch is only needed for the test mode
            self._kill = True

    def _start_listener(self):
        self._signal_reachable_changed = self._dbus.add_signal_receiver(
            dbus_interface=INTERFACE,
            signal_name="reachableChanged",
            handler_function=self._reachable_on_change,
            path_keyword='path',
            interface_keyword='iface',
            member_keyword='member',
        )

        self._signal_battery = self._dbus.add_signal_receiver(
            dbus_interface=INTERFACE_BATTERY,
            signal_name=None,
            handler_function=self._battery_on_change,
            path_keyword='path',
            interface_keyword='iface',
            member_keyword='member',
        )

        if self._format_contains_notifications:
            self._signal_notifications = self._dbus.add_signal_receiver(
                dbus_interface=INTERFACE_NOTIFICATIONS,
                signal_name=None,
                handler_function=self._notifications_on_change,
                path_keyword='path',
                interface_keyword='iface',
                member_keyword='member',
            )

        if self._format_contains_connection_status:
            self._signal_conn_report = self._dbus.add_signal_receiver(
                dbus_interface=INTERFACE_CONN_REPORT,
                signal_name=None,
                handler_function=self._conn_report_on_change,
                path_keyword='path',
                interface_keyword='iface',
                member_keyword='member',
            )

        t = Thread(target=self._start_loop)
        t.daemon = True
        t.start()

    def _notifications_on_change(self, *args, **kwargs):
        if self._is_current_device(kwargs['path']):
            self._update_notif_info()
            self.py3.update()

    def _reachable_on_change(self, *args, **kwargs):
        if self._is_current_device(kwargs['path']):
            # Update only when device is connected
            if args[0]:
                self._update_battery_info()
                self._update_notif_info()
                self._update_conn_info()
            self.py3.update()

    def _battery_on_change(self, *args, **kwargs):
        event = kwargs.get("member")
        if self._is_current_device(kwargs['path']):
            if event == "refreshed":
                if args[1] != -1:
                    self._set_battery_status(isCharging=args[0], charge=args[1])
            elif event == "stateChanged":
                self._set_battery_status(isCharging=args[0], charge=None)
            elif event == "chargeChanged":
                self._set_battery_status(isCharging=None, charge=args[0])
            else:
                self._update_battery_info()
            self.py3.update()

    def _conn_report_on_change(self, *args, **kwargs):
        if self._is_current_device(kwargs['path']):
            event = kwargs.get("member")
            if event == "refreshed":
                if (
                    self._result["net_type"] != args[0]
                    or self._result["net_strength_raw"] != args[1]
                ):
                    self._set_conn_status(net_type=args[0], net_strength=args[1])
                    self.py3.update()
            else:
                self._update_conn_info()
                self.py3.update()

    # Get DBus method up to 2 arguments
    def _dbus_method(self, method, mod=None, value1=None, value2=None):
        path = DEVICE_PATH + f"/{self.device_id}"
        iface = INTERFACE
        if mod:
            path = path + '/' + mod
            iface = iface + '.' + mod
        elif method in ["charge", "isCharging"]:
            iface += "." + MOD_BATTERY
        elif method == "activeNotifications":
            iface += "." + MOD_NOTIFICATIONS

        dbus_object = self._dbus.get_object(SERVICE_BUS, path)
        if not value2:
            answer = dbus_object.get_dbus_method(method, iface)(True)
        else:
            answer = dbus_object.get_dbus_method(method, iface)(value1, value2)
        return answer

    # Get DBus property
    def _dbus_property(self, prop, mod=None, device_id=None):
        if not device_id:
            device_id = self.device_id
        path = DEVICE_PATH + f"/{device_id}"
        iface = INTERFACE
        if mod:
            path = path + '/' + mod
            iface = iface + '.' + mod
        dbus_object = self._dbus.get_object(SERVICE_BUS, path)
        dbus_interface = Interface(dbus_object, 'org.freedesktop.DBus.Properties')
        propertie = dbus_interface.Get(iface, prop)
        return propertie

    def _dbus_introspect_exists(self, mod=None):
        path = DEVICE_PATH + f"/{self.device_id}"
        if mod:
            path += "/" + mod
        dbus_object = self._dbus.get_object(SERVICE_BUS, path)
        result = dbus_object.Introspect(dbus_interface="org.freedesktop.DBus.Introspectable")
        return len(result) > 0

    def _is_current_device(self, object_path):
        return self.device_id in object_path

    def _timeout(self):
        if self._kill:
            self._loop.quit()
            sys.exit(0)

    def _init_dbus(self):
        """
        Get the device id
        """
        if self.device_id is None:
            self.device_id = self._get_device_id()
            if self.device_id is None:
                return False

        try:
            self._dev = self._dbus_introspect_exists()
            try:
                self._bat = self._dbus_introspect_exists(MOD_BATTERY)

                if self._format_contains_notifications:
                    self._not = self._dbus_introspect_exists(MOD_NOTIFICATIONS)
                else:
                    self._not = None
            except Exception:
                # Fallback to the old version
                self._bat = None
                self._not = None

            try:  # This plugin is released after kdeconnect version Mar 13, 2021
                if self._format_contains_connection_status:
                    self._con = self._dbus_introspect_exists(MOD_CONNECTIVITY_REPORT)
                else:
                    self._con = None
            except Exception:
                self._con = None

        except Exception:
            return False

        return True

    def _get_device_id(self):
        """
        Find the device id
        """
        _bus = self._dbus.get_object(SERVICE_BUS, PATH)
        devices = _bus.devices()

        if self.device is None and self.device_id is None and len(devices) == 1:
            return devices[0]

        for id in devices:
            name = self._dbus_property("name", device_id=id)
            if self.device == name:
                return id

        return None

    def _get_isTrusted(self):
        if self._dev is None:
            return False

        try:
            # New method which replaced 'isTrusted' in version 1.0
            return self._dbus_method('isPaired')
        except Exception:
            try:
                # Deprecated since version 1.0
                return self._dbus_method("isTrusted")
            except Exception:
                return False

    def _get_device(self):
        """
        Get the device
        """
        try:
            device = {
                "name": self._dbus_property('name'),
                "isReachable": self._dbus_property('isReachable'),
                "isTrusted": self._get_isTrusted(),
            }
        except Exception:
            return None

        return device

    def _get_battery(self):
        """
        Get the battery
        """
        try:
            if self._bat:
                charge = self._dbus_property("charge", MOD_BATTERY)
                isCharging = self._dbus_property("isCharging", MOD_BATTERY)
            else:
                charge = self._dbus_method("charge")
                isCharging = self._dbus_method("isCharging")

            battery = {
                "charge": charge,
                "isCharging": isCharging == 1,
            }
        except Exception:
            return {
                "charge": -1,
                "isCharging": None,
            }

        return battery

    def _get_conn(self):
        """
        Get the connection report
        """
        try:
            if self._con:
                # Possible values are -1 - 4
                strength = self._dbus_property("cellularNetworkStrength", MOD_CONNECTIVITY_REPORT)
                type = self._dbus_property("cellularNetworkType", MOD_CONNECTIVITY_REPORT)

                con_info = {
                    "strength": strength,
                    "type": type,
                }
            else:
                con_info = {
                    "strength": -1,
                    "type": "",
                }
        except Exception:
            return {
                "strength": -1,
                "type": "",
            }

        return con_info

    def _get_notifications(self):
        """
        Get notifications
        """
        try:
            if self._not:
                notifications = self._dbus_method("activeNotifications", MOD_NOTIFICATIONS)
            else:
                notifications = self._dbus_method("activeNotifications")
        except Exception:
            return []

        return notifications

    def _set_battery_status(self, isCharging, charge):
        """
        Get the battery status
        """
        if charge == -1:
            self._result["charge"] = UNKNOWN_SYMBOL
            self._result["bat_status"] = UNKNOWN
            self._result["color"] = "#FFFFFF"
            return

        if charge is not None:
            self._result["charge"] = charge

        if isCharging is not None:
            if isCharging:
                self._result["bat_status"] = self.status_chr
                self._result["color"] = self.py3.COLOR_GOOD
            else:
                self._result["bat_status"] = self.status_bat
                self._result["color"] = self.py3.COLOR_DEGRADED

            if (
                not isCharging
                and isinstance(self._result["charge"], int)
                and self._result["charge"] <= self.low_threshold
            ):
                self._result["color"] = self.py3.COLOR_BAD

        if charge is not None:
            if charge > 99:
                self._result["bat_status"] = self.status_full

    def _set_notifications_status(self, activeNotifications):
        """
        Get the notifications status
        """
        size = len(activeNotifications)
        self._result["notif_status"] = self.status_notif if size > 0 else self.status_no_notif
        self._result["notif_size"] = size

    def _set_conn_status(self, net_type, net_strength):
        """
        Get the conn status
        """
        self._result["net_strength_raw"] = net_strength
        self._result["net_strength"] = net_strength * 25 if net_strength > -1 else UNKNOWN_SYMBOL
        self._result["net_type"] = net_type

    def _get_text(self):
        """
        Get the current metadatas
        """
        device = self._get_device()
        if device is None:
            return (UNKNOWN_DEVICE, self.py3.COLOR_BAD)

        if not device["isReachable"] or not device["isTrusted"]:
            return (
                self.py3.safe_format(self.format_disconnected, {"name": device["name"]}),
                self.py3.COLOR_BAD,
            )

        return (
            self.py3.safe_format(
                self.format,
                dict(name=device["name"], **self._result),
            ),
            self._result.get("color"),
        )

    def _update_conn_info(self):
        if self._format_contains_connection_status:
            conn = self._get_conn()
            self._set_conn_status(net_type=conn["type"], net_strength=conn["strength"])

    def _update_notif_info(self):
        if self._format_contains_notifications:
            notif = self._get_notifications()
            self._set_notifications_status(notif)

    def _update_battery_info(self):
        battery = self._get_battery()
        self._set_battery_status(isCharging=battery["isCharging"], charge=battery["charge"])

    def kill(self):
        self._kill = True
        if self._signal_reachable_changed:
            self._signal_reachable_changed.remove()

        if self._signal_battery:
            self._signal_battery.remove()

        if self._signal_notifications:
            self._signal_notifications.remove()

        if self._signal_conn_report:
            self._signal_conn_report.remove()

    def kdeconnector(self):
        """
        Get the current state and return it.
        """
        if self._kill:
            raise KeyboardInterrupt

        if self._bus_initialized:
            (text, color) = self._get_text()
            cached_until = self.py3.CACHE_FOREVER

        else:
            text = UNKNOWN_DEVICE
            color = self.py3.COLOR_BAD
            cached_until = self.py3.time_in(self.cache_timeout)
            self._bus_initialized = self._init_dbus()
            if self._bus_initialized:
                self._update_conn_info()
                self._update_notif_info()
                self._update_battery_info()
                self.py3.update()

        response = {
            "cached_until": cached_until,
            "full_text": text,
            "color": color,
        }
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/keyboard_layout.py
================================================
"""
Display keyboard layout.

Configuration parameters:
    button_next: mouse button to cycle next layout (default 4)
    button_prev: mouse button to cycle previous layout (default 5)
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default '{layout}')
    layouts: specify a list of layouts to use (default None)

Format placeholders:
    {layout} keyboard layout

Color options:
    color_<layout>: colorize the layout. eg color_fr = '#729FCF'

Requires:
    xkblayout-state:
        or
    setxkbmap: and `xset` (works for the first two predefined layouts. overrides `XkbLayout` when switching layout.)

Examples:
```
# define keyboard layouts that can be switched between
keyboard_layout {
    layouts = ['gb', 'fr', 'dvorak']
}
```

@author shadowprince, tuxitop
@license Eclipse Public License

SAMPLE OUTPUT
{'full_text': 'gb'}

fr
{'color': '#268BD2', 'full_text': 'fr'}

ru
{'color': '#F75252', 'full_text': 'ru'}

ua
{'color': '#FCE94F', 'full_text': 'ua'}

us
{'color': '#729FCF', 'full_text': 'us'}

"""

import re

LAYOUTS_RE = re.compile(r".*layout:\s*((\w+,?)+).*", flags=re.DOTALL)
LEDMASK_RE = re.compile(r".*LED\smask:\s*\d{4}([01])\d{3}.*", flags=re.DOTALL)
VARIANTS_RE = re.compile(r".*variant:\s*(([\w-]+,?)+).*", flags=re.DOTALL)


class Py3status:
    """ """

    # available configuration parameters
    button_next = 4
    button_prev = 5
    cache_timeout = 10
    format = "{layout}"
    layouts = None

    def post_config_hook(self):
        self.colors = getattr(self, "colors", None)  # old config

        avail_command = {
            "xkblayout-state": (self._set_xkblayout, self._get_xkblayout),
            "setxkbmap": (self._set_setxkbmap, self._get_setxkbmap),
        }
        self._set_command, self._get_command = avail_command[
            self.py3.check_commands(list(avail_command))
        ]

        if not self.layouts:
            self.layouts = []
        # We use a copy of layouts so that we can add extra layouts without
        # affecting the original list
        self._layouts = self.layouts[:]
        self._last_layout = None

        self.colors_dict = {}
        # old compatibility: set default values
        self.defaults = {
            "fr": "#268BD2",
            "ru": "#F75252",
            "ua": "#FCE94F",
            "us": "#729FCF",
        }

    def keyboard_layout(self):
        layout, variant = self._get_command()
        # If the current layout is not in our layouts list we need to add it
        if layout not in self._layouts:
            self._layouts = [layout] + self.layouts
            self._active = 0
        # show new layout if it has been changed externally
        if layout != self._last_layout:
            self._active = self._layouts.index(layout)
            self._last_layout = layout
        lang = self._layouts[self._active]

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"layout": lang, "variant": variant}),
        }

        if self.colors and not self.colors_dict:
            self.colors_dict = {
                k.strip(): v.strip()
                for k, v in (layout.split("=") for layout in self.colors.split(","))
            }

        # colorize languages containing spaces and/or dashes too
        language = lang.upper()
        for character in " -":
            if character in language:
                language = language.replace(character, "_")

        lang_color = getattr(self.py3, f"COLOR_{language}")
        if not lang_color:
            lang_color = self.colors_dict.get(lang)
        if not lang_color:  # old compatibility: try default value
            lang_color = self.defaults.get(lang)
        if lang_color:
            response["color"] = lang_color

        return response

    def _get_xkblayout(self):
        layout, variant = [
            x.strip()
            for x in self.py3.command_output(["xkblayout-state", "print", "%s|SEPARATOR|%v"]).split(
                "|SEPARATOR|"
            )
        ]
        return layout, variant

    def _get_setxkbmap(self):
        # this method works only for the first two predefined layouts.
        out = self.py3.command_output(["setxkbmap", "-query"])
        layouts = re.match(LAYOUTS_RE, out).group(1).split(",")
        if len(layouts) == 1:
            variant = re.match(VARIANTS_RE, out)
            if variant:
                variant = variant.group(1)
                return "{} {}".format(layouts[0], variant), variant
            else:
                return layouts[0], ""

        xset_output = self.py3.command_output(["xset", "-q"])
        led_mask = re.match(LEDMASK_RE, xset_output).groups(0)[0]
        return layouts[int(led_mask)], ""

    def _set_setxkbmap(self):
        layout = self._layouts[self._active]
        # Note: This will override user-defined layout, keyboard shortcut won't work
        self.py3.command_run(f"setxkbmap -layout {layout}")

    def _set_xkblayout(self):
        layout = self._layouts[self._active]
        layout_pos = (
            self.py3.command_output(["xkblayout-state", "print", "%E"]).split().index(layout)
        )
        self.py3.command_run(f"xkblayout-state set {layout_pos}")

    def _set_active(self, delta):
        self._active += delta
        self._active = self._active % len(self._layouts)
        self._set_command()

    def on_click(self, event):
        button = event["button"]
        if button == self.button_next:
            self._set_active(1)
        if button == self.button_prev:
            self._set_active(-1)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/keyboard_locks.py
================================================
r"""
Display NumLock, CapsLock, and ScrLock keys.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 1)
    format: display format for this module
        *(default '[\?if=num_lock&color=good NUM|\?color=bad NUM] '
        '[\?if=caps_lock&color=good CAPS|\?color=bad CAPS] '
        '[\?if=scroll_lock&color=good SCR|\?color=bad SCR]')*

Control placeholders:
    {num_lock} a boolean based on xset data
    {caps_lock} a boolean based on xset data
    {scroll_lock} a boolean based on xset data

Color options:
    color_good: Lock on
    color_bad: Lock off

Examples:
```
# hide NUM, CAPS, SCR
keyboard_locks {
    format = '\?color=good [\?if=num_lock NUM][\?soft  ]'
    format += '[\?if=caps_lock CAPS][\?soft  ][\?if=scroll_lock SCR]'
}
```

@author lasers

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'NUM CAPS SCR'}

no_locks
{'color': '#FF0000', 'full_text': 'NUM CAPS SCR'}
"""


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 1
    format = (
        r"[\?if=num_lock&color=good NUM|\?color=bad NUM] "
        r"[\?if=caps_lock&color=good CAPS|\?color=bad CAPS] "
        r"[\?if=scroll_lock&color=good SCR|\?color=bad SCR]"
    )

    def post_config_hook(self):
        items = [
            "icon_num_on",
            "icon_num_off",
            "icon_caps_on",
            "icon_caps_off",
            "icon_scr_on",
            "icon_scr_off",
        ]
        if self.py3.format_contains(self.format, ["caps", "num", "scr"]) or (
            any(getattr(self, v, None) is not None for v in items)
        ):
            raise Exception("please update the config for this module")
        # end deprecation
        self.locks = {}
        self.keyring = {"num_lock": "Num", "caps_lock": "Caps", "scroll_lock": "Scroll"}

    def keyboard_locks(self):
        xset_data = self.py3.command_output("xset q")
        for k, v in self.keyring.items():
            self.locks[k] = "on" in xset_data.split(f"{v} Lock:")[1][0:6]

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, self.locks),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/khal_calendar.py
================================================
"""
Displays upcoming khal events.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 60)
    config_path: Path to khal configuration file. The default None resolves to /home/$USER/.config/khal/config (default None)
    date_end: Until which datetime the module searches for events (default 'eod')
    format: display format for this module (default '{appointments}')
    max_results: an upper bound for the number of returned calendar entries (default None)
    output_format: khal conform format for displaying event output (default '{start-time} {title}')

Format placeholders:
    {appointments} list of events in time range

Requires:
    khal: https://github.com/pimutils/khal

@author @xenrox
@license BSD

SAMPLE OUTPUT
{'full_text': '13:00 Eat lunch'}

"""

from datetime import datetime
from re import compile as re_compile

from khal.cli import build_collection
from khal.controllers import khal_list
from khal.settings import get_config


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 60
    config_path = None
    date_end = "eod"
    format = "{appointments}"
    max_results = None
    output_format = "{start-time} {title}"

    def _format_output(self, output):
        ansi_escape = re_compile(r"\x1B\[[0-?]*[ -/]*[@-~]")
        return ansi_escape.sub("", output)

    def _init_config(self):
        self.config = get_config(self.config_path)
        self.collection = build_collection(self.config, None)
        self.datetimeformat = self.config["locale"]["datetimeformat"]

    def khal_calendar(self):
        self._init_config()
        daterange = str(datetime.now().strftime(self.datetimeformat)) + " " + self.date_end
        output = khal_list(self.collection, daterange, self.config, self.output_format)
        output = [self._format_output(x) for x in output[1:]][: self.max_results]

        output = " ".join(output)
        khal_data = {"appointments": output}
        return {
            "full_text": self.py3.safe_format(self.format, khal_data),
            "cached_until": self.py3.time_in(self.cache_timeout),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    config = {"always_show": True}
    from py3status.module_test import module_test

    module_test(Py3status, config=config)



================================================
FILE: py3status/modules/lm_sensors.py
================================================
r"""
Display temperatures, voltages, fans, and more from hardware sensors.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    chips: specify a list of chips to use (default [])
    format: display format for this module (default '{format_chip}')
    format_chip: display format for chips (default '{name} {format_sensor}')
    format_chip_separator: show separator if more than one (default ' ')
    format_sensor: display format for sensors
        (default '[\?color=darkgray {name}] [\?color=auto.input&show {input}]')
    format_sensor_separator: show separator if more than one (default ' ')
    sensors: specify a list of sensors to use (default [])
    thresholds: specify color thresholds to use (default {'auto.input': True})

Format placeholders:
    {format_chip}   format for chips

Format_chip placeholders:
    {name}          chip name, eg coretemp-isa-0000, nouveau-pci-0500
    {adapter}       adapter type, eg ISA adapter, PCI adapter
    {format_sensor} format for sensors

Format_sensor placeholders:
    {name}          sensor name, eg core_0, gpu_core, temp1, fan1

    See `sensors -u` for a full list of placeholders for `format_chip`,
    `format_sensors` without the prefixes, `chips` and `sensors` options.

    See https://www.kernel.org/doc/Documentation/hwmon/sysfs-interface
    for more information on the sensor placeholders.

Color options for `auto.input` threshold:
    color_zero: zero value or less (color red)
    color_min: minimum value (color lightgreen)
    color_excl_input: input value excluded from threshold (color None)
    color_input: input value (color lime)
    color_near_max: input value near maximum value (color yellow)
    color_max: maximum value (color orange)
    color_near_crit: input value near critical value (color lightcoral)
    color_crit: critical value (color red)

Color thresholds:
    format_sensor:
        xxx: print a color based on the value of `xxx` placeholder
        auto.input: print a color based on the value of `input` placeholder
            against a customized threshold

Requires:
    lm_sensors: a tool to read temperature/voltage/fan sensors
    sensors-detect: see `man sensors-detect # --auto` to read about
        using defaults or to compile a list of kernel modules

Examples:
```
# identify possible chips, sensors, placeholders, etc
    [user@py3status ~] $ sensors -u
    ----------------------------- # ──────────────────────────────────────
    coretemp-isa-0000             # chip {name}         # chip: coretemp*
    Adapter: ISA adapter          #  ├── {adapter} type
    ----                          #  │------------------------------------
    Core 0:                       #  ├── sensor {name}  # sensor: core_0
      temp2_input: 48.000         #  │    ├── {input}
      temp2_max: 81.000           #  │    ├── {max}
      temp2_crit: 91.000          #  │    ├── {crit}
      temp2_crit_alarm: 0.000     #  │    └── {crit_alarm}
    Core 1:                       #  └── sensor {name}  # sensor: core_1
      temp3_input: 48.000         #       ├── {input}
      temp3_max: 81.000           #       ├── {max}
      temp3_crit: 91.000          #       ├── {crit}
      temp3_crit_alarm: 0.000     #       └── {crit_alarm}
                                  # ──────────────────────────────────────
    k10temp-pci-00c3              # chip {name}         # chip: k10temp*
    Adapter: PCI adapter          #  ├── {adapter} type
    ----                          #  │------------------------------------
    temp1:                        #  ├── sensor {name}  # sensor: temp1
      temp1_input: 30.000         #  │    ├── {input}
      temp1_max: -71.000          #  │    ├── {max}
      temp1_min: -15.000          #  │    ├── {min}
      temp1_alarm: 1.000          #  │    ├── {alarm}
      temp1_offset: 0.000         #  │    ├── {offset}
      temp1_beep: 0.000           #  │    └── {beep}
    intrusion0:                   #  └── sensor {name}  # sensor: intrusion0
      intrusion0_alarm: 0.000     #       └── {alarm}

    Solid lines denotes chips. Dashed lines denotes sensors.
    Sensor names are lowercased and its spaces replaced with underscores.
    The numbered prefixes, eg `temp1_*` are removed to keep names clean.

# specify chips to use
lm_sensors {
    chips = ['coretemp-isa-0000']  # full
        OR
    chips = ['coretemp-*']  # lm_sensors-compatible wildcard
}

# specify sensors to use
lm_sensors {
    sensors = ['core_0', 'core_1', 'core_2', 'core_3']  # full
        OR
    sensors = ['core_*']  # fnmatch
}

# show name per chip, eg CPU 35°C 36°C 37°C 39°C GPU 52°C
lm_sensors {
    format_chip = '[\?if=name=coretemp-isa-0000 CPU ]'
    format_chip += '[\?if=name=nouveau-pci-0500 GPU ]'
    format_chip += '{format_sensor}'
    format_sensor = '\?color=auto.input {input}°C'
    sensors = ['core*', 'temp*']
}

# show name per sensor, eg CPU1 35°C CPU2 36°C CPU3 37°C CPU4 39°C GPU 52°C
lm_sensors {
    format_chip = '{format_sensor}'
    format_sensor = '[\?if=name=core_0 CPU1 ]'
    format_sensor += '[\?if=name=core_1 CPU2 ]'
    format_sensor += '[\?if=name=core_2 CPU3 ]'
    format_sensor += '[\?if=name=core_3 CPU4 ]'
    format_sensor += '[\?if=name=gpu_core GPU ]'
    format_sensor += '[\?color=auto.input {input}°C]'
    sensors = ['core*', 'temp*']
}
```

@author lasers

SAMPLE OUTPUT
[
    {'full_text': 'coretemp-isa-000 '},
    {'full_text': 'core_0 ', 'color': '#a9a9a9'},
    {'full_text': '39 ', 'color': '#00ff00'},
    {'full_text': 'core_1 ', 'color': '#a9a9a9'},
    {'full_text': '40', 'color': '#00ff00'},
]

chip_names
[
    {'full_text': 'CPU '},
    {'full_text': '62°C ', 'color': '#00ff00'},
    {'full_text': '76°C ', 'color': '#ffff00'},
    {'full_text': '83°C ', 'color': '#ffa500'},
    {'full_text': '92°C ', 'color': '#ff0000'},
    {'full_text': 'GPU '},
    {'full_text': '52°C', 'color': '#00ff00'},
]

sensor_names
[
    {'full_text': 'CPU1 '},
    {'full_text': '62°C ', 'color': '#00ff00'},
    {'full_text': 'CPU2 '},
    {'full_text': '76°C ', 'color': '#ffff00'},
    {'full_text': 'TEMP1 '},
    {'full_text': '30 ', 'color': '#ffa500'},
    {'full_text': 'TEMP2 '},
    {'full_text': '27 ', 'color': '#ffa500'},
    {'full_text': 'GPU '},
    {'full_text': '52°C', 'color': '#00ff00'},
]
"""

import re
from collections import OrderedDict
from fnmatch import fnmatch
from json import loads

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    chips = []
    format = "{format_chip}"
    format_chip = "{name} {format_sensor}"
    format_chip_separator = " "
    format_sensor = r"[\?color=darkgray {name}] [\?color=auto.input&show {input}]"
    format_sensor_separator = " "
    sensors = []
    thresholds = {"auto.input": True}

    def post_config_hook(self):
        self.lm_sensors_command = ["sensors", "-j"]
        if not self.py3.check_commands(self.lm_sensors_command):
            raise Exception(STRING_NOT_INSTALLED)

        placeholders = self.py3.get_placeholders_list(self.format_sensor)
        format_sensor = {x: ":g" for x in placeholders if x != "name"}
        self.sensor_placeholders = [x for x in placeholders if x != "name"]
        self.format_sensor = self.py3.update_placeholder_formats(self.format_sensor, format_sensor)

        self.lm_sensors_pattern = re.compile(r'(?<=})\n(?={)', re.MULTILINE)
        self.first_run = True

        if self.chips:
            lm_sensors_data = self._get_lm_sensors_data()
            chips = OrderedDict()
            for _filter in self.chips:
                for chip_name in lm_sensors_data:
                    if fnmatch(chip_name, _filter):
                        chips[_filter] = None
            self.lm_sensors_command += OrderedDict.keys(chips)

        self.sensors = {"list": [], "name": {}, "sensors": self.sensors}

        self.thresholds_auto = False
        self.thresholds_man = self.py3.get_color_names_list(self.format_sensor)
        if (
            all("auto.input" in x for x in [self.thresholds, self.thresholds_man])
            and "input" in placeholders
        ):
            self.color_zero = self.py3.COLOR_ZERO or "red"
            self.color_input = self.py3.COLOR_INPUT or "lime"
            self.color_min = self.py3.COLOR_MIN or "lightgreen"
            self.color_excl_input = self.py3.COLOR_EXCL_INPUT or None
            self.color_near_max = self.py3.COLOR_NEAR_MAX or "yellow"
            self.color_max = self.py3.COLOR_MAX or "orange"
            self.color_near_crit = self.py3.COLOR_NEAR_CRIT or "lightcoral"
            self.color_crit = self.py3.COLOR_CRIT or "red"

            self.thresholds_auto = self.thresholds["auto.input"]
            del self.thresholds["auto.input"]

        if "auto.input" in self.thresholds_man:
            self.thresholds_man.remove("auto.input")

    def _get_lm_sensors_data(self):
        output = self.py3.command_output(self.lm_sensors_command)
        temporary = OrderedDict()

        for chunk in self.lm_sensors_pattern.split(output):
            temporary.update(loads(chunk))

        return temporary

    def lm_sensors(self):
        lm_sensors_data = self._get_lm_sensors_data()
        new_chip = []

        for chip_name, sensors in lm_sensors_data.items():
            chip = {
                "name": chip_name,
                "adapter": sensors.pop("Adapter"),
                "sensors": {},
            }

            new_sensor = []
            for sensor_key, sensor in sensors.items():
                try:
                    sensor_name = self.sensors["name"][sensor_key]
                except KeyError:
                    sensor_name = sensor_key.lower().replace(" ", "_")
                    self.sensors["name"][sensor_key] = sensor_name

                if self.sensors["sensors"]:
                    if self.first_run:
                        for _filter in self.sensors["sensors"]:
                            if fnmatch(sensor_name, _filter):
                                self.sensors["list"].append(sensor_name)
                    if sensor_name not in self.sensors["list"]:
                        continue

                chip["sensors"][sensor_name] = {}
                for temp_key, value in sensor.items():
                    try:
                        temp_name = self.sensors["name"][temp_key]
                    except KeyError:
                        temp_name = temp_key.split("_", 1)[-1]
                        self.sensors["name"][temp_key] = temp_name
                    chip["sensors"][sensor_name][temp_name] = value

            for sensor_name, sensor in chip["sensors"].items():
                sensor["name"] = sensor_name

                for x in self.thresholds_man:
                    if x in sensor:
                        self.py3.threshold_get_color(sensor[x], x)

                if self.thresholds_auto:
                    auto_input = []
                    _input = sensor.get("input")
                    if self.first_run and _input is not None:
                        _input = float(_input)
                        _min = float(sensor.get("min", 0))
                        _max = float(sensor.get("max", 0))
                        _crit = float(sensor.get("crit", 0))
                        auto_input.append((0, self.color_zero))
                        if _min or _max or _crit:
                            _color_input = self.color_input
                        else:
                            _color_input = self.color_excl_input
                        auto_input.append((0.001, _color_input))
                        if _min >= _input:
                            auto_input.append((_min, self.color_min))
                        if _max:
                            _near_max = _max - _max / 100 * 10
                            auto_input.append((_near_max, self.color_near_max))
                            auto_input.append((_max, self.color_max))
                        if _crit:
                            _near_crit = _crit - _crit / 100 * 10
                            auto_input.append((_near_crit, self.color_near_crit))
                            auto_input.append((_crit, self.color_crit))

                    key = "{}/{}".format(chip["name"], sensor["name"])
                    self.py3.threshold_get_color(_input, ("auto.input", key, auto_input))

                for x in self.sensor_placeholders:
                    if x not in sensor:
                        sensor[x] = None

                new_sensor.append(self.py3.safe_format(self.format_sensor, sensor))

            format_sensor_separator = self.py3.safe_format(self.format_sensor_separator)
            format_sensor = self.py3.composite_join(format_sensor_separator, new_sensor)

            chip["format_sensor"] = format_sensor
            del chip["sensors"]

            new_chip.append(self.py3.safe_format(self.format_chip, chip))

        format_chip_separator = self.py3.safe_format(self.format_chip_separator)
        format_chip = self.py3.composite_join(format_chip_separator, new_chip)
        self.first_run = False

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"format_chip": format_chip}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/loadavg.py
================================================
r"""
Display average system load over a period of time.

In UNIX computing, the system load is a measure of the amount of computational
work that a computer system performs. The load average represents the average
system load over a period of time. It conventionally appears in the form of
three numbers which represent the system load during the last one-, five-,
and fifteen-minute periods.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 5)
    format: display format for this module
        *(default 'Loadavg [\?color=1avg {1min}] '
        '[\?color=5avg {5min}] [\?color=15avg {15min}]')*
    thresholds: specify color thresholds to use
        *(default [(0, '#9dd7fb'), (20, 'good'),
        (40, 'degraded'), (60, '#ffa500'), (80, 'bad')])*

Format placeholders:
    {1min} load average during the last 1-minute, eg 1.44
    {5min} load average during the last 5-minutes, eg 1.66
    {15min} load average during the last 15-minutes, eg 1.52
    {1avg} load average percentage during the last 1-minute, eg 12.00
    {5avg} load average percentage during the last 5-minutes, eg 13.83
    {15avg} load average percentage during the last 15-minutes, eg 12.67

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Notes:
    http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages
    http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html

Examples:
```
# show load averages with static colors
loadavg {
    format = 'Loadavg [\?color=orange {1min} ][\?color=gold {5min} {15min}]'
}

# remove prefix - easy copy and paste
loadavg {
    format = '[\?color=1avg {1min}] '
    format += '[\?color=5avg {5min}] '
    format += '[\?color=15avg {15min}]'
}

# show detailed load averages + percentages
loadavg {
    format = 'Loadavg [\?color=darkgray '
    format += '1min [\?color=1avg {1min}]\|[\?color=1avg {1avg}%] '
    format += '5min [\?color=5avg {5min}]\|[\?color=5avg {5avg}%] '
    format += '15min [\?color=15avg {15min}]\|[\?color=15avg {15avg}%]]'
}

# show load averages with different colors + thresholds
loadavg {
    # htop - default
        (0, '#9dd7fb'),     # 1avg
        (0, 'cyan'),        # 5avg
        (0, 'darkcyan'),    $ 15avg

    # htop - monochrome
        (0, '#9dd7fb'),     # 1avg
        (0, None),          # 5avg
        (0, None),          # 15avg

    # htop - black night
        (0, 'greenyellow'), # 1avg
        (0, 'limegreen'),   # 5avg
        (0, 'limegreen'),   # 15avg

    # htop - mc
        (0, '#ffffff'),     # 1avg
        (0, '#aaaaaa'),     # 5avg
        (0, '#555555'),     # 15avg

    # three shades of blue
        (0, '#87cefa'),     # 1avg
        (0, '#4bb6f8'),     # 5avg
        (0, '#0991e5'),     # 15avg

    # three shades of gray
        (0, '#dddddd'),     # 1avg
        (0, '#bbbbbb'),     # 5avg
        (0, '#999999'),     # 15avg

    # htop - mc and three shades of gray is similar. htop - mc
    # have higher contrast between time periods over three shades
    # of gray for better readability. your mileage may vary.

    thresholds = {
        '1avg': [
            (0, 'REPLACE_ME'),
            (20, 'good'), (40, 'degraded'),
            (60, '#ffa500'), (80, 'bad')
        ],
        '5avg': [
            (0, 'REPLACE_ME'),
            (20, 'good'), (40, 'degraded'),
            (60, '#ffa500'), (80, 'bad')
        ],
        '15avg': [
            (0, 'REPLACE_ME'),
            (20, 'good'), (40, 'degraded'),
            (60, '#ffa500'), (80, 'bad')
        ],
    }
}

# don't show load averages if 1avg is under 60%
loadavg {
    format = '[\?if=1avg>59 Loadavg [\?color=1avg {1min}] '
    format += '[\?color=5avg {5min}] [\?color=15avg {15min}]]'
}

# add your snippets here
loadavg {
    format = "..."
}
```

@author lasers

SAMPLE OUTPUT
[
    {'full_text': 'Loadavg '},
    {'full_text': '2.73 1.84 1.34', 'color': '#9dd7fb'},
]

detailed
[
    {'full_text': '1min ', 'color': '#a9a9a9'},
    {'full_text': '0.48', 'color': '#9DD7FB'},
    {'full_text': '|', 'color': '#a9a9a9'},
    {'full_text': '4.0%', 'color': '#9DD7FB'},
    {'full_text': ' 5min ', 'color': '#a9a9a9'},
    {'full_text': '0.51', 'color': '#9DD7FB'},
    {'full_text': '|', 'color': '#a9a9a9'},
    {'full_text': '4.2%', 'color': '#9DD7FB'},
    {'full_text': ' 15min ', 'color': '#a9a9a9'},
    {'full_text': '0.54', 'color': '#9DD7FB'},
    {'full_text': '|', 'color': '#a9a9a9'},
    {'full_text': '4.5%', 'color': '#9DD7FB'}
]

percentages
[
    {'full_text': 'percentages '},
    {'full_text': '65.1% ', 'color': '#ffa500'},
    {'full_text': '44.8% ', 'color': '#ffff00'},
    {'full_text': '25.0%', 'color': '#00ff00'},
]

shadesofgrey
[
    {'full_text': 'shades_of_grey '},
    {'full_text': '0.49 ', 'color': '#dddddd'},
    {'full_text': '0.70 ', 'color': '#bbbbbb'},
    {'full_text': '0.89', 'color': '#999999'},
]

shadesofblue
[
    {'full_text': 'shades_of_blue '},
    {'full_text': '0.88 ', 'color': '#87cefa'},
    {'full_text': '0.92 ', 'color': '#35adf7'},
    {'full_text': '0.91', 'color': '#0983cf'},
]

monochrome
[
    {'full_text': 'monochrome '},
    {'full_text': '0.41 ', 'color': '#9dd7fb'},
    {'full_text': '0.75 0.85'},
]

htop
[
    {'full_text': 'htop '},
    {'full_text': '1.64 ', 'color': '#9dd7fb'},
    {'full_text': '1.68 ', 'color': '#00ffff'},
    {'full_text': '1.67', 'color': '#008b8b'},
]

black_night
[
    {'full_text': 'black_night '},
    {'full_text': '0.51 ', 'color': '#adff2f'},
    {'full_text': '1.01 0.93', 'color': '#32cd32'},
]

orange_gold
[
    {'full_text': 'orange_gold '},
    {'full_text': '0.51 ', 'color': '#ffa500'},
    {'full_text': '1.01 0.93', 'color': '#ffd700'},
]
"""

from multiprocessing import cpu_count
from os import getloadavg


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 5
    format = r"Loadavg [\?color=1avg {1min}] " r"[\?color=5avg {5min}] [\?color=15avg {15min}]"
    thresholds = [
        (0, "#9dd7fb"),
        (20, "good"),
        (40, "degraded"),
        (60, "#ffa500"),
        (80, "bad"),
    ]

    class Meta:
        update_config = {
            "update_placeholder_format": [
                {
                    "placeholder_formats": {
                        "1min": ":.2f",
                        "5min": ":.2f",
                        "15min": ":.2f",
                        "1avg": ":.1f",
                        "5avg": ":.1f",
                        "15avg": ":.1f",
                    },
                    "format_strings": ["format"],
                }
            ]
        }

    def post_config_hook(self):
        self.load_data = {}
        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def loadavg(self):
        cpu = float(cpu_count())

        for key, value in zip(["1", "5", "15"], getloadavg()):
            self.load_data[key + "min"] = value
            self.load_data[key + "avg"] = value / cpu * 100

        for x in self.thresholds_init:
            if x in self.load_data:
                self.py3.threshold_get_color(self.load_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, self.load_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/mail.py
================================================
r"""
Display number of messages in various mailbox formats.
This module supports Maildir, mbox, MH, Babyl, MMDF, and IMAP.

Configuration parameters:
    accounts: specify a dict consisting of mailbox types and a list of dicts
        consisting of mailbox settings and/or paths to use (default {})
    cache_timeout: refresh interval for this module (default 60)
    format: display format for this module
        (default '\?not_zero Mail {mail}|No Mail')
    thresholds: specify color thresholds to use (default [])

Format placeholders:
    {mail}    number of messages
    {maildir} number of Maildir messages
    {mbox}    number of mbox messages
    {mh}      number of MH messages
    {babyl}   number of Babyl messages
    {mmdf}    number of MMDF messages
    {imap}    number of IMAP messages

    We can divide mailbox, eg `{maildir}`, into numbered placeholders based
    on number of mailbox accounts, eg `{maildir_1}`, and if we add `name` to
    a mailbox account, we can use `{name}` placeholder instead, eg `{home}`.

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

IMAP Subscriptions:
    You can specify a list of filters to decide which folders to search.
    By default, we search only the INBOX folder (ie: `['^INBOX$']`). We
    can use regular expressions, so if you use more than one, it would
    be joined by a logical operator `or`.

    `'.*'` will match all folders.
    `'pattern'` will match folders containing `pattern`.
    `'^pattern'` will match folders beginning with `pattern`.
    `'pattern$'` will match folders ending with `pattern`.
    `'^((?![Ss][Pp][Aa][Mm]).)*$'` will match all folders
    except for every possible case of `spam` folders.

    For more documentation, see https://docs.python.org/3/library/re.html
    and/or any regex builder on the web. Don't forget to escape characters.

Examples:
```
# add multiple accounts
mail {                                       #
    accounts = {                             #     {mail}
        'maildir': [                         #      ├── {maildir}
            {'path': '~/.mutt'},             #      │    ├── {maildir_1}
            {'path': '~/Mail'},              #      │    └── {maildir_2}
        ],                                   #      │
        'mbox': [                            #      ├── {mbox}
            {'path': '~/home.mbox'},         #      │    ├── {mbox_1}
            {                                #      │    ├── {mbox_2}
                'name': 'local',             # <----│----│----└── {local}
                'path': '~/mbox'             #      │    │
            },                               #      │    │
            {                                #      │    └── {mbox_3}
                'name': 'debian',            # <----│---------└── {debian}
                'path': '/var/mail/$USER'    #      │
                'urgent': False,             # <----│---- disable urgent
            },                               #      │
        ],                                   #      │
        'mh': [                              #      ├── {mh}
            {'path': '~/mh_mail'},           #      │    └── {mh_1}
        ],                                   #      │
        'babyl': [                           #      ├── {babyl}
            {'path': '~/babyl_mail'},        #      │    └── {babyl_1}
        ],                                   #      │
        'mmdf': [                            #      ├── {mmdf}
            {'path': '~/mmdf_mail'},         #      │    └── {mmdf_1}
        ]                                    #      │
        'imap': [                            #      ├── {imap}
            {                                #      │    ├── {imap_1}
                'name': 'home',              # <----│----│----└── {home}
                'user': 'lasers',            #      │    │
                'password': 'kiss_my_butt!', #      │    │
                'server': 'imap.gmail.com',  #      │    │
                                             #  <---│----│ no filters to
                'port': 993,                 #      │    │ search folders, use
                                             #      │    │ filters ['^INBOX$']
            },                               #      │    │
            {                                #      │    └── {imap_2}
                'name': 'work',              # <----│---------└── {work}
                'user': 'tobes',             #      │
                'password': 'i_love_python', #
                'server': 'imap.yahoo.com',  #
                                             # <---- no port, use port 993
                'urgent': False,             # <---- disable urgent
                                             #       for this account
                'filters': ['^INBOX$']       # <---- specify a list of filters
                                             #       to search folders
                'log': True,                 # <---- print a list of folders
            }                                #       to filter in the log
        ]
    }
    allow_urgent = False             <---- disable urgent for all accounts
}

# add colors, disable urgent
mail {
    format = '[\?color=mail&show Mail] {mail}'
    thresholds = [(1, 'good'), (5, 'degraded'), (15, 'bad')]
    allow_urgent = False
}

# identify the mailboxes, remove what you don't need
mail {
    format = '[\?color=mail '
    format += '[\?if=imap&color=#00ff00 IMAP ]'
    format += '[\?if=maildir&color=#ffff00 MAILDIR ]'
    format += '[\?if=mbox&color=#ff0000 MBOX ]'
    format += '[\?if=babyl&color=#ffa500 BABYL ]'
    format += '[\?if=mmdf&color=#00bfff MMDF ]'
    format += '[\?if=mh&color=#ee82ee MH ]'
    format += ']'
    format += '[\?not_zero&color Mail {mail}|No Mail]'
}

# individual colorized mailboxes, remove what you don't need
mail {
    format = '[\?if=imap&color=#00ff00 IMAP] {imap} '
    format += '[\?if=maildir&color=#ffff00 MAILDIR] {maildir} '
    format += '[\?if=mbox&color=#ff0000 MBOX] {mbox} '
    format += '[\?if=babyl&color=#ffa500 BABYL] {babyl} '
    format += '[\?if=mmdf&color=#00bfff MMDF] {mmdf} '
    format += '[\?if=mh&color=#ee82ee MH] {mh}'
    allow_urgent = False
}
```

@author lasers

SAMPLE OUTPUT
{'full_text': 'Mail 15', 'urgent': True}

identified
[
    {'full_text': 'IMAP ', 'color': '#00ff00'},
    {'full_text': 'MAILDIR ', 'color': '#ffff00'},
    {'full_text': 'MBOX ', 'color': '#ff0000'},
    {'full_text': 'Mail 15'},
]

individualized
[
    {'full_text': 'IMAP ', 'color': '#00ff00'}, {'full_text': 'Mail 10 '},
    {'full_text': 'MAILDIR ', 'color': '#ffff00'}, {'full_text': 'Mail 2 '},
    {'full_text': 'MBOX ', 'color': '#ff0000'}, {'full_text': 'Mail 3'},
]

no_mail
{'full_text': 'No Mail'}
"""

import mailbox
import os
from csv import reader
from imaplib import IMAP4, IMAP4_SSL
from pathlib import Path

STRING_MISSING = "missing {} {}"
STRING_INVALID_NAME = "invalid name `{}`"
STRING_INVALID_BOX = "invalid mailbox `{}`"
STRING_INVALID_FILTER = "invalid imap filters `{}`"


class Py3status:
    """"""

    # available configuration parameters
    accounts = {}
    cache_timeout = 60
    format = r"\?not_zero Mail {mail}|No Mail"
    thresholds = []

    def post_config_hook(self):
        if not self.accounts:
            raise Exception("missing accounts")

        self.first_run = True
        self.mailboxes = {}
        mailboxes = ["Maildir", "mbox", "mh", "Babyl", "MMDF", "IMAP"]
        lowercased_names = [x.lower() for x in mailboxes]
        reserved_names = lowercased_names + ["mail"]
        for mail, accounts in self.accounts.items():
            if mail not in lowercased_names:
                raise Exception(STRING_INVALID_BOX.format(mail))
            self.mailboxes[mail] = []
            for account in accounts:
                if "name" in account:
                    name = account["name"]
                    strip = name.rstrip("_0123456789")
                    if any(x in [name, strip] for x in reserved_names):
                        raise Exception(STRING_INVALID_NAME.format(name))
                    reserved_names.append(name)
                account.setdefault("urgent", True)
                if mail == "imap":
                    for v in ["user", "password", "server"]:
                        if v not in account:
                            raise Exception(STRING_MISSING.format(mail, v))
                    account.setdefault("port", 993)
                    if "filters" in account:
                        filters = account["filters"]
                        if not isinstance(filters, list):
                            raise Exception(STRING_INVALID_FILTER.format(filters))
                    else:
                        account["filters"] = ["^INBOX$"]
                    account["folders"] = []
                    self.mailboxes[mail].append(account)
                else:
                    for box in mailboxes[:-1]:
                        if mail == box.lower():
                            if "path" not in account:
                                raise Exception(STRING_MISSING.format(mail, "path"))
                            path = Path(os.path.expandvars(account["path"])).expanduser()
                            if not path.exists():
                                path = f"path: {path}"
                                raise Exception(STRING_MISSING.format(mail, path))
                            account["box"] = box
                            account["path"] = path
                            self.mailboxes[mail].append(account)
                            break

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def mail(self):
        mail_data = {"mail": 0, "urgent": False}
        for k, v in self.mailboxes.items():
            mail_data[k] = 0
            for i, account in enumerate(v, 1):
                if k == "imap":
                    inbox = IMAP4_SSL(account["server"], account["port"])
                    inbox.login(account["user"], account["password"])

                    if self.first_run:
                        import re

                        filters = "|".join(account.pop("filters"))
                        objs = [x.decode() for x in inbox.list()[1]]
                        folders = [x[-1] for x in reader(objs, delimiter=" ")]
                        lines = [f"===== IMAP {i} ====="]
                        for name in folders:
                            subscribed = " "
                            try:
                                if re.search(filters, name):
                                    subscribed = "x"
                                    folder = name.replace("\\", "\\\\")
                                    folder = folder.replace('"', '\\"')
                                    folder = f'"{folder}"'
                                    account["folders"].append(folder)
                            except re.error:
                                account["folders"] = []
                                break
                            lines.append(f"[{subscribed}] {name}")
                        if not account["folders"]:
                            self.py3.error(
                                STRING_INVALID_FILTER.format(filters),
                                self.py3.CACHE_FOREVER,
                            )
                        if account.get("log") is True:
                            for line in lines:
                                self.py3.log(line)

                    count_mail = 0
                    for folder in account["folders"]:
                        if inbox.select(folder, readonly=True)[0] == "OK":
                            imap_data = inbox.search(None, "(UNSEEN)")
                            count_mail += len(imap_data[1][0].split())
                        else:
                            account["folders"].remove(folder)
                    try:
                        inbox.close()
                        inbox.logout()
                    except IMAP4.error:
                        pass
                else:
                    inbox = getattr(mailbox, account["box"])(account["path"], create=False)
                    count_mail = len(inbox)
                    inbox.close()
                if "name" in account:
                    mail_data[account["name"]] = count_mail
                if account["urgent"] and count_mail:
                    mail_data["urgent"] = True
                mail_data[f"{k}_{i}"] = count_mail
                mail_data["mail"] += count_mail
                mail_data[k] += count_mail

        for x in self.thresholds_init:
            if x in mail_data:
                self.py3.threshold_get_color(mail_data[x], x)

        self.first_run = False

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, mail_data),
        }
        if mail_data["urgent"]:
            response["urgent"] = True
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/mega_sync.py
================================================
"""
Display status of MEGAcmd.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for the module (default "MEGA {format_sync}|No MEGA")
    format_sync: display format for every sync (default "{syncstate}")
    format_sync_separator: show separator if more than one sync (default " ")

Format placeholders:
    {format_sync} Format for every sync returned by 'mega-sync' command.

format_sync placeholders:
    Any column returned by 'mega-sync' command - in lower case!
    For example: id, syncstate, localpath

Requires:
    MEGAcmd: command-line interface for MEGA

@author Maxim Baz (https://github.com/maximbaz)
@license BSD

SAMPLE OUTPUT
{'full_text': 'MEGA Synced'}
"""

STRING_NOT_INSTALLED = "MEGAcmd is not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "MEGA {format_sync}|No MEGA"
    format_sync = "{syncstate}"
    format_sync_separator = " "

    def post_config_hook(self):
        if not self.py3.check_commands("mega-sync"):
            raise Exception(STRING_NOT_INSTALLED)

    def mega_sync(self):
        output = self.py3.command_output("mega-sync").splitlines()

        format_sync = None
        if len(output) > 0:
            columns = output[0].lower().split()
            megasync_data = []
            for line in output[1:]:
                cells = dict(zip(columns, line.split()))
                megasync_data.append(self.py3.safe_format(self.format_sync, cells))

            format_sync_separator = self.py3.safe_format(self.format_sync_separator)
            format_sync = self.py3.composite_join(format_sync_separator, megasync_data)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"format_sync": format_sync}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/moc.py
================================================
r"""
Display song currently playing in moc.

MOC (music on console) is a console audio player for Linux/Unix designed to be
powerful and easy to use. It consists of two parts, a server (moc) and a
player/interface (mocp). It supports OGG, WAV, MP3 and other formats.

Configuration parameters:
    button_next: mouse button to skip next track (default None)
    button_pause: mouse button to pause/play the playback (default 1)
    button_previous: mouse button to skip previous track (default None)
    button_stop: mouse button to stop the playback (default 3)
    cache_timeout: refresh interval for this module (default 5)
    format: display format for this module
        *(default '\?if=is_started [\?if=is_stopped \[\] moc|'
        '[\?if=is_paused \|\|][\?if=is_playing >] {title}]')*
    replacements: specify a list/dict of string placeholders to modify (default None)
    sleep_timeout: when moc is not running, this interval will be used to
        allow one to refresh constantly with time placeholders and/or
        to refresh once every minute rather than every few seconds
        (default 20)

Control placeholders:
    {is_paused} a boolean based on moc status
    {is_playing} a boolean based on moc status
    {is_started} a boolean based on moc status
    {is_stopped} a boolean based on moc status

Format placeholders:
    {album} album name, eg (new output here)
    {artist} artist name, eg (new output here)
    {avgbitrate} audio average bitrate, eg 230kbps
    {bitrate} audio bitrate, eg 230kbps
    {currentsec} elapsed time in seconds, eg 32
    {currenttime} elapsed time in [HH:]MM:SS, eg 00:32
    {file} file location, eg /home/user/Music...
    {rate} audio rate, eg 44kHz
    {songtitle} song title, eg (new output here)
    {state} playback state, eg PLAY, PAUSE, STOP
    {timeleft} time left in [HH:]MM:SS, eg 71:30
    {title} track title, eg (new output here)
    {totalsec} total time in seconds, eg 4322
    {totaltime} total time in seconds, eg 72:02

    Placeholders are retrieved directly from `mocp --info` command.
    The list was harvested once and should not represent a full list.

Color options:
    color_paused: Paused, defaults to color_degraded
    color_playing: Playing, defaults to color_good
    color_stopped: Stopped, defaults to color_bad

Requires:
    moc: a console audio player with simple ncurses interface

Examples:
```
# see 'man mocp' for more buttons
moc {
    on_click 9 = 'exec mocp --example'
}
```

@author lasers

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': '> Music For Programming - Mindaugaszq'}

paused
{'color': '#FFFF00', 'full_text': '|| Music For Programming - Mindaugaszq'}

stopped
{'color': '#FF0000', 'full_text': '[] moc'}
"""

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    button_next = None
    button_pause = 1
    button_previous = None
    button_stop = 3
    cache_timeout = 5
    format = (
        r"\?if=is_started [\?if=is_stopped \[\] moc|"
        r"[\?if=is_paused \|\|][\?if=is_playing >] {title}]"
    )
    replacements = None
    sleep_timeout = 20

    def post_config_hook(self):
        if not self.py3.check_commands("mocp"):
            raise Exception(STRING_NOT_INSTALLED)

        self.color_stopped = self.py3.COLOR_STOPPED or self.py3.COLOR_BAD
        self.color_paused = self.py3.COLOR_PAUSED or self.py3.COLOR_DEGRADED
        self.color_playing = self.py3.COLOR_PLAYING or self.py3.COLOR_GOOD
        self.replacements_init = self.py3.get_replacements_list(self.format)

    def _get_moc_data(self):
        try:
            data = self.py3.command_output("mocp --info")
            is_started = True
        except self.py3.CommandError:
            data = {}
            is_started = False
        return is_started, data

    def _organize_data(self, data):
        temporary = {}
        for line in data.splitlines():
            category, value = line.split(": ", 1)
            temporary[category.lower()] = value
        return temporary

    def moc(self):
        is_paused = is_playing = is_stopped = None
        cached_until = self.sleep_timeout
        color = self.py3.COLOR_BAD

        is_started, moc_data = self._get_moc_data()

        if is_started:
            cached_until = self.cache_timeout
            moc_data = self._organize_data(moc_data)

            self.state = moc_data["state"]
            if self.state == "PLAY":
                is_playing = True
                color = self.color_playing
            elif self.state == "PAUSE":
                is_paused = True
                color = self.color_paused
            elif self.state == "STOP":
                is_stopped = True
                color = self.color_stopped

        for x in self.replacements_init:
            if x in moc_data:
                moc_data[x] = self.py3.replace(moc_data[x], x)

        moc_data.update(
            {
                "is_paused": is_paused,
                "is_playing": is_playing,
                "is_started": is_started,
                "is_stopped": is_stopped,
            }
        )

        return {
            "cached_until": self.py3.time_in(cached_until),
            "color": color,
            "full_text": self.py3.safe_format(self.format, moc_data),
        }

    def on_click(self, event):
        """
        Control moc with mouse clicks.
        """
        button = event["button"]
        if button == self.button_pause:
            if self.state == "STOP":
                self.py3.command_run("mocp --play")
            else:
                self.py3.command_run("mocp --toggle-pause")
        elif button == self.button_stop:
            self.py3.command_run("mocp --stop")
        elif button == self.button_next:
            self.py3.command_run("mocp --next")
        elif button == self.button_previous:
            self.py3.command_run("mocp --prev")
        else:
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/mpd_status.py
================================================
r"""
Display song currently playing in mpd.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds (default 2)
    format: template string (see below)
        (default '{state} [[[{artist} ]- {title}]|[{file}]]')
    hide_on_error: hide the status if an error has occurred (default False)
    hide_when_paused: hide the status if state is paused (default False)
    hide_when_stopped: hide the status if state is stopped (default True)
    host: mpd host (default 'localhost')
    idle_subsystems: a list of subsystems to idle on.
        player: changes in song information, play state
        mixer: changes in volume
        options: e.g. repeat mode
        See the MPD protocol documentation for additional events.
        (default ['player', 'playlist', 'mixer', 'options'])
    idle_timeout: force idle to reset every n seconds (default 3600)
    max_width: maximum status length (default 120)
    password: mpd password (default None)
    port: mpd port (default '6600')
    state_pause: label to display for "paused" state (default '[pause]')
    state_play: label to display for "playing" state (default '[play]')
    state_stop: label to display for "stopped" state (default '[stop]')
    use_idle: whether to use idling instead of polling. None to autodetect
        (default None)

Format placeholders:
    {state} state (paused, playing. stopped) can be defined via `state_..`
        configuration parameters
    Refer to the mpc(1) manual page for the list of available placeholders to
    be used in the format.  Placeholders should use braces `{}` rather than
    percent `%%` eg `{artist}`.
    Every placeholder can also be prefixed with
    `next_` to retrieve the data for the song following the one currently
    playing.

Color options:
    color_pause: Paused, default color_degraded
    color_play: Playing, default color_good
    color_stop: Stopped, default color_bad

Requires:
    python-mpd2: (NOT python2-mpd2)

Examples:
```
# Show state and (artist -) title, if no title fallback to file:
{state} [[[{artist} - ]{title}]|[{file}]]

# Show state, [duration], title (or file) and next song title (or file):
{state} \[{time}\] [{title}|{file}] → [{next_title}|{next_file}]
```

@author shadowprince, zopieux
@license Eclipse Public License

SAMPLE OUTPUT
{'color': '#00ff00', 'full_text': '[play] Music For Programming - Idol Eyes'}

paused
{'color': '#ffff00', 'full_text': '[pause] Music For Programming - Idol Eyes'}

stopped
{'color': '#ff0000', 'full_text': '[stop] Music For Programming - Idol Eyes'}
"""

import datetime
import re
import socket
from threading import Thread
from time import sleep

from mpd import CommandError, ConnectionError, MPDClient

from py3status.composite import Composite


def song_attr(song, attr):
    def parse_mtime(date_str):
        return datetime.datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")

    if attr == "time":
        try:
            duration = int(song["time"])
            if duration > 0:
                minutes, seconds = divmod(duration, 60)
                return f"{minutes:d}:{seconds:02d}"
            raise ValueError
        except (KeyError, ValueError):
            return ""
    elif attr == "position":
        try:
            return "{}".format(int(song["pos"]) + 1)
        except (KeyError, ValueError):
            return ""
    elif attr == "mtime":
        return parse_mtime(song["last-modified"]).strftime("%c")
    elif attr == "mdate":
        return parse_mtime(song["last-modified"]).strftime("%x")

    return song.get(attr, "")


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 2
    format = "{state} [[[{artist} ]- {title}]|[{file}]]"
    hide_on_error = False
    hide_when_paused = False
    hide_when_stopped = True
    host = "localhost"
    idle_subsystems = ["player", "playlist", "mixer", "options"]
    idle_timeout = 3600
    max_width = 120
    password = None
    port = "6600"
    state_pause = "[pause]"
    state_play = "[play]"
    state_stop = "[stop]"
    use_idle = None

    def post_config_hook(self):
        # Convert from %placeholder% to {placeholder}
        # This is not perfect but should be good enough
        if not self.py3.get_placeholders_list(self.format) and "%" in self.format:
            self.format = re.sub("%([a-z]+)%", r"{\1}", self.format)
            self.py3.log("Old % style format DEPRECATED use { style format")
        # class variables:
        self.client = None
        self.current_status = None
        self.idle_thread = Thread()

    def _get_mpd(self, disconnect=False):
        if disconnect:
            try:
                self.client.disconnect()
            finally:
                self.client = None
            return

        try:
            if self.client is None:
                self.client = MPDClient()
                self.client.connect(host=self.host, port=self.port)
                if self.password:
                    self.client.password(self.password)
                if self.use_idle is None:
                    self.use_idle = "idle" in self.client.commands()
                if self.use_idle and self.idle_timeout:
                    self.client.idletimeout = self.idle_timeout
            return self.client
        except (OSError, ConnectionError, CommandError) as e:
            self.client = None
            raise e

    def _state_character(self, state):
        if state == "play":
            return self.state_play
        elif state == "pause":
            return self.state_pause
        elif state == "stop":
            return self.state_stop
        return "?"

    def mpd_status(self):
        # I - get current mpd status (or wait until it changes)
        # this writes into self.current_status
        if self.use_idle is not False:
            if not self.idle_thread.is_alive():
                sleep(self.cache_timeout)  # rate limit thread restarting
                self.idle_thread = Thread(target=self._get_status)
                self.idle_thread.daemon = True
                self.idle_thread.start()
        else:
            self._get_status()

        # II - format response
        (text, state) = ("", "")
        if self.current_status is not None:
            (text, state) = self.current_status

        if len(text) > self.max_width:
            text = "{}...".format(text[: self.max_width - 3])

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": text if state or not self.hide_on_error else "",
        }

        if state:
            if state == "play":
                response["color"] = self.py3.COLOR_PLAY or self.py3.COLOR_GOOD
            elif state == "pause":
                response["color"] = self.py3.COLOR_PAUSE or self.py3.COLOR_DEGRADED
            elif state == "stop":
                response["color"] = self.py3.COLOR_STOP or self.py3.COLOR_BAD

        return response

    def _get_status(self):
        while True:
            try:
                status = self._get_mpd().status()
                song = int(status.get("song", 0))
                next_song = int(status.get("nextsong", 0))

                state = status.get("state")

                if (state == "pause" and self.hide_when_paused) or (
                    state == "stop" and self.hide_when_stopped
                ):
                    text = ""

                else:
                    playlist_info = self._get_mpd().playlistinfo()
                    try:
                        song = self._get_mpd().currentsong() or playlist_info[song]
                    except IndexError:
                        song = {}
                    try:
                        next_song = playlist_info[next_song]
                    except IndexError:
                        next_song = {}

                    song["state"] = next_song["state"] = self._state_character(state)

                    def attr_getter(attr):
                        if attr.startswith("next_"):
                            return song_attr(next_song, attr[5:])
                        return song_attr(song, attr)

                    text = self.py3.safe_format(self.format, attr_getter=attr_getter)
                    if isinstance(text, Composite):
                        text = text.text()

                self.current_status = (text, state)

                if self.use_idle:
                    self.py3.update()
                    self._get_mpd().idle(*self.idle_subsystems)
                else:
                    return

            except (ValueError, OSError, ConnectionError, CommandError) as e:
                # ValueError can happen when status.get(...) returns None; e.g.
                # during reversal of playlist
                if isinstance(e, ValueError):
                    text = "No song information!"
                if isinstance(e, socket.error):
                    text = "Failed to connect to mpd!"
                if isinstance(e, ConnectionError):
                    text = "Error while connecting to mpd!"
                    self._get_mpd(disconnect=True)
                if isinstance(e, CommandError):
                    text = "Failed to authenticate to mpd!"
                    self._get_mpd(disconnect=True)

                self.current_status = (text, None)
                return
            finally:
                self.py3.update()  # to propagate error message

    def kill(self):
        if self.idle_thread.is_alive():
            # otherwise the idling thread will block in mpd.idle() until idle_timeout
            self._get_mpd()._sock.shutdown(socket.SHUT_RD)
            self._get_mpd()._sock.close()
        self._get_mpd(disconnect=True)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/mpris.py
================================================
"""
Display song/video and control MPRIS compatible players.

There are two ways to control the media player. Either by clicking with a mouse
button in the text information or by using buttons. For former you have
to define the button parameters in your config.

Configuration parameters:
    button_next: mouse button to play the next entry (default None)
    button_next_player: mouse button to switch next player in list (Same status as top player) (default None)
    button_prev_player: mouse button to switch previous player in list (Same status as top player) (default None)
    button_previous: mouse button to play the previous entry (default None)
    button_stop: mouse button to stop the player (default None)
    button_switch_to_top_player: mouse button to switch to top player (default None)
    button_toggle: mouse button to toggle between play and pause mode (default 1)
    cache_timeout: time (s) between Position update (default 0.5)
    format: display format for this module
        (default '[{artist} - ][{title}] {previous} {toggle} {next}')
    format_none: define output if no player is running (default 'no player running')
    icon_next: specify icon for next button (default u'\u25b9')
    icon_pause: specify icon for pause button (default u'\u25eb')
    icon_play: specify icon for play button (default u'\u25b7')
    icon_previous: specify icon for previous button (default u'\u25c3')
    icon_stop: specify icon for stop button (default u'\u25a1')
    max_width: maximum status length (default None)
    player_priority: priority of the players.
        Keep in mind that the state has a higher priority than
        player_priority. So when player_priority is "[mpd, bomi]" and mpd is
        paused and bomi is playing than bomi wins. (default [])
    replacements: specify a list/dict of string placeholders to modify (default None)
    state_pause: specify icon for pause state (default u'\u25eb')
    state_play: specify icon for play state (default u'\u25b7')
    state_stop: specify icon for stop state (default u'\u25a1')

Format placeholders:
    {album} album name
    {artist} artist name (first one)
    {length} time duration of the song
    {player} show name of the player
    {player_shortname} show name of the player from busname (usually command line name)
    {state} playback status of the player
    {time} played time of the song
    {title} name of the song
    {tracknumber} track number of the song
    {nowplaying} now playing field provided by VLC for stream info

Button placeholders:
    {next} play the next title
    {pause} pause the player
    {play} play the player
    {previous} play the previous title
    {stop} stop the player
    {toggle} toggle between play and pause

Color options:
    color_control_inactive: button is not clickable
    color_control_active: button is clickable
    color_paused: song is paused, defaults to color_degraded
    color_playing: song is playing, defaults to color_good
    color_stopped: song is stopped, defaults to color_bad

Requires:
    mpris2: Python usable definiton of MPRIS2
    dbus-python: Python bindings for dbus
    PyGObject: Python bindings for GObject Introspection

Tested players:
    bomi: powerful and easy-to-use gui multimedia player based on mpv
    cantata: qt5 client for the music player daemon (mpd)
    mpdris2: mpris2 support for mpd
    vlc: multi-platform mpeg, vcd/dvd, and divx player

Examples:
```
mpris {
    format = "{previous}{play}{next} {player}: {state} [[{artist} - {title}]|[{title}]]"
    format_none = "no player"
    player_priority = "[mpd, cantata, vlc, bomi, *]"
}

only show information from mpd and vlc, but mpd has a higher priority:
mpris {
    player_priority = "[mpd, vlc]"
}

show information of all players, but mpd and vlc have the highest priority:
mpris {
    player_priority = "[mpd, vlc, *]"
}

vlc has the lowest priority:
mpris {
    player_priority = "[*, vlc]"
}
```

@author Moritz Lüdecke, tobes, valdur55

SAMPLE OUTPUT
[
    {'color': '#00FF00', 'full_text': u'\xab \u25ae \xbb \u25b6 '},
    {'color': '#00FF00', 'full_text': u'Happy Mondays - Fat Lady Wrestlers'}
]
"""

import re
import sys
from datetime import timedelta
from enum import IntEnum
from threading import Thread

from dbus import DBusException, SessionBus
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GLib
from mpris2 import Interfaces
from mpris2 import MediaPlayer2 as dMediaPlayer2
from mpris2 import Player as dPlayer
from mpris2 import get_players_uri
from mpris2.types import Metadata_Map


class STATE(IntEnum):
    Playing = 0
    Paused = 1
    Stopped = 2


# noinspection PyProtectedMember
class Player:
    def __init__(
        self,
        parent,
        player_id,
        name_from_id,
        name_with_instance,
        name_priority,
        identity,
        identity_index,
    ):
        self._id = player_id
        self.parent = parent
        self._name_with_instance = name_with_instance
        self._identity = identity
        self._identity_index = identity_index
        self._name_priority = name_priority
        self._metadata = {}
        self._can = {}
        self._buttons = {}
        self._properties_changed_match = None
        self._state = None
        self._player_shortname = name_from_id
        self._dPlayer = dPlayer(dbus_interface_info={"dbus_uri": player_id})
        self._full_name = f"{self._identity} {self._identity_index}"

        self._placeholders = {
            "player": self._identity,
            "player_shortname": self._player_shortname,
            # for debugging ;p
            "full_name": self._full_name,
        }

        # Init data from dbus interface
        self.state = None
        self.metadata = None

        for canProperty in self.parent._used_can_properties:
            self._set_can_property(canProperty, getattr(self._dPlayer, canProperty))

        # Workaround for bug which prevents to use self._dPlayer.propertiesChanged = handler.
        self._properties_changed_match = self.parent._dbus.add_signal_receiver(
            self._player_on_change,
            dbus_interface=Interfaces.PROPERTIES,
            path=Interfaces.OBJECT_PATH,
            signal_name=Interfaces.SIGNAL,
            bus_name=player_id,
        )

    def __del__(self):
        if self._properties_changed_match:
            self.parent._dbus._clean_up_signal_match(self._properties_changed_match)

    @staticmethod
    def _get_time_str(microseconds):
        if microseconds is None:
            return None

        delta = timedelta(seconds=microseconds // 1_000_000)
        delta_str = str(delta).lstrip("0").lstrip(":")
        if delta_str.startswith("0"):
            delta_str = delta_str[1:]
        return delta_str

    def _set_response_buttons(self):
        buttons = {}

        for button, control_state in self.parent._states.items():
            if self.parent.py3.format_contains(self.parent.format, button):
                if self.get_button_state(control_state):
                    color = self.parent._color_active
                else:
                    color = self.parent._color_inactive

                buttons[button] = {
                    "color": color,
                    "full_text": control_state["icon"],
                    "index": button,
                }

        if buttons.get("toggle"):
            buttons["toggle"]["full_text"] = self.parent._state_icon_color_map[self.state][
                "toggle_icon"
            ]

        self._buttons = buttons

    def _set_can_property(self, key, value):
        self._can[key] = value

    def _player_on_change(self, interface_name, data, invalidated_properties):
        is_active_player = self is self.parent._player
        call_set_player = False
        call_update = False

        for key, new_value in data.items():
            if key == "PlaybackStatus":
                self.state = new_value
                call_set_player = True

            elif key == "Metadata":
                if self.parent._format_contains_metadata:
                    self.metadata = new_value
                    call_update = True

            elif key.startswith("Can"):
                self._set_can_property(key, new_value)
                call_update = True

                if key == "CanPlay":
                    call_set_player = True

            elif key == "Rate":
                if is_active_player:
                    self.state = None
                    call_update = True

        if call_set_player:
            return self.parent._set_player()

        if is_active_player and call_update:
            return self.parent.py3.update()

    @property
    def metadata(self):
        return self._metadata

    @metadata.setter
    def metadata(self, metadata=None):
        if not self.parent._format_contains_metadata:
            return

        if metadata is None:
            metadata = self._dPlayer.Metadata

        self._metadata = {}

        if metadata:
            url = metadata.get(Metadata_Map.URL)
            is_stream = url is not None and "file://" not in url
            if is_stream:
                self._metadata["title"] = re.sub(
                    r"\....$", "", metadata.get(Metadata_Map.TITLE, "")
                )
            else:
                self._metadata["title"] = metadata.get(Metadata_Map.TITLE, None)
            self._metadata["album"] = metadata.get(Metadata_Map.ALBUM, None)

            artist = metadata.get(Metadata_Map.ARTIST, None)
            if artist:
                self._metadata["artist"] = artist[0]

            self._metadata["length"] = self._get_time_str(metadata.get(Metadata_Map.LENGTH))

            # we are converting the attribute name to lowercase because although the spec
            # says it's `xesam:trackNumber`, VLC exposes it as `xesam:tracknumber`
            self._metadata["tracknumber"] = metadata.get(Metadata_Map.TRACK_NUMBER.lower())

            self._metadata["nowplaying"] = metadata.get("vlc:nowplaying", None)

            for x in self.parent.replacements_init:
                if x in self._metadata:
                    self._metadata[x] = self.parent.py3.replace(self._metadata[x], x)

        if not self._metadata.get("title"):
            self._metadata["title"] = "No Track"

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, new_value):
        if new_value is None:
            new_value = self._dPlayer.PlaybackStatus

        if new_value != self._state:
            self._state = getattr(STATE, new_value)
            if self is self.parent._player:
                self.prepare_output()

    def send_mpris_action(self, index):
        control_state = self.parent._states.get(index)
        try:
            if self.get_button_state(control_state):
                getattr(self._dPlayer, self.parent._states[index]["action"])()
                self.state = None
        except DBusException as err:
            self.parent.py3.log(
                f"Player {self._name_with_instance} responded {str(err).split(':', 1)[-1]}"
            )

    def prepare_output(self):
        if self.parent._format_contains_control_buttons:
            self._set_response_buttons()

    def get_button_state(self, control_state):
        try:
            clickable = self._can.get(control_state["clickable"], True)
        except Exception:
            clickable = False

        if self.state in control_state.get("inactive", []):
            clickable = False

        return clickable

    @property
    def state_map(self):
        return self.parent._state_icon_color_map[self.state]

    @property
    def data(self):
        """
        Output player specific data
        """
        if self.parent._format_contains_time:
            try:
                ptime = self._get_time_str(self._dPlayer.Position)
            except DBusException:
                ptime = None

            self._placeholders["time"] = ptime

        return dict(self._placeholders, **self.metadata, **self._buttons)

    @property
    def hide(self):
        return not self._can.get("CanPlay")

    @property
    def id(self):
        return self._id

    @property
    def priority_tuple(self):
        if self.hide:
            return None

        return self._state, self._name_priority, self._identity_index, self.id


class Py3status:
    """ """

    # available configuration parameters
    button_next = None
    button_next_player = None
    button_prev_player = None
    button_previous = None
    button_stop = None
    button_switch_to_top_player = None
    button_toggle = 1
    cache_timeout = 0.5
    format = "[{artist} - ][{title}] {previous} {toggle} {next}"
    format_none = "no player running"
    icon_next = "\u25b9"
    icon_pause = "\u25eb"
    icon_play = "\u25b7"
    icon_previous = "\u25c3"
    icon_stop = "\u25a1"
    max_width = None
    player_priority = []
    replacements = None
    state_pause = "\u25eb"
    state_play = "\u25b7"
    state_stop = "\u25a1"

    class Meta:
        deprecated = {
            'remove': [
                {
                    'param': 'player_hide_non_canplay',
                    'msg': 'obsolete because we now hide all non canplay players',
                },
            ],
        }

    def post_config_hook(self):
        self.replacements_init = self.py3.get_replacements_list(self.format)
        self._name_owner_change_match = None
        self._kill = False
        self._mpris_players: dict[Player] = {}
        self._identity_cache = {}
        self._identity_index = {}
        self._priority_cache = {}
        self._player: [Player, None] = None
        self._tries = 0
        self._empty_response = {
            "album": None,
            "artist": None,
            "length": None,
            "title": None,
            "tracknumber": None,
            "nowplaying": None,
            "time": None,
            "state": None,
            "player": None,
            # for debugging ;p
            "full_name": None,
        }

        self._states = {
            "pause": {
                "action": "Pause",
                "clickable": "CanPause",
                "icon": self.icon_pause,
                "inactive": [STATE.Stopped, STATE.Paused],
            },
            "play": {
                "action": "Play",
                "clickable": "CanPlay",
                "icon": self.icon_play,
                "inactive": [STATE.Playing],
            },
            "stop": {
                "action": "Stop",
                "clickable": "CanControl",
                "icon": self.icon_stop,
                "inactive": [STATE.Stopped],
            },
            "next": {
                "action": "Next",
                "clickable": "CanGoNext",
                "icon": self.icon_next,
            },
            "previous": {
                "action": "Previous",
                "clickable": "CanGoPrevious",
                "icon": self.icon_previous,
            },
            "toggle": {
                "action": "PlayPause",
                "clickable": "CanPause",
                # Not used, but it will be set dynamically with player state map.
                "icon": None,
            },
        }

        self._state_icon_color_map = {
            STATE.Playing: {
                "state_icon": self.state_play,
                "color": self.py3.COLOR_PLAYING or self.py3.COLOR_GOOD,
                "toggle_icon": self.state_pause,
                "cached_until": self.cache_timeout,
            },
            STATE.Paused: {
                "state_icon": self.state_pause,
                "color": self.py3.COLOR_PAUSED or self.py3.COLOR_DEGRADED,
                "toggle_icon": self.state_play,
                "cached_until": self.py3.CACHE_FOREVER,
            },
            STATE.Stopped: {
                "state_icon": self.state_stop,
                "color": self.py3.COLOR_STOPPED or self.py3.COLOR_BAD,
                "toggle_icon": self.state_play,
                "cached_until": self.py3.CACHE_FOREVER,
            },
        }

        self._color_active = self.py3.COLOR_CONTROL_ACTIVE or self.py3.COLOR_GOOD
        self._color_inactive = self.py3.COLOR_CONTROL_INACTIVE or self.py3.COLOR_BAD

        self._format_contains_metadata = False
        self._metadata_keys = ["album", "artist", "title", "nowplaying", "length", "tracknumber"]
        for key in self._metadata_keys:
            if self.py3.format_contains(self.format, key):
                self._format_contains_metadata = True
                break

        self._format_contains_control_buttons = False
        self._used_can_properties = []
        for key, value in self._states.items():
            if self.py3.format_contains(self.format, key):
                self._format_contains_control_buttons = True
                self._used_can_properties.append(value["clickable"])

        if "CanPlay" not in self._used_can_properties:
            self._used_can_properties.append("CanPlay")

        self._format_contains_time = self.py3.format_contains(self.format, "time")
        self._button_cache_flush = None
        if 2 not in [
            self.button_next,
            self.button_next_player,
            self.button_prev_player,
            self.button_previous,
            self.button_stop,
            self.button_switch_to_top_player,
            self.button_toggle,
        ]:
            self._button_cache_flush = 2

        if self.player_priority:
            try:
                self._random_player_priority = self.player_priority.index("*")
            except ValueError:
                self._random_player_priority = False
        else:
            self._random_player_priority = 0

        # start last
        self._dbus_loop = DBusGMainLoop()
        self._dbus = SessionBus(mainloop=self._dbus_loop)
        self._start_listener()

    def _start_loop(self):
        self._loop = GLib.MainLoop()
        GLib.timeout_add(1000, self._timeout)
        try:
            self._loop.run()
        except KeyboardInterrupt:
            # This branch is only needed for the test mode
            self._kill = True

    @staticmethod
    def _is_mediaplayer_interface(player_id):
        return player_id.startswith(Interfaces.MEDIA_PLAYER)

    def _dbus_name_owner_changed(self, name, old_owner, new_owner):
        if not self._is_mediaplayer_interface(name):
            return
        if new_owner:
            self._add_player(name)
        if old_owner:
            self._remove_player(name)
        self._set_player()

    def _set_player(self, update=True):
        """
        Sort the current players into priority order and set self._player
        Players are ordered by working state, then by preference supplied by
        user and finally by instance if a player has more than one running.
        """
        players = []
        for name, player in self._mpris_players.items():
            player_priority_tuple = player.priority_tuple
            if player_priority_tuple:
                players.append(player_priority_tuple)

        new_top_player_id = None
        if players:
            new_top_player_id = sorted(players)[0][3]

        self._set_data_entry_point_by_name_key(new_top_player_id, update)

    def _player_on_change(self, interface_name, data, invalidated_properties, sender):
        """
        Monitor a player and update its status.
        """
        pass

    def _add_player(self, player_id):
        """
        Add player to mpris_players
        """
        player_id_parts_list = player_id.split(".")
        name_from_id = player_id_parts_list[3]

        identity = None
        if name_from_id not in ["chromium", "kdeconnect"]:
            identity = self._identity_cache.get(name_from_id)

        if not identity:
            dMediaPlayer = dMediaPlayer2(dbus_interface_info={"dbus_uri": player_id})
            identity = str(dMediaPlayer.Identity)
            self._identity_cache[name_from_id] = identity

        if self.player_priority:
            # Expected value: numeric / False, None is cache miss.
            priority = self._priority_cache.get(name_from_id, None)
            if priority is None:
                for i, _player in enumerate(self.player_priority):
                    if _player == name_from_id or _player == identity:
                        priority = i
                        break

                if priority is None:
                    priority = self._random_player_priority
                self._priority_cache[identity] = priority

            if not isinstance(priority, int):
                return

        else:
            priority = 0

        identity_index = self._identity_index.get(identity, 0)
        if identity_index:
            self._identity_index[identity] += 1
        else:
            self._identity_index[identity] = 1

        name_with_instance = ".".join(player_id_parts_list[3:])

        player = Player(
            self,
            player_id=player_id,
            name_from_id=name_from_id,
            name_with_instance=name_with_instance,
            name_priority=priority,
            identity=identity,
            identity_index=identity_index,
        )

        self._mpris_players[player_id] = player

    def _remove_player(self, player_id):
        """
        Remove player from mpris_players
        """
        if self._mpris_players.get(player_id):
            del self._mpris_players[player_id]

    def _get_players(self):
        for player in get_players_uri():
            try:
                # str(player) helps avoid to use dbus.Str(*) as dict key
                self._add_player(str(player))
            except DBusException:
                continue

        self._set_player()

    def _start_listener(self):
        self._get_players()

        self._name_owner_change_match = self._dbus.add_signal_receiver(
            handler_function=self._dbus_name_owner_changed,
            dbus_interface="org.freedesktop.DBus",
            signal_name="NameOwnerChanged",
        )

        # Start listening things after initiating players.
        t = Thread(target=self._start_loop)
        t.daemon = True
        t.start()

    def _timeout(self):
        if self._kill:
            self._loop.quit()
            sys.exit(0)

    def _set_data_entry_point_by_name_key(self, new_active_player_key, update=True):
        if self._player is None or new_active_player_key != self._player.id:
            self._player = self._mpris_players.get(new_active_player_key, None)
            if self._player:
                self._player.prepare_output()

        if update:
            self.py3.update()

    def kill(self):
        self._kill = True
        if self._name_owner_change_match:
            self._dbus._clean_up_signal_match(self._name_owner_change_match)

    def mpris(self):
        """
        Get the current output format and return it.
        """
        if self._kill:
            raise KeyboardInterrupt

        current_player = self._player
        cached_until = self.py3.CACHE_FOREVER
        color = self.py3.COLOR_BAD

        if current_player:
            current_player_id = str(current_player.id)
            current_state_map = current_player.state_map
            data = current_player.data

            if current_player_id == self._player.id:
                if self._format_contains_time:
                    cached_until = self.py3.time_in(
                        seconds=current_state_map.get("cached_until"), sync_to=0
                    )

                placeholders = {"state": current_state_map["state_icon"]}
                color = current_state_map["color"]
                composite = self.py3.safe_format(
                    self.format,
                    dict(self._empty_response, **placeholders, **data),
                    max_width=self.max_width,
                )
            else:
                # The player changed during our processing
                # This is usually due to something like a player being killed
                # whilst we are checking its details
                # Retry but limit the number of attempts
                self._tries += 1
                if self._tries < 3:
                    return self.mpris()

                # Max retries hit we need to output something
                return {
                    # Can't decide what is good time to restart 3 retry cycle
                    "cached_until": self.py3.time_in(10),
                    "color": self.py3.COLOR_BAD,
                    "composite": [
                        {
                            "full_text": "Something went wrong",
                            "color": self.py3.COLOR_BAD,
                        }
                    ],
                }

        else:
            composite = [{"full_text": self.format_none, "color": color}]

        # we are outputting so reset tries
        self._tries = 0

        response = {
            "cached_until": cached_until,
            "color": color,
            "composite": composite,
        }
        return response

    def on_click(self, event):
        """
        Handles click events
        """
        index = event["index"]
        button = event["button"]

        if not self._player:
            return

        if button == self._button_cache_flush:
            self._player.metadata = None
            self._player.state = None

        elif index not in self._states:
            if button == self.button_toggle:
                return self._player.send_mpris_action("toggle")
            elif button == self.button_stop:
                return self._player.send_mpris_action("stop")
            elif button == self.button_next:
                return self._player.send_mpris_action("next")
            elif button == self.button_previous:
                return self._player.send_mpris_action("previous")
            elif button == self.button_switch_to_top_player:
                return self._set_player(update=False)

            elif button == self.button_prev_player or button == self.button_next_player:
                switchable_players = []
                order_asc = button == self.button_next_player
                current_player_index = False
                for key, player in self._mpris_players.items():
                    if player.state == self._player.state and not player.hide:
                        if not current_player_index:
                            if player.id == self._player.id:
                                current_player_index = len(switchable_players)
                                if order_asc:
                                    continue

                        switchable_players.append(key)
                        if current_player_index:
                            if order_asc:
                                break
                            else:
                                if current_player_index != 0:
                                    break

                if len(switchable_players):
                    try:
                        if order_asc:
                            next_index = current_player_index % len(switchable_players)
                        else:
                            next_index = (current_player_index - 1) % len(switchable_players)

                        self._set_data_entry_point_by_name_key(
                            switchable_players[next_index], update=False
                        )

                    except KeyError:
                        pass

            else:
                return

        elif button == 1:
            self._player.send_mpris_action(index)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/net_iplist.py
================================================
"""
Display list of network interfaces and IP addresses.

This module supports both IPv4 and IPv6. There is the possibility to blacklist
interfaces and IPs, as well as to show interfaces with no IP address. It will
show an alternate text if no IP are available.

Configuration parameters:
    cache_timeout: refresh interval for this module in seconds.
        (default 30)
    format: format of the output.
        (default 'Network: {format_iface}')
    format_iface: format string for the list of IPs of each interface.
        (default '{iface}:[ {ip4}][ {ip6}]')
    format_no_ip: string to show if there are no IPs to display.
        (default 'no connection')
    iface_blacklist: list of interfaces to ignore. Accepts shell-style wildcards.
        (default ['lo'])
    iface_sep: string to write between interfaces.
        (default ' ')
    ip_blacklist: list of IPs to ignore. Accepts shell-style wildcards.
        (default [])
    ip_sep: string to write between IP addresses.
        (default ',')
    remove_empty: do not show interfaces with no IP.
        (default True)

Format placeholders:
    {format_iface} the format_iface string.

Format placeholders for format_iface:
    {iface} name of the interface.
    {ip4} list of IPv4 of the interface.
    {ip6} list of IPv6 of the interface.

Color options:
    color_bad: no IPs to show
    color_good: IPs to show

Requires:
    ip: utility found in iproute2 package

Examples:
```
net_iplist {
    iface_blacklist = []
    ip_blacklist = ['127.*', '::1']
}
```

@author guiniol

SAMPLE OUTPUT
{'color': '#00FF00',
 'full_text': u'Network: wls1: 192.168.1.3 fe80::f861:44bd:694a:b99c'}
"""

import re
from fnmatch import fnmatch


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 30
    format = "Network: {format_iface}"
    format_iface = "{iface}:[ {ip4}][ {ip6}]"
    format_no_ip = "no connection"
    iface_blacklist = ["lo"]
    iface_sep = " "
    ip_blacklist = []
    ip_sep = ","
    remove_empty = True

    def post_config_hook(self):
        self.iface_re = re.compile(r"\d+: (?P<iface>[\w\-@]+):")
        self.ip_re = re.compile(r"\s+inet (?P<ip4>[\d.]+)(?:/| )")
        self.ip6_re = re.compile(r"\s+inet6 (?P<ip6>[\da-f:]+)(?:/\d{1,3}| ) scope global dynamic")

    def net_iplist(self):
        response = {
            "cached_until": self.py3.time_in(seconds=self.cache_timeout),
            "full_text": "",
        }

        connection = False
        data = self._get_data()
        iface_list = []
        for iface, ips in data.items():
            if not self._check_blacklist(iface, self.iface_blacklist):
                continue

            ip4_list = []
            ip6_list = []
            for ip4 in ips.get("ip4", []):
                if self._check_blacklist(ip4, self.ip_blacklist):
                    connection = True
                    ip4_list.append(ip4)
            for ip6 in ips.get("ip6", []):
                if self._check_blacklist(ip6, self.ip_blacklist):
                    connection = True
                    ip6_list.append(ip6)
            iface_list.append(
                self.py3.safe_format(
                    self.format_iface,
                    {
                        "iface": iface,
                        "ip4": self.ip_sep.join(ip4_list),
                        "ip6": self.ip_sep.join(ip6_list),
                    },
                )
            )
        if not connection:
            response["full_text"] = self.py3.safe_format(
                self.format_no_ip,
                {"format_iface": self.py3.composite_join(self.iface_sep, iface_list)},
            )
            response["color"] = self.py3.COLOR_BAD
        else:
            response["full_text"] = self.py3.safe_format(
                self.format,
                {"format_iface": self.py3.composite_join(self.iface_sep, iface_list)},
            )
            response["color"] = self.py3.COLOR_GOOD

        return response

    def _get_data(self):
        txt = self.py3.command_output(["ip", "address", "show"]).splitlines()

        data = {}
        for line in txt:
            iface = self.iface_re.match(line)
            if iface:
                cur_iface = iface.group("iface")
                if not self.remove_empty:
                    data[cur_iface] = {}
                continue

            ip4 = self.ip_re.match(line)
            if ip4:
                data.setdefault(cur_iface, {}).setdefault("ip4", []).append(ip4.group("ip4"))
                continue

            ip6 = self.ip6_re.match(line)
            if ip6:
                data.setdefault(cur_iface, {}).setdefault("ip6", []).append(ip6.group("ip6"))
                continue

        return data

    def _check_blacklist(self, string, blacklist):
        for ignore in blacklist:
            if fnmatch(string, ignore):
                return False
        return True


if __name__ == "__main__":
    """
    Test this module by calling it directly.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/net_rate.py
================================================
r"""
Display network transfer rate.

Configuration parameters:
    all_interfaces: ignore self.interfaces, but not self.interfaces_blacklist
        (default True)
    cache_timeout: how often we refresh this module in seconds
        (default 2)
    devfile: location of dev file under /proc
        (default '/proc/net/dev')
    format: format of the module output
        (default '{interface}: {total}')
    format_no_connection: when there is no data transmitted from the start of the plugin
        (default '')
    format_value: format to use for values
        (default "[\?min_length=11 {value:.1f} {unit}]")
    hide_if_zero: hide indicator if rate == 0
        (default False)
    interfaces: comma separated list of interfaces to track
        (default [])
    interfaces_blacklist: comma separated list of interfaces to ignore
        (default 'lo')
    si_units: use SI units
        (default False)
    sum_values: sum values of each interface instead of taking the top one
        (default False)
    thresholds: specify color thresholds to use
        (default [(0, 'bad'), (1024, 'degraded'), (1024 * 1024, 'good')])
    unit: unit to use. If the unit contains a multiplier prefix, only this
        exact unit will ever be used
        (default "B/s")

Format placeholders:
    {down} download rate
    {interface} name of interface
    {total} total rate
    {up} upload rate

format_value placeholders:
    {unit} current unit
    {value} numeric value

Color thresholds:
    {down} Change color based on the value of down
    {total} Change color based on the value of total
    {up} Change color based on the value of up

@author shadowprince
@license Eclipse Public License

SAMPLE OUTPUT
{'full_text': 'eno1:  852.2 KiB/s'}
"""

import time


class Py3status:
    """ """

    # available configuration parameters
    all_interfaces = True
    cache_timeout = 2
    devfile = "/proc/net/dev"
    format = "{interface}: {total}"
    format_no_connection = ""
    format_value = r"[\?min_length=11 {value:.1f} {unit}]"
    hide_if_zero = False
    interfaces = []
    interfaces_blacklist = "lo"
    si_units = False
    sum_values = False
    thresholds = [(0, "bad"), (1024, "degraded"), (1024 * 1024, "good")]
    unit = "B/s"

    class Meta:
        def deprecate_function(config):
            # support old thresholds
            precision = config.get("precision", 1)
            padding = 3 + 1 + precision + 1 + 5
            format_value = r"[\?min_length={padding} {{value:.{precision}f}} {{unit}}]".format(
                padding=padding, precision=precision
            )
            return {"format_value": format_value}

        deprecated = {
            "function": [{"function": deprecate_function}],
            "remove": [{"param": "precision", "msg": "obsolete, use format_value instead"}],
        }

    def post_config_hook(self):
        # parse some configuration parameters
        if not isinstance(self.interfaces, list):
            self.interfaces = self.interfaces.split(",")
        if not isinstance(self.interfaces_blacklist, list):
            self.interfaces_blacklist = self.interfaces_blacklist.split(",")
        placeholders = self.py3.get_placeholder_formats_list(self.format_value)
        values = [f"{{{x[1]}}}" for x in placeholders if x[0] == "value"]
        self._value_formats = values
        # last
        self.last_interface = None
        self.last_stat = self._get_stat()
        self.last_time = time.monotonic()

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def net_rate(self):
        network_stat = self._get_stat()
        deltas = {}
        try:
            # time from previous check
            current_time = time.monotonic()
            timedelta = current_time - self.last_time

            # calculate deltas for all interfaces
            for old, new in zip(self.last_stat, network_stat):
                down = (int(new[1]) - int(old[1])) / timedelta
                up = (int(new[9]) - int(old[9])) / timedelta

                deltas[new[0]] = {"total": up + down, "up": up, "down": down}

            # update last_ info
            self.last_stat = network_stat
            self.last_time = current_time

            # get the interface with max rate
            if self.sum_values:
                interface = "sum"
                sum_up = sum(itm["up"] for _, itm in deltas.items())
                sum_down = sum(itm["down"] for _, itm in deltas.items())
                deltas[interface] = {
                    "total": sum_up + sum_down,
                    "up": sum_up,
                    "down": sum_down,
                }
            else:
                interface = max(deltas, key=lambda x: deltas[x]["total"])

            # if there is no rate - show last active interface, or hide

            # we need to check if it will be zero after it is formatted
            # with the desired unit eg MB/s
            total, _ = self.py3.format_units(
                deltas[interface]["total"], unit=self.unit, si=self.si_units
            )
            values = [float(x.format(total)) for x in self._value_formats]
            if max(values) == 0:
                interface = self.last_interface
                hide = self.hide_if_zero
            # if there is - update last_interface
            else:
                self.last_interface = interface
                hide = False

            # get the deltas into variable
            delta = deltas[interface] if interface else None

        except (TypeError, ValueError, KeyError):
            delta = None
            interface = None
            hide = self.hide_if_zero

        response = {"cached_until": self.py3.time_in(self.cache_timeout)}

        if hide:
            response["full_text"] = ""
        elif not interface:
            response["full_text"] = self.format_no_connection
        else:
            for x in self.thresholds_init:
                if x in delta:
                    self.py3.threshold_get_color(delta[x], x)

            response["full_text"] = self.py3.safe_format(
                self.format,
                {
                    "down": self._format_value(delta["down"]),
                    "total": self._format_value(delta["total"]),
                    "up": self._format_value(delta["up"]),
                    "interface": interface[:-1],
                },
            )

        return response

    def _get_stat(self):
        """
        Get statistics from devfile in list of lists of words
        """

        def dev_filter(x):
            # get first word and remove trailing interface number
            x = x.strip().split(" ")[0][:-1]

            if x in self.interfaces_blacklist:
                return False

            if self.all_interfaces:
                return True

            if x in self.interfaces:
                return True

            return False

        # read devfile, skip two header files
        x = filter(dev_filter, open(self.devfile).readlines()[2:])

        try:
            # split info into words
            return [_x.split() for _x in x]

        except StopIteration:
            return None

    def _format_value(self, value):
        """
        Return formatted string
        """
        value, unit = self.py3.format_units(value, unit=self.unit, si=self.si_units)
        return self.py3.safe_format(self.format_value, {"value": value, "unit": unit})


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/netdata.py
================================================
r"""
Display network speed and bandwidth usage.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 2)
    format: display format for this module
        *(default '{nic} [\?color=down LAN(Kb): {down}↓ {up}↑] '
        '[\?color=total T(Mb): {download}↓ {upload}↑ {total}↕]')*
    nic: specify a network interface to use (default None)
    thresholds: specify color thresholds to use
        *(default {'down': [(0, 'bad'), (30, 'degraded'), (60, 'good')],
        'total': [(0, 'good'), (400, 'degraded'), (700, 'bad')]})*

Format placeholders:
    {nic}      network interface
    {down}     number of download speed
    {up}       number of upload speed
    {download} number of download usage
    {upload}   number of upload usage
    {total}    number of total usage

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

@author Shahin Azad <ishahinism at Gmail>

SAMPLE OUTPUT
[
    {'full_text': 'eth0 '},
    {'full_text': 'LAN(Kb):  77.8↓  26.9↑ ', 'color': '#00FF00'},
    {'full_text': 'T(Mb): 394↓  45↑ 438↕', 'color': '#FFFF00'},
]
"""

import time
from pathlib import Path


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 2
    format = (
        r"{nic} [\?color=down LAN(Kb): {down}↓ {up}↑] "
        r"[\?color=total T(Mb): {download}↓ {upload}↑ {total}↕]"
    )
    nic = None
    thresholds = {
        "down": [(0, "bad"), (30, "degraded"), (60, "good")],
        "total": [(0, "good"), (400, "degraded"), (700, "bad")],
    }

    class Meta:
        def deprecate_function(config):
            return {
                "thresholds": {
                    "down": [
                        (0, "bad"),
                        (config.get("low_speed", 30), "degraded"),
                        (config.get("med_speed", 60), "good"),
                    ],
                    "total": [
                        (0, "good"),
                        (config.get("low_traffic", 400), "degraded"),
                        (config.get("med_traffic", 700), "bad"),
                    ],
                }
            }

        deprecated = {
            "function": [{"function": deprecate_function}],
            "remove": [
                {
                    "param": "low_speed",
                    "msg": "obsolete, set using thresholds parameter",
                },
                {
                    "param": "med_speed",
                    "msg": "obsolete, set using thresholds parameter",
                },
                {
                    "param": "low_traffic",
                    "msg": "obsolete, set using thresholds parameter",
                },
                {
                    "param": "med_traffic",
                    "msg": "obsolete, set using thresholds parameter",
                },
            ],
        }

        update_config = {
            "update_placeholder_format": [
                {
                    "placeholder_formats": {
                        "down": ":5.1f",
                        "up": ":5.1f",
                        "download": ":3.0f",
                        "upload": ":3.0f",
                        "total": ":3.0f",
                    },
                    "format_strings": ["format"],
                }
            ]
        }

    def post_config_hook(self):
        self.last_transmitted_bytes = 0
        self.last_received_bytes = 0
        self.last_time = time.monotonic()
        # Get default gateway from /proc.
        if self.nic is None:
            with Path("/proc/net/route").open() as fh:
                for line in fh:
                    fields = line.strip().split()
                    if fields[1] == "00000000" and int(fields[3], 16) & 2:
                        self.nic = fields[0]
                        break
            if self.nic is None:
                self.nic = "lo"
            self.py3.log(f"selected nic: {self.nic}")

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def _get_bytes(self):
        with Path("/proc/net/dev").open() as fh:
            net_data = fh.read().split()
        interface_index = net_data.index(self.nic + ":")
        received_bytes = int(net_data[interface_index + 1])
        transmitted_bytes = int(net_data[interface_index + 9])
        return received_bytes, transmitted_bytes

    def netdata(self):
        received_bytes, transmitted_bytes = self._get_bytes()
        # speed
        current_time = time.monotonic()
        timedelta = current_time - self.last_time
        self.last_time = current_time
        down = (received_bytes - self.last_received_bytes) / 1024 / timedelta
        up = (transmitted_bytes - self.last_transmitted_bytes) / 1024 / timedelta
        # history
        self.last_received_bytes = received_bytes
        self.last_transmitted_bytes = transmitted_bytes
        # traffic
        download = received_bytes / 1024 / 1024
        upload = transmitted_bytes / 1024 / 1024
        total = download + upload

        net_data = {
            "down": down,
            "up": up,
            "download": download,
            "upload": upload,
            "total": total,
            "nic": self.nic,
        }

        for x in self.thresholds_init:
            if x in net_data:
                self.py3.threshold_get_color(net_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, net_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/networkmanager.py
================================================
r"""
Display NetworkManager fields via nmcli, a command-line tool.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    devices: specify a list of devices to use (default ['[e|w]*'])
    format: display format for this module (default '{format_device}')
    format_device: format for devices
        *(default "[\?if=general_connection {general_device}[\?soft  ][\?color=ap_signal {ap_ssid} {ap_bars} {ap_signal}%][\?soft  ][\?color=good {ip4_address1}]]")*
    format_device_separator: show separator if more than one (default ' ')
    thresholds: specify color thresholds to use
        (default [(0, 'bad'), (30, 'degraded'), (65, 'good')])

Format placeholders:
    {format_device} format for devices

Format_device placeholders:
    {general_connection} eg Py3status, Wired Connection 1
    {general_device}     eg wlp3s0b1, enp2s0
    {general_type}       eg wifi, ethernet
    {ap_bars}            signal strength in bars, eg ▂▄▆_
    {ap_chan}            wifi channel, eg 6
    {ap_mode}            network mode, eg Adhoc or Infra
    {ap_rate}            bitrate, eg 54 Mbit/s
    {ap_security}        signal security, eg WPA2
    {ap_signal}          signal strength in percentage, eg 63
    {ap_ssid}            ssid name, eg Py3status
    {ip4_address1}       eg 192.168.1.108
    {ip6_address1}       eg 0000::0000:0000:0000:0000

    Use `nmcli --terse --fields=general,ap,ip4,ip6 device show` for a full list of
    supported NetworkManager fields to use. Not all of NetworkManager fields will
    be usable. See `man nmcli` for more information.

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    nmcli: cli configuration utility for NetworkManager

Examples:
```
# specify devices to use
networkmanager {
    devices = ['e*']    # ethernet only
    devices = ['w*']    # wireless only
    devices = []        # ethernet, wireless, lo, etc
}
```

@author Kevin Pulo <kev@pulo.com.au>
@license BSD

SAMPLE OUTPUT
[{'full_text': 'enp2s0 '}, {'color': '#00FF00', 'full_text': '192.168.1.108'}]

wifi
[
    {'full_text': 'wlp3s0b1 '},
    {'color': '#FFFF00', 'full_text': 'Py3net ▂▄__ 54% '},
    {'color': '#00FF00', 'full_text': '192.168.1.106'},
]
"""

from fnmatch import fnmatch

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    devices = ["[e|w]*"]
    format = "{format_device}"
    format_device = (
        r"[\?if=general_connection {general_device}[\?soft  ]"
        r"[\?color=ap_signal {ap_ssid} {ap_bars} {ap_signal}%][\?soft  ]"
        r"[\?color=good {ip4_address1}]]"
    )
    format_device_separator = " "
    thresholds = [(0, "bad"), (30, "degraded"), (65, "good")]

    def post_config_hook(self):
        command = "nmcli --terse --colors=no"
        if not self.py3.check_commands(command.split()[0]):
            raise Exception(STRING_NOT_INSTALLED)

        self.first_run = True

        addresses = [
            x.split("_")[0]
            for x in self.py3.get_placeholders_list(
                self.format_device, "ip[46]_address[0123456789]"
            )
        ]

        self.nmcli_command = "{} --fields={} device show".format(
            command, ",".join(["general", "ap"] + addresses)
        ).split()
        self.caches = {"lines": {}, "devices": {}}
        self.devices = {"list": [], "devices": self.devices}
        self.thresholds_init = self.py3.get_color_names_list(self.format_device)

    def _update_key(self, key):
        for old, new in [("[", ""), ("]", ""), (".", "_"), ("-", "_")]:
            key = key.replace(old, new)
        return key.lower()

    def networkmanager(self):
        nm_data = self.py3.command_output(self.nmcli_command, localized=True)
        new_device = []
        used_ap = None

        for chunk in nm_data.split("\n\n"):
            lines = chunk.splitlines()
            key, value = lines[0].split(":", 1)
            if self.first_run:
                if self.devices["devices"]:
                    for _filter in self.devices["devices"]:
                        if fnmatch(value, _filter):
                            self.devices["list"].append(value)
            if value not in self.devices["list"]:
                continue

            try:
                key = self.caches["devices"][key]
            except KeyError:
                new_key = self._update_key(key)

                self.caches["devices"][key] = new_key
                key = self.caches["devices"][key]

            device = {key: value}
            for line in lines[1:]:
                try:
                    key, value = self.caches["lines"][line]
                except (KeyError, ValueError):
                    key, value = line.split(":", 1)
                    key = self._update_key(key)
                    if "IP" in line and "ADDRESS" in line:
                        value = value.split("/")[0]
                    else:
                        try:
                            value = int(value)
                        except ValueError:
                            pass

                    self.caches["lines"][line] = (key, value)

                if "ap" in key and "in_use" in key and value == "*":
                    used_ap = key.split("_")[0]
                device[key] = value

            # Add specific extra entries for the AP currently used by the device.
            if used_ap is not None:
                current_ap = {}
                for key in device:
                    if key.startswith(used_ap + "_"):
                        current_ap[key.replace(used_ap + "_", "ap_")] = device[key]
                device.update(current_ap)

            for x in self.thresholds_init:
                if x in device:
                    self.py3.threshold_get_color(device[x], x)

            new_device.append(self.py3.safe_format(self.format_device, device))

        format_device_separator = self.py3.safe_format(self.format_device_separator)
        format_device = self.py3.composite_join(format_device_separator, new_device)

        self.first_run = False

        return {
            "cache_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"format_device": format_device}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/ns_checker.py
================================================
"""
Display DNS resolution success on a configured domain.

This module launch a simple query on each nameservers for the specified domain.
Nameservers are dynamically retrieved. The FQDN is the only one mandatory
parameter.  It's also possible to add additional nameservers by appending them
in nameservers list.

The default resolver can be overwritten with my_resolver.nameservers parameter.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds (default 300)
    domain: domain name to check (default '')
    format: output format string (default '{total_count} NS {status}')
    lifetime: resolver lifetime (default 0.3)
    nameservers: specify a list of reference DNS nameservers (default [])
    resolvers: specify a list of DNS resolvers to use (default [])

Format placeholders:
    {nok_count} The number of failed name servers
    {ok_count} The number of working name servers
    {status} The overall status of the name servers (OK or NOK)
    {total_count} The total number of name servers

Color options:
    color_bad: One or more lookups have failed
    color_good: All lookups have succeeded

Requires:
    dnspython: a dns toolkit for python

@author nawadanp

SAMPLE OUTPUT
{'full_text': '10 NS OK'}
"""

import socket

import dns.resolver


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 300
    domain = ""
    format = "{total_count} NS {status}"
    lifetime = 0.3
    nameservers = []
    resolvers = []

    def post_config_hook(self):
        # parse some configuration parameters
        if not isinstance(self.nameservers, list):
            self.nameservers = self.nameservers.split(",")
        if not isinstance(self.resolvers, list):
            self.resolvers = self.resolvers.split(",")

    def ns_checker(self):
        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": self.py3.COLOR_GOOD,
        }
        count_nok = 0
        count_ok = 0
        nameservers = []
        status = "OK"

        my_resolver = dns.resolver.Resolver()
        my_resolver.lifetime = self.lifetime
        if self.resolvers:
            my_resolver.nameservers = self.resolvers

        my_ns = my_resolver.resolve(self.domain, "NS")

        # Insert each NS ip address in nameservers
        for ns in my_ns:
            nameservers.append(str(socket.gethostbyname(str(ns))))
        for ns in self.nameservers:
            nameservers.append(str(ns))

        # Perform a simple DNS query, for each NS servers
        for ns in nameservers:
            my_resolver.nameservers = [ns]
            try:
                my_resolver.resolve(self.domain, "A")
                count_ok += 1
            except:  # noqa e722
                count_nok += 1
                status = "NOK"
                response["color"] = self.py3.COLOR_BAD

        response["full_text"] = self.py3.safe_format(
            self.format,
            dict(
                total_count=len(nameservers),
                nok_count=count_nok,
                ok_count=count_ok,
                status=status,
            ),
        )

        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/nvidia_smi.py
================================================
r"""
Display NVIDIA properties currently exhibiting in the NVIDIA GPUs.

nvidia-smi, short for NVIDIA System Management Interface program, is a cross
platform tool that supports all standard NVIDIA driver-supported Linux distros.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default '{format_gpu}')
    format_gpu: display format for NVIDIA GPUs
        *(default '{gpu_name} [\?color=temperature.gpu {temperature.gpu}°C] '
        '[\?color=memory.used_percent {memory.used_percent}%]')*
    format_gpu_separator: show separator if more than one (default ' ')
    memory_unit: specify memory unit, eg 'KiB', 'MiB', 'GiB', otherwise auto
        (default None)
    thresholds: specify color thresholds to use
        (default [(0, 'good'), (65, 'degraded'), (75, 'orange'), (85, 'bad')])

Format placeholders:
    {format_gpu} format for NVIDIA GPUs

format_gpu placeholders:
    {index}               Zero based index of the GPU.
    {count}               The number of NVIDIA GPUs in the system
    {driver_version}      The version of the installed NVIDIA display driver
    {gpu_name}            The official product name of the GPU
    {gpu_uuid}            Globally unique immutable identifier of the GPU
    {memory.free}         Total free memory
    {memory.free_unit}    Total free memory unit
    {memory.total}        Total installed GPU memory
    {memory.total_unit}   Total installed GPU memory unit
    {memory.used}         Total memory allocated by active contexts
    {memory.used_percent} Total memory allocated by active contexts percentage
    {memory.used_unit}    Total memory unit
    {temperature.gpu}     Core GPU temperature in degrees C

    Use `python /path/to/nvidia_smi.py --list-properties` for a full list of
    supported NVIDIA properties to use. Not all of supported NVIDIA properties
    will be usable. See `nvidia-smi --help-query-gpu` for more information.

Color thresholds:
    format_gpu:
        `xxx`: print a color based on the value of NVIDIA `xxx` property

Requires:
    nvidia-smi: command line interface to query NVIDIA devices

Examples:
```
# display nvidia properties
nvidia_smi {
    format_gpu = '{gpu_name} [\?color=temperature.gpu {temperature.gpu}°C] '
    format_gpu += '[\?color=memory.used_percent {memory.used} {memory.used_unit}'
    format_gpu += '[\?color=darkgray&show \|]{memory.used_percent:.1f}%]'
}
```

@author lasers

SAMPLE OUTPUT
[
    {'full_text': 'Quadro NVS 295 '},
    {'color': '#00ff00', 'full_text': '51°C '},
    {'color': '#00ff00', 'full_text': '60.8%'},
]

percent
[
    {'full_text': 'GPU '},
    {'full_text': '73°C ', 'color': '#ffff00'},
    {'full_text': '192 MiB', 'color': '#ffa500'},
    {'full_text': '|', 'color': '#a9a9a9'},
    {'full_text': '75.3%', 'color': '#ffa500'}
]
"""

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{format_gpu}"
    format_gpu = (
        r"{gpu_name} [\?color=temperature.gpu {temperature.gpu}°C] "
        r"[\?color=memory.used_percent {memory.used_percent}%]"
    )
    format_gpu_separator = " "
    memory_unit = None
    thresholds = [(0, "good"), (65, "degraded"), (75, "orange"), (85, "bad")]

    def post_config_hook(self):
        command = "nvidia-smi --format=csv,noheader,nounits --query-gpu="
        if not self.py3.check_commands(command.split()[0]):
            raise Exception(STRING_NOT_INSTALLED)

        properties = self.py3.get_placeholders_list(self.format_gpu)
        format_gpu = {x: ":.1f" for x in properties if "used_percent" in x}
        self.format_gpu = self.py3.update_placeholder_formats(self.format_gpu, format_gpu)

        new_memory_properties = set()
        new_properties = {"memory.used", "memory.total"}
        for name in properties:
            if "used_percent" in name:
                continue
            if name.startswith("memory"):
                if name.endswith("_unit"):
                    name = name[:-5]
                new_memory_properties.add(name)
            new_properties.add(name)

        self.properties = list(new_properties)
        self.memory_properties = list(new_memory_properties)
        self.memory_unit = self.memory_unit or "B"
        self.nvidia_command = command + ",".join(self.properties)

        self.thresholds_init = self.py3.get_color_names_list(self.format_gpu)

    def _get_nvidia_data(self):
        return self.py3.command_output(self.nvidia_command)

    def nvidia_smi(self):
        nvidia_data = self._get_nvidia_data()
        new_gpu = []

        for line in nvidia_data.splitlines():
            gpu = dict(zip(self.properties, line.split(", ")))
            gpu["memory.used_percent"] = (
                float(gpu["memory.used"]) / float(gpu["memory.total"]) * 100
            )

            for key in self.memory_properties:
                value, unit_key = float(gpu[key]) * 1024**2, key + "_unit"
                value, unit_value = self.py3.format_units(value, self.memory_unit)
                gpu.update({key: value, unit_key: unit_value})

            for x in self.thresholds_init:
                if x in gpu:
                    self.py3.threshold_get_color(gpu[x], x)

            new_gpu.append(self.py3.safe_format(self.format_gpu, gpu))

        format_gpu_separator = self.py3.safe_format(self.format_gpu_separator)
        format_gpu = self.py3.composite_join(format_gpu_separator, new_gpu)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"format_gpu": format_gpu}),
        }


if __name__ == "__main__":
    from sys import argv

    if "--list-properties" in argv:
        from json import dumps
        from subprocess import check_output
        from sys import exit

        help_cmd = "nvidia-smi --help-query-gpu"
        help_data = check_output(help_cmd.split()).decode()

        new_properties = []
        for line in help_data.splitlines():
            if line.startswith('"'):
                properties = line.split('"')[1::2]
                for name in properties:
                    if ":" not in name:
                        new_properties.append(name)

        properties = ",".join(new_properties)
        gpu_cmd = "nvidia-smi --format=csv,noheader,nounits --query-gpu="
        gpu_data = check_output((gpu_cmd + properties).split()).decode()

        new_gpus = []
        msg = "This GPU contains {} supported properties."
        e = ["Not Supported", "N/A"]
        for line in gpu_data.splitlines():
            gpu = dict(zip(new_properties, line.split(", ")))
            gpu = {k: v for k, v in gpu.items() if all(x not in v for x in e)}
            gpu["= " + msg.format(len(gpu))] = ""
            gpu["=" * (len(msg) + 2)] = ""
            new_gpus.append(gpu)

        print(dumps(new_gpus, sort_keys=True, indent=4))
        exit()
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/online_status.py
================================================
"""
Determine if you have an Internet Connection.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default '{icon}')
    icon_off: show when connection is offline (default '■')
    icon_on: show when connection is online (default '●')
    timeout: time to wait for a response, in seconds (default 2)
    url: specify URL to connect when checking for a connection
        (default 'https://www.google.com')

Format placeholders:
    {icon} connection status

Color options:
    color_off: Connection offline, defaults to color_bad
    color_on: Connection online, defaults to color_good

@author obb


SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'\u25cf'}

off
{'color': '#FF0000', 'full_text': u'\u25a0'}
"""

from urllib.request import URLError, urlopen


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{icon}"
    icon_off = "■"
    icon_on = "●"
    timeout = 2
    url = "https://www.google.com"

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "format_online",
                    "new": "icon_on",
                    "msg": "obsolete parameter use `icon_on`",
                },
                {
                    "param": "format_offline",
                    "new": "icon_off",
                    "msg": "obsolete parameter use `icon_off`",
                },
            ]
        }

    def post_config_hook(self):
        self.color_on = self.py3.COLOR_ON or self.py3.COLOR_GOOD
        self.color_off = self.py3.COLOR_OFF or self.py3.COLOR_BAD
        self.ping_command = ["ping", "-c", "1", "-W", f"{self.timeout}", self.url]

    def _connection_present(self):
        if "://" in self.url:
            try:
                urlopen(self.url, timeout=self.timeout)
                return True
            except URLError:
                return False
        else:
            try:
                self.py3.command_output(self.ping_command)
                return True
            except self.py3.CommandError:
                return False

    def online_status(self):
        if self._connection_present():
            icon = self.icon_on
            color = self.color_on
        else:
            color = self.color_off
            icon = self.icon_off

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"icon": icon}),
            "color": color,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/pingdom.py
================================================
"""
Display response times of the configured Pingdom checks.

We also verify the status of the checks and colorize if needed.
Pingdom API doc : https://www.pingdom.com/features/api/documentation/

Configuration parameters:
    app_key: create an APP KEY on pingdom first (default '')
    cache_timeout: how often to refresh the check from pingdom (default 600)
    checks: comma separated pindgom check names to display (default '')
    format: display format for this module (default '{pingdom}')
    login: pingdom login (default '')
    max_latency: maximal latency before coloring the output (default 500)
    password: pingdom password (default '')
    request_timeout: pindgom API request timeout (default 10)

Format placeholders:
    {pingdom} pingdom response times

Color options:
    color_bad: Site is down
    color_degraded: Latency exceeded max_latency

Requires:
    requests: https://pypi.python.org/pypi/requests

@author ultrabug

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'Pingdom: 323ms'}

degraded
{'color': '#FFFF00', 'full_text': 'Pingdom: 945ms'}

down
{'color': '#FF0000', 'full_text': 'Pingdom: DOWN'}
"""

import requests


class Py3status:
    """ """

    # available configuration parameters
    app_key = ""
    cache_timeout = 600
    checks = ""
    format = "{pingdom}"
    login = ""
    max_latency = 500
    password = ""
    request_timeout = 10

    def pingdom(self):
        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": "",
        }
        pingdom = None

        # parse some configuration parameters
        if not isinstance(self.checks, list):
            self.checks = self.checks.split(",")

        r = requests.get(
            "https://api.pingdom.com/api/2.0/checks",
            auth=(self.login, self.password),
            headers={"App-Key": self.app_key},
            timeout=self.request_timeout,
        )
        result = r.json()
        if "checks" in result:
            for check in [ck for ck in result["checks"] if ck["name"] in self.checks]:
                if check["status"] == "up":
                    pingdom += "{}: {}ms, ".format(check["name"], check["lastresponsetime"])
                    if check["lastresponsetime"] > self.max_latency:
                        response["color"] = self.py3.COLOR_DEGRADED
                else:
                    response["color"] = self.py3.COLOR_BAD
                    pingdom += "{}: DOWN".format(check["name"])
            pingdom = pingdom.strip(", ")
            response["full_text"] = self.py3.safe_format(self.format, {"pingdom": pingdom})

        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/playerctl.py
================================================
r"""
Display song/video and control players supported by playerctl

Playerctl is a command-line utility for controlling media players
that implement the MPRIS D-Bus Interface Specification. With Playerctl
you can bind player actions to keys and get metadata about the currently
playing song or video.

Configuration parameters:
    button_loop: mouse button to cycle the loop status of the player (default None)
    button_next: mouse button to skip to the next track (default None)
    button_pause: mouse button to pause the playback (default None)
    button_play: mouse button to play the playback (default None)
    button_play_pause: mouse button to play/pause the playback (default 1)
    button_previous: mouse button to skip to the previous track (default None)
    button_seek_backward: mouse button to playback's position backward (default None)
    button_seek_forward: mouse button to playback's position forward (default None)
    button_shuffle: mouse button to toggle the shuffle mode of the player (default None)
    button_stop: mouse button to stop the playback (default 3)
    button_volume_down: mouse button to decrease the volume of the player (default None)
    button_volume_up: mouse button to increase the volume of the player (default None)
    format: display format for this module (default '{format_player}')
    format_player: display format for players
        *(default '[\?color=status [\?if=status=Playing > ][\?if=status=Paused \|\| ]'
        '[\?if=status=Stopped .. ][[{artist}][\?soft  - ][{title}|{player}]]]')*
    format_player_separator: show separator if more than one player (default ' ')
    players: list of players to track. An empty list tracks all players (default [])
    replacements: specify a list/dict of string placeholders to modify (default None)
    seek_delta: time (in seconds) to change the playback's position by (default 5)
    thresholds: specify color thresholds to use for different placeholders
        (default {"status": [("Playing", "good"), ("Paused", "degraded"), ("Stopped", "bad")]})
    volume_delta: percentage (from 0 to 100) to change the player's volume by (default 10)

    Not all players support every button action

Format placeholders:
    {format_player} format for players

Format player placeholders:
    {album} album name
    {artist} artist name
    {duration} length of track/video in [HH:]MM:SS, e.g. 03:22
    {loop} loop status of the player, e.g. None, playlist, Track
    {player} name of the player
    {position} elapsed time in [HH:]MM:SS, e.g. 00:17
    {shuffle} boolean indicating if the player's shuffle mode is on
    {status} playback status, e.g. Playing, Paused, Stopped
    {title} track/video title
    {trackNumber} position of the track in the album or playlist
    {volume} volume level of the player from 0 to 100

    Not all media players support every placeholder

Requires:
    playerctl: mpris media player controller and lib for spotify, vlc, audacious,
        bmp, xmms2, and others.
    python-gobject: Python Bindings for GLib/GObject/GIO/GTK+

@author jdholtz

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': '> Don’t Eat the Yellow Snow - Frank Zappa'}

Paused
{'color': '#FFFF00', 'full_text': '|| Too Much Skunk Tonight - Birdy Nam Nam'}

Stopped
{'color': '#FF0000', 'full_text': '.. This Song Has No Title - Elton John'}
"""

import time
from fnmatch import fnmatch
from threading import Thread

import gi

gi.require_version("Playerctl", "2.0")
from gi.repository import GLib, Playerctl  # noqa e402


class Py3status:
    """ """

    # available configuration parameters
    button_loop = None
    button_next = None
    button_pause = None
    button_play = None
    button_play_pause = 1
    button_previous = None
    button_seek_backward = None
    button_seek_forward = None
    button_shuffle = None
    button_stop = 3
    button_volume_down = None
    button_volume_up = None
    format = "{format_player}"
    format_player = (
        r"[\?color=status [\?if=status=Playing > ][\?if=status=Paused \|\| ]"
        r"[\?if=status=Stopped .. ][[{artist}][\?soft  - ][{title}|{player}]]]"
    )
    format_player_separator = " "
    players = []
    replacements = None
    seek_delta = 5
    thresholds = {"status": [("Playing", "good"), ("Paused", "degraded"), ("Stopped", "bad")]}
    volume_delta = 10

    class Meta:
        update_config = {
            "update_placeholder_format": [
                {
                    # Escape the title by default because many contain special characters
                    "placeholder_formats": {"title": ":escape"},
                    "format_strings": ["format_player"],
                }
            ]
        }

    def post_config_hook(self):
        self.thresholds_init = self.py3.get_color_names_list(self.format_player)
        self.replacements_init = self.py3.get_replacements_list(self.format_player)
        self.position = self.py3.format_contains(self.format_player, "position")
        self.cache_timeout = getattr(self, "cache_timeout", 1)

        # Initialize the manager + event listeners
        self.manager = Playerctl.PlayerManager()
        self.manager.connect("name-appeared", self._on_name_appeared)
        self.manager.connect("name-vanished", self._on_name_vanished)

        # Initialize all currently active players
        for player_name in self.manager.props.player_names:
            self._init_player(player_name)

        self._start_loop()

    def _player_should_be_tracked(self, player_name):
        for _filter in self.players:
            if fnmatch(player_name.name, _filter):
                return True

        return len(self.players) == 0

    def _init_player(self, player_name):
        if not self._player_should_be_tracked(player_name):
            return

        player = Playerctl.Player.new_from_name(player_name)

        # Initialize player event listeners
        player.connect("loop-status", self._loop_status_changed, self.manager)
        player.connect("metadata", self._on_metadata, self.manager)
        player.connect("playback-status", self._status_changed, self.manager)
        player.connect("seeked", self._on_seeked, self.manager)
        player.connect("shuffle", self._shuffle_changed, self.manager)
        player.connect("volume", self._volume_changed, self.manager)

        self.manager.manage_player(player)

    def _start_loop(self):
        loop = GLib.MainLoop()

        # The loop is blocking so it needs to be run a separate thread
        thread = Thread(target=loop.run)
        thread.daemon = True
        thread.start()

    def _on_name_appeared(self, manager, player_name):
        self._init_player(player_name)

    def _on_name_vanished(self, manager, name):
        # Add a very small delay to give Playerctl time to remove the player
        time.sleep(0.01)
        self.py3.update()

    def _loop_status_changed(self, player, loop_status, manager):
        self.py3.update()

    def _on_metadata(self, player, metadata, manager):
        self.py3.update()

    def _status_changed(self, player, status, manager):
        self.py3.update()

    def _on_seeked(self, player, position, manager):
        self.py3.update()

    def _shuffle_changed(self, player, shuffle, manager):
        self.py3.update()

    def _volume_changed(self, player, volume, manager):
        self.py3.update()

    @staticmethod
    def _microseconds_to_time(microseconds):
        seconds = int(microseconds // 1_000_000)
        m, s = divmod(seconds, 60)
        h, m = divmod(m, 60)
        time = f"{h}:{m:02d}:{s:02d}"
        return time.lstrip("0").lstrip(":")

    def _get_player_position(self, player):
        try:
            # Playerctl doesn't support getting positions for all players
            microseconds = player.get_position()
            position = self._microseconds_to_time(microseconds)
        except GLib.GError:
            position = None

        return position

    def _set_data_from_metadata(self, player, data):
        """Set any data retrieved directly from the metadata for a player"""
        metadata = dict(player.props.metadata)

        data["trackNumber"] = metadata.get("xesam:trackNumber")

        duration_ms = metadata.get("mpris:length")
        if duration_ms:
            data["duration"] = self._microseconds_to_time(duration_ms)
        else:
            data["duration"] = None

    def _get_player_data(self, player):
        data = {}

        # Song attributes
        data["album"] = player.get_album()
        data["artist"] = player.get_artist()
        data["title"] = player.get_title()
        data["position"] = self._get_player_position(player)
        self._set_data_from_metadata(player, data)

        # Player attributes
        data["player"] = player.props.player_name
        data["loop"] = player.props.loop_status.value_nick
        data["shuffle"] = player.props.shuffle
        data["status"] = player.props.status
        data["volume"] = int(player.props.volume * 100)

        return data

    def _get_player_from_index(self, index):
        for player in self.manager.props.players:
            if player.props.player_name == index:
                return player

        return None

    def _change_player_volume(self, player, volume_factor):
        volume_change = volume_factor * self.volume_delta / 100
        new_volume = player.props.volume + volume_change
        try:
            # Playerctl can't set the volume for every player
            player.set_volume(new_volume)
        except GLib.GError:
            pass

    def _cycle_player_loop_status(self, player):
        new_loop_status = (player.props.loop_status + 1) % 3
        try:
            # Not all players support setting the loop status
            player.set_loop_status(new_loop_status)
        except GLib.GError:
            pass

    def _toggle_player_shuffle(self, player):
        try:
            # Not all players support setting the shuffle mode
            player.set_shuffle(not player.props.shuffle)
        except GLib.GError:
            pass

    def playerctl(self):
        tracked_players = self.manager.props.players

        players = []
        cached_until = self.py3.CACHE_FOREVER
        for player in tracked_players:
            if not player.props.can_play:
                continue

            player_data = self._get_player_data(player)

            # Check if the player should cause the module to continuously update
            if self.position and player_data["status"] == "Playing" and player_data["position"]:
                cached_until = self.cache_timeout

            # Replace the values
            for x in self.replacements_init:
                if x in player_data:
                    player_data[x] = self.py3.replace(player_data[x], x)

            # Set the color of a player
            for key in self.thresholds_init:
                if key in player_data:
                    self.py3.threshold_get_color(player_data[key], key)

            format_player = self.py3.safe_format(self.format_player, player_data)
            self.py3.composite_update(format_player, {"index": player_data["player"]})

            players.append(format_player)

        format_player_separator = self.py3.safe_format(self.format_player_separator)
        format_players = self.py3.composite_join(format_player_separator, players)

        return {
            "cached_until": self.py3.time_in(cached_until),
            "full_text": self.py3.safe_format(self.format, {"format_player": format_players}),
        }

    def on_click(self, event):
        """
        Control playerctl with mouse clicks.
        """
        button = event["button"]
        index = event["index"]

        # Always prevent a refresh because this module updates whenever
        # a player's status or metadata changes
        self.py3.prevent_refresh()

        player = self._get_player_from_index(index)
        if not player or not player.props.can_control:
            return

        if button == self.button_play and player.props.can_play:
            player.play()
        elif button == self.button_pause and player.props.can_pause:
            player.pause()
        elif button == self.button_play_pause and player.props.can_play:
            player.play_pause()
        elif button == self.button_stop:
            player.stop()
        elif button == self.button_next and player.props.can_go_next:
            player.next()
        elif button == self.button_previous and player.props.can_go_previous:
            player.previous()
        elif button == self.button_seek_forward and player.props.can_seek:
            player.seek(self.seek_delta * 10**6)
        elif button == self.button_seek_backward and player.props.can_seek:
            player.seek(self.seek_delta * -1 * 10**6)
        elif button == self.button_volume_up:
            self._change_player_volume(player, 1)
        elif button == self.button_volume_down:
            self._change_player_volume(player, -1)
        elif button == self.button_loop:
            self._cycle_player_loop_status(player)
        elif button == self.button_shuffle:
            self._toggle_player_shuffle(player)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/pomodoro.py
================================================
"""
Use Pomodoro technique to get things done easily.

Button 1 starts/pauses countdown.
Button 2 switch Pomodoro/Break.
Button 3 resets timer.

Configuration parameters:
    display_bar: display time in bars when True, otherwise in seconds
        (default False)
    format: define custom time format. See placeholders below (default '{ss}')
    format_active: format to display when timer is active
        (default 'Pomodoro [{format}]')
    format_break: format to display during break
        (default 'Break #{breakno} [{format}]')
    format_break_stopped: format to display during a break that is stopped
        (default 'Break #{breakno} ({format})')
    format_separator: separator between minutes:seconds (default ':')
    format_stopped: format to display when timer is stopped
        (default 'Pomodoro ({format})')
    num_progress_bars: number of progress bars (default 5)
    pomodoros: specify a number of pomodoros (intervals) (default 4)
    sound_break_end: break end sound (file path) (default None)
    sound_pomodoro_end: pomodoro end sound (file path) (default None)
    sound_pomodoro_start: pomodoro start sound (file path) (default None)
    timer_break: normal break time (seconds) (default 300)
    timer_long_break: long break time (seconds) (default 900)
    timer_pomodoro: pomodoro time (seconds) (default 1500)

Format placeholders:
    {bar} display time in bars
    {breakno} current break number
    {ss} display time in total seconds (1500)
    {mm} display time in total minutes (25)
    {mmss} display time in (hh-)mm-ss (25:00)

Color options:
    color_bad: Pomodoro not running
    color_degraded: Pomodoro break
    color_good: Pomodoro active

Examples:
```
pomodoro {
    format = "{mmss} {bar}"
}
```

@author Fandekasp (Adrien Lemaire), rixx, FedericoCeratto, schober-ch, ricci

SAMPLE OUTPUT
{'color': '#FF0000', 'full_text': u'Pomodoro (1500)'}

running
{'color': '#00FF00', 'full_text': u'Pomodoro [1483]'}
"""

import time
from math import ceil
from threading import Timer

PROGRESS_BAR_ITEMS = "▏▎▍▌▋▊▉"


class Py3status:
    """ """

    # available configuration parameters
    display_bar = False
    format = "{ss}"
    format_active = "Pomodoro [{format}]"
    format_break = "Break #{breakno} [{format}]"
    format_break_stopped = "Break #{breakno} ({format})"
    format_separator = ":"
    format_stopped = "Pomodoro ({format})"
    num_progress_bars = 5
    pomodoros = 4
    sound_break_end = None
    sound_pomodoro_end = None
    sound_pomodoro_start = None
    timer_break = 5 * 60
    timer_long_break = 15 * 60
    timer_pomodoro = 25 * 60

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "max_breaks",
                    "new": "pomodoros",
                    "msg": "obsolete parameter use `pomodoros`",
                }
            ]
        }

    def post_config_hook(self):
        self._initialized = False

    def _init(self):
        self._break_number = 0
        self._active = True
        self._running = False
        self._time_left = self.timer_pomodoro
        self._section_time = self.timer_pomodoro
        self._timer = None
        self._end_time = None
        self._alert = False
        if self.display_bar is True:
            self.format = "{bar}"
        self._initialized = True

    def _time_up(self):
        if self._active:
            self.py3.notify_user("Pomodoro time is up !")
        else:
            self.py3.notify_user(f"Break #{self._break_number} time is up !")
        self._alert = True
        self._advance()

    def _advance(self, user_action=False):
        self._running = False
        if self._active:
            if not user_action:
                self.py3.play_sound(self.sound_pomodoro_end)
            # start break
            self._time_left = self.timer_break
            self._section_time = self.timer_break
            self._break_number += 1
            if self._break_number >= self.pomodoros:
                self._time_left = self.timer_long_break
                self._section_time = self.timer_long_break
                self._break_number = 0
            self._active = False
        else:
            if not user_action:
                self.py3.play_sound(self.sound_break_end)
            self._time_left = self.timer_pomodoro
            self._section_time = self.timer_pomodoro
            self._active = True

    def kill(self):
        """
        cancel any timer
        """
        if self._timer:
            self._timer.cancel()

    def on_click(self, event):
        """
        Handles click events:
            - left click starts an inactive counter and pauses a running
              Pomodoro
            - middle click resets everything
            - right click starts (and ends, if needed) a break
        """
        if event["button"] == 1:
            if self._running:
                self._running = False
                self._time_left = self._end_time - time.monotonic()
                if self._timer:
                    self._timer.cancel()
            else:
                self._running = True
                self._end_time = time.monotonic() + self._time_left
                if self._timer:
                    self._timer.cancel()
                self._timer = Timer(self._time_left, self._time_up)
                self._timer.start()
                if self._active:
                    self.py3.play_sound(self.sound_pomodoro_start)

        elif event["button"] == 2:
            # reset
            self._init()
            if self._timer:
                self._timer.cancel()

        elif event["button"] == 3:
            # advance
            self._advance(user_action=True)
            if self._timer:
                self._timer.cancel()

    def _setup_bar(self):
        """
        Setup the process bar.
        """
        bar = ""
        items_cnt = len(PROGRESS_BAR_ITEMS)
        bar_val = self._time_left / self._section_time * self.num_progress_bars
        while bar_val > 0:
            selector = min(int(bar_val * items_cnt), items_cnt - 1)
            bar += PROGRESS_BAR_ITEMS[selector]
            bar_val -= 1

        bar = bar.ljust(self.num_progress_bars)
        return bar

    def pomodoro(self):
        """
        Pomodoro response handling and countdown
        """
        if not self._initialized:
            self._init()

        cached_until = self.py3.time_in(0)
        if self._running:
            self._time_left = ceil(self._end_time - time.monotonic())
            time_left = ceil(self._time_left)
        else:
            time_left = ceil(self._time_left)

        vals = {"ss": int(time_left), "mm": ceil(time_left / 60)}

        if self.py3.format_contains(self.format, "mmss"):
            hours, rest = divmod(time_left, 3600)
            mins, seconds = divmod(rest, 60)

            if hours:
                vals["mmss"] = (
                    f"{hours}{self.format_separator}"
                    f"{mins:02d}{self.format_separator}{seconds:02d}"
                )
            else:
                vals["mmss"] = f"{mins}{self.format_separator}{seconds:02d}"

        if self.py3.format_contains(self.format, "bar"):
            vals["bar"] = self._setup_bar()

        formatted = self.format.format(**vals)

        if self._running:
            if self._active:
                format = self.format_active
            else:
                format = self.format_break
        else:
            if self._active:
                format = self.format_stopped
            else:
                format = self.format_break_stopped
            cached_until = self.py3.CACHE_FOREVER

        response = {
            "full_text": format.format(breakno=self._break_number, format=formatted, **vals),
            "cached_until": cached_until,
        }

        if self._alert:
            response["urgent"] = True
            self._alert = False

        if not self._running:
            response["color"] = self.py3.COLOR_BAD
        else:
            if self._active:
                response["color"] = self.py3.COLOR_GOOD
            else:
                response["color"] = self.py3.COLOR_DEGRADED

        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/process_status.py
================================================
"""
Display status of a process on your system.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default '{icon}')
    full: match against the full command line (default False)
    icon_off: show this if a process is not running (default '■')
    icon_on: show this if a process is running (default '●')
    process: specify a process name to use (default None)

Format placeholders:
    {icon} process icon
    {process} process name

Color options:
    color_bad: Not running
    color_good: Running

@author obb, Moritz Lüdecke

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'\u25cf'}

not_running
{'color': '#FF0000', 'full_text': u'\u25a0'}
"""

STRING_ERROR = "missing process"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{icon}"
    full = False
    icon_off = "■"
    icon_on = "●"
    process = None

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "format_running",
                    "new": "icon_on",
                    "msg": "obsolete parameter use `icon_on`",
                },
                {
                    "param": "format_not_running",
                    "new": "icon_off",
                    "msg": "obsolete parameter use `icon_off`",
                },
            ]
        }

    def post_config_hook(self):
        if not self.process:
            raise Exception(STRING_ERROR)
        self.color_on = self.py3.COLOR_ON or self.py3.COLOR_GOOD
        self.color_off = self.py3.COLOR_OFF or self.py3.COLOR_BAD
        self.pgrep_command = ["pgrep", self.process]
        if self.full:
            self.pgrep_command.insert(1, "-f")

    def _is_running(self):
        try:
            self.py3.command_output(self.pgrep_command)
            return True
        except self.py3.CommandError:
            return False

    def process_status(self):
        if self._is_running():
            icon = self.icon_on
            color = self.color_on
        else:
            icon = self.icon_off
            color = self.color_off

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": color,
            "full_text": self.py3.safe_format(self.format, {"icon": icon, "process": self.process}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/prometheus.py
================================================
"""
Displays result of a Prometheus query.

Configuration parameters:
    color: Text colour. Supports py3status colour names.
        Examples: GOOD, DEGRADED, BAD, #E9967A
        (default None)
    format: Formatting of query result. Can refer to all labels from the query
        result. Query value placeholder __v.
        (default "{__v:.0f}")
    join: If query returned multiple rows, join them using this string.
        If you want to show just one, update your query.
        (default None)
    query: The PromQL query
        (default None)
    query_interval: Re-query interval in seconds.
        (default 60)
    server: str, URL pointing at your Prometheus(-compatible) server, example:
        http://prom.int.mydomain.net:9090
        (default None)
    units: Dict with py3.format_units arguments, if you want human-readable
        unit formatting. Example: {"unit": "Wh", "si": True}
        If used, __v placeholder will contain formatted output. __n and __u
        will contain number and unit separately if you want to more finely
        control formatting.
        (default None)

Dynamic format placeholders:
    All query result labels are available as format placeholders. The vector
    values themselves are in placeholder __v. (Or __n and __u if you specified
    units).

Examples:
    # If blackbox exporter ran into any failures, show it. If everything
    # is healthy this will produce 0 rows hence not shown.
    query = "probe_success == 0"
    format = "💀 {job} {instance} 💀"
    color = "bad"

    # Basic Prometheus stat
    query = "sum(prometheus_sd_discovered_targets)"
    format = "{__v:.0f} targets monitored"
    color = "ok"

@author github.com/Wilm0r

SAMPLE OUTPUT
{"full_text": "Ceph 21% (944GiB/4.4TiB)", "instance": "", "name": "prometheus"}
"""


class Py3status:
    # available configuration parameters
    color = None
    format = "{__v:.0f}"
    join = None
    query = None
    query_interval = 60
    server = None
    units = None

    def prometheus(self):
        self._rows = []
        self._rownum = 0
        rows = self._query(self.query)
        res = []
        for row in rows:
            val = float(row["value"][1])
            if self.units:
                num, unit = self.py3.format_units(val, **self.units)
                val = f"{num}{unit}"
            else:
                num = val
                unit = None

            vars = dict(row["metric"])
            vars.update({"__v": val, "__n": num, "__u": unit})
            res.append(self.format.format(**vars))

        if res:
            join = self.join or ""
            res = join.join(res)
        else:
            res = ""

        ret = dict(full_text=res, cached_until=self.py3.time_in(self.query_interval))
        if self.color:
            if self.color.startswith("#"):
                ret["color"] = self.color
            else:
                entry = "COLOR_" + self.color.upper()
                if getattr(self.py3, entry):
                    ret["color"] = getattr(self.py3, entry)
        return ret

    def _query(self, query):
        r = self.py3.request(self.server + "/api/v1/query", params={"query": query})
        if r.status_code != 200:
            return []
        r = r.json()
        if r["status"] != "success" or r["data"]["resultType"] != "vector":
            return []
        return r["data"]["result"]


if __name__ == "__main__":
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/rainbow.py
================================================
"""
Add color cycling fun to your i3bar.

This is the most pointless yet most exciting module you can imagine.

It allows color cycling of modules. Imagine the joy of having the current time
change through the colors of the rainbow.

If you were completely insane you could also use it to implement the i3bar
equivalent of the <blink> tag and cause yourself endless headaches and the
desire to vomit.

The color for the contained module(s) is changed and cycles through your chosen
gradient by default this is the colors of the rainbow.  This module will
increase the amount of updates that py3status needs to do so should be used
sparingly.

Configuration parameters:
    cycle_time: How often we change this color in seconds
        (default 1)
    force: If True then the color will always be set.  If false the color will
        only be changed if it has not been set by a module.
        (default False)
    format: display format for this module (default '{output}')
    gradient: The colors we will cycle through, This is a list of hex values
        *(default [ '#FF0000', '#FFFF00', '#00FF00', '#00FFFF',
        '#0000FF', '#FF00FF', '#FF0000', ])*
    multi_color: If True then each module the rainbow contains will be colored
        differently (default True)
    steps: Number of steps between each color in the gradient
        (default 10)

Format placeholders:
    {output} rainbow output

Examples:
```
# show time colorfully
order += "rainbow time"
rainbow time {
    time {}
}

# blinking text black/white
order += "rainbow blink_time"
rainbow blink_time {
    gradient = [
        '#FFFFFF',
        '#000000',
    ]
    steps = 1
    time {}
}
```

@author tobes

SAMPLE OUTPUT
[
    {'color': '#FF0000', 'full_text': 'module 1'},
    {'color': '#CCFF00', 'full_text': 'module 2', 'separator': True},
    {'color': '#00FF66', 'full_text': 'module 3', 'separator': True},
    {'color': '#0066FF', 'full_text': 'module 4', 'separator': True},
    {'color': '#CC00FF', 'full_text': 'module 5', 'separator': True}
]
"""

import math
import re
import time

HEX_RE = re.compile("#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})")


class Py3status:
    """ """

    # available configuration parameters
    cycle_time = 1
    force = False
    format = "{output}"
    gradient = [
        "#FF0000",
        "#FFFF00",
        "#00FF00",
        "#00FFFF",
        "#0000FF",
        "#FF00FF",
        "#FF0000",
    ]
    multi_color = True
    steps = 10

    class Meta:
        container = True

    def post_config_hook(self):
        def from_hex(color):
            """
            Convert hex color #xxx or #xxxxxx to [r, g, b].
            """
            if not HEX_RE.match(color):
                color = "#FFF"
            if len(color) == 7:
                return (int(color[1:3], 16), int(color[3:5], 16), int(color[5:], 16))
            return (
                int(color[1], 16) * 17,
                int(color[2], 16) * 17,
                int(color[3], 16) * 17,
            )

        def to_hex(color):
            """
            Convert [r, g, b] to hex.
            """
            return "#{:02X}{:02X}{:02X}".format(int(color[0]), int(color[1]), int(color[2]))

        def make_color(c1, c2, t):
            """
            Generate a mid color between c1 and c2.
            """

            def fade(i):
                a = c1[i]
                b = c2[i]
                x = b * t
                x += a * (1 - t)
                return x

            c1 = from_hex(c1)
            c2 = from_hex(c2)
            return (fade(0), fade(1), fade(2))

        colors = []
        if self.steps == 1:
            colors = [to_hex(from_hex(x)) for x in self.gradient]
        else:
            for grad_a, grad_b in zip(self.gradient, self.gradient[1:]):
                for j in range(self.steps):
                    colors.append(to_hex(make_color(grad_a, grad_b, j / self.steps)))
        self.colors = colors
        self.active_color = 0
        self._set_cycle_time()

    def _set_cycle_time(self):
        """
        Set next cycle update time synced to nearest second or 0.1 of second.
        """
        now = time.monotonic()
        try:
            cycle_time = now - self._cycle_time
            if cycle_time < 0:
                cycle_time = 0
        except AttributeError:
            cycle_time = 0
        cycle_time += self.cycle_time
        if cycle_time == int(cycle_time):
            self._cycle_time = math.ceil(now + cycle_time)
        else:
            self._cycle_time = math.ceil((now + cycle_time) * 10) / 10
        self._cycle_time = now + self.cycle_time

    def _get_current_output(self):
        """
        Get child modules output.
        """
        output = []
        for item in self.items:
            out = self.py3.get_output(item)
            if out and "separator" not in out[-1]:
                out[-1]["separator"] = True
            output += out
        return output

    def rainbow(self):
        """
        Make a rainbow!
        """
        if not self.items:
            return {"full_text": "", "cached_until": self.py3.CACHE_FOREVER}

        if time.monotonic() >= self._cycle_time - (self.cycle_time / 10):
            self.active_color = (self.active_color + 1) % len(self.colors)
            self._set_cycle_time()

        color = self.colors[self.active_color]
        content = self._get_current_output()
        output = []

        if content:
            step = len(self.colors) // len(content)
        for index, item in enumerate(content):
            if self.multi_color:
                offset = (self.active_color + (index * step)) % len(self.colors)
                color = self.colors[offset]
            obj = item.copy()
            if self.force or not obj.get("color"):
                obj["color"] = color
            output.append(obj)

        composites = {"output": self.py3.composite_create(output)}
        rainbow = self.py3.safe_format(self.format, composites)

        return {"cached_until": self._cycle_time, "full_text": rainbow}


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/rate_counter.py
================================================
"""
Display time spent and calculate the price of your service.

Configuration parameters:
    cache_timeout: how often to update in seconds (default 5)
    config_file: file path to store the time already spent
        and restore it the next session
        (default '~/.i3/py3status/counter-config.save')
    format: output format string
        (default 'Time: {days} day {hours}:{mins:02d} Cost: {total}')
    format_money: output format string
        (default '{price}$')
    hour_price: your price per hour (default 30)
    tax: tax value (1.02 = 2%) (default 1.02)

Format placeholders:
    {days} The number of whole days in running timer
    {hours} The remaining number of whole hours in running timer
    {mins} The remaining number of whole minutes in running timer
    {secs} The remaining number of seconds in running timer
    {subtotal} The subtotal cost (time * rate)
    {tax} The tax cost, based on the subtotal cost
    {total} The total cost (subtotal + tax)
    {total_hours} The total number of whole hours in running timer
    {total_mins} The total number of whole minutes in running timer

format_money placeholders:
    {price} numeric value of money

Color options:
    color_running: Running, default color_good
    color_stopped: Stopped, default color_bad

@author Amaury Brisou <py3status AT puzzledge.org>

SAMPLE OUTPUT
{'color': '#FF0000', 'full_text': u'Time: 0 day 0:00 Cost: 0.13$'}
"""

import time
from pathlib import Path

# No "magic numbers"
SECS_IN_MIN = 60
SECS_IN_HOUR = 60 * SECS_IN_MIN  # 3600
SECS_IN_DAY = 24 * SECS_IN_HOUR  # 86400


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 5
    config_file = "~/.i3/py3status/counter-config.save"
    format = "Time: {days} day {hours}:{mins:02d} Cost: {total}"
    format_money = "{price}$"
    hour_price = 30
    tax = 1.02

    def post_config_hook(self):
        self.config_file = Path(self.config_file).expanduser()
        self.running = False
        self.saved_time = 0
        self.start_time = self.current_time
        try:
            # Use file to refer to the file object
            with self.config_file.open() as file:
                self.saved_time = float(file.read())
        except:  # noqa e722 // (IOError, FileNotFoundError):  # py2/py3
            pass

    @property
    def current_time(self):
        """Get the current time.

        Using a helper property to make it easy to keep consistency.
        """
        return time.monotonic()

    @staticmethod
    def secs_to_dhms(time_in_secs):
        """Convert seconds to days, hours, minutes, seconds.

        Using days as the largest unit of time.  Blindly using the days in
        `time.gmtime()` will fail if it's more than one month (days > 31).
        """
        days, secs = divmod(int(time_in_secs), SECS_IN_DAY)
        hours, secs = divmod(secs, SECS_IN_HOUR)
        mins, secs = divmod(secs, SECS_IN_MIN)
        return days, hours, mins, secs

    def _start_timer(self):
        if not self.running:
            self.start_time = self.current_time - self.saved_time
            self.running = True

    def _stop_timer(self):
        if self.running:
            self.saved_time = self.current_time - self.start_time
            self.running = False

    def _toggle_timer(self):
        if self.running:
            self._stop_timer()
        else:
            self._start_timer()

    def kill(self):
        self._stop_timer()
        with self.config_file.open("w") as f:
            f.write(str(self.saved_time))

    def on_click(self, event):
        if event["button"] == 1:
            self._toggle_timer()
        elif event["button"] == 3:
            self._reset()

    def _reset(self):
        if not self.running:
            self.saved_time = 0.0
            with self.config_file.open("w") as f:
                f.write("0")

    def rate_counter(self):
        running_time = 0.0
        if self.running:
            color = self.py3.COLOR_RUNNING or self.py3.COLOR_GOOD
            running_time = self.current_time - self.start_time
        else:
            color = self.py3.COLOR_STOPPED or self.py3.COLOR_BAD
            running_time = self.saved_time

        days, hours, mins, secs = self.secs_to_dhms(running_time)
        subtotal = self.hour_price * running_time / SECS_IN_HOUR
        total = subtotal * float(self.tax)
        subtotal_cost = self.py3.safe_format(self.format_money, {"price": f"{subtotal:.2f}"})
        total_cost = self.py3.safe_format(self.format_money, {"price": f"{total:.2f}"})
        tax_cost = self.py3.safe_format(self.format_money, {"price": f"{total - subtotal:.2f}"})
        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": color,
            "full_text": self.py3.safe_format(
                self.format,
                dict(
                    days=days,
                    hours=hours,
                    mins=mins,
                    secs=secs,
                    total_hours=running_time // SECS_IN_HOUR,
                    total_mins=running_time // SECS_IN_MIN,
                    subtotal=subtotal_cost,
                    total=total_cost,
                    tax=tax_cost,
                ),
            ),
        }
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/rss_aggregator.py
================================================
"""
Display unread feeds in your favorite RSS aggregator.

Configuration parameters:
    aggregator: feed aggregator used. Supported values are `owncloud` and `ttrss`.
        Other aggregators might be supported in future releases. Contributions are
        welcome. (default 'owncloud')
    cache_timeout: how often to run this check (default 60)
    feed_ids: list of IDs of feeds to watch, see note below (default [])
    folder_ids: list of IDs of folders ro watch (default [])
    format: format to display (default 'Feed: {unseen}')
    password: login password (default None)
    server: aggregator server to connect to (default 'https://yourcloudinstance.com')
    user: login user (default None)

Format placeholders:
    {unseen} sum of numbers of unread feed elements

Color options:
    color_new_items: text color when there is new items (default color_good)
    color_error: text color when there is an error (default color_bad)

Requires:
    requests: python module from pypi https://pypi.python.org/pypi/requests

Notes:
    You can also decide to check only for specific feeds or folders of feeds.
    To use this feature, you have to first get the IDs of those feeds or
    folders. You can get those IDs by clicking on the desired feed or folder
    and watching the URL.

    For OwnCloud/NextCloud with News application:
    https://yourcloudinstance.com/index.php/apps/news/#/items/feeds/FEED_ID
    https://yourcloudinstance.com/index.php/apps/news/#/items/folders/FOLDER_ID

    For Tiny Tiny RSS 1.6 or newer:
    https://yourttrssinstance.com/index.php#f=FEED_ID&c=0
    https://yourttrssinstance.com/index.php#f=FOLDER_ID&c=1

    If both feeds list and folders list are left empty, all unread feed items
    will be counted. You may use both feeds list and folders list, but given
    feeds shouldn't be included in given folders, else unread count number
    behavior is unpredictable. Same warning when aggregator allows subfolders:
    the folders list shouldn't include a folder and one of its subfolder.

@author raspbeguy

SAMPLE OUTPUT
{'full_text': 'Feed: 488'}
"""

import json

import requests


class Py3status:
    """ """

    # available configuration parameters
    aggregator = "owncloud"
    cache_timeout = 60
    feed_ids = []
    folder_ids = []
    format = "Feed: {unseen}"
    password = None
    server = "https://yourcloudinstance.com"
    user = None

    def post_config_hook(self):
        self._cached = "?"
        if self.aggregator not in ["owncloud", "ttrss"]:  # more options coming
            raise ValueError(f"{self.aggregator} is not a supported feed aggregator")
        if self.user is None or self.password is None:
            raise ValueError("user and password must be provided")

    def rss_aggregator(self):
        if self.aggregator == "owncloud":
            rss_count = self._get_count_owncloud()
        elif self.aggregator == "ttrss":
            rss_count = self._get_count_ttrss()

        self._cached = self._cached if rss_count is None else rss_count

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"unseen": self._cached}),
        }

        if rss_count is None:
            response["color"] = self.py3.COLOR_ERROR or self.py3.COLOR_BAD
        elif rss_count != 0:
            response["color"] = self.py3.COLOR_NEW_ITEMS or self.py3.COLOR_GOOD

        return response

    def _get_count_owncloud(self):
        try:
            rss_count = 0
            api_url = f"{self.server}/index.php/apps/news/api/v1-2/"
            r = requests.get(api_url + "feeds", auth=(self.user, self.password), timeout=10)
            for feed in r.json()["feeds"]:
                if (
                    (not self.feed_ids and not self.folder_ids)
                    or feed["id"] in self.feed_ids
                    or feed["folderId"] in self.folder_ids
                ):
                    rss_count += feed["unreadCount"]

            return rss_count

        except:  # noqa e722
            return None

    def _get_count_ttrss(self):
        try:
            rss_count = 0
            api_url = f"{self.server}/api/"
            r = requests.post(
                api_url,
                data=json.dumps({"op": "login", "user": self.user, "password": self.password}),
            )
            sid = r.json()["content"]["session_id"]
            if not self.feed_ids and not self.folder_ids:
                r = requests.post(api_url, data=json.dumps({"sid": sid, "op": "getUnread"}))
                rss_count = r.json()["content"]["unread"]
            else:
                for folder in self.folder_ids:
                    r = requests.post(
                        api_url,
                        data=json.dumps(
                            {
                                "sid": sid,
                                "op": "getFeeds",
                                "cat_id": folder,
                                "include_nested": True,
                            }
                        ),
                    )
                    for item in r.json()["content"]:
                        rss_count += item["unread"]
                if self.feed_ids:
                    r = requests.post(
                        api_url,
                        data=json.dumps({"sid": sid, "op": "getFeeds", "cat_id": -3}),
                    )
                    for feed in r.json()["content"]:
                        if feed["id"] in self.feed_ids:
                            rss_count += feed["unread"]
            requests.post(api_url, data=json.dumps({"sid": sid, "op": "logOut"}))

            return rss_count

        except:  # noqa e722
            return None


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/rt.py
================================================
"""
Display number of ongoing tickets from RT queues.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds (default 300)
    db: database to use (default '')
    format: see placeholders below (default 'general: {General}')
    host: database host to connect to (default '')
    password: login password (default '')
    threshold_critical: set bad color above this threshold (default 20)
    threshold_warning: set degraded color above this threshold (default 10)
    timeout: timeout for database connection (default 5)
    user: login user (default '')

Format placeholders:
    {YOUR_QUEUE_NAME} number of ongoing RT tickets (open+new+stalled)

Color options:
    color_bad: Exceeded threshold_critical
    color_degraded: Exceeded threshold_warning

Requires:
    PyMySQL: https://pypi.org/project/PyMySQL/
        or
    MySQL-python: https://pypi.org/project/MySQL-python/

It features thresholds to colorize the output and forces a low timeout to
limit the impact of a server connectivity problem on your i3bar freshness.

@author ultrabug

SAMPLE OUTPUT
{'full_text': 'general: 24'}
"""

try:
    import pymysql as mysql
except:  # noqa e722 // (ImportError, ModuleNotFoundError):  # py2/py3
    import MySQLdb as mysql


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 300
    db = ""
    format = "general: {General}"
    host = ""
    password = ""
    threshold_critical = 20
    threshold_warning = 10
    timeout = 5
    user = ""

    def rt(self):
        has_one_queue_formatted = False
        response = {"full_text": ""}
        tickets = {}

        mydb = mysql.connect(
            host=self.host,
            user=self.user,
            passwd=self.password,
            db=self.db,
            connect_timeout=self.timeout,
        )
        mycr = mydb.cursor()
        mycr.execute(
            """select q.Name as queue, coalesce(total,0) as total
            from Queues as q
            left join (
                select t.Queue as queue, count(t.id) as total
                from Tickets as t
                where Status = 'new' or Status = 'open' or Status = 'stalled'
                group by t.Queue)
            as s on s.Queue = q.id
            group by q.Name;"""
        )
        for row in mycr.fetchall():
            queue, nb_tickets = row
            if queue == "___Approvals":
                continue
            tickets[queue] = nb_tickets
            if queue in self.format:
                has_one_queue_formatted = True
                if nb_tickets > self.threshold_critical:
                    response.update({"color": self.py3.COLOR_BAD})
                elif nb_tickets > self.threshold_warning and "color" not in response:
                    response.update({"color": self.py3.COLOR_DEGRADED})
        if has_one_queue_formatted:
            response["full_text"] = self.py3.safe_format(self.format, tickets)
        else:
            response["full_text"] = f"queue(s) not found ({self.format})"
        mydb.close()

        response["cached_until"] = self.py3.time_in(self.cache_timeout)
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/scratchpad.py
================================================
"""
Display number of scratchpad windows and urgency hints.

Configuration parameters:
    cache_timeout: refresh interval for i3-msg or swaymsg (default 5)
    format: display format for this module
        (default "\u232b [\\?color=scratchpad {scratchpad}]")
    thresholds: specify color thresholds to use
        (default [(0, "darkgray"), (1, "violet")])

Format placeholders:
    {scratchpad} number of scratchpads
    {urgent} number of urgent scratchpads

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Optional:
    i3ipc: an improved python library to control i3wm and sway

Examples:
```
# hide zero scratchpad
scratchpad {
    format = '[\\?not_zero \u232b [\\?color=scratchpad {scratchpad}]]'
}

# hide non-urgent scratchpad
scratchpad {
    format = '[\\?not_zero \u232b {urgent}]'
}

# bring up scratchpads on clicks
scratchpad {
    on_click 1 = 'scratchpad show'
}

# add more colors
scratchpad {
    thresholds = [
       (0, "darkgray"), (1, "violet"), (2, "deepskyblue"), (3, "lime"),
       (4, "yellow"), (5, "orange"), (6, "red"), (7, "tomato"),
    ]
}
```

@author shadowprince (counter), cornerman (async)
@license Eclipse Public License (counter), BSD (async)

SAMPLE OUTPUT
[{'full_text': '\u232b '}, {'full_text': u'0', 'color': '#a9a9a9'}]

violet
[{'full_text': '\u232b '}, {'full_text': u'5', 'color': '#ee82ee'}]

urgent
[{'full_text': '\u232b URGENT 1', 'urgent': True}]
"""

STRING_ERROR = "invalid ipc `{}`"


class Ipc:
    """ """

    def __init__(self, parent):
        self.parent = parent
        self.setup(parent)


class I3ipc(Ipc):
    """
    i3ipc - an improved python library to control i3wm and sway
    """

    def setup(self, parent):
        from threading import Thread

        self.parent.cache_timeout = self.parent.py3.CACHE_FOREVER
        self.scratchpad_data = {"scratchpad": 0, "urgent": 0}

        t = Thread(target=self.start)
        t.daemon = True
        t.start()

    def start(self):
        from i3ipc import Connection

        i3 = Connection()
        self.update(i3)
        for event in ["window::move", "window::urgent"]:
            i3.on(event, self.update)
        i3.main()

    def update(self, i3, event=None):
        scratchpad = i3.get_tree().scratchpad()
        if not scratchpad:
            return

        # Workaround for I3ipc 2.2.1 not finding leaves() in sway. Fixing: #2038
        leaves = getattr(scratchpad, "floating_nodes", [])

        temporary = {
            "ipc": self.parent.ipc,
            "scratchpad": len(leaves),
            "urgent": sum(window.urgent for window in leaves),
        }
        if self.scratchpad_data != temporary:
            self.scratchpad_data = temporary
            self.parent.py3.update()

    def get_scratchpad_data(self):
        return self.scratchpad_data


class Msg(Ipc):
    """
    i3-msg - send messages to i3 window manager
    swaymsg - send messages to sway window manager
    """

    def setup(self, parent):
        from json import loads

        self.json_loads = loads
        wm_msg = {"i3msg": "i3-msg"}.get(parent.ipc, parent.ipc)
        self.tree_command = [wm_msg, "-t", "get_tree"]

    def get_scratchpad_data(self):
        tree = self.json_loads(self.parent.py3.command_output(self.tree_command))
        leaves = self.find_scratchpad(tree).get("floating_nodes", [])
        return {
            "ipc": self.parent.ipc,
            "scratchpad": len(leaves),
            "urgent": sum(window["urgent"] for window in leaves),
        }

    def find_scratchpad(self, tree):
        if tree.get("name") == "__i3_scratch":
            return tree
        for x in tree.get("nodes", []):
            result = self.find_scratchpad(x)
            if result:
                return result
        return {}


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 5
    format = "\u232b [\\?color=scratchpad {scratchpad}]"
    thresholds = [(0, "darkgray"), (1, "violet")]

    def post_config_hook(self):
        # ipc: specify i3ipc, i3-msg, or swaymsg, otherwise auto
        self.ipc = getattr(self, "ipc", "")
        if self.ipc in ["", "i3ipc"]:
            try:
                from i3ipc import Connection  # noqa f401

                self.ipc = "i3ipc"
            except Exception:
                if self.ipc:
                    raise  # module not found

        self.ipc = (self.ipc or self.py3.get_wm_msg()).replace("-", "")
        if self.ipc in ["i3ipc"]:
            self.backend = I3ipc(self)
        elif self.ipc in ["i3msg", "swaymsg"]:
            self.backend = Msg(self)
        else:
            raise Exception(STRING_ERROR.format(self.ipc))

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def scratchpad(self):
        scratchpad_data = self.backend.get_scratchpad_data()

        for x in self.thresholds_init:
            if x in scratchpad_data:
                self.py3.threshold_get_color(scratchpad_data[x], x)

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, scratchpad_data),
        }
        if scratchpad_data["urgent"]:
            response["urgent"] = True
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    config = {"format": r"\[{ipc}\] [\?color=scratchpad {scratchpad}]"}
    module_test(Py3status, config=config)



================================================
FILE: py3status/modules/screenshot.py
================================================
r"""
Take screenshots and upload them to a given server.

Configuration parameters:
    file_length: generated file_name length (default 4)
    format: display format for this module
        (default '\?color=good [{basename}|\?show SHOT]')
    save_path: Directory where to store your screenshots (default '~/Pictures')
    screenshot_command: the command used to generate the screenshot
        (default 'gnome-screenshot -f')
    upload_path: the remote path where to push the screenshot (default None)
    upload_server: your server address (default None)
    upload_user: your ssh user (default None)

Format placeholders:
    {basename} generated basename, eg qs60.jpg

Examples:
```
# push screenshots to a server
screenshot {
    save_path = "~/Pictures/"
    upload_user = "erol"
    upload_server = "puzzledge.org"
    upload_path = "/files"

    # scp $HOME/Pictures/$UUID.jpg erol@puzzledge.org:/files
}
```

@author Amaury Brisou <py3status AT puzzledge.org>

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'SHOT'}

basename
{'color': '#00FF00', 'full_text': 'qs60.jpg'}
"""

import random
import string
from pathlib import Path


class Py3status:
    """ """

    # available configuration parameters
    file_length = 4
    format = r"\?color=good [{basename}|\?show SHOT]"
    save_path = "~/Pictures"
    screenshot_command = "gnome-screenshot -f"
    upload_path = None
    upload_server = None
    upload_user = None

    class Meta:
        deprecated = {
            "remove": [
                {"param": "push", "msg": "obsolete"},
                {"param": "cache_timeout", "msg": "obsolete"},
            ]
        }

    def post_config_hook(self):
        self.shot_data = {}
        self.save_path = Path(self.save_path).expanduser()
        self.chars = string.ascii_lowercase + string.digits

    def _generator(self, size=6):
        return "".join(random.choice(self.chars) for _ in range(size))

    def screenshot(self):
        return {
            "cached_until": self.py3.time_in(self.py3.CACHE_FOREVER),
            "full_text": self.py3.safe_format(self.format, self.shot_data),
        }

    def on_click(self, event):
        basename = self._generator(self.file_length) + ".jpg"
        pathname = self.save_path / basename
        self.shot_data["basename"] = basename

        self.py3.command_run(" ".join(self.screenshot_command, pathname))

        if self.upload_server and self.upload_user and self.upload_path:
            self.py3.command_run(
                "scp {} {}@{}:{}".format(
                    pathname, self.upload_user, self.upload_server, self.upload_path
                )
            )


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/scroll.py
================================================
"""
Scroll modules.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 1)
    length: specify a length of characters to scroll (default 25)

Format placeholders:
    {output} output

Examples:
```
scroll {
    length = 30

    playerctl {}
    networkmanager {}
    static_string {
        format = "some long long text"
    }
}
```

@author farnoy

SAMPLE OUTPUT
[
    {'full_text': 'module 4', 'separator': True},
    {'full_text': 'module 5', 'separator': True},
    {'full_text': 'module 6', 'separator': True},
]
"""

STRING_ERROR = "missing modules"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 1
    length = 25

    class Meta:
        container = True

    def post_config_hook(self):
        if len(self.items) <= 1:
            raise Exception(STRING_ERROR)
        self.format = "{output}"
        self.index = 0

    def _set_scroll(self):
        length = sum(
            len(output["full_text"]) for item in self.items for output in self.py3.get_output(item)
        )

        self.index += 1
        if length <= self.length:
            self.index = 0
        self.index = self.index % length

    def scroll(self):
        self._set_scroll()
        length_position = 0
        last_position = 0

        composite = []
        while length_position < self.length:
            for item in self.items:
                _composite = []
                for output in self.py3.get_output(item):
                    # cut strings
                    start = max(0, self.index - last_position)
                    end = max(0, self.length - length_position)
                    sliced = output["full_text"][start:][:end]
                    # set positions
                    length_position += len(sliced)
                    last_position += len(output["full_text"])
                    output["full_text"] = sliced
                    # disable separators
                    if output["full_text"]:
                        output["separator"] = False
                        _composite.append(output)
                # enable separators
                if _composite:
                    _composite[-1]["separator"] = True
                    _composite[-1].pop("separator_block_width", None)
                composite += _composite

        scroll_data = {"output": self.py3.composite_create(composite)}

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, scroll_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/selinux.py
================================================
"""
Display SELinux state.

This module displays the state of SELinux on your machine:
Enforcing (good), Permissive (degraded), or Disabled (bad).

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default 'SELinux: {state}')
    state_disabled: show when no SELinux policy is loaded.
        (default 'disabled')
    state_enforcing: show when SELinux security policy is enforced.
        (default 'enforcing')
    state_permissive: show when SELinux prints warnings instead of enforcing.
        (default 'permissive')

Format placeholders:
    {state} SELinux state

Color options:
    color_bad: Enforcing
    color_degraded: Permissive
    color_good: Disabled

Requires:
    libselinux-python: SELinux python bindings for libselinux

@author bstinsonmhk
@license BSD

SAMPLE OUTPUT
{'full_text': 'SELinux: enforcing', 'color': '#00FF00'}

permissive
{'full_text': 'SELinux: permissive', 'color': '#FFFF00'}

disabled
{'full_text': 'SELinux: disabled', 'color': '#FF0000'}
"""

import selinux


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "SELinux: {state}"
    state_disabled = "disabled"
    state_enforcing = "enforcing"
    state_permissive = "permissive"

    def selinux(self):
        try:
            if selinux.security_getenforce():
                state = self.state_enforcing
                color = self.py3.COLOR_GOOD
            else:
                state = self.state_permissive
                color = self.py3.COLOR_DEGRADED
        except AttributeError:
            state = self.state_disabled
            color = self.py3.COLOR_BAD

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"state": state}),
            "color": color,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/spaceapi.py
================================================
"""
Display status of a given hackerspace.

Configuration parameters:
    button_url: mouse button to open URL sent in space's API (default 3)
    cache_timeout: refresh interval for this module (default 60)
    format: display format for this module (default '{state}[ {lastchanged}]')
    format_lastchanged: display format for time (default 'since %H:%M')
    state_closed: show when hackerspace is closed (default 'closed')
    state_open: show when hackerspace is open (default 'open')
    url: specify JSON URL of a hackerspace to retrieve from
        (default 'https://status.chaospott.de/status.json')

Format placeholders:
    {state} Hackerspace state
    {lastchanged} Time

format_lastchanged conversion:
    '%' Strftime characters to be translated

Color options:
    color_closed: Space closed, defaults to color_bad
    color_open: Space open, defaults to color_good

@author timmszigat
@license WTFPL <http://www.wtfpl.net/txt/copying/>

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'open since 05:41'}

closed
{'color': '#FF0000', 'full_text': 'closed since 16:38'}
"""

import datetime

STRING_UNAVAILABLE = "spaceapi: N/A"


class Py3status:
    """ """

    # available configuration parameters
    button_url = 3
    cache_timeout = 60
    format = "{state}[ {lastchanged}]"
    format_lastchanged = "since %H:%M"
    state_closed = "closed"
    state_open = "open"
    url = "https://status.chaospott.de/status.json"

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "open_color",
                    "new": "color_open",
                    "msg": "obsolete parameter use `color_open`",
                },
                {
                    "param": "closed_color",
                    "new": "color_closed",
                    "msg": "obsolete parameter use `color_closed`",
                },
                {
                    "param": "closed_text",
                    "new": "state_closed",
                    "msg": "obsolete parameter use `state_closed`",
                },
                {
                    "param": "open_text",
                    "new": "state_open",
                    "msg": "obsolete parameter use `state_open`",
                },
                {
                    "param": "time_text",
                    "new": "format_lastchanged",
                    "msg": "obsolete parameter use `format_lastchanged`",
                },
            ]
        }

    def post_config_hook(self):
        self.button_refresh = 2
        self.color_open = self.py3.COLOR_OPEN or self.py3.COLOR_GOOD
        self.color_closed = self.py3.COLOR_CLOSED or self.py3.COLOR_BAD
        self.hackerspace_url = None

    def spaceapi(self):
        color = self.color_closed
        state = self.state_closed
        lastchanged = "unknown"

        try:
            data = self.py3.request(self.url).json()

            if data["state"]["open"]:
                color = self.color_open
                state = self.state_open

            if "lastchange" in data["state"]:
                try:
                    dt = datetime.datetime.fromtimestamp(data["state"]["lastchange"])
                    lastchanged = dt.strftime(self.format_lastchanged)
                except TypeError:
                    pass

            full_text = self.py3.safe_format(
                self.format, {"state": state, "lastchanged": lastchanged}
            )

        except (self.py3.RequestException, KeyError):
            full_text = STRING_UNAVAILABLE
            data = {}

        self.hackerspace_url = data.get("url")

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": full_text,
            "color": color,
        }

    def on_click(self, event):
        button = event["button"]
        if button == self.button_url:
            if self.hackerspace_url:
                self.py3.command_run(f"xdg-open {self.hackerspace_url}")
        if button != self.button_refresh:
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/speedtest.py
================================================
r"""
Perform a bandwidth test with speedtest-cli.

Use middle-click to start the speed test.

Configuration parameters:
    button_share: mouse button to share an URL (default None)
    format: display format for this module
        *(default "speedtest[\?if=elapsed&color=elapsed_time  "
        "{elapsed_time}s][ [\?color=download ↓{download}Mbps] "
        "[\?color=upload ↑{upload}Mbps]]")*
    thresholds: specify color thresholds to use
        *(default {"upload": [(0, "violet")], "ping": [(0, "#fff381")],
        "download": [(0, "cyan")], "elapsed_time": [(0, "#1cbfff")]})*

Control placeholders:
    {elapsed}          elapsed time state, eg False, True

Format placeholders:
    {bytes_sent}       bytes sent during test (in MB), eg 52.45
    {bytes_received}   bytes received during test (in MB), eg 70.23
    {client_country}   client country code, eg FR
    {client_ip}        client ip, eg 78.194.13.7
    {client_isp}       client isp, eg Free SAS
    {client_ispdlavg}  client isp download average, eg 0
    {client_isprating} client isp rating, eg 3.7
    {client_ispulavg}  client isp upload average, eg 0
    {client_lat}       client latitude, eg 48.8534
    {client_loggedin}  client logged in, eg 0
    {client_lon}       client longitude, eg 2.3487999999999998
    {client_rating}    client rating, eg 0
    {download}         download speed (in MB), eg 20.23
    {elapsed_time}     elapsed time since speedtest start
    {ping}             ping time in ms to speedtest server
    {server_cc}        server country code, eg FR
    {server_country}   server country, eg France
    {server_d}         server distance, eg 2.316599376968091
    {server_host}      server host, eg speedtest.telecom-paristech.fr:8080
    {server_id}        server id, eg 11977
    {share}            share, eg share url
    {timestamp}        timestamp, eg 2018-08-30T16:27:25.318212Z
    {server_lat}       server latitude, eg 48.8742
    {server_latency}   server latency, eg 8.265
    {server_lon}       server longitude, eg 2.3470
    {server_name}      server name, eg Paris
    {server_sponsor}   server sponsor, eg Télécom ParisTech
    {server_url}       server url, eg http://speedtest.telecom-paristech...
    {upload}           upload speed (in MB), eg 20.23

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    speedtest-cli: Command line interface for testing Internet bandwidth

Examples:
```
# show detailed elapsed_time|download/upload
speedtest {
    format = "speedtest[\?soft  ][\?if=elapsed [\?color=darkgray [time "
    format += "[\?color=elapsed_time {elapsed_time} s]]]|[\?color=darkgray "
    # format += "ping [\?color=ping {ping} ms] "
    format += "download [\?color=download {download}Mbps] "
    format += "upload [\?color=upload {upload}Mbps]]]"
}

# show everything
speedtest {
    format = "speedtest[\?soft  ][\?color=darkgray "
    format += "[time [\?color=elapsed_time {elapsed_time} s]][\?soft  ]"
    format += "[ping [\?color=ping {ping} ms] "
    format += "download [\?color=download {download}Mbps] "
    format += "upload [\?color=upload {upload}Mbps]]]"
}

# minimal
speedtest {
    format = "speedtest[\?soft  ][\?if=elapsed "
    format += "[\?color=elapsed_time {elapsed_time}]|"
    # format += "[\?color=ping {ping}] "
    format += "[[\?color=download {download}] [\?color=upload {upload}]]]"
}

# don't hide data on reset
speedtest {
    format = "speedtest[\?soft  ][\?color=darkgray time "
    format += "[\?color=elapsed_time {elapsed_time} s] "
    # format += "ping [\?color=ping {ping} ms] "
    format += "download [\?color=download {download}Mbps] "
    format += "upload [\?color=upload {upload}Mbps]]"
}

# don't hide data on reset, minimal
speedtest {
    format = "speedtest[\?soft  ][[\?color=elapsed_time {elapsed_time}] "
    # format += "[\?color=ping {ping}] "
    format += "[\?color=download {download}] [\?color=upload {upload}]]"
}
```

@author Cyril Levis (@cyrinux)

SAMPLE OUTPUT
[
    {"full_text": "speedtest "},
    {"full_text": "19.76Mbps ", "color": "#00ffff"},
    {"full_text": "3.86Mbps", "color": "#ee82ee"},
]

time+ping
[
    {"full_text": "speedtest "},
    {"full_text": "time ", "color": "#a9a9a9"},
    {"full_text": "24.65 s ", "color": "#1cbfff"},
    {"full_text": "ping ", "color": "#a9a9a9"},
    {"full_text": "28.27 ms", "color": "#ffff00"},
]

details
[
    {"full_text": "speedtest "},
    {"full_text": "download ", "color": "#a9a9a9"},
    {"full_text": "18.2Mbps ", "color": "#00ffff"},
    {"full_text": "upload ", "color": "#a9a9a9"},
    {"full_text": "19.2Mbps", "color": "#ee82ee"},
]
"""

import time
from json import loads
from threading import Thread

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    button_share = None
    format = (
        r"speedtest[\?if=elapsed&color=elapsed_time  "
        r"{elapsed_time}s][ [\?color=download ↓{download}Mbps] "
        r"[\?color=upload ↑{upload}Mbps]]"
    )
    thresholds = {
        "download": [(0, "cyan")],
        "elapsed_time": [(0, "#1cbfff")],
        "ping": [(0, "#fff381")],
        "upload": [(0, "violet")],
    }

    class Meta:
        update_config = {
            "update_placeholder_format": [
                {
                    "format_strings": ["format"],
                    "placeholder_formats": {
                        "bytes_received": ":.2f",
                        "bytes_sent": ":.2f",
                        "download": ":.2f",
                        "elapsed_time": ":.2f",
                        "ping": ":.2f",
                        "server_d": ":.2f",
                        "upload": ":.2f",
                    },
                }
            ]
        }

    def post_config_hook(self):
        self.speedtest_command = "speedtest-cli --json --secure"
        if not self.py3.check_commands(self.speedtest_command.split()[0]):
            raise Exception(STRING_NOT_INSTALLED)

        # init
        self.button_refresh = 2
        self.placeholders = self.py3.get_placeholders_list(self.format)
        self.speedtest_data = self.py3.storage_get("speedtest_data") or {}
        self.thread = None
        self.thresholds_init = self.py3.get_color_names_list(self.format)

        # remove elapsed_time
        if "elapsed_time" in self.placeholders:
            self.placeholders.remove("elapsed_time")

        # share
        if self.button_share:
            self.speedtest_command += " --share"

        # perform download/upload based on placeholders
        tests = ["download", "upload"]
        if any(x in tests for x in self.placeholders):
            for x in tests:
                if x not in self.placeholders:
                    self.speedtest_command += f" --no-{x}"

    def _set_speedtest_data(self):
        # start
        self.start_time = time.monotonic()
        self.speedtest_data["elapsed"] = True

        try:
            self.speedtest_data = self.py3.flatten_dict(
                loads(self.py3.command_output(self.speedtest_command)), delimiter="_"
            )
            for x in ["download", "upload", "bytes_received", "bytes_sent"]:
                if x not in self.placeholders or x not in self.speedtest_data:
                    continue
                si = False if "bytes" in x else True
                self.speedtest_data[x], unit = self.py3.format_units(
                    self.speedtest_data[x], unit="MB", si=si
                )
        except self.py3.CommandError:
            pass

        # end
        self.speedtest_data["elapsed"] = False
        self.speedtest_data["elapsed_time"] = time.monotonic() - self.start_time
        self.thread = None

    def speedtest(self):
        if self.speedtest_data.get("elapsed"):
            cached_until = 0
            self.speedtest_data["elapsed_time"] = time.monotonic() - self.start_time
        else:
            cached_until = self.py3.CACHE_FOREVER
            self.py3.storage_set("speedtest_data", self.speedtest_data)

        # thresholds
        for x in self.thresholds_init:
            if x in self.speedtest_data:
                self.py3.threshold_get_color(self.speedtest_data[x], x)

        return {
            "cached_until": self.py3.time_in(cached_until),
            "full_text": self.py3.safe_format(self.format, self.speedtest_data),
        }

    def on_click(self, event):
        button = event["button"]
        if button == self.button_share:
            share = self.speedtest_data.get("share")
            if share:
                self.py3.command_run(f"xdg-open {share}")
        if button == self.button_refresh:
            if self.thread is None:
                self.thread = Thread(target=self._set_speedtest_data)
                self.thread.daemon = True
                self.thread.start()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/spotify.py
================================================
"""
Display song currently playing in Spotify.

Configuration parameters:
    button_next: button to switch to next song (default None)
    button_play_pause: button to toggle play/pause (default None)
    button_previous: button to switch to previous song (default None)
    cache_timeout: how often to update the bar (default 5)
    dbus_client: Used to override which app is used as a client for
        spotify. If you use spotifyd as a client, set this to
        'org.mpris.MediaPlayer2.spotifyd'
        (default 'org.mpris.MediaPlayer2.spotify')
    format: see placeholders below (default '{artist} : {title}')
    format_down: define output if spotify is not running
        (default 'Spotify not running')
    format_stopped: define output if spotify is not playing
        (default 'Spotify stopped')
    replacements: specify a list/dict of string placeholders to modify
        (default None)

Format placeholders:
    {album} album name
    {artist} artiste name (first one)
    {playback} state of the playback: Playing, Paused
    {time} time duration of the song
    {title} name of the song

Color options:
    color_offline: Spotify is not running, defaults to color_bad
    color_paused: Song is stopped or paused, defaults to color_degraded
    color_playing: Song is playing, defaults to color_good

Requires:
    python-dbus: to access dbus in python
    spotify: a proprietary music streaming service

Examples:
```
spotify {
    button_next = 4
    button_play_pause = 1
    button_previous = 5
    format = "{title} by {artist} -> {time}"
    format_down = "no Spotify"

    # sanitize
    replacements = {
        "album": [("\s?[\(\[\-,;/][^)\],;/]*?(bonus|demo|edit|explicit|extended|feat|mono|remaster|stereo|version)[^)\],;/]*[\)\]]?", "")],
        "title": [("\s?[\(\[\-,;/][^)\],;/]*?(bonus|demo|edit|explicit|extended|feat|mono|remaster|stereo|version)[^)\],;/]*[\)\]]?", "")]
    }
}
```

@author Pierre Guilbert, Jimmy Garpehäll, sondrele, Andrwe

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'Rick Astley : Never Gonna Give You Up'}

paused
{'color': '#FFFF00', 'full_text': 'Rick Astley : Never Gonna Give You Up'}

stopped
{'color': '#FF0000', 'full_text': 'Spotify stopped'}
"""

from datetime import timedelta
from time import sleep

import dbus

SPOTIFY_CMD = """dbus-send --print-reply --dest={dbus_client}
                 /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.{cmd}"""


class Py3status:
    """ """

    # available configuration parameters
    button_next = None
    button_play_pause = None
    button_previous = None
    cache_timeout = 5
    dbus_client = "org.mpris.MediaPlayer2.spotify"
    format = "{artist} : {title}"
    format_down = "Spotify not running"
    format_stopped = "Spotify stopped"
    replacements = None

    def _spotify_cmd(self, action):
        return SPOTIFY_CMD.format(dbus_client=self.dbus_client, cmd=action)

    def _get_playback_status(self):
        """
        Get the playback status. One of: "Playing", "Paused" or "Stopped".
        """
        return self.player.Get("org.mpris.MediaPlayer2.Player", "PlaybackStatus")

    def _get_text(self):
        """
        Get the current song metadatas (artist - title)
        """
        bus = dbus.SessionBus()
        try:
            self.__bus = bus.get_object(self.dbus_client, "/org/mpris/MediaPlayer2")
            self.player = dbus.Interface(self.__bus, "org.freedesktop.DBus.Properties")

            try:
                metadata = self.player.Get("org.mpris.MediaPlayer2.Player", "Metadata")
                album = metadata.get("xesam:album")
                artist = metadata.get("xesam:artist")[0]
                microtime = metadata.get("mpris:length")
                rtime = str(timedelta(seconds=microtime // 1_000_000))
                title = metadata.get("xesam:title")
                playback_status = self._get_playback_status()
                if playback_status == "Playing":
                    color = self.py3.COLOR_PLAYING or self.py3.COLOR_GOOD
                else:
                    color = self.py3.COLOR_PAUSED or self.py3.COLOR_DEGRADED
            except Exception:
                return (
                    self.format_stopped,
                    self.py3.COLOR_PAUSED or self.py3.COLOR_DEGRADED,
                )

            spotify_data = {
                "title": title,
                "artist": artist,
                "album": album,
                "time": rtime,
                "playback": playback_status,
            }

            for x in self.replacements_init:
                if x in spotify_data:
                    spotify_data[x] = self.py3.replace(spotify_data[x], x)

            return (self.py3.safe_format(self.format, spotify_data), color)
        except Exception:
            return (self.format_down, self.py3.COLOR_OFFLINE or self.py3.COLOR_BAD)

    def post_config_hook(self):
        self.replacements_init = self.py3.get_replacements_list(self.format)

    def spotify(self):
        """
        Get the current "artist - title" and return it.
        """
        (text, color) = self._get_text()
        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": color,
            "full_text": text,
        }
        return response

    def on_click(self, event):
        """ """
        button = event["button"]
        if button == self.button_play_pause:
            # we do not use the 'PlayPause' command because of a bug
            # in spotifyd: https://github.com/Spotifyd/spotifyd/issues/890
            playback_status = self._get_playback_status()
            if playback_status == "Playing":
                self.py3.command_run(self._spotify_cmd("Pause"))
            else:
                self.py3.command_run(self._spotify_cmd("Play"))
            sleep(0.1)
        elif button == self.button_next:
            self.py3.command_run(self._spotify_cmd("Next"))
            sleep(0.1)
        elif button == self.button_previous:
            self.py3.command_run(self._spotify_cmd("Previous"))
            sleep(0.1)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/sql.py
================================================
r"""
Display data stored in MariaDB, MySQL, sqlite3, and hopefully more.

Configuration parameters:
    cache_timeout: refresh cache_timeout for this module (default 10)
    database: specify database name to import (default None)
    format: display format for this module (default '{format_row}')
    format_row: display format for SQL rows (default None)
    format_separator: show separator if more than one (default ' ')
    parameters: specify connection parameters to use (default None)
    query: specify command to query a database (default None)
    thresholds: specify color thresholds to use (default [])

Format placeholders:
    {row} number of SQL rows
    {format_row} format for SQL rows
    Parameters can be placeholders too, eg {host}, {passd}

Format_row placeholders:
    {field} placeholders will have the value returned by the query for the field

Color thresholds:
    format:
        row: print a color based on the number of SQL rows
    format_row:
        field: print a color based on the value of `field` placeholder

Requires:
    mariadb: fast sql database server, drop-in replacement for mysql
    mysql-python: mysql support for python
    sqlite: a c library that implements an sql database engine

Examples:
```
# specify database name to import
sql {
    database = 'sqlite3'  # from sqlite3 import connect
    database = 'MySQLdb'  # from MySQLdb import connect
    database = '...'      # from ... import connect
}

# specify connection parameters to use
http://mysql-python.sourceforge.net/MySQLdb.html#functions-and-attributes
https://docs.python.org/3/library/sqlite3.html#module-functions-and-constants
sql {
    name = 'MySQLdb'
    format = '{host} {passd} ...'
    parameters = {
        'host': 'host',
        'passwd': 'password',
        '...': '...',
    }
}

# specify command to query a database
sql {
    query = 'SHOW SLAVE STATUS'
    query = 'SELECT * FROM cal_todos'
    query = '...'
}

# display number of seconds behind master with MySQLdb
sql {
    database = 'MySQLdb'
    format_row = '\?color=seconds_behind_master {host} is '
    format_row += '[{seconds_behind_master}s behind|\?show master]'
    parameters = {
        'host': 'localhost',
        'passwd': '********'
    }
    query = 'SHOW SLAVE STATUS'
    thresholds = [
        (0, 'deepskyblue'), (100, 'good'), (300, 'degraded'), (600, 'bad')
    ]
}

# display thunderbird tasks with sqlite3
sql {
    database = 'sqlite3'
    format_row = '{title}'
    format_separator = ', '
    query = 'SELECT * FROM cal_todos'
    parameters = '~/.thunderbird/user.default/calendar-data/local.sqlite'
}
```

@author cereal2nd
@license BSD

SAMPLE OUTPUT
{'full_text': 'New Row Item 1, New Row Item 2'}
"""

from importlib import import_module
from pathlib import Path


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    database = None
    format = "{format_row}"
    format_row = None
    format_separator = " "
    parameters = None
    query = None
    thresholds = []

    def post_config_hook(self):
        names = ["database", "format", "format_row", "parameters", "query"]
        for config_name in names:
            if config_name == "format_row":
                if not self.py3.format_contains(self.format, config_name):
                    continue
            if not getattr(self, config_name, None):
                raise Exception(f"missing {config_name}")

        self.connect = getattr(import_module(self.database), "connect")
        self.operational_error = getattr(import_module(self.database), "OperationalError")
        self.is_parameters_a_dict = isinstance(self.parameters, dict)
        if not self.is_parameters_a_dict:
            self.parameters = Path(self.parameters).expanduser()

        self.thresholds_init = {}
        for name in ("format", "format_row"):
            self.thresholds_init[name] = self.py3.get_color_names_list(getattr(self, name))

    def _get_sql_data(self):
        if self.is_parameters_a_dict:
            connection = self.connect(**self.parameters)
        else:
            connection = self.connect(self.parameters)
        cursor = connection.cursor()
        cursor.execute(self.query)
        sql_keys = [desc[0].lower() for desc in cursor.description]
        sql_values = cursor.fetchall()
        cursor.close()
        connection.close()
        return [dict(zip(sql_keys, values)) for values in sql_values]

    def sql(self):
        sql_data = {}
        if self.is_parameters_a_dict:
            sql_data.update(self.parameters)

        try:
            data = self._get_sql_data()
        except self.operational_error:
            pass
        else:
            new_data = []
            count_row = len(data)
            for row in data:
                for x in self.thresholds_init["format_row"]:
                    if x in row:
                        self.py3.threshold_get_color(row[x], x)

                new_data.append(self.py3.safe_format(self.format_row, row))

            format_separator = self.py3.safe_format(self.format_separator)
            format_row = self.py3.composite_join(format_separator, new_data)
            sql_data.update({"row": count_row, "format_row": format_row})

            for x in self.thresholds_init["format"]:
                if x in sql_data:
                    self.py3.threshold_get_color(sql_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, sql_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/static_string.py
================================================
"""
Display static text.

Configuration parameters:
    format: display format for this module (default 'Hello, world!')

@author frimdo ztracenastopa@centrum.cz

SAMPLE OUTPUT
{'full_text': 'Hello, world!'}
"""


class Py3status:
    """ """

    # available configuration parameters
    format = "Hello, world!"

    def static_string(self):
        return {
            "cached_until": self.py3.CACHE_FOREVER,
            "full_text": self.py3.safe_format(self.format),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/sway_idle.py
================================================
r"""
Display sway inhibit idle status.

This Module shows an indicator, if an idle is inhibited by an inhibitor.
For more information about inhibit idle see `man 5 sway`

Configuration parameters:
    cache_timeout: How often we refresh this module in seconds (default 1)
    format: Display format (default 'Inhibit Idle: {inhibit_idle}')

Format placeholders:
    {inhibit_idle} Returns 'True' if idle is inhibited, 'False' else.

Example:

```
sway_idle {
    format = "Inhibit Idle: [\?if=inhibit_idle=True True]|False"
}
```

@author Valentin Weber <valentin+py3status@wv2.ch>
@license BSD

SAMPLE OUTPUT
{full_text': 'Inhibit Idle: True'}
"""


class Py3status:
    # available configuration parameters
    cache_timeout = 1
    format = "Inhibit Idle: {inhibit_idle}"

    def sway_idle(self):
        sway_tree = self.py3.command_output(self.py3.get_wm_msg() + " -t get_tree")
        inhibit_idle = '"inhibit_idle": true' in sway_tree
        return {
            "full_text": self.py3.safe_format(
                self.format, param_dict={"inhibit_idle": inhibit_idle}
            ),
            "cached_until": self.py3.time_in(self.cache_timeout),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """

    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/sysdata.py
================================================
r"""
Display system RAM, SWAP and CPU utilization.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds (default 10)
    cpu_freq_unit: the unit of CPU frequency to use in report, case insensitive.
        ['kHz', 'MHz', 'GHz'] (default 'GHz')
    cpu_temp_unit: specify cpu temperature unit ['C', 'F', 'K'] (default 'C')
    cpus: specify a list of CPUs to use (default ['cpu?*'])
    format: output format string
        *(default '[\?color=cpu_used_percent CPU: {cpu_used_percent}%], '
        '[\?color=mem_used_percent Mem: {mem_used}/{mem_total} '
        '{mem_total_unit} ({mem_used_percent}%)]')*
    format_cpu: display format for CPUs
        (default '\?color=used_percent {used_percent}%')
    format_cpu_separator: show separator if more than one (default ' ')
    mem_unit: the unit of memory to use in report, case insensitive.
        ['dynamic', 'KiB', 'MiB', 'GiB'] (default 'GiB')
    swap_unit: the unit of swap to use in report, case insensitive.
        ['dynamic', 'KiB', 'MiB', 'GiB'] (default 'GiB')
    thresholds: specify color thresholds to use
        (default [(0, "good"), (40, "degraded"), (75, "bad")])

Format placeholders:
    {cpu_freq_avg} average CPU frequency across all cores
    {cpu_freq_max} highest CPU clock frequency
    {cpu_freq_unit} unit for frequency
    {cpu_temp} cpu temperature
    {cpu_temp_unit} cpu temperature unit
    {cpu_used_percent} cpu used percentage
    {format_cpu} format for CPUs
    {load1} load average over the last minute
    {load5} load average over the five minutes
    {load15} load average over the fifteen minutes
    {mem_total} total memory
    {mem_total_unit} memory total unit, eg GiB
    {mem_used} used memory
    {mem_used_unit} memory used unit, eg GiB
    {mem_used_percent} used memory percentage
    {mem_free} free memory
    {mem_free_unit} free memory unit, eg GiB
    {mem_free_percent} free memory percentage
    {swap_total} total swap
    {swap_total_unit} swap total memory unit, eg GiB
    {swap_used} used swap
    {swap_used_unit} swap used memory unit, eg GiB
    {swap_used_percent} used swap percentage
    {swap_free} free swap
    {swap_free_unit} free swap unit, eg GiB
    {swap_free_percent} free swap percentage

format_cpu placeholders:
    {name} cpu name, eg cpu, cpu0, cpu1, cpu2, cpu3
    {used_percent} cpu used percentage, eg 88.99

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    lm_sensors: a tool to read cpu temperature

Examples:
```
# specify a list of cpus to use. see "grep cpu /proc/stat"
sysdata {
    cpus = []                # avg + all CPUs
    cpus = ['cpu']           # avg             # same as {cpu_used_percent}
    cpus = ['cpu0', 'cpu2']  # selective CPUs  # full
    cpus = ['cpu?*']         # all CPUs        # fnmatch (default)
}

# display per cpu percents
sysdata {
    format = "{format_cpu}"
    format_cpu = "{name} [\?color=used_percent {used_percent}%]"
}

# customize per cpu padding, precision, etc
sysdata {
    format = "CPU {format_cpu}"
    format_cpu = "[\?min_length=4 [\?color=used_percent {used_percent:.0f}%]]"
}

# display per cpu histogram
sysdata {
    format = "CPU Histogram [\?color=cpu_used_percent {format_cpu}]"
    format_cpu = "[\?if=used_percent>80 ⡇|[\?if=used_percent>60 ⡆"
    format_cpu += "|[\?if=used_percent>40 ⡄|[\?if=used_percent>20 ⡀"
    format_cpu += "|⠀]]]]"
    format_cpu_separator = ""
    thresholds = [(0, "good"), (60, "degraded"), (80, "bad")]
    cache_timeout = 1
}
```

@author Shahin Azad <ishahinism at Gmail>, shrimpza, guiniol, JackDoan <me at jackdoan dot com>, farnoy

SAMPLE OUTPUT
[
    {'color': '#00FF00', 'full_text': 'CPU: 9.60%'},
    {'full_text': ', '},
    {'color': '#FFFF00', 'full_text': 'Mem: 1.91/3.76 GiB (50.96%)'}
]
"""

import re
from fnmatch import fnmatch
from json import loads
from os import getloadavg
from pathlib import Path

INVALID_CPU_TEMP_UNIT = "invalid cpu_temp_unit"
STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    cpu_freq_unit = "GHz"
    cpu_temp_unit = "C"
    cpus = ["cpu?*"]
    format = (
        r"[\?color=cpu_used_percent CPU: {cpu_used_percent}%], "
        r"[\?color=mem_used_percent Mem: {mem_used}/{mem_total} "
        "{mem_total_unit} ({mem_used_percent}%)]"
    )
    format_cpu = r"\?color=used_percent {used_percent}%"
    format_cpu_separator = " "
    mem_unit = "GiB"
    swap_unit = "GiB"
    thresholds = [(0, "good"), (40, "degraded"), (75, "bad")]

    class Meta:
        def update_deprecated_placeholder_format(config):
            padding = config.get("padding", 0)
            precision = config.get("precision", 2)
            format_vals = ":{padding}.{precision}f".format(padding=padding, precision=precision)
            return {
                "cpu_freq_avg": format_vals,
                "cpu_freq_max": format_vals,
                "cpu_usage": format_vals,
                "cpu_used_percent": format_vals,
                "cpu_temp": format_vals,
                "load1": format_vals,
                "load5": format_vals,
                "load15": format_vals,
                "mem_total": format_vals,
                "mem_used": format_vals,
                "mem_used_percent": format_vals,
                "mem_free": format_vals,
                "mem_free_percent": format_vals,
                "swap_total": format_vals,
                "swap_used": format_vals,
                "swap_used_percent": format_vals,
                "swap_free": format_vals,
                "swap_free_percent": format_vals,
            }

        deprecated = {
            "rename": [
                {
                    "param": "temp_unit",
                    "new": "cpu_temp_unit",
                    "msg": "obsolete parameter use `cpu_temp_unit`",
                },
            ],
            "rename_placeholder": [
                {
                    "placeholder": "temp_unit",
                    "new": "cpu_temp_unit",
                    "format_strings": ["format"],
                },
                {
                    "placeholder": "cpu_usage",
                    "new": "cpu_used_percent",
                    "format_strings": ["format"],
                },
                {
                    "placeholder": "mem_unit",
                    "new": "mem_total_unit",
                    "format_strings": ["format"],
                },
                {
                    "placeholder": "swap_unit",
                    "new": "swap_total_unit",
                    "format_strings": ["format"],
                },
            ],
            "remove": [
                {"param": "padding", "msg": "obsolete, use the format_* parameters"},
                {"param": "precision", "msg": "obsolete, use the format_* parameters"},
                {"param": "zone", "msg": "obsolete"},
            ],
            "update_placeholder_format": [
                {
                    "function": update_deprecated_placeholder_format,
                    "format_strings": ["format"],
                }
            ],
        }

        update_config = {
            "update_placeholder_format": [
                {
                    "placeholder_formats": {
                        "cpu_freq_avg": ":.2f",
                        "cpu_freq_max": ":.2f",
                        "cpu_usage": ":.2f",
                        "cpu_used_percent": ":.2f",
                        "cpu_temp": ":.2f",
                        "load1": ":.2f",
                        "load5": ":.2f",
                        "load15": ":.2f",
                        "mem_total": ":.2f",
                        "mem_used": ":.2f",
                        "mem_used_percent": ":.2f",
                        "mem_free": ":.2f",
                        "mem_free_percent": ":.2f",
                        "swap_total": ":.2f",
                        "swap_used": ":.2f",
                        "swap_used_percent": ":.2f",
                        "swap_free": ":.2f",
                        "swap_free_percent": ":.2f",
                    },
                    "format_strings": ["format"],
                },
                {
                    "placeholder_formats": {"used_percent": ":.2f"},
                    "format_strings": ["format_cpu"],
                },
            ]
        }

    def post_config_hook(self):
        self.first_run = True
        self.init = {"meminfo": [], "stat": []}
        names_and_matches = [
            ("cpu_freq", ["cpu_freq_avg", "cpu_freq_max"]),
            ("cpu_temp", "cpu_temp"),
            ("cpu_percent", "cpu_used_percent"),
            ("cpu_per_core", "format_cpu"),
            ("load", "load*"),
            ("mem", "mem_*"),
            ("swap", "swap_*"),
        ]
        for name, match in names_and_matches:
            self.init[name] = list(
                set(
                    self.py3.get_placeholders_list(self.format, match)
                    + self.py3.get_color_names_list(self.format, match)
                )
            )
            if self.init[name]:
                if name in ["mem", "swap"]:
                    self.init["meminfo"].append(name)
                elif name in ["cpu_percent", "cpu_per_core"]:
                    self.init["stat"].append(name)

        self.thresholds_init = {
            "format": self.py3.get_color_names_list(self.format),
            "format_cpu": self.py3.get_color_names_list(self.format_cpu),
            "legacy": {
                "cpu": "cpu_used_percent",
                "temp": "cpu_temp",
                "mem": "mem_used_percent",
                "swap": "swap_used_percent",
                "load": "load1",
                "max_cpu_mem": "max_used_percent",
            },
        }

        if self.init["cpu_freq"]:
            name = sorted(self.init["cpu_freq"])[0]
            self.thresholds_init["legacy"]["cpu_freq"] = name

        if self.init["stat"]:
            self.cpus = {"cpus": self.cpus, "last": {}, "list": []}

        if self.init["cpu_temp"]:
            command, args = ("sensors", "-jA")
            if not self.py3.check_commands(command):
                raise Exception(STRING_NOT_INSTALLED)
            if self.cpu_temp_unit not in list("CFK"):
                raise Exception(INVALID_CPU_TEMP_UNIT)
            elif self.cpu_temp_unit == "F":
                args += "f"  # print fahrenheit

            chips_and_sensors = [
                ("coretemp-isa-0000", ["Core"]),  # Intel
                ("k10temp-pci-00c3", ["Tdie", "Tctl"]),  # AMD
                ("cpu_thermal-virtual-0", ["temp"]),  # RPi
            ]

            chips = loads(self.py3.command_output([command, args]))
            for chip, sensors in chips_and_sensors:
                if chip in chips:
                    for sensor in sensors:
                        for temp_sensor in chips[chip]:
                            if sensor in temp_sensor:
                                self.lm_sensors = {
                                    "command": [command, args, chip],
                                    "chip": chip,
                                    "sensor": sensor,
                                }
                                break
                    break
            else:
                self.init["cpu_temp"] = []

    def _get_cpuinfo(self):
        with Path("/proc/cpuinfo").open() as f:
            return [float(line.split()[-1]) for line in f if "cpu MHz" in line]

    def _calc_cpu_freqs(self, cpu_freqs, unit, keys):
        freq_avg, freq_max = None, None
        for key in keys:
            if key == "cpu_freq_avg":
                value = sum(cpu_freqs) / len(cpu_freqs) * 10**6
                freq_avg, _ = self.py3.format_units(value, unit, si=True)
            elif key == "cpu_freq_max":
                value = max(cpu_freqs) * 10**6
                freq_max, _ = self.py3.format_units(value, unit, si=True)
        return freq_avg, freq_max

    def _get_stat(self):
        # kernel/system statistics. man -P 'less +//proc/stat' procfs
        stat = []
        with Path("/proc/stat").open() as f:
            for line in f:
                if "cpu" in line:
                    stat.append(line)
                else:
                    return stat

    def _filter_stat(self, stat, avg=False):
        # if avg, return (name, idle, total)
        if avg:
            fields = stat[0].split()
            return "avg", int(fields[4]), sum(int(x) for x in fields[1:])

        # return a list of (name, idle, total)
        new_stat = []
        for line in stat:
            fields = line.split()
            cpu_name = fields[0]
            if self.cpus["cpus"]:
                if self.first_run:
                    for _filter in self.cpus["cpus"]:
                        if fnmatch(cpu_name, _filter):
                            self.cpus["list"].append(cpu_name)
                if cpu_name not in self.cpus["list"]:
                    continue

            new_stat.append((cpu_name, int(fields[4]), sum(int(x) for x in fields[1:])))
        return new_stat

    def _calc_mem_info(self, unit, meminfo, memory):
        """
        Parse /proc/meminfo, grab the memory capacity and used size
        then return; Memory size 'total_mem', Used_mem, percentage
        of used memory, and units of mem (KiB, MiB, GiB).
        """
        if memory:
            zfs_cache = self._get_zfs_arc_size()
            total_mem_kib = meminfo["MemTotal:"]
            used_mem_kib = (
                total_mem_kib
                - meminfo["MemFree:"]
                - (
                    meminfo["Buffers:"]
                    + zfs_cache
                    + meminfo["Cached:"]
                    + (meminfo["SReclaimable:"] - meminfo["Shmem:"])
                )
            )
            free_mem_kib = total_mem_kib - used_mem_kib
        else:
            total_mem_kib = meminfo["SwapTotal:"]
            free_mem_kib = meminfo["SwapFree:"]
            used_mem_kib = total_mem_kib - free_mem_kib

        if total_mem_kib == 0:
            used_percent = 0
            free_percent = 100
        else:
            used_percent = 100 * used_mem_kib / total_mem_kib
            free_percent = 100 - used_percent

        unit = "B" if unit == "dynamic" else unit
        (total, total_unit) = self.py3.format_units(total_mem_kib * 1024, unit)
        (used, used_unit) = self.py3.format_units(used_mem_kib * 1024, unit)
        (free, free_unit) = self.py3.format_units(free_mem_kib * 1024, unit)
        return (
            total,
            total_unit,
            used,
            used_unit,
            used_percent,
            free,
            free_unit,
            free_percent,
        )

    def _get_meminfo(self, head=28):
        with Path("/proc/meminfo").open() as f:
            info = [next(f).split() for _ in range(head)]
            return {fields[0]: float(fields[1]) for fields in info}

    def _get_zfs_arc_size(self):
        """will raise OSError on failures"""
        ZFS_SIZE_REGEX = re.compile(r"^size\s+\d+\s+(\d+)")
        try:
            with Path("/proc/spl/kstat/zfs/arcstats").open() as f:
                for line in f.readlines():
                    m = ZFS_SIZE_REGEX.match(line)
                    if m:
                        return int(m.group(1)) / 1024
        except (OSError, ValueError):
            # skip errors if file is missing or inaccessible, or
            # doesn't have the expected syntax
            pass
        return 0

    def _calc_cpu_percent(self, cpu):
        name, idle, total = cpu
        last_idle = self.cpus["last"].get(name, {}).get("idle", 0)
        last_total = self.cpus["last"].get(name, {}).get("total", 0)
        used_percent = 0

        if total != last_total:
            used_percent = (1 - (idle - last_idle) / (total - last_total)) * 100

        self.cpus["last"].setdefault(name, {}).update(zip(["name", "idle", "total"], cpu))
        return used_percent

    def _get_cputemp(self, cpu_temp_unit):
        chips = loads(self.py3.command_output(self.lm_sensors["command"]))
        sensor_total, sensor_count = (0, 0)

        for name, sensor in chips[self.lm_sensors["chip"]].items():
            if self.lm_sensors["sensor"] in name:
                sensor_count += 1
                for key, value in sensor.items():
                    if "input" in key:
                        sensor_total += value
                        break

        cpu_temp = sensor_total / sensor_count

        if cpu_temp_unit == "K":
            cpu_temp += 273.15

        return cpu_temp, cpu_temp_unit

    def sysdata(self):
        sys = {"max_used_percent": 0}

        if self.init["cpu_freq"]:
            cpu_freqs = self._calc_cpu_freqs(
                self._get_cpuinfo(), self.cpu_freq_unit, self.init["cpu_freq"]
            )
            cpu_freq_keys = ["cpu_freq_avg", "cpu_freq_max"]
            sys.update(zip(cpu_freq_keys, cpu_freqs))

        if self.init["stat"]:
            stat = self._get_stat()

            if self.init["cpu_percent"]:
                cpu = self._filter_stat(stat, avg=True)
                sys["cpu_used_percent"] = self._calc_cpu_percent(cpu)

            if self.init["cpu_per_core"]:
                cpu_keys = ["name", "used_percent"]
                new_cpu = []
                for cpu in self._filter_stat(stat):
                    cpu = dict(zip(cpu_keys, [cpu[0], self._calc_cpu_percent(cpu)]))
                    for x in self.thresholds_init["format_cpu"]:
                        if x in cpu:
                            self.py3.threshold_get_color(cpu[x], x)
                    new_cpu.append(self.py3.safe_format(self.format_cpu, cpu))

                format_cpu_separator = self.py3.safe_format(self.format_cpu_separator)
                format_cpu = self.py3.composite_join(format_cpu_separator, new_cpu)
                sys["format_cpu"] = format_cpu

        if self.init["cpu_temp"]:
            cputemp = self._get_cputemp(self.cpu_temp_unit)
            cputemp_keys = ["cpu_temp", "cpu_temp_unit"]
            sys.update(zip(cputemp_keys, cputemp))

        if self.init["load"]:
            load_keys = ["load1", "load5", "load15"]
            sys.update(zip(load_keys, getloadavg()))

        if self.init["meminfo"]:
            meminfo = self._get_meminfo()

            if self.init["mem"]:
                mem = self._calc_mem_info(self.mem_unit, meminfo, True)
                mem_keys = [
                    "mem_total",
                    "mem_total_unit",
                    "mem_used",
                    "mem_used_unit",
                    "mem_used_percent",
                    "mem_free",
                    "mem_free_unit",
                    "mem_free_percent",
                ]
                sys.update(zip(mem_keys, mem))

            if self.init["swap"]:
                swap = self._calc_mem_info(self.swap_unit, meminfo, False)
                swap_keys = [
                    "swap_total",
                    "swap_total_unit",
                    "swap_used",
                    "swap_used_unit",
                    "swap_used_percent",
                    "swap_free",
                    "swap_free_unit",
                    "swap_free_percent",
                ]
                sys.update(zip(swap_keys, swap))

        sys["max_used_percent"] = max(
            [perc for name, perc in sys.items() if "used_percent" in name]
        )

        for x in self.thresholds_init["format"]:
            if x in sys:
                self.py3.threshold_get_color(sys[x], x)
            elif x in self.thresholds_init["legacy"]:
                y = self.thresholds_init["legacy"][x]
                if y in sys:
                    self.py3.threshold_get_color(sys[y], x)

        self.first_run = False

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, sys),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/systemd.py
================================================
r"""
Display status of a service on your system.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 5)
    format: display format for this module (default '\?if=!hide {unit}: {status}')
    hide_extension: suppress extension of the systemd unit (default False)
    hide_if_default: suppress the output if the systemd unit is in default state
        'off' the output is never suppressed
        'on' the output is suppressed if the unit is (enabled and active)
                                                  or (disabled and inactive)
        'active' the output is suppressed if the unit is active
        'inactive' the output is suppressed if the unit is inactive
        (default 'off')
    unit: specify the systemd unit to use (default 'dbus.service')
    user: specify if this is a user service (default False)

Format placeholders:
    {unit} unit name, eg sshd.service
    {status} unit status, eg active, inactive, not-found

Color options:
    color_good: unit active
    color_bad: unit inactive
    color_degraded: unit not-found

Requires:
    dbus-python: to interact with dbus
    pygobject: which in turn requires libcairo2-dev, libgirepository1.0-dev

Examples:
```
# show the status of vpn service
# left click to start, right click to stop
systemd vpn {
    unit = 'vpn.service'
    on_click 1 = 'exec sudo systemctl start vpn'
    on_click 3 = 'exec sudo systemctl stop vpn'
}
```

@author Adrian Lopez <adrianlzt@gmail.com>
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'sshd.service: active'}

inactive
{'color': '#FF0000', 'full_text': 'sshd.service: inactive'}

not-found
{'color': '#FFFF00', 'full_text': 'sshd.service: not-found'}
"""

import dbus


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 5
    format = r"\?if=!hide {unit}: {status}"
    hide_extension = False
    hide_if_default = "off"
    unit = "dbus.service"
    user = False

    def post_config_hook(self):
        if self.user:
            bus = dbus.SessionBus()
        else:
            bus = dbus.SystemBus()
        systemd = bus.get_object("org.freedesktop.systemd1", "/org/freedesktop/systemd1")
        systemd_unit = systemd.LoadUnit(
            self.unit, dbus_interface="org.freedesktop.systemd1.Manager"
        )
        unit_proxy = bus.get_object("org.freedesktop.systemd1", systemd_unit)
        self.systemd_interface = dbus.Interface(unit_proxy, "org.freedesktop.DBus.Properties")

    def systemd(self):
        status = self.systemd_interface.Get("org.freedesktop.systemd1.Unit", "ActiveState")
        exists = self.systemd_interface.Get("org.freedesktop.systemd1.Unit", "LoadState")
        state = self.systemd_interface.Get("org.freedesktop.systemd1.Unit", "UnitFileState")

        if exists == "not-found":
            color = self.py3.COLOR_DEGRADED
            status = exists
        elif status == "active":
            color = self.py3.COLOR_GOOD
        elif status == "inactive":
            color = self.py3.COLOR_BAD
        else:
            color = self.py3.COLOR_DEGRADED

        if self.hide_if_default == "on":
            hide = (status == "active" and state == "enabled") or (
                status == "inactive" and state == "disabled"
            )
        else:
            hide = status == self.hide_if_default

        if self.hide_extension and self.unit.endswith(".service"):
            unitPrintName = self.unit[:-8]
        else:
            unitPrintName = self.unit

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": color,
            "full_text": self.py3.safe_format(
                self.format, {"hide": hide, "unit": unitPrintName, "status": status}
            ),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/systemd_suspend_inhibitor.py
================================================
r"""
Turn on and off systemd suspend inhibitor.

Configuration parameters:
    format: display format for this module
        (default '[\?color=state SUSPEND [\?if=state OFF|ON]]')
    lock_types: specify state to inhibit, comma separated list
        https://www.freedesktop.org/wiki/Software/systemd/inhibit/
        (default ['handle-lid-switch', 'idle', 'sleep'])
    thresholds: specify color thresholds to use
        (default [(True, 'bad'), (False, 'good')])

Format placeholders:
    {state} systemd suspend inhibitor state, eg True, False

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

@author Cyrinux https://github.com/cyrinux
@license BSD

SAMPLE OUTPUT
[{'full_text': 'SUSPEND ON', 'color': '#00FF00'}]

off
[{'full_text': 'SUSPEND OFF', 'color': '#FF0000'}]
"""

from os import close

from dbus import SystemBus

STRING_DBUS_EXCEPTION = "DBUS error, systemd-logind not started?"
STRING_BAD_LOCK_TYPES = "DBUS error, bad lock types used"


class Py3status:
    """ """

    # available configuration parameters
    format = r"[\?color=state SUSPEND [\?if=state OFF|ON]]"
    lock_types = ["handle-lid-switch", "idle", "sleep"]
    thresholds = [(True, "bad"), (False, "good")]

    def post_config_hook(self):
        try:
            self.login1 = SystemBus().get_object(
                "org.freedesktop.login1", "/org/freedesktop/login1"
            )
        except Exception:
            raise Exception(STRING_DBUS_EXCEPTION)
        self.lock = None
        self.lock_types = ":".join(self.lock_types)
        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def systemd_suspend_inhibitor(self):
        suspend_data = {"state": bool(self.lock)}

        for x in self.thresholds_init:
            if x in suspend_data:
                self.py3.threshold_get_color(suspend_data[x], x)

        return {
            "cached_until": self.py3.CACHE_FOREVER,
            "full_text": self.py3.safe_format(self.format, suspend_data),
        }

    def on_click(self, event):
        if self.lock is None:
            self.lock = self.login1.Inhibit(
                self.lock_types,
                "Py3Status",
                "Systemd suspend inhibitor module",
                "block",
                dbus_interface="org.freedesktop.login1.Manager",
            ).take()
        else:
            close(self.lock)
            self.lock = None


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/taskwarrior.py
================================================
"""
Display tasks currently running in taskwarrior.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 5)
    filter: specify one or more criteria to use (default 'status:pending')
    format: display format for this module (default '{descriptions}')
    report: report to export, for TaskWarrior 2.6.0 and above (default '')

Format placeholders:
    {descriptions} descriptions of active tasks
    {tasks} number of active tasks

Requires
    task: https://taskwarrior.org/download/

@author James Smith https://jazmit.github.io
@license BSD

SAMPLE OUTPUT
{'full_text': '1 Prepare first draft, 2 Buy milk'}
"""

import json

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 5
    filter = "status:pending"
    format = "{descriptions}"
    report = ""

    class Meta:
        deprecated = {
            "rename_placeholder": [
                {
                    "placeholder": "task",
                    "new": "descriptions",
                    "format_strings": ["format"],
                }
            ]
        }

    def post_config_hook(self):
        if not self.py3.check_commands("task"):
            raise Exception(STRING_NOT_INSTALLED)
        self.placeholders = self.py3.get_placeholders_list(self.format)
        if self.filter:
            self.taskwarrior_command = f"task {self.filter} export"
        else:
            self.taskwarrior_command = "task export"
        if self.report:
            self.taskwarrior_command += " " + self.report

    @staticmethod
    def descriptions(tasks_json):
        return ", ".join(f"{t['id']} {t['description']}" for t in tasks_json)

    @staticmethod
    def tasks(tasks_json):
        return len(tasks_json)

    def taskwarrior(self):
        tasks_json = json.loads(self.py3.command_output(self.taskwarrior_command))
        taskwarrior_data = {}
        for ph in self.placeholders:
            if hasattr(self, ph):
                ph_func = getattr(self, ph)
                taskwarrior_data[ph] = ph_func(tasks_json)
        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, taskwarrior_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/thunderbird_todos.py
================================================
"""
Display number of todos and more for Thunderbird.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 60)
    format: display format for this module (default '{format_todo}')
    format_datetime: specify strftime formatting to use (default {})
    format_separator: show separator if more than one (default ' ')
    format_todo: display format for todos
        (default '\\?if=!todo_completed {title}')
    profile: specify a profile path, otherwise first available profile
        eg '~/.thunderbird/abcd1234.default' (default None)
    sort: specify a tuple, eg ('placeholder_name', reverse_boolean)
        to sort by; excluding placeholder indexes (default ())
    thresholds: specify color thresholds to use (default [])

Format placeholders:
    {todo_total}        eg 5
    {todo_completed}    eg 2
    {todo_incompleted}  eg 3
    {format_todo}       format for todos

format_todo placeholders:
    {index_total}       eg 1, 2, 3
    {index_completed}   eg 1, 2, 3
    {index_incompleted} eg 1, 2, 3
    {alarm_last_ack}    eg None, 1513291952000000
    {cal_id}            eg 966bd855-5e71-4168-8072-c98f244ed825
    {flags}             eg 4, 276
    {ical_status}       eg None, IN-PROCESS, COMPLETED
    {id}                eg 87e9bfc9-eaad-4aa6-ad5f-adbf6d7a11a5
    {last_modified}     eg 1513276147000000
    {offline_journal}   eg None
    {priority}          eg None, # None=None, 0=None, 1=High, 5=Normal, 9=Low
    {privacy}           eg None, CONFIDENTIAL
    {recurrence_id}     eg None
    {recurrence_id_tz}  eg None, UTC
    {time_created}      eg 1513276147000000
    {title}             eg New Task
    {todo_complete}     eg None
    {todo_completed}    eg None, 1513281528000000
    {todo_completed_tz} eg None, UTC
    {todo_due}          eg None, 1513292400000000
    {todo_due_tz}       eg None, America/Chicago
    {todo_entry}        eg None, 1513292400000000
    {todo_entry_tz}     eg None, America/Chicago
    {todo_stamp}        eg 1513276147000000

format_datetime placeholders:
    KEY: alarm_last_ack, last_modified, time_created, todo,
        todo_completed, todo_entry, todo_stamp
    VALUE: % strftime characters to be translated, eg '%b %d' ----> 'Dec 14'
    SEE EXAMPLE BELOW: "show incompleted titles with last modified time"

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    thunderbird: standalone mail and news reader

Examples:
```
# show number of incompleted titles
thunderbird_todos {
    format = '{todo_incompleted} incompleted todos'
}

# show rainbow number of incompleted titles
thunderbird_todos {
    format = '\\?color=todo_incompleted {todo_incompleted} todos'
    thresholds = [
        (1, '#bababa'), (2, '#ffb3ba'), (3, '#ffdfba'), (4, '#ffffba'),
        (5, '#baefba'), (6, '#baffc9'), (7, '#bae1ff'), (8, '#bab3ff')
    ]
}

# show rainbow incompleted titles
thunderbird_todos {
    format_todo = '\\?if=!todo_completed&color=index_incompleted {title}'
    thresholds = [
        (1, '#bababa'), (2, '#ffb3ba'), (3, '#ffdfba'), (4, '#ffffba'),
        (5, '#baefba'), (6, '#baffc9'), (7, '#bae1ff'), (8, '#bab3ff')
    ]
}

# show incompleted titles with last modified time
thunderbird_todos {
    format_todo = '\\?if=!todo_completed {title} {last_modified}'
    format_datetime = {
        'last_modified': '\\?color=degraded last modified %-I:%M%P'
    }
}

# show 'No todos'
thunderbird_todos {
    format = '{format_todo}|No todos'
}

# show completed titles and incompleted titles
thunderbird_todos {
    format_todo = '\\?if=todo_completed&color=good {title}|\\?color=bad {title}'
}

# make todo blocks
thunderbird_todos {
    format = 'TODO {format_todo}'
    format_todo = '\\?if=todo_completed&color=good \u25b0|\\?color=bad \u25b0'
    format_separator = ''
}

# display incompleted titles with any priority
thunderbird_todos {
    format_todo = '\\?if=!todo_completed [\\?if=priority>0 {title}]'
}

# colorize titles based on priorities
thunderbird_todos {
    format_todo = '\\?if=!todo_completed [\\?color=priority {title}]'
    thresholds = [(0, None), (1, 'red'), (5, None), (9, 'deepskyblue')]
}

# sort todos
thunderbird_todos {
    sort = ('last_modified', True) # sort by modified time: recent first
    sort = ('priority', True)      # sort by priority: high to low
    sort = ('title', False)        # sort by title: ABC to abc
}

# add your snippets here
thunderbird_todos {
    format = '...'
}
```

@author mrt-prodz, lasers

SAMPLE OUTPUT
{'full_text': 'New Task 1, New Task 2'}
"""

from datetime import datetime
from pathlib import Path
from sqlite3 import connect

STRING_NO_PROFILE = "missing profile"
STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 60
    format = "{format_todo}"
    format_datetime = {}
    format_separator = " "
    format_todo = r"\?if=!todo_completed {title}"
    profile = None
    sort = ()
    thresholds = []

    def post_config_hook(self):
        if not self.py3.check_commands("thunderbird"):
            raise Exception(STRING_NOT_INSTALLED)

        # first profile, please.
        if not self.profile:
            directory = Path("~/.thunderbird").expanduser()
            profile_ini = directory / "profiles.ini"
            profile = []
            with profile_ini.open() as f:
                for line in f:
                    if line.startswith("Path="):
                        profile.append("{}/{}".format(directory, line.split("Path=")[-1].strip()))
            if not len(profile):
                raise Exception(STRING_NO_PROFILE)
            self.profile = profile[0]

        self.profile = Path(self.profile).expanduser()
        self.path = self.profile / "calendar-data/local.sqlite"

        self.init_datetimes = []
        for word in self.format_datetime:
            if (self.py3.format_contains(self.format_todo, word)) and (
                word in self.format_datetime
            ):
                self.init_datetimes.append(word)

        self.thresholds_init = {}
        for name in ["format", "format_todo"]:
            self.thresholds_init[name] = self.py3.get_color_names_list(getattr(self, name))

    def _get_thunderbird_todos_data(self):
        connection = connect(self.path)
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM cal_todos")
        keys = [desc[0] for desc in cursor.description]
        todos_data = cursor.fetchall()
        cursor.close()
        connection.close()
        return [dict(zip(keys, values)) for values in todos_data]

    def _organize(self, data):
        # sort?
        if self.sort:
            data = sorted(data, key=lambda k: k[self.sort[0]], reverse=self.sort[1])
        # counts and indexes
        count = {"todo_total": 0, "todo_completed": 0, "todo_incompleted": 0}
        for todo_index, todo in enumerate(data, 1):
            count["todo_total"] += 1
            todo["index_total"] = todo_index
            todo["index_completed"] = todo["index_incompleted"] = None
            if todo["todo_completed"]:
                count["todo_completed"] += 1
                todo["index_completed"] = count["todo_completed"]
            else:
                count["todo_incompleted"] += 1
                todo["index_incompleted"] = count["todo_incompleted"]

        return data, count

    def _manipulate(self, data, count):
        new_data = []
        for todo in data:
            # datetimes
            for k in self.init_datetimes:
                if k in todo:
                    todo[k] = self.py3.safe_format(
                        datetime.strftime(
                            datetime.fromtimestamp(float(str(todo[k])[:-6])),
                            self.format_datetime[k],
                        )
                    )
            # thresholds
            for x in self.thresholds_init["format_todo"]:
                if x in todo:
                    self.py3.threshold_get_color(todo[x], x)

            new_data.append(self.py3.safe_format(self.format_todo, todo))

        for x in self.thresholds_init["format"]:
            if x in count:
                self.py3.threshold_get_color(count[x], x)

        format_separator = self.py3.safe_format(self.format_separator)
        format_todo = self.py3.composite_join(format_separator, new_data)

        return format_todo

    def thunderbird_todos(self):
        todo_data = self._get_thunderbird_todos_data()
        data, count = self._organize(todo_data)
        format_todo = self._manipulate(data, count)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, dict(format_todo=format_todo, **count)),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/timer.py
================================================
"""
A simple countdown timer.

This is a very basic countdown timer.  You can change the timer length as well
as pausing, restarting and resetting it.  Currently this is more of a demo of a
composite.

Each part of the timer can be changed independently hours, minutes, seconds using
mouse buttons 4 and 5 (scroll wheel).
Button 1 starts/pauses the countdown.
Button 2 resets timer.

Configuration parameters:
    format: display format for this module (default 'Timer {timer}')
    sound: play sound file path when the timer ends (default None)
    time: number of seconds to start countdown with (default 60)

Format placeholders:
    {timer} display hours:minutes:seconds

@author tobes

SAMPLE OUTPUT
{'full_text': 'Timer 0:01:00'}

running
[
    {'full_text': 'Timer '},
    {'color': '#00FF00', 'full_text': '0'},
    {'full_text': ':'},
    {'color': '#00FF00', 'full_text': '00'},
    {'full_text': ':'},
    {'color': '#00FF00', 'full_text': '54'},
]

paused
[
    {'full_text': 'Timer '},
    {'color': '#FFFF00', 'full_text': '0'},
    {'full_text': ':'},
    {'color': '#FFFF00', 'full_text': '00'},
    {'full_text': ':'},
    {'color': '#FFFF00', 'full_text': '54'},
]
"""

import time
from threading import Timer


class Py3status:
    """ """

    # available configuration parameters
    format = "Timer {timer}"
    sound = None
    time = 60

    def post_config_hook(self):
        self.running = False
        self.end_time = None
        self.time_left = None
        self.color = None
        self.alarm_timer = None
        self.alarm = False
        self.done = False

    def _time_up(self):
        """
        Called when the timer expires
        """
        self.running = False
        self.color = self.py3.COLOR_BAD
        self.time_left = 0
        self.done = True
        if self.sound:
            self.py3.play_sound(self.sound)
            self.alarm = True
        self.timer()

    def timer(self):
        if self.running or self.done:
            t = int(self.end_time - time.monotonic())
            if t <= 0:
                t = 0
        else:
            if self.time_left:
                t = self.time_left
            else:
                t = self.time

        hours, t = divmod(t, 3600)
        minutes, t = divmod(t, 60)
        seconds = t

        if self.running:
            cached_until = self.py3.time_in(0, offset=self.cache_offset)
        else:
            cached_until = self.py3.CACHE_FOREVER

        composites = [
            {"full_text": str(hours), "color": self.color, "index": "hours"},
            {"full_text": ":"},
            {
                "full_text": format(minutes, "02d"),
                "color": self.color,
                "index": "minutes",
            },
            {"full_text": ":"},
            {
                "full_text": format(seconds, "02d"),
                "color": self.color,
                "index": "seconds",
            },
        ]

        timer = self.py3.composite_create(composites)

        response = {
            "cached_until": cached_until,
            "full_text": self.py3.safe_format(self.format, {"timer": timer}),
        }
        if self.done:
            response["urgent"] = True
        return response

    def on_click(self, event):
        deltas = {"hours": 3600, "minutes": 60, "seconds": 1}
        index = event["index"]
        button = event["button"]

        # If played an alarm sound, then cancel the sound and urgent on any
        # button press... otherwise, we only cancel an urgent
        if self.done:
            self.done = False
            if self.alarm:
                self.py3.stop_sound()
                self.alarm = False
            return

        if button == 1:
            if self.running:
                # pause timer
                self.running = False
                self.time_left = int(self.end_time - time.monotonic())
                self.color = self.py3.COLOR_DEGRADED
                if self.alarm_timer:
                    self.alarm_timer.cancel()
            else:
                # start/restart timer
                self.running = True
                if self.time_left:
                    self.end_time = time.monotonic() + self.time_left
                else:
                    self.end_time = time.monotonic() + self.time
                self.cache_offset = self.end_time % 1
                self.color = self.py3.COLOR_GOOD
                if self.alarm_timer:
                    self.alarm_timer.cancel()
                self.done = False
                self.alarm_timer = Timer(self.time_left or self.time, self._time_up)
                self.alarm_timer.start()

        if button == 2:
            self.running = False
            self.time_left = None
            self.color = None
            self.done = False
            if self.alarm_timer:
                self.alarm_timer.cancel()

        if not self.running:
            self.done = False
            # change timer section HH:MM:SS
            if self.time_left:
                t = self.time_left
            else:
                t = self.time
            if button == 4:
                t += deltas.get(index, 0)
            if button == 5:
                t -= deltas.get(index, 0)
                if t < 0:
                    t = 0
            if self.time_left:
                self.time_left = t
            else:
                self.time = t

    def kill(self):
        # remove any timer
        if self.alarm_timer:
            self.alarm_timer.cancel()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/timewarrior.py
================================================
r"""
Track your time with Timewarrior.

Timewarrior is a time tracking utility that offers simple stopwatch features
as well as sophisticated calendar-base backfill, along with flexible reporting.
See https://taskwarrior.org/docs/timewarrior for more information.

Configuration parameters:
    cache_timeout: refresh interval for this module, otherwise auto
        (default None)
    filter: specify interval and/or tag to filter (default '1day')
    format: display format for this module
        (default '[Timew {format_time}]|No Timew')
    format_datetime: specify strftime characters to format (default {})
    format_duration: display format for time duration
        (default '\?not_zero [{days}d ][{hours}:]{minutes}:{seconds}')
    format_tag: display format for tags (default '\?color=state_tag {name}')
    format_tag_separator: show separator if more than one (default ' ')
    format_time: display format for tracked times
        (default '[\?color=state_time [{format_tag} ]{format_duration}]')
    format_time_separator: show separator if more than one (default ' ')
    thresholds: specify color thresholds to use
        *(default {'state_tag': [(0, 'darkgray'), (1, 'darkgray')],
        'state_time': [(0, 'darkgray'), (1, 'degraded')]})*

Format placeholders:
    {format_time} format for tracked times
    {tracking} time tracking state, eg False, True

format_time placeholders:
    {state} time tracking state, eg False, True
    {format_tag} format for tags
    {format_duration} format for time duration
    {start} start date, eg 20171021T010203Z
    {end} end date, eg 20171021T010203Z

format_tag placeholders:
    {name} tag name, eg gaming, studying, gardening

format_datetime placeholders:
    key: start, end
    value: strftime characters, eg '%b %d' ----> 'Oct 06'

format_duration placeholders:
    {days} days
    {hours} hours
    {minutes} minutes
    {seconds} seconds

Color thresholds:
    format_time:
        state_time: print color based on the state of time tracking
    format_tag:
        state_tag:  print color based on the state of time tracking

Requires:
    timew: feature-rich time tracking utility

Recommendations:
    We can refresh a module using `py3-cmd` command.
    An excellent example of using this command in a function.

    ```
    ~/.{bash,zsh}{rc,_profile}
    ---------------------------
    function timew () {
        command timew "$@" && py3-cmd refresh timewarrior
    }
    ```

    With this, you can consider giving `cache_timeout` a much larger number,
    eg 3600 (an hour), so the module does not need to be updated that often.

Examples:
```
# show times matching the filter, see documentation for more filters
timewarrior {
    filter = ':day'           # filter times not in 24 hours of current day
    filter = '12hours'        # filter times not in 12 hours of current time
    filter = '5min'           # filter times not in 5 minutes of current time
    filter = '1sec'           # filter times not in 1 second of current time
    filter = '5pm to 11:59pm  # filter times not in 5pm to 11:59pm range
}

# intervals
timewarrior {
    # if you are printing other intervals too with '1day' filter or so,
    # then you may want to add this too for better bar readability
    format_time_separator = ', '

    # you also can change the thresholds with different colors
    thresholds = {
        'state_tag': [(0, 'darkgray'), (1, 'degraded')],
        'state_time': [(0, 'darkgray'), (1, 'degraded')],
    }
}

# cache_timeout
timewarrior {
    # auto refresh every 10 seconds when there is no active time tracking
    # auto refresh every second when there is active time tracking
    cache_timeout = None

    # refresh every minute when there is no active time tracking
    # refresh every second when there is active time tracking
    cache_timeout = 60

    # explicit refresh every 20 seconds when there is no active time tracking
    # explicit refresh every 5 seconds when there is active time tracking
    cache_timeout = (20, 5)
}

# add your snippets here
timewarrior {
    format = "..."
}
```

@author lasers

SAMPLE OUTPUT
[
    {'full_text': 'Timew '},
    {'full_text': 'gaming ', 'color': '#a9a9a9'},
    {'full_text': '15:02 ', 'color': '#a9a9a9'},
    {'full_text': 'studying ', 'color': '#a9a9a9'},
    {'full_text': '03:42', 'color': '#ffff00'}
]

no_tag
[
    {'full_text': 'Timew '},
    {'full_text': 'gardening ', 'color': '#a9a9a9'},
    {'full_text': '20:37', 'color': '#ffff00'}
]

no_timew
{'full_text': 'No Timew'}
"""

import datetime as dt
from json import loads as json_loads

STRING_NOT_INSTALLED = "not installed"
DATETIME = "%Y%m%dT%H%M%SZ"
STRING_INVALID_TIMEOUT = "invalid cache_timeout"


class Py3status:
    """"""

    # available configuration parameters
    cache_timeout = None
    filter = "1day"
    format = "[Timew {format_time}]|No Timew"
    format_datetime = {}
    format_duration = r"\?not_zero [{days}d ][{hours}:]{minutes}:{seconds}"
    format_tag = r"\?color=state_tag {name}"
    format_tag_separator = " "
    format_time = r"[\?color=state_time [{format_tag} ]{format_duration}]"
    format_time_separator = " "
    thresholds = {
        "state_tag": [(0, "darkgray"), (1, "darkgray")],
        "state_time": [(0, "darkgray"), (1, "degraded")],
    }

    class Meta:
        update_config = {
            "update_placeholder_format": [
                {
                    "placeholder_formats": {"minutes": ":02d", "seconds": ":02d"},
                    "format_strings": ["format_duration"],
                }
            ]
        }

    def post_config_hook(self):
        if not self.py3.check_commands("timew"):
            raise Exception(STRING_NOT_INSTALLED)

        if self.cache_timeout is None:
            self.sleep_timeout = 10
            self.cache_timeout = 0
        elif isinstance(self.cache_timeout, tuple):
            if len(self.cache_timeout) != 2:
                raise Exception(STRING_INVALID_TIMEOUT)
            self.sleep_timeout = self.cache_timeout[0]
            self.cache_timeout = self.cache_timeout[1]
        elif isinstance(self.cache_timeout, int):
            self.sleep_timeout = self.cache_timeout
            self.cache_timeout = 0

        self.timewarrior_command = "timew export"
        if self.filter:
            self.timewarrior_command += f" {self.filter}"

        self.init = {"datetimes": []}
        for word in ["start", "end"]:
            if (self.py3.format_contains(self.format_time, word)) and (
                word in self.format_datetime
            ):
                self.init["datetimes"].append(word)

        self.tracking = None
        self.thresholds_init = {}
        for name in ("format", "format_tag", "format_time"):
            self.thresholds_init[name] = self.py3.get_color_names_list(getattr(self, name))

    def _get_timewarrior_data(self):
        return json_loads(self.py3.command_output(self.timewarrior_command))

    def _manipulate(self, data):
        new_time = []
        self.tracking = False

        for i, time in enumerate(data):
            time["index"] = len(data) - i
            time["state_time"] = "end" not in time

            # tags
            new_tag = []
            time["tags"] = time.get("tags", [])
            for tag_name in time["tags"]:
                tag_data = {"name": tag_name, "state_tag": time["state_time"]}
                for x in self.thresholds_init["format_tag"]:
                    if x in tag_data:
                        self.py3.threshold_get_color(tag_data[x], x)
                new_tag.append(self.py3.safe_format(self.format_tag, tag_data))

            format_tag_separator = self.py3.safe_format(self.format_tag_separator)
            format_tag = self.py3.composite_join(format_tag_separator, new_tag)

            time["format_tag"] = format_tag
            del time["tags"]

            # duraton
            if time["state_time"]:
                self.tracking = True
                end = dt.datetime.utcnow()
            else:
                end = dt.datetime.strptime(time["end"], DATETIME)

            start = dt.datetime.strptime(time["start"], DATETIME)
            duration = end - start

            time["format_duration"] = self.py3.safe_format(
                self.format_duration,
                {
                    "days": duration.days,
                    "hours": duration.seconds // (60 * 60),
                    "minutes": (duration.seconds // 60) % 60,
                    "seconds": duration.seconds % 60,
                },
            )

            # datetime
            for word in self.init["datetimes"]:
                if word in time:
                    time[word] = self.py3.safe_format(
                        dt.datetime.strftime(
                            dt.datetime.strptime(time[word], DATETIME),
                            self.format_datetime[word],
                        )
                    )

            # time
            for x in self.thresholds_init["format_time"]:
                if x in time:
                    self.py3.threshold_get_color(time[x], x)

            new_time.append(self.py3.safe_format(self.format_time, time))

        format_time_separator = self.py3.safe_format(self.format_time_separator)
        format_time = self.py3.composite_join(format_time_separator, new_time)
        return format_time

    def timewarrior(self):
        timewarrior_data = self._get_timewarrior_data()
        format_time = self._manipulate(timewarrior_data)

        if self.tracking:
            cached_until = self.cache_timeout
        else:
            cached_until = self.sleep_timeout

        timew_data = {"format_time": format_time, "tracking": self.tracking}

        for x in self.thresholds_init["format"]:
            if x in timew_data:
                self.py3.threshold_get_color(timew_data[x], x)

        return {
            "cached_until": self.py3.time_in(cached_until),
            "full_text": self.py3.safe_format(self.format, timew_data),
        }


if __name__ == "__main__":
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/tor_rate.py
================================================
"""
Display transfer rates of a tor instance.

Configuration parameters:
    cache_timeout: An integer specifying the cache life-time of the modules
        output in seconds (default 2)
    control_address: The address on which the Tor daemon listens for control
        connections (default "127.0.0.1")
    control_password: The password to use for the Tor control connection
        (default None)
    control_port: The port on which the Tor daemon listens for control
        connections (default 9051)
    format: A string describing the output format for the module
        (default "↑ {up} ↓ {down}")
    format_value: A string describing how to format the transfer rates
        (default "[\\?min_length=12 {rate:.1f} {unit}]")
    hide_socket_errors: Hide errors connecting to Tor control socket
        (default False)
    rate_unit: The unit to use for the transfer rates
        (default "B/s")
    si_units: A boolean value selecting whether or not to use SI units
        (default False)

Format placeholders:
    {down} The incoming transfer rate
    {up} The outgoing transfer rate

format_value placeholders:
    {rate} The current transfer-rate's value
    {unit} The current transfer-rate's unit

Requires:
    stem: python controller library for tor https://pypi.org/project/stem

Examples:
```
tor_rate {
    cache_timeout = 10
    format = "IN: {down} | OUT: {up}"
    control_port = 1337
    control_password = "TertiaryAdjunctOfUnimatrix01"
    si_units = True
}
```

@author Felix Morgner <felix.morgner@gmail.com>
@license 3-clause-BSD

SAMPLE OUTPUT
{'full_text': u'\u2191 652.3 B/s \u2193 938.1 B/s'}
"""

from stem import ProtocolError, SocketError
from stem.connection import AuthenticationFailure
from stem.control import Controller, EventType

ERROR_AUTHENTICATION = "Error: Failed to authenticate with Tor daemon!"
ERROR_CONNECTION = "Error: Failed to establish control connection!"
ERROR_PROTOCOL = "Error: Failed to register event handler!"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 2
    control_address = "127.0.0.1"
    control_password = None
    control_port = 9051
    format = "↑ {up} ↓ {down}"
    format_value = r"[\?min_length=12 {rate:.1f} {unit}]"
    hide_socket_errors = False
    rate_unit = "B/s"
    si_units = False

    def post_config_hook(self):
        self._auth_failure = False
        self._down = 0
        self._handler_active = False
        self._up = 0

    def tor_rate(self, outputs, config):
        text = ""
        if not self._handler_active and not self._auth_failure:
            try:
                self._register_event_handler()
            except ProtocolError:
                text = ERROR_PROTOCOL
            except SocketError:
                if not self.hide_socket_errors:
                    text = ERROR_CONNECTION
            except AuthenticationFailure:
                text = ERROR_AUTHENTICATION
                self._auth_failure = True
        elif self._auth_failure:
            text = ERROR_AUTHENTICATION
        else:
            text = self.py3.safe_format(self.format, self._get_rates())

        return {"cached_until": self.py3.time_in(self.cache_timeout), "full_text": text}

    def _get_rates(self):
        up, up_unit = self.py3.format_units(self._up, unit=self.rate_unit, si=self.si_units)
        down, down_unit = self.py3.format_units(self._down, unit=self.rate_unit, si=self.si_units)
        return {
            "up": self.py3.safe_format(self.format_value, {"rate": up, "unit": up_unit}),
            "down": self.py3.safe_format(self.format_value, {"rate": down, "unit": down_unit}),
        }

    def _handle_event(self, event):
        self._down = event.read
        self._up = event.written

    def _register_event_handler(self):
        self._control = Controller.from_port(address=self.control_address, port=self.control_port)
        if self.control_password:
            self._control.authenticate(password=self.control_password)
        self._control.add_event_listener(lambda e: self._handle_event(e), EventType.BW)
        self._handler_active = True


if __name__ == "__main__":
    from py3status.module_test import module_test

    config = {"control_password": "SevenOfNine"}
    module_test(Py3status, config)



================================================
FILE: py3status/modules/transmission.py
================================================
r"""
Display number of torrents and more.

Configuration parameters:
    arguments: additional arguments for the transmission-remote (default None)
    button_next: mouse button to switch next torrent (default None)
    button_previous: mouse button to switch previous torrent (default None)
    button_run: mouse button to run the command on current torrent
        (default [(1, '--start'), (2, '--verify'), (3, '--stop')])
    cache_timeout: refresh interval for this module (default 20)
    format: display format for this module (default '{format_torrent}')
    format_separator: show separator if more than one (default ' ')
    format_torrent: display format for torrents
        (default '[\?if=is_focused&color=bad X] {status} {id} {name} {done}%')
    thresholds: specify color thresholds to use (default [])

Format placeholders:
    {torrent} number of torrents
    {format_torrent} format for torrents
    {up} summary up traffic
    {down} summary down traffic
    {have} summary download

format_torrent placeholders:
    {index} torrent index, eg 1
    {id} torrent id, eg 2
    {done} torrent percent, eg 100%
    {have} torrent download, 253 KB
    {eta} torrent estimated time, eg Done, 1 min, etc
    {up} torrent up traffic
    {down} torrent down traffic
    {ratio} torrent seed ratio
    {status} torrent status, eg Idle, Downloading, Stopped, Verifying, etc
    {name} torrent name, eg py3status-3.8.tar.gz

Color options:
    color_bad: current torrent

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    transmission-cli:
        fast, easy, and free bittorrent client (cli tools, daemon, web client)

Examples:
```
# add arguments
transmission {
    # We use 'transmission-remote --list'
    # See `transmission-remote --help' for more information.
    # Not all of the arguments will work here.
    arguments = '--auth username:password --port 9091'
}
# see 'man transmission-remote' for more buttons
transmission {
    button_run = [
        (1, '--start'),
        (2, '--verify'),
        (3, '--stop'),
        (8, '--remove'),
        (9, '--exit'),
    ]
}

# open web-based transmission client
transmission {
    on_click 1 = 'exec xdg-open http://username:password@localhost:9091'
}

# add buttons
transmission {
    button_next = 5
    button_previous = 4
}

# see 'man transmission-remote' for more buttons
transmission {
    # specify a script to run when a torrent finishes
    on_click 9 = 'exec transmission-remote --torrent-done-script ~/file'

    # use the alternate limits?
    on_click 9 = 'exec transmission-remote --alt-speed'
    on_click 10 = 'exec transmission-remote --no-alt-speed'
}

# show summary statistcs - up, down, have
transmission {
    format = '{format_torrent}'
    format += '[\?color=#ffccff [\?not_zero  Up:{up}]'
    format += '[\?not_zero  Down:{down}][\?not_zero  Have:{have}]]'
}

# add a format that sucks less than the default plain format
transmission {
    format_torrent = '[\?if=is_focused&color=bad X ]'
    format_torrent += '[[\?if=status=Idle&color=degraded {status}]'
    format_torrent += '|[\?if=status=Stopped&color=bad {status}]'
    format_torrent += '|[\?if=status=Downloading&color=good {status}]'
    format_torrent += '|[\?if=status=Verifying&color=good {status}]'
    format_torrent += '|\?color=degraded {status}]'
    format_torrent += ' {name} [\?color=done {done}]'
}

# show percent thresholds
transmission {
    format_torrent = '{name} [\?color=done {done}]'
    thresholds = [(0, 'bad'), (1, 'degraded'), (100, 'good')]
}

# download the rainbow
transmission {
    format_torrent = '[\?if=is_focused&color=bad X ]'
    format_torrent += '{status} [\?color=index {name}] [\?color=done {done}%]'
    thresholds = {
        'done': [(0, '#ffb3ba'), (1, '#ffffba'), (100, '#baefba')],
        'index': [
            (1, '#ffb3ba'), (2, '#ffdfba'), (3, '#ffffba'),
            (4, '#baefba'), (5, '#baffc9'), (6, '#bae1ff'),
            (7, '#bab3ff')
        ]
    }
}
```

@author lasers

SAMPLE OUTPUT
{'full_text': 'Downloading py3status-3.8.tar.gz 89%'}

verifying
{'full_text': 'Verifying py3status-3.8.tar.gz 100%'}

stopped
{'full_text': 'Stopped py3status-3.8.tar.gz 100%'}

idle
{'full_text': 'Idle py3status-3.8.tar.gz 100%'}

"""

import time

STRING_NOT_INSTALLED = "transmission-remote not installed"


class Py3status:
    """ """

    # available configuration parameters
    arguments = None
    button_next = None
    button_previous = None
    button_run = [(1, "--start"), (2, "--verify"), (3, "--stop")]
    cache_timeout = 20
    format = "{format_torrent}"
    format_separator = " "
    format_torrent = r"[\?if=is_focused&color=bad X] {status} {id} {name} {done}%"
    thresholds = []

    def post_config_hook(self):
        self.command = "transmission-remote --list"
        if not self.py3.check_commands(self.command):
            raise Exception(STRING_NOT_INSTALLED)
        if self.arguments:
            self.command = f"{self.command} {self.arguments}"
        self.init_summary = self.py3.format_contains(self.format, ["up", "down", "have"])
        self.id = 0
        self.state = None
        self.reset_id = self.id
        self.torrent_data = None
        self.is_scrolling = False
        self.count_torrent = 0
        self.summary_data = {}

        self.thresholds_init = {}
        for name in ["format", "format_torrent"]:
            self.thresholds_init[name] = self.py3.get_color_names_list(getattr(self, name))

    def _scroll(self, direction=0):
        self.is_scrolling = True
        data = self.shared
        if direction == 0:
            self.id = self.reset_id
            self.state = None
            self.is_scrolling = False
            for d in data:
                d["is_focused"] = False
        else:
            if data and not any(d for d in data if d["is_focused"]):
                data[0]["is_focused"] = True

            length = len(data)
            for index, d in enumerate(data):
                if d.get("is_focused"):
                    data[index]["is_focused"] = False
                    if direction < 0:  # switch previous
                        if index > 0:
                            data[index - 1]["is_focused"] = True
                        else:
                            data[index]["is_focused"] = True
                    elif direction > 0:  # switch next
                        if index < (length - 1):
                            data[index + 1]["is_focused"] = True
                        else:
                            data[length - 1]["is_focused"] = True
                    break

            for d in data:
                if d["is_focused"]:
                    self.id = d["id"]
                    self.state = d["status"]
                    break

        self._manipulate(data)

    def _organize(self, data):
        self.id = self.reset_id
        new_data = []
        for line in data:
            new_data.append(
                {
                    "is_focused": None,
                    "id": line[0:6].strip(),
                    "done": line[7:12].strip().strip("%"),
                    "have": line[13:23].strip(),
                    "eta": line[24:33].strip(),
                    "up": line[34:41].strip(),
                    "down": line[42:49].strip(),
                    "ratio": line[50:56].strip(),
                    "status": line[57:69].strip(),
                    "name": line[70:].strip(),
                }
            )
        return new_data

    def _manipulate(self, data):
        self.shared = data
        new_data = []
        for index, t in enumerate(data, 1):
            t["index"] = index
            if not self.is_scrolling:
                t["is_focused"] = False
            for x in self.thresholds_init["format_torrent"]:
                if x in t:
                    self.py3.threshold_get_color(t[x], x)

            new_data.append(self.py3.safe_format(self.format_torrent, t))
        return new_data

    def transmission(self):
        data = self.torrent_data
        summary_data = self.summary_data

        if not self.is_scrolling:
            data = self.py3.command_output(self.command).splitlines()
            if self.init_summary:
                summary_line = data[-1]
                summary_data["have"] = summary_line[13:23].strip()
                summary_data["up"] = summary_line[34:41].strip()
                summary_data["down"] = summary_line[42:49].strip()
            data = data[1:-1]
            self.count_torrent = len(data)
            data = self.torrent_data = self._organize(data)

        data = self._manipulate(data)
        format_separator = self.py3.safe_format(self.format_separator)
        format_torrent = self.py3.composite_join(format_separator, data)

        summary_data.update({"torrent": self.count_torrent, "format_torrent": format_torrent})

        for x in self.thresholds_init["format"]:
            if x in summary_data:
                self.py3.threshold_get_color(summary_data[x], x)

        self.is_scrolling = False
        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, summary_data),
        }

    def on_click(self, event):
        button = event["button"]
        self.id = str(self.id).strip("*")
        if button == self.button_next and self.torrent_data:
            self._scroll(+1)
        elif button == self.button_previous and self.torrent_data:
            self._scroll(-1)
        elif self.id:
            for x in self.button_run:
                if button == x[0]:
                    cmd = "transmission-remote -t {} {}".format(self.id, x[1])
                    self.py3.command_run(cmd)
                    time.sleep(0.75)
                    break


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/twitch.py
================================================
"""
Display if a Twitch channel is currently streaming or not.

Configuration parameters:
    cache_timeout: how often we refresh this module in seconds
        (default 60)
    client_id: Your client id. Create your own key at https://dev.twitch.tv
        (default None)
    client_secret: Your client secret.
        (default None)
    format: Display format when online
        (default "{display_name} is live!")
    format_offline: Display format when offline
        (default "{display_name} is offline.")
    format_tag: Tag formatting
        (default "{name}")
    locales: List of locales to try for tag translations, eg. ["cs-cz", "en-uk", "en-us"]. If none is specified, auto-detect from environment, with a fallback to "en-us".
        (default [])
    stream_name: name of streamer(twitch.tv/<stream_name>)
        (default None)
    tag_delimiter: string to write between tags
        (default " ")
    trace: enable trace level debugging
        (default False)

Stream format placeholders:
    {display_name} User's display name., eg Ultrabug
    {is_streaming} (bool) True if streaming, fields prefixed with stream_ are available.
    {tags} List of tags
    {user_id} User's id
    {user_login} User's login name, eg xisumavoid
    {user_display_name} (same as {display_name})
    {user_type} "staff", "admin", "global_mod", or ""
    {user_broadcaster_type} "partner", "affiliate", or "".
    {user_description} User's channel description.
    {user_profile_image_url} URL of the user's profile image.
    {user_offline_image_url} URL of the user's offline image.
    {user_view_count} Total number of views of the user's channel.
    {user_created_at} Date when the user was created.
    {stream_id} Stream ID.
    {stream_game_id} ID of the game being played on the stream.
    {stream_game_name} Name of the game being played.
    {stream_title} Stream title.
    {stream_viewer_count} Number of viewers watching the stream at the time of last update.
    {stream_started_at} Stream start UTC timestamp.
    {stream_language} Stream language. A language value is either the ISO 639-1 two-letter code or “other”.
    {stream_thumbnail_url} Thumbnail URL of the stream. All image URLs have variable width and height. You can replace {width} and {height} with any values to get that size image
    {stream_is_mature} Indicates if the broadcaster has specified their channel contains mature content that may be inappropriate for younger audiences.
    {stream_runtime} (string) Stream runtime as a human readable, non-localized string. eg "3h 5m"
    {stream_runtime_seconds} (int) Stream runtime in seconds.

Tag format placeholders: (see locales)
    {name} The tag name
    {desc} The tag description

Color options:
    color_bad: Stream offline
    color_good: Stream is live

Client ID:
    Example settings when creating your app at https://dev.twitch.tv

    Name: <your_name>_py3status
    OAuth Redirect URI: https://localhost
    Application Category: Application Integration


@author Alex Caswell horatioesf@virginmedia.com
@author Julian Picht julian.picht@gmail.com
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'exotic_bug is live!'}

offline
{'color': '#FF0000', 'full_text': 'exotic_bug is offline!'}
"""

import datetime
import time

STRING_MISSING = "missing {}"


def time_since(s):
    ts = datetime.datetime.strptime(s, "%Y-%m-%dT%H:%M:%SZ").timestamp()
    seconds = int(datetime.datetime.utcnow().timestamp() - ts)
    if seconds > 3600:
        return "%dh %dm" % (seconds / 3600, (seconds % 3600) / 60), seconds
    if seconds > 60:
        return "%dm" % (seconds / 60), seconds
    return "0m", seconds


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 60
    client_id = None
    client_secret = None
    format = "{display_name} is live!"
    format_offline = "{display_name} is offline."
    format_tag = "{name}"
    locales = []
    stream_name = None
    tag_delimiter = " "
    trace = False

    class Meta:
        deprecated = {
            "remove": [{"param": "format_invalid", "msg": "obsolete"}],
            "rename_placeholder": [
                {
                    "placeholder": "stream_name",
                    "new": "display_name",
                    "format_strings": ["format"],
                }
            ],
        }

    def _trace(self, msg):
        if not self.trace:
            return
        self.py3.log(msg, self.py3.LOG_INFO)

    def _refresh_token(self):
        if self._token and self._token["expires"] > time.time():
            return

        self._trace("refreshing twitch oauth token")
        auth_endpoint = "https://id.twitch.tv/oauth2/token"
        auth_request = {
            "client_id": self.client_id,
            "client_secret": self.client_secret,
            "grant_type": "client_credentials",
        }

        try:
            response = self.py3.request(auth_endpoint, data=auth_request)
        except self.py3.RequestException:
            return {}

        data = response.json()
        if not data:
            data = vars(response)
            error = data.get("_error_message")
            if error:
                self.py3.error("{} {}".format(error, data["_status_code"]))

        self._token = data
        self._token["expires"] = time.time() + self._token["expires_in"] - 60
        self.py3.storage_set("oauth_token", self._token)

    def _headers(self):
        self._refresh_token()
        return {
            "Authorization": "Bearer " + self._token["access_token"],
            "Client-ID": self.client_id,
        }

    def post_config_hook(self):
        for config_name in ["client_id", "client_secret", "stream_name"]:
            if not getattr(self, config_name, None):
                raise Exception(STRING_MISSING.format(config_name))

        base_api = "https://api.twitch.tv/helix/"
        self.url = {
            "users": base_api + f"users/?login={self.stream_name}",
            "streams": base_api + f"streams/?user_login={self.stream_name}",
            "tags": base_api + "streams/tags",
        }

        self.user = {}
        self._token = self.py3.storage_get("oauth_token")

        if self.locales is False:
            return

        have_tags = (
            self.py3.format_contains(self.format, "tags")
            or
            # it doesn't make any sense here... but we'll check
            self.py3.format_contains(self.format_offline, "tags")
        )

        if not have_tags:
            self.locales = False
            return

        if not isinstance(self.locales, list):
            self.locales = [x for x in [str(self.locales)] if x]

        if len(self.locales) == 0:
            try:
                import locale

                self.locales = [locale.getdefaultlocale()[0].lower().replace("_", "-")]
            except (ModuleNotFoundError, IndexError):
                pass

        if "en-us" not in self.locales:
            self.locales.append("en-us")

    def _get_twitch_data(self, url, first=True):
        try:
            response = self.py3.request(url, headers=self._headers())
        except self.py3.RequestException as e:
            self.py3.error(f"get({url}): exception={e}")
            return {}
        data = response.json()
        if not data:
            data = vars(response)
            error = data.get("_error_message")
            if error:
                self.py3.error("{} {}".format(error, data["_status_code"]))

        if first:
            if len(data["data"]) > 0:
                return data["data"][0]
            return {}

        cursor = False
        if "pagination" in data and "cursor" in data["pagination"]:
            cursor = data["pagination"]["cursor"]

        return data["data"], cursor

    def _get_tags(self, user_id, cursor=None):
        if self.locales is False:
            return self.py3.composite_create([])

        url = self.url["tags"] + f"?broadcaster_id={user_id}"

        if cursor is not None:
            url = f"{url}&after={cursor}"

        self._trace(f"fetching tags, page={cursor}")

        tags = []
        page, next_cursor = self._get_twitch_data(url, first=False)
        if page:
            for tag in page:
                tag_data = {}
                for loc in self.locales:
                    if loc in tag["localization_names"] and "name" not in tag_data:
                        tag_data["name"] = tag["localization_names"][loc]
                    if loc in tag["localization_descriptions"] and "desc" not in tag_data:
                        tag_data["desc"] = tag["localization_descriptions"][loc]
                if tag_data:
                    tags.append(self.py3.safe_format(self.format_tag, tag_data))

        if next_cursor:
            tags.append(*self._get_tags(user_id, next_cursor))

        return tags

    def twitch(self):
        if not self.user:
            self._trace("fetching user")
            self.user = self._get_twitch_data(self.url["users"])

        twitch_data = {
            "user": self.user,
            # ensure display name is still there, deprecate+remove later?
            "display_name": self.user["display_name"],
        }
        current_format = ""
        color = None

        self._trace("fetching stream data")
        stream = self._get_twitch_data(self.url["streams"])
        if stream and "type" in stream and stream["type"] == "live":
            # this is always "live" if the stream is healthy
            del stream["type"]
            # remove useless UUIDs
            del stream["tag_ids"]
            # remove redundant data
            del stream["user_id"]
            del stream["user_login"]
            del stream["user_name"]

            # calculate runtime and  update data dict
            stream["runtime"], stream["runtime_seconds"] = time_since(stream["started_at"])
            twitch_data["stream"] = stream
            twitch_data["is_streaming"] = True

            color = self.py3.COLOR_GOOD
            current_format = self.format
        else:
            twitch_data["is_streaming"] = False
            color = self.py3.COLOR_BAD
            current_format = self.format_offline

        twitch_data = self.py3.flatten_dict(twitch_data, delimiter="_")
        twitch_data["tags"] = self.py3.composite_join(
            self.tag_delimiter, self._get_tags(self.user["id"])
        )

        self._trace("fields available: {}".format(list(twitch_data.keys())))

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(current_format, twitch_data),
        }

        if color:
            response["color"] = color

        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from os import getenv

    from py3status.module_test import module_test

    config = {
        "client_id": getenv("TWITCH_CLIENT_ID"),
        "client_secret": getenv("TWITCH_CLIENT_SECRET"),
        "stream_name": "xisumavoid",
        "format": "{display_name} is playing {stream_game_name} for {stream_runtime} with title '{stream_title}'\n\tlanguage: {stream_language}\n\tviewers: {stream_viewer_count}\n\ttags:\n{tags}",
        "format_tag": "\t\t{name} -> {desc}",
        "tag_delimiter": "\n",
        "locales": "invalid",
        "trace": True,
    }

    module_test(Py3status, config)



================================================
FILE: py3status/modules/uname.py
================================================
"""
Display system information.

Configuration parameters:
    format: display format for this module (default '{system} {release}')

Format placeholders:
    {system} system/OS name, e.g. 'Linux', 'Windows', or 'Java'
    {node} computer’s network name (may not be fully qualified!)
    {release} system’s release, e.g. '2.2.0' or 'NT'
    {version} system’s release version, e.g. '#3 on degas'
    {machine} machine type, e.g. 'x86_64'
    {processor} the (real) processor name, e.g. 'amdk6'

@author ultrabug (inspired by ndalliard)

SAMPLE OUTPUT
{'full_text': 'Linux 4.8.15-300.fc25.x86_64'}
"""

from platform import uname


class Py3status:
    """ """

    # available configuration parameters
    format = "{system} {release}"

    class Meta:
        deprecated = {"remove": [{"param": "cache_timeout", "msg": "obsolete parameter"}]}

    def uname(self):
        keys = ["system", "node", "release", "version", "machine", "processor"]
        full_text = self.py3.safe_format(self.format, dict(zip(keys, uname())))

        return {"cached_until": self.py3.CACHE_FOREVER, "full_text": full_text}


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/uptime.py
================================================
r"""
Display system uptime.

Configuration parameters:
    format: display format for this module
        (default 'up {days} days {hours} hours {minutes} minutes')

Format placeholders:
    {decades} decades
    {years}   years
    {weeks}   weeks
    {days}    days
    {hours}   hours
    {minutes} minutes
    {seconds} seconds

    If you don't use a placeholder, its value will be carried over
    to the next placeholder. For example, an uptime of 1 hour 30 minutes
    will give you 90 if {minutes} or 1:30 if {hours}:{minutes}.

    You also can specify strftime characters to print system up since
    with or without placeholders. See `man strftime` for more information.

Examples:
```
# show uptime without zeroes
uptime {
    format = 'up [\?if=weeks {weeks} weeks ][\?if=days {days} days ]
        [\?if=hours {hours} hours ][\?if=minutes {minutes} minutes ]'
}

# show uptime in multiple formats using group module
group uptime {
    format = "up {output}"
    uptime {
        format = '[\?if=weeks {weeks} weeks ][\?if=days {days} days ]
            [\?if=hours {hours} hours ][\?if=minutes {minutes} minutes]'
    }
    uptime {
        format = '[\?if=weeks {weeks}w ][\?if=days {days}d ]
            [\?if=hours {hours}h ][\?if=minutes {minutes}m]'
    }
    uptime {
        format = '[\?if=days {days}, ][\?if=hours {hours}:]
            [\?if=minutes {minutes:02d}]'
    }
}

# specify strftime characters to display system up since
uptime {
    format = "{days}d {hours}:{minutes:02d}:{seconds:02d}"
    format += ", up since %Y-%m-%d %H:%M:%S"
}
```

@author Alexis "Horgix" Chotard <alexis.horgix.chotard@gmail.com>, Volkov "BabyWolf" Semjon <Volkov.BabyWolf.Semjon@gmail.com>
@license BSD

SAMPLE OUTPUT
{'full_text': 'up 1 days 18 hours 20 minutes'}
"""

import time
from collections import OrderedDict
from datetime import datetime
from pathlib import Path


class Py3status:
    """ """

    # available configuration parameters
    format = "up {days} days {hours} hours {minutes} minutes"

    def post_config_hook(self):
        self.time_periods = OrderedDict()
        self.since = "%" in self.format
        periods = [
            ("decades", 315360000),
            ("years", 31536000),
            ("weeks", 604800),
            ("days", 86400),
            ("hours", 3600),
            ("minutes", 60),
            ("seconds", 1),
        ]
        self.seconds, self.interval = self.py3.CACHE_FOREVER, None
        for unit, second in periods:
            if self.py3.format_contains(self.format, unit):
                self.time_periods[unit] = second
                self.seconds, self.interval = None, second

    def uptime(self):
        with Path("/proc/uptime").open() as f:
            up = int(float(f.readline().split()[0]))
            offset = time.time() - up

        uptime = {}
        for unit, interval in self.time_periods.items():
            uptime[unit], up = divmod(up, interval)

        if self.since:
            since = datetime.fromtimestamp(offset)
            new_format = datetime.strftime(since, self.format)
        else:
            new_format = self.format

        return {
            "cached_until": self.py3.time_in(self.seconds, self.interval, offset),
            "full_text": self.py3.safe_format(new_format, uptime),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/usbguard.py
================================================
r"""
Allow or Reject newly plugged USB devices using USBGuard.

Configuration parameters:
    format: display format for this module
        (default '{format_device}')
    format_button_allow: display format for allow button filter
        (default '\[Allow\]')
    format_button_reject: display format for reject button filter
        (default '\[Reject\]')
    format_device: display format for USB devices
        (default '{format_button_reject} [{name}|{usb_id}] {format_button_allow}')
    format_device_separator: show separator if more than one (default ' ')

Format placeholders:
    {device}                  number of USB devices
    {format_device}           format for USB devices

format_device:
    {format_button_allow}     button to allow the device
    {format_button_reject}    button to reject the device
    {id}                      eg 1, 2, 5, 6, 7, 22, 23, 33
    {policy}                  eg allow, block, reject
    {usb_id}                  eg 054c:0268
    {name}                    eg Poker II, PLAYSTATION(R)3 Controller
    {serial}                  eg 0000:00:00.0
    {port}                    eg usb1, usb2, usb3, 1-1, 4-1.2.1
    {interface}               eg 00:00:00:00 00:00:00 00:00:00
    {hash}                    eg ihYz60+8pxZBi/cm+Q/4Ibrsyyzq/iZ9xtMDAh53sng
    {parent_hash}             eg npSDT1xuEIOSLNt2RT2EbFrE8XRZoV29t1n7kg6GxXg

Requires:
    python-gobject: Python Bindings for GLib/GObject/GIO/GTK+
    usbguard: USB device authorization policy framework

@author @cyrinux, @maximbaz
@license BSD

SAMPLE OUTPUT
[
    {'full_text': '[Reject] ', 'urgent': True},
    {'full_text': 'USB Flash Drive ', 'urgent': True},
    {'full_text': '[Allow]', 'urgent': True}
]
"""

import re
from threading import Thread

from gi.repository import Gio, GLib

STRING_USBGUARD_DBUS = "start usbguard-dbus.service"


class Py3status:
    """ """

    # available configuration parameters
    format = "{format_device}"
    format_button_allow = r"\[Allow\]"
    format_button_reject = r"\[Reject\]"
    format_device = "{format_button_reject} [{name}|{usb_id}] {format_button_allow}"
    format_device_separator = " "

    def post_config_hook(self):
        self.init = {
            "format_button": self.py3.get_placeholders_list(self.format_device, "format_button_*"),
            "target": {"allow": 0, "reject": 2},
        }

        self.keys = [
            ("serial", re.compile(r"\S*serial \"(\S+)\"\S*")),
            ("policy", re.compile(r"^(\S+)")),
            ("usb_id", re.compile(r"id (\S+)")),
            ("name", re.compile(r"name \"(.*)\" hash")),
            ("hash", re.compile(r"hash \"(.*)\" parent-hash")),
            ("parent_hash", re.compile(r"parent-hash \"(.*)\" via-port")),
            ("port", re.compile(r"via-port \"(.*)\" with-interface")),
            ("interface", re.compile(r"with-interface { (.*) }$")),
        ]

        self._init_dbus()

    def _init_dbus(self):
        self.bus = Gio.bus_get_sync(Gio.BusType.SYSTEM, None)
        self.proxy = Gio.DBusProxy.new_sync(
            self.bus,
            Gio.DBusProxyFlags.NONE,
            None,
            "org.usbguard1",
            "/org/usbguard1/Devices",
            "org.usbguard.Devices1",
            None,
        )
        for signal in ["DevicePolicyChanged", "DevicePresenceChanged"]:
            self.bus.signal_subscribe(
                None,
                "org.usbguard.Devices1",
                signal,
                None,
                None,
                0,
                lambda *args: self.py3.update(),
            )

        thread = Thread(target=lambda: GLib.MainLoop().run())
        thread.daemon = True
        thread.start()

    def _get_devices(self):
        try:
            raw_devices = self.proxy.listDevices("(s)", "block")
        except Exception:
            raise Exception(STRING_USBGUARD_DBUS)

        devices = []
        for device_id, string in raw_devices:
            device = {"id": device_id}
            string = string.encode("latin-1").decode("unicode_escape")
            string = string.encode("latin-1").decode("utf-8")
            for name, regex in self.keys:
                value = regex.findall(string) or None
                if value:
                    value = value[0]
                device[name] = value
            devices.append(device)

        return devices

    def _format_device(self, devices):
        device_info = []
        for device in devices:
            for btn in self.init["format_button"]:
                composite = self.py3.safe_format(getattr(self, btn), device)
                device[btn] = self.py3.composite_update(
                    composite,
                    {"index": "{}/{}".format(device["id"], btn.split("_")[-1])},
                )

            device_info.append(self.py3.safe_format(self.format_device, device))

        format_device_separator = self.py3.safe_format(self.format_device_separator)
        format_device = self.py3.composite_join(format_device_separator, device_info)

        return format_device

    def usbguard(self):
        devices = self._get_devices()

        usbguard_data = {
            "device": len(devices),
            "format_device": self._format_device(devices),
        }

        return {
            "cached_until": self.py3.CACHE_FOREVER,
            "full_text": self.py3.safe_format(self.format, usbguard_data),
            "urgent": True,
        }

    def on_click(self, event):
        if isinstance(event["index"], int):
            return

        device_id, policy_name = event["index"].split("/")
        policy = self.init["target"][policy_name]
        self.proxy.applyDevicePolicy("(uub)", int(device_id), policy, False)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/vnstat.py
================================================
r"""
Display vnstat statistics.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 180)
    format: display format for this module (default '{total}')
    initial_multi: set to 1 to disable first bytes
        (default 1024)
    left_align: (default 0)
    multiplier_top: if value is greater, divide it with unit_multi and get
        next unit from units (default 1024)
    precision: (default 1)
    statistics_type: d for daily, m for monthly (default 'd')
    thresholds: thresholds to use for color changes (default [])
    unit_multi: value to divide if rate is greater than multiplier_top
        (default 1024)

Format placeholders:
    {down} download
    {total} total
    {up} upload

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    vnstat: a console-based network traffic monitor

Examples:
```
# colorize thresholds
vnstat {
    format = '[\?color=total {total}]'
    thresholds = [
        (838860800, "degraded"),  # 838860800 B -> 800 MiB
        (943718400, "bad"),       # 943718400 B -> 900 MiB
    ]
}
```

@author shadowprince
@license Eclipse Public License

SAMPLE OUTPUT
{'full_text': '826.4 mb'}
"""

STRING_NOT_INSTALLED = "not installed"
STRING_INVALID_TYPE = "invalid statistics_type"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 180
    format = "{total}"
    initial_multi = 1024
    left_align = 0
    multiplier_top = 1024
    precision = 1
    statistics_type = "d"
    thresholds = []
    unit_multi = 1024

    def post_config_hook(self):
        """
        Format of total, up and down placeholders under FORMAT.
        As default, substitutes left_align and precision as %s and %s
        Placeholders:
            value - value (float)
            unit - unit (string)
        """
        if not self.py3.check_commands("vnstat"):
            raise Exception(STRING_NOT_INSTALLED)
        elif self.statistics_type not in ["d", "m"]:
            raise Exception(STRING_INVALID_TYPE)
        self.slice = slice(*(3, 6) if self.statistics_type == "d" else (8, 11))
        self.value_format = "{{value:{}.{}f}} {{unit}}".format(self.left_align, self.precision)
        # list of units, first one - value/initial_multi, second - value/1024,
        # third - value/1024^2, etc...
        self.units = ["kb", "mb", "gb", "tb"]

        # deprecations
        self.coloring = getattr(self, "coloring", None)
        if self.coloring and not self.thresholds:
            self.thresholds = [(num * 1024**2, col) for num, col in self.coloring.items()]

        self.thresholds_init = self.py3.get_color_names_list(self.format)

    def _divide_and_format(self, value):
        # Divide a value and return formatted string
        value /= self.initial_multi
        for i, unit in enumerate(self.units):
            if value > self.multiplier_top:
                value /= self.unit_multi
            else:
                break
        return self.value_format.format(value=value, unit=unit)

    def vnstat(self):
        vnstat_data = self.py3.command_output("vnstat --oneline b")
        values = vnstat_data.splitlines()[0].split(";")[self.slice]
        stat = dict(zip(["down", "up", "total"], map(int, values)))
        response = {"cached_until": self.py3.time_in(self.cache_timeout)}

        if self.coloring:
            response["color"] = self.py3.threshold_get_color(stat["total"])

        for x in self.thresholds_init:
            if x in stat:
                self.py3.threshold_get_color(stat[x], x)

        response["full_text"] = self.py3.safe_format(
            self.format,
            dict(
                total=self._divide_and_format(stat["total"]),
                up=self._divide_and_format(stat["up"]),
                down=self._divide_and_format(stat["down"]),
            ),
        )
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/volume_status.py
================================================
"""
Volume control.

Configuration parameters:
    blocks: a string, where each character represents a volume level
            (default "_▁▂▃▄▅▆▇█")
    button_down: button to decrease volume (default 5)
    button_mute: button to toggle mute (default 1)
    button_up: button to increase volume (default 4)
    cache_timeout: how often we refresh this module in seconds.
        (default 10)
    card: Card to use. amixer supports this. (default None)
    channel: channel to track. Default value is backend dependent.
        (default None)
    command: Choose between "amixer", "pamixer" or "pactl".
        If None, try to guess based on available commands.
        (default None)
    device: Device to use. Defaults value is backend dependent.
        "aplay -L", "pactl list sinks short", "pamixer --list-sinks"
        (default None)
    format: Format of the output.
        (default '[\\?if=is_input 😮|♪]: {percentage}%')
    format_muted: Format of the output when the volume is muted.
        (default '[\\?if=is_input 😶|♪]: muted')
    is_input: Is this an input device or an output device?
        (default False)
    max_volume: Allow the volume to be increased past 100% if available.
        pactl and pamixer supports this. (default 120)
    thresholds: Threshold for percent volume.
        (default [(0, 'bad'), (20, 'degraded'), (50, 'good')])
    volume_delta: Percentage amount that the volume is increased or
        decreased by when volume buttons pressed.
        (default 5)

Format placeholders:
    {icon} Character representing the volume level,
            as defined by the 'blocks'
    {percentage} Percentage volume

Color options:
    color_muted: Volume is muted, if not supplied color_bad is used
        if set to `None` then the threshold color will be used.

Requires:
    alsa-utils: an alternative implementation of linux sound support
    pamixer: pulseaudio command-line mixer like amixer

Notes:
    If you are changing volume state by external scripts etc and
    want to refresh the module quicker than the i3status interval,
    send a USR1 signal to py3status in the keybinding.
    Example: killall -s USR1 py3status

Examples:
```
# Set thresholds to rainbow colors
volume_status {
    thresholds = [
        (0, "#FF0000"),
        (10, "#E2571E"),
        (20, "#FF7F00"),
        (30, "#FFFF00"),
        (40, "#00FF00"),
        (50, "#96BF33"),
        (60, "#0000FF"),
        (70, "#4B0082"),
        (80, "#8B00FF"),
        (90, "#FFFFFF")
    ]
}
```

@author <Jan T> <jans.tuomi@gmail.com>
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'\u266a: 95%'}

mute
{'color': '#FF0000', 'full_text': u'\u266a: muted'}
"""

import math
import re
from time import sleep

from py3status.exceptions import CommandError

STRING_ERROR = "invalid command `{}`"
STRING_NOT_AVAILABLE = "no available binary"
COMMAND_NOT_INSTALLED = "command `{}` not installed"


class Audio:
    def __init__(self, parent):
        self.card = parent.card
        self.channel = parent.channel
        self.device = parent.device
        self.is_input = parent.is_input
        self.max_volume = parent.max_volume
        self.parent = parent
        self.setup(parent)

    def setup(self, parent):
        raise NotImplementedError

    def run_cmd(self, cmd):
        return self.parent.py3.command_run(cmd)

    def command_output(self, cmd):
        return self.parent.py3.command_output(cmd)


class Amixer(Audio):
    def setup(self, parent):
        if self.card is None:
            self.card = "0"
        if self.device is None:
            self.device = "default"
        if self.channel is None:
            controls = self.parent.py3.command_output(
                ["amixer", "-c", self.card, "-D", self.device, "scontrols"]
            ).splitlines()
            self.channel = controls[-abs(int(self.is_input))].split("'")[1::2][0]
        self.cmd = [
            "amixer",
            "-M",
            "-q",
            "-c",
            self.card,
            "-D",
            self.device,
            "sset",
            self.channel,
        ]
        self.get_volume_cmd = [
            "amixer",
            "-M",
            "-c",
            self.card,
            "-D",
            self.device,
            "sget",
            self.channel,
        ]

    def get_volume(self):
        output = self.command_output(self.get_volume_cmd)

        # find percentage and status
        p = re.compile(r"\[(\d{1,3})%\].*\[(\w{2,3})\]")
        perc, muted = p.search(output).groups()

        # muted should be 'on' or 'off'
        if muted in ["on", "off"]:
            muted = muted == "off"
        else:
            muted = False

        return perc, muted

    def volume_up(self, delta):
        self.run_cmd(self.cmd + [f"{delta}%+"])

    def volume_down(self, delta):
        self.run_cmd(self.cmd + [f"{delta}%-"])

    def toggle_mute(self):
        self.run_cmd(self.cmd + ["toggle"])


class Pamixer(Audio):
    def setup(self, parent):
        if self.device is not None:
            dev_target = ["--source" if self.is_input else "--sink", self.device]
        elif self.is_input:
            dev_target = ["--default-source"]
        else:
            dev_target = []
        self.cmd = ["pamixer", "--allow-boost"] + dev_target

    def get_volume(self):
        try:
            line = self.command_output(self.cmd + ["--get-mute", "--get-volume"])
        except CommandError as ce:
            # pamixer throws error on zero percent. see #1135
            line = ce.output
        try:
            muted, perc = line.split()
            muted = muted == "true"
        except ValueError:
            muted, perc = None, None
        return perc, muted

    def volume_up(self, delta):
        perc, muted = self.get_volume()
        if int(perc) + delta >= self.max_volume:
            options = ["--set-volume", str(self.max_volume)]
        else:
            options = ["--increase", str(delta)]
        self.run_cmd(self.cmd + options)

    def volume_down(self, delta):
        self.run_cmd(self.cmd + ["--decrease", str(delta)])

    def toggle_mute(self):
        self.run_cmd(self.cmd + ["--toggle-mute"])


class Pactl(Audio):
    def setup(self, parent):
        # get available device number if not specified
        self.detected_devices = {}
        self.device_type = "source" if self.is_input else "sink"
        self.device_type_pl = self.device_type + "s"
        self.device_type_cap = self.device_type[0].upper() + self.device_type[1:]

        self.use_default_device = self.device is None
        if self.use_default_device:
            self.device = self.get_default_device()
        else:
            # if a device name was present but is used to match multiple
            # possible devices sharing the same name pattern we allow ourselves
            # to override the device name
            self.set_selected_device()
        self.update_device()

    def update_device(self):
        self.re_volume = re.compile(
            r"{} (?:#{}|.*?Name: {}).*?Mute: (\w{{2,3}}).*?Volume:.*?(\d{{1,3}})%".format(
                self.device_type_cap, self.device, self.device
            ),
            re.M | re.DOTALL,
        )

    def get_default_device(self):
        device_id = None

        # Find the default device for the device type
        default_dev_pattern = re.compile(rf"^Default {self.device_type_cap}: (.*)$")
        output = self.command_output(["pactl", "info"])
        for info_line in output.splitlines():
            default_dev_match = default_dev_pattern.match(info_line)
            if default_dev_match is not None:
                device_id = default_dev_match.groups()[0]
                break

        # with the long gross id, find the associated number
        if device_id is not None:
            for d_number, d_id in self.get_current_devices().items():
                if d_id == device_id:
                    return d_number

        raise RuntimeError(
            "Failed to find default {} device.  Looked for {}".format(
                "input" if self.is_input else "output", device_id
            )
        )

    def set_selected_device(self):
        current_devices = self.get_current_devices()
        if self.device in current_devices.values():
            return
        for device_name in current_devices.values():
            if self.device in device_name:
                self.parent.py3.log(f"device {self.device} detected as {device_name}")
                self.device = device_name
                break

    def get_current_devices(self):
        current_devices = {}
        output = self.command_output(["pactl", "list", "short", self.device_type_pl])
        for line in output.splitlines():
            parts = line.split()
            if len(parts) < 2:
                continue
            current_devices[parts[0]] = parts[1]
        if current_devices != self.detected_devices:
            self.detected_devices = current_devices
            self.parent.py3.log(f"available {self.device_type_pl}: {current_devices}")
        return current_devices

    def get_volume(self):
        output = self.command_output(["pactl", "list", self.device_type_pl]).strip()
        if self.use_default_device:
            self.device = self.get_default_device()
            self.update_device()
        try:
            muted, perc = self.re_volume.search(output).groups()
            muted = muted == "yes"
        except AttributeError:
            muted, perc = None, None
        return perc, muted

    def volume_up(self, delta):
        perc, muted = self.get_volume()
        if int(perc) + delta >= self.max_volume:
            change = f"{self.max_volume}%"
        else:
            change = f"+{delta}%"
        self.run_cmd(["pactl", "--", f"set-{self.device_type}-volume", self.device, change])

    def volume_down(self, delta):
        self.run_cmd(
            [
                "pactl",
                "--",
                f"set-{self.device_type}-volume",
                self.device,
                f"-{delta}%",
            ]
        )

    def toggle_mute(self):
        self.run_cmd(["pactl", f"set-{self.device_type}-mute", self.device, "toggle"])


class Py3status:
    """"""

    # available configuration parameters
    blocks = "_▁▂▃▄▅▆▇█"
    button_down = 5
    button_mute = 1
    button_up = 4
    cache_timeout = 10
    card = None
    channel = None
    command = None
    device = None
    format = r"[\?if=is_input 😮|♪]: {percentage}%"
    format_muted = r"[\?if=is_input 😶|♪]: muted"
    is_input = False
    max_volume = 120
    thresholds = [(0, "bad"), (20, "degraded"), (50, "good")]
    volume_delta = 5

    class Meta:
        def deprecate_function(config):
            # support old thresholds
            return {
                "thresholds": [
                    (0, "bad"),
                    (config.get("threshold_bad", 20), "degraded"),
                    (config.get("threshold_degraded", 50), "good"),
                ]
            }

        deprecated = {
            "function": [{"function": deprecate_function}],
            "remove": [
                {
                    "param": "threshold_bad",
                    "msg": "obsolete set using thresholds parameter",
                },
                {
                    "param": "threshold_degraded",
                    "msg": "obsolete set using thresholds parameter",
                },
                {
                    "param": "start_delay",
                    "msg": "obsolete parameter",
                },
            ],
        }

    def post_config_hook(self):
        if not self.command:
            commands = ["pamixer", "pactl", "amixer"]
            # pamixer, pactl requires pulseaudio to work
            if not self.py3.check_commands(["pulseaudio", "pipewire"]):
                commands = ["amixer"]
            self.command = self.py3.check_commands(commands)
        elif self.command not in ["amixer", "pamixer", "pactl"]:
            raise Exception(STRING_ERROR.format(self.command))
        elif not self.py3.check_commands(self.command):
            raise Exception(COMMAND_NOT_INSTALLED.format(self.command))
        if not self.command:
            raise Exception(STRING_NOT_AVAILABLE)

        # turn integers to strings
        if self.card is not None:
            self.card = str(self.card)
        if self.device is not None:
            self.device = str(self.device)

        self._init_backend()
        self.color_muted = self.py3.COLOR_MUTED or self.py3.COLOR_BAD

    def _init_backend(self):
        # attempt it a few times since the audio service may still be loading during startup
        for i in range(6):
            try:
                self.backend = globals()[self.command.capitalize()](self)
                return
            except Exception:  # noqa e722
                # try again later (exponential backoff)
                sleep(0.5 * 2**i)

        self.backend = globals()[self.command.capitalize()](self)

    def volume_status(self):
        perc, muted = self.backend.get_volume()
        color = None
        icon = None
        new_format = self.format

        if perc is None:
            perc = "?"
        elif muted:
            color = self.color_muted
            new_format = self.format_muted
        else:
            color = self.py3.threshold_get_color(perc)
            icon = self.blocks[
                min(
                    len(self.blocks) - 1,
                    math.ceil(int(perc) / 100 * (len(self.blocks) - 1)),
                )
            ]

        volume_data = {"icon": icon, "percentage": perc}

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(new_format, volume_data),
            "color": color,
        }

    def on_click(self, event):
        button = event["button"]
        if button == self.button_up:
            try:
                self.backend.volume_up(self.volume_delta)
            except TypeError:
                pass
        elif button == self.button_down:
            self.backend.volume_down(self.volume_delta)
        elif button == self.button_mute:
            self.backend.toggle_mute()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/vpn_status.py
================================================
"""
Drop-in replacement for i3status run_watch VPN module.

Expands on the i3status module by displaying the name of the connected vpn
using pydbus. Asynchronously updates on dbus signals unless check_pid is True.

Configuration parameters:
    cache_timeout: How often to refresh in seconds when check_pid is True.
        (default 10)
    check_pid: If True, act just like the default i3status module.
        (default False)
    format: Format of the output.
        (default 'VPN: {format_vpn}|VPN: no')
    format_vpn: display format for vpns (default '{name}')
    format_vpn_separator: show separator if more than one VPN (default ', ')
    pidfile: Same as i3status pidfile, checked when check_pid is True.
        (default '/sys/class/net/vpn0/dev_id')

Format placeholders:
    {format_vpn} format for VPNs

Format VPN placeholders:
    {name} The name and/or status of the VPN.
    {ipv4} The IPv4 address of the VPN
    {ipv6} The IPv6 address of the VPN

Color options:
    color_bad: VPN connected
    color_good: VPN down

Requires:
    dbus-python: to interact with dbus
    pygobject: which in turn requires libcairo2-dev, libgirepository1.0-dev

@author Nathan Smith <nathan AT praisetopia.org>

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'VPN: vpn0, tun0'}

off
{'color': '#FF0000', 'full_text': u'VPN: no'}
"""

from pathlib import Path
from threading import Thread
from time import sleep

import dbus
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GLib


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    check_pid = False
    format = "VPN: {format_vpn}|VPN: no"
    format_vpn = "{name}"
    format_vpn_separator = ", "
    pidfile = "/sys/class/net/vpn0/dev_id"

    def post_config_hook(self):
        self.thread_started = False
        self.active = []

    def _start_handler_thread(self):
        """Called once to start the event handler thread."""
        # Create handler thread
        t = Thread(target=self._start_loop)
        t.daemon = True

        # Start handler thread
        t.start()
        self.thread_started = True

    def _start_loop(self):
        """Starts main event handler loop, run in handler thread t."""
        # Create our main loop, get our bus, and add the signal handler
        loop = DBusGMainLoop(set_as_default=True)
        dbus.set_default_main_loop(loop)

        bus = dbus.SystemBus()
        bus.add_signal_receiver(self._vpn_signal_handler, path="/org/freedesktop/NetworkManager")
        # Initialize the already active connections
        manager = bus.get_object(
            "org.freedesktop.NetworkManager",
            "/org/freedesktop/NetworkManager",
        )
        interface = dbus.Interface(manager, "org.freedesktop.DBus.Properties")
        self.active = interface.Get("org.freedesktop.NetworkManager", "ActiveConnections")

        # Loop forever to listen for events
        loop = GLib.MainLoop()
        loop.run()

    def _vpn_signal_handler(self, *args):
        """Called on NetworkManager PropertiesChanged signal"""
        # Args is a dictionary of changed properties
        # We only care about changes in ActiveConnections
        active = "ActiveConnections"
        # Compare current ActiveConnections to last seen ActiveConnections
        for arg in args:
            if (
                isinstance(arg, dict)
                and active in arg
                and sorted(self.active) != sorted(arg[active])
            ):
                self.active = arg[active]
                self.py3.update()

    def _get_vpn_status(self):
        """Returns None if no VPN active, Id if active."""
        # Sleep for a bit to let any changes in state finish
        sleep(0.3)
        # Check if any active connections are a VPN
        bus = dbus.SystemBus()
        vpns = []
        for name in self.active:
            manager = bus.get_object(
                "org.freedesktop.NetworkManager",
                name,
            )
            interface = dbus.Interface(manager, "org.freedesktop.DBus.Properties")
            try:
                properties = interface.GetAll("org.freedesktop.NetworkManager.Connection.Active")
                if properties.get("Vpn") or properties.get("Type") in ("wireguard", "tun"):
                    ipv4, ipv6 = self._get_ips(bus, properties["Connection"])
                    vpns.append({"name": properties.get("Id"), "ipv4": ipv4, "ipv6": ipv6})
            except dbus.DBusException:
                # the connection id has disappeared
                pass

        return vpns

    def _get_ips(self, bus, connection_path):
        conn = bus.get_object("org.freedesktop.NetworkManager", connection_path)
        interface = dbus.Interface(conn, "org.freedesktop.NetworkManager.Settings.Connection")

        settings = interface.GetSettings()
        ipv4 = self._get_ip(settings["ipv4"])
        ipv6 = self._get_ip(settings["ipv6"])
        return ipv4, ipv6

    def _get_ip(self, ip_settings):
        address_data = ip_settings["address-data"]
        if address_data:
            return address_data[0].get("address")

        return None

    def _check_pid(self):
        """Returns True if pidfile exists, False otherwise."""
        return Path(self.pidfile).is_file()

    # Method run by py3status
    def vpn_status(self):
        """Returns response dict"""

        # Start signal handler thread if it should be running
        if not self.check_pid and not self.thread_started:
            self._start_handler_thread()

        vpns = []

        # If we are acting like the default i3status module
        if self.check_pid:
            if self._check_pid():
                format_vpn = self.py3.safe_format(self.format_vpn, {"name": "yes"})
                vpns.append(format_vpn)

        # Otherwise, find the VPN name, if it is active
        else:
            vpn_info = self._get_vpn_status()
            for vpn in vpn_info:
                format_vpn = self.py3.safe_format(self.format_vpn, vpn)
                vpns.append(format_vpn)

        color = self.py3.COLOR_GOOD if vpns else self.py3.COLOR_BAD

        # Format and create the response dict
        format_vpn_separator = self.py3.safe_format(self.format_vpn_separator)
        format_vpns = self.py3.composite_join(format_vpn_separator, vpns)
        full_text = self.py3.safe_format(self.format, {"format_vpn": format_vpns})
        response = {
            "full_text": full_text,
            "color": color,
            "cached_until": self.py3.CACHE_FOREVER,
        }

        # Cache forever unless in check_pid mode
        if self.check_pid:
            response["cached_until"] = self.py3.time_in(self.cache_timeout)
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/wanda_the_fish.py
================================================
"""
Display a fortune-telling, swimming fish.

Wanda has no use what-so-ever. It only takes up disk space and compilation time,
and if loaded, it also takes up precious bar space, memory, and cpu cycles.
Anybody found using it should be promptly sent for a psychiatric evaluation.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 0)
    format: display format for this module
        (default '{nomotion}[{fortune} ]{wanda}{motion}')
    fortune_timeout: refresh interval for fortune (default 60)

Format placeholders:
    {fortune} one of many aphorisms or vague prophecies
    {wanda} name of one of the most commonly kept freshwater aquarium fish
    {motion} biologically propelled motion through a liquid medium
    {nomotion} opposite behavior of motion to prevent modules from shifting

Optional:
    fortune-mod: the fortune cookie program from bsd games

Examples:
```
# disable motions when not in use
wanda_the_fish {
    format = '[\\?if=fortune {nomotion}][{fortune} ]'
    format += '{wanda}[\\?if=fortune {motion}]'
}

# no updates, no motions, yes fortunes, you click
wanda_the_fish {
    format = '[{fortune} ]{wanda}'
    cache_timeout = -1
}

# wanda moves, fortunes stays
wanda_the_fish {
    format = '[{fortune} ]{nomotion}{wanda}{motion}'
}

# wanda is swimming too fast, slow down wanda
wanda_the_fish {
    cache_timeout = 2
}
```

@author lasers

SAMPLE OUTPUT
[
    {'full_text': 'innovate, v.: To annoy people.'},
    {'full_text': ' <', 'color': '#ffa500'},
    {'full_text': '\xba', 'color': '#add8e6'},
    {'full_text': ',', 'color': '#ff8c00'},
    {'full_text': '))', 'color': '#ffa500'},
    {'full_text': '))>< ', 'color': '#ff8c00'},
]

idle
[
    {'full_text': ' <', 'color': '#ffa500'},
    {'full_text': '\xba', 'color': '#add8e6'},
    {'full_text': ',', 'color': '#ff8c00'},
    {'full_text': '))', 'color': '#ffa500'},
    {'full_text': '))>3', 'color': '#ff8c00'},
]

py3status
[
    {'full_text': 'py3status is so cool!'},
    {'full_text': ' <', 'color': '#ffa500'},
    {'full_text': '\xba', 'color': '#add8e6'},
    {'full_text': ',', 'color': '#ff8c00'},
    {'full_text': '))', 'color': '#ffa500'},
    {'full_text': '))>< ', 'color': '#ff8c00'},
]
"""

from time import time


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 0
    format = "{nomotion}[{fortune} ]{wanda}{motion}"
    fortune_timeout = 60

    def post_config_hook(self):
        body = (
            r"[\?color=orange&show <"
            r"[\?color=lightblue&show º]"
            r"[\?color=darkorange&show ,]))"
            r"[\?color=darkorange&show ))>{}]]"
        )
        wanda = [body.format(fin) for fin in ("<", ">", "<", "3")]
        self.wanda = [self.py3.safe_format(x) for x in wanda]
        self.wanda_length = len(self.wanda)
        self.index = 0

        self.fortune_command = ["fortune", "-as"]
        self.fortune = self.py3.storage_get("fortune") or None
        self.toggled = self.py3.storage_get("toggled") or False
        self.motions = {"motion": " ", "nomotion": ""}

        # deal with {new,old} timeout between storage
        fortune_timeout = self.py3.storage_get("fortune_timeout")
        timeout = None
        if self.fortune_timeout != fortune_timeout:
            timeout = time() + self.fortune_timeout
        self.time = timeout or self.py3.storage_get("time") or (time() + self.fortune_timeout)

    def _set_fortune(self, state=None, new=False):
        if not self.fortune_command:
            return
        if new:
            try:
                fortune_data = self.py3.command_output(self.fortune_command)
            except self.py3.CommandError:
                self.fortune = ""
                self.fortune_command = None
            else:
                self.fortune = " ".join(fortune_data.split())
                self.time = time() + self.fortune_timeout
        elif state is None:
            if self.toggled and time() >= self.time:
                self._set_fortune(new=True)
        else:
            self.toggled = state
            if state:
                self._set_fortune(new=True)
            else:
                self.fortune = None

    def _set_motion(self):
        for k in self.motions:
            self.motions[k] = "" if self.motions[k] else " "

    def _set_wanda(self):
        self.index += 1
        if self.index >= self.wanda_length:
            self.index = 0

    def wanda_the_fish(self):
        self._set_fortune()
        self._set_motion()
        self._set_wanda()

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(
                self.format,
                {
                    "fortune": self.fortune,
                    "motion": self.motions["motion"],
                    "nomotion": self.motions["nomotion"],
                    "wanda": self.wanda[self.index],
                },
            ),
        }

    def kill(self):
        self.py3.storage_set("toggled", self.toggled)
        self.py3.storage_set("fortune", self.fortune)
        self.py3.storage_set("fortune_timeout", self.fortune_timeout)
        self.py3.storage_set("time", self.time)

    def on_click(self, event):
        if not self.fortune_command:
            return
        self._set_fortune(not self.toggled)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/watson.py
================================================
"""
Display the current status of the watson time-tracking tool.

Configuration parameters:
    cache_timeout: Number of seconds before state is re-read
        (default 10)
    format: The format for module output.
        (default 'Project {project}{tag_str} started')
    state_file: Path to the file which watson uses to track its own state
        (default '~/.config/watson/state')

Format placeholders:
    {project} Name of the active project
    {tag_str} String-representation of the list of active tags

Requires:
    https://github.com/TailorDev/Watson: commandline time tracking tool

@author Markus Sommer (https://github.com/CryptoCopter)
@license BSD

SAMPLE OUTPUT
{'full_text': 'Project baking [milk, eggs] started', 'color': '#00FF00'}
"""

import json
from pathlib import Path
from typing import Dict, List, Union


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "Project {project}{tag_str} started"
    state_file = "~/.config/watson/state"

    def post_config_hook(self):
        self.state_file = Path(self.state_file).expanduser()

    def watson(self) -> Dict[str, str]:
        if not self.state_file.is_file():
            return {
                "full_text": "State file not found",
                "color": self.py3.COLOR_BAD,
                "cached_until": self.py3.time_in(seconds=self.cache_timeout),
            }

        try:
            with self.state_file.open("r") as f:
                session_data = json.load(f)
                output = self._format_output(session_data=session_data)
                output["cached_until"] = self.py3.time_in(seconds=self.cache_timeout)
                return output
        except OSError:
            return {
                "full_text": "Error reading file",
                "color": self.py3.COLOR_BAD,
                "cached_until": self.py3.time_in(seconds=self.cache_timeout),
            }
        except json.JSONDecodeError:
            return {
                "full_text": "Error decoding json",
                "color": self.py3.COLOR_BAD,
                "cached_until": self.py3.time_in(seconds=self.cache_timeout),
            }

    def _format_output(self, session_data: Dict[str, Union[str, int, List[str]]]) -> Dict[str, str]:
        if not session_data:
            return {"full_text": "No project started", "color": self.py3.COLOR_BAD}

        project = session_data["project"]
        tags = session_data["tags"]

        if tags:
            tag_str = " [{}]".format(", ".join(tags))
        else:
            tag_str = " "

        return {
            "full_text": self.py3.safe_format(
                self.format, {"project": project, "tag_str": tag_str}
            ),
            "color": self.py3.COLOR_GOOD,
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/weather_owm.py
================================================
r"""
Display ultimately customizable weather.

This module allows you to specify an icon for nearly every weather scenario
imaginable. The default configuration options lump many of the icons into
a few groups, and due to the limitations of UTF-8, this is really as expressive
as it gets.

This module uses OpenWeatherMap API (https://openweathermap.org).

Requires a 3.0 API key for OpenWeatherMap (OWM) with a subscription which this
module will try as hard as it can to stay under the free tier limit.

Setting `location` or `city` allows you to specify the location for the weather
you want displaying.

I would highly suggest you install an additional font, such as the incredible
(and free!) Weather Icons font (https://erikflowers.github.io/weather-icons),
which has icons for most weather scenarios. But, this will still work with
the i3bar default font, Deja Vu Sans Mono font, which has Unicode support.
You can see the (limited) weather icon support within Unicode in the defaults.

For more information, see the documentation
(https://openweathermap.org/weather-conditions) on what weather conditions are
supported. See the configuration options for how to specify each weather icon.

Configuration parameters:
    api_key: Your OpenWeatherMap API key
        See https://openweathermap.org/appid. Required!
        (default None)
    cache_timeout: The time between API polling in seconds
        It is recommended to keep this at a higher value to avoid rate
        limiting with the API's.
        (default 1800)
    city: The city to display for location information. If set,
        implicitly disables the Geo API for determining city name.
        (default None)
    country: The country to display for location information. If set,
        implicitly disables the Geo API for determining country name.
        (default None)
    forecast_days: Number of days to include in the forecast, including today
        (regardless of the 'forecast_include_today' flag)
        (default 3)
    forecast_include_today: Include today in the forecast? (Boolean)
        (default False)
    format: How to display the weather
        This also dictates the type of forecast. The placeholders here refer to
        the format_[...] variables found below.
        Available placeholders:
            icon, city, clouds, rain, snow, wind, humidity, pressure,
            temperature, sunrise, sunset, main, description, forecast
        (default '{city} {icon} {temperature}[ {rain}], {description} {forecast}')
    format_clouds: Formatting for cloud coverage (percentage)
        Available placeholders:
            icon, coverage
        (default '{icon} {coverage}%')
    format_forecast: Formatting for future forecasts
        Available placeholders:
            See 'format'
        This is similar to the 'format' field, but contains information
        for future weather. Notably, this does not include information about
        sunrise or sunset times.
        (default '{icon}')
    format_forecast_separator: Separator between entries in the forecast
        (default ' ')
    format_humidity: Formatting for humidity (percentage)
        Available placeholders:
            icon, humidity
        (default '{icon} {humidity}%')
    format_pressure: Formatting for atmospheric pressure
        Available placeholders:
            icon, pressure, sea_level
        (default '{icon} {pressure} hPa')
    format_rain: Formatting for rain volume over the past 3 hours
        Available placeholders:
            icon, amount
        (default '[\?if=amount {icon} {amount:.0f} {unit}]')
    format_snow: Formatting for snow volume over the past 3 hours
        Available placeholders:
            icon, amount
        (default '[\?if=amount {icon} {amount:.0f} {unit}]')
    format_sunrise: Formatting for sunrise time
        Note that this format accepts strftime/strptime placeholders to populate
        the output with the time information.
        Available placeholders:
            icon
        (default '{icon} %-I:%M %p')
    format_sunset: Formatting for sunset time
        This format accepts strftime/strptime placeholders to populate the
        output with the time information.
        Available placeholders:
            icon
        (default '{icon} %-I:%M %p')
    format_temperature: Formatting for temperature
        Available placeholders:
            current, icon, max, min
        (default '{icon} [\?color=all {current:.0f}°{unit}]')
    format_wind: Formatting for wind degree and speed
        The 'gust' option represents the speed of wind gusts in the wind unit.
        Available placeholders:
            icon, degree, speed, gust, direction
        (default '[\?if=speed {icon} {speed:.0f} {unit}]')
    icon_atmosphere: Icon for atmospheric conditions, like fog, smog, etc.
        (default '🌫')
    icon_cloud: Icon for clouds
        (default '☁')
    icon_extreme: Icon for extreme weather
        (default '⚠')
    icon_humidity: Icon for humidity
        (default '●')
    icon_pressure: Icon for pressure
        (default '◌')
    icon_rain: Icon for rain
        (default '🌧')
    icon_snow: Icon for snow
        (default '❄')
    icon_sun: Icon for sunshine
        (default '☼')
    icon_sunrise: Icon for sunrise
        (default '⇑')
    icon_sunset: Icon for sunset
        (default '⇓')
    icon_temperature: Icon for temperature
        (default '○')
    icon_thunderstorm: Icon for thunderstorms
        (default '⛈')
    icon_wind: Icon for wind or breeze
        (default '☴')
    icons: A dictionary relating weather code to icon
        See https://openweathermap.org/weather-conditions for a complete list
        of supported icons. This will fall-back to the listed icon if there is
        no specific icon present. However, options included here take precedent
        over the above 'icon_{...}' options.
        There are multiple ways to specify individual icons based on the id:
            * Use the key '601' to reference the condition with id = 601
              (snow)
            * Use the key '230_232' to reference a span of conditions
              inclusive, in this case conditions (230, 231, 232) (thunderstorm
              with drizzle)
        (default None)
    lang: An ISO 639-1 code for your language (two letters)
        (default 'en')
    location: A tuple of floats describing the desired weather location
        The tuple should follow the form (latitude, longitude), and if set,
        implicitly disables the Geo API for determining location.
        (default None)
    thresholds: Configure temperature colors based on limits
        The numbers specified inherit the unit of the temperature as configured.
        The default below is intended for Fahrenheit. If the set value is empty
        or None, the feature is disabled. You can specify this parameter using a
        dictionary:
            * Keys are names. You have the option of 'current', 'min', 'max',
              or 'all' to specify a threshold. The first three are tied to the
              various temperature values, the last sets the same threshold for
              all outputs. If both 'all' and one of the first three are set
              (lets say 'min' for this example), the threshold will default to
              be the value in 'min', not 'all'. This goes for any configuration
            * The values are lists of pairs, with temperature (in the
              configured unit) as the first and the color as the second
            * To use the thresholds color, place '\?color=all' in the
              formatting string for temperature, replacing 'all' with any of
              the valid threshold names for different coloring effects
            * To have smooth transitions between colors, consider setting the
              'gradients' configuration parameter to 'True', either in the
              global configuration, or in the module configuration!
        (default {'all': [(-100, '#0FF'), (0, '#00F'), (50, '#0F0'), (150, '#FF0')]})
    unit_rain: Unit for rain fall
        When specified, a unit may be any combination of upper and lower
        case, such as 'Ft', and still be considered valid as long as it is in
        the below options.
        Options:
            mm, cm, in
        (default 'in')
    unit_snow: Unit for snow fall
        Options:
            mm, cm, in
        (default 'in')
    unit_temperature: Unit for temperature
        Options:
            c, f, k
        (default 'F')
    unit_wind: Unit for wind speed
        Options:
            fsec, msec, mph, kmh, knot
        (default 'mph')

Format placeholders:
        {icon} The icon associated with a formatting section
    format_clouds:
        {coverage} Cloud coverage percentage
    format_humidity:
        {humidity} Humidity percentage
    format_pressure:
        {pressure} Current atmospheric pressure in Pascals
        {sea_level} Sea-level atmospheric pressure in Pascals.
    format_rain:
        {amount} Rainfall in the specified unit
        {unit} The unit specified
    format_snow:
        {amount} Snowfall in the specified unit
        {unit} The unit specified
    format_temperature:
        {current} Current temperature
        {max} Maximum temperature in the configured unit
        {min} Minimum temperature
        {unit} The unit specified
    format_wind:
        {degree} Current wind heading
        {direction} Letter reprents direction e.g. N,NE,E etc
        {gust} Wind gusts speed in the specified unit
        {speed} Wind speed
        {unit} The unit specified
    format only:
        {city} The name of the city where the weather is
        {country} The name of the country where the weather is
        {forecast} Output of format_forecast
    format, format_forecast:
        {clouds} Output of format_clouds
        {description} Natural description of the current weather
        {humidity} Output of format_humidity
        {main} Short description of the current weather
        {pressure} Output of format_pressure
        {snow} Output of format_snow
        {sunrise} Output of format_sunrise
        {sunset} Output of format_sunset
        {temperature} Output of format_temperature
        {wind} Output of format_wind

Examples:
```
# change icons
weather_owm {
    api_key = <my api key>
    icons = {
        '200': "☔"
        '230_232': "🌧"
    }
}

# set a city
weather_owm {
    api_key = <my api key>
    city = 'London'
}

# set a location
weather_owm {
    api_key = <my api key>
    location = (48.9342, 2.3548)  # Saint-Denis
}
```

@author alexoneill
@licence MIT

SAMPLE OUTPUT
{'full_text': 'New York ○ 30°F, mist ☁ ☁ ☁'}

diff
{'full_text': '○ 59°F, foggy  ☼ '}
"""

import datetime
import json

# API information
OWM_CURR_ENDPOINT = "https://api.openweathermap.org/data/2.5/weather?"
OWM_FUTURE_ENDPOINT = "https://api.openweathermap.org/data/2.5/forecast?"
OWM_ONECALL_ENDPOINT = "https://api.openweathermap.org/data/3.0/onecall?exclude=alerts,minutely"
IP_ENDPOINT = "http://geo.ultrabug.fr"

# Paths of information to extract from JSON
IP_CITY = "//city"
IP_COUNTRY = "//country"
IP_LAT = "//latitude"
IP_LON = "//longitude"
OWM_CLOUD_COVER = "//clouds/all"
OWM_DESC = "//weather:0/main"
OWM_DESC_LONG = "//weather:0/description"
OWM_HUMIDITY = "//humidity"
OWM_PRESSURE = "//pressure"
OWM_RAIN = "//rain/1h"
OWM_SNOW = "//snow/1h"
OWM_SUNRISE = "//sys/sunrise"
OWM_SUNSET = "//sys/sunset"
OWM_TEMP_DAY = "//temp/day"
OWM_TEMP_MAX = "//temp/max"
OWM_TEMP_MIN = "//temp/min"
OWM_WEATHER_ICON = "//weather:0/id"
OWM_WIND_SPEED = "//wind_speed"
OWM_WIND_GUST = "//wind_gust"
OWM_WIND_DEG = "//wind_deg"

OWN_CURRENT_WIND_DEG = "//wind/deg"
OWN_CURRENT_WIND_GUST = "//wind/gust"
OWN_CURRENT_WIND_SPEED = "//wind/speed"
OWM_CURRENT_TEMP = "//main/temp"
OWM_CURRENT_TEMP_MAX = "//main/temp_max"
OWM_CURRENT_TEMP_MIN = "//main/temp_min"
OWM_CURRENT_HUMIDITY = "//main/humidity"
OWM_CURRENT_PRESSURE = "//main/pressure"

# Units constants
RAIN_UNITS = {"mm", "cm", "in"}
SNOW_UNITS = RAIN_UNITS
TEMP_UNITS = {"c", "f", "k"}
WIND_UNITS = {"fsec", "msec", "mph", "kmh", "knot"}

# Conversion factors
FT_FROM_METER = 3.28084
IN_FROM_MM = 0.0393701
KMH_FROM_MSEC = 0.277778
MPH_FROM_MSEC = 2.23694
KNOT_FROM_MSEC = 1.94384

# Thresholds options
THRESHOLDS_ALL = "all"
THRESHOLDS_NAMES = {THRESHOLDS_ALL, "current", "min", "max"}

# Thresholds defaults
THRESHOLDS = {"all": [(-100, "#0FF"), (0, "#00F"), (50, "#0F0"), (150, "#FF0")]}


class Py3status:
    """ """

    # available configuration parameters
    api_key = None
    cache_timeout = 1800
    city = None
    country = None
    forecast_days = 3
    forecast_include_today = False
    format = "{city} {icon} {temperature}[ {rain}], {description} {forecast}"
    format_clouds = "{icon} {coverage}%"
    format_forecast = "{icon}"
    format_forecast_separator = " "
    format_humidity = "{icon} {humidity}%"
    format_pressure = "{icon} {pressure} hPa"
    format_rain = r"[\?if=amount {icon} {amount:.0f} {unit}]"
    format_snow = r"[\?if=amount {icon} {amount:.0f} {unit}]"
    format_sunrise = "{icon} %-I:%M %p"
    format_sunset = "{icon} %-I:%M %p"
    format_temperature = r"{icon} [\?color=all {current:.0f}°{unit}]"
    format_wind = r"[\?if=speed {icon} {speed:.0f} {unit}]"
    icon_atmosphere = "🌫"
    icon_cloud = "☁"
    icon_extreme = "⚠"
    icon_humidity = "●"
    icon_pressure = "◌"
    icon_rain = "🌧"
    icon_snow = "❄"
    icon_sun = "☼"
    icon_sunrise = "⇑"
    icon_sunset = "⇓"
    icon_temperature = "○"
    icon_thunderstorm = "⛈"
    icon_wind = "☴"
    icons = None
    lang = "en"
    location = None
    thresholds = THRESHOLDS
    unit_rain = "in"
    unit_snow = "in"
    unit_temperature = "F"
    unit_wind = "mph"

    class Meta:
        deprecated = {
            "remove": [{"param": "offset_gmt", "msg": "obsolete"}],
            "rename": [
                {
                    "param": "forecast_text_separator",
                    "new": "format_forecast_separator",
                    "msg": "obsolete parameter, use format_forecast_separator",
                }
            ],
        }

        update_config = {
            "update_placeholder_format": [
                {
                    "placeholder_formats": {"amount": ":.2f"},
                    "format_strings": ["format_rain", "format_snow"],
                },
                {
                    "placeholder_formats": {
                        "max": ":.1f",
                        "min": ":.1f",
                        "current": ":.1f",
                    },
                    "format_strings": ["format_temperature"],
                },
                {
                    "placeholder_formats": {"speed": ":.1f", "gust": ":.1f"},
                    "format_strings": ["format_wind"],
                },
            ],
        }

    def _get_icons(self):
        if self.icons is None:
            self.icons = {}

        # Defaults for weather ranges
        defaults = {
            "200_299": self.icon_thunderstorm,
            "300_399": self.icon_rain,
            "500_599": self.icon_rain,
            "600_699": self.icon_snow,
            "700_799": self.icon_atmosphere,
            "800": self.icon_sun,
            "801_809": self.icon_cloud,
            "900_909": self.icon_extreme,
            "950_959": self.icon_wind,
            "960_999": self.icon_extreme,
        }

        # Handling ranges from OpenWeatherMap
        data = {}
        for source in (defaults, self.icons):
            for key in source:
                if not key.replace("_", "").isdigit():
                    raise Exception(f"Invalid icon id: ({key})")

                if "_" in key:
                    if key.count("_") != 1:
                        raise Exception("fInvalid icon range: {key}")

                    # Populate each code
                    start, _, end = key.partition("_")
                    for code in range(int(start), int(end) + 1):
                        data[code] = source[key]

                else:
                    data[int(key)] = source[key]

        return data

    def post_config_hook(self):
        # Verify the API key
        if self.api_key is None:
            raise Exception(
                "API Key for OpenWeatherMap cannot be empty!"
                " Go to https://openweathermap.org/appid to"
                " get an API Key."
            )

        # Generate our icon array
        self.icons = self._get_icons()

        # Implement safe-to-reload rate limit
        cached_day = datetime.datetime.now(datetime.UTC).strftime("%Y%m%d")
        self.cached_hits = json.loads(
            self.py3.storage_get("cached_hits") or json.dumps({cached_day: 0})
        )
        self.cached_onecall_response = self.py3.storage_get("cached_onecall_response")

        # We want to make sure users to not exceed the request limit
        # to 3.0 API and get billed while taking into account that
        # OWM does refresh its API data every 10min anyway.
        self.cache_timeout = max(600, self.cache_timeout)

        # Verify the units configuration
        if self.unit_rain.lower() not in RAIN_UNITS:
            raise Exception("unit_rain is not recognized")
        if self.unit_snow.lower() not in SNOW_UNITS:
            raise Exception("unit_snow is not recognized")
        if self.unit_temperature.lower() not in TEMP_UNITS:
            raise Exception("unit_temperature is not recognized")
        if self.unit_wind.lower() not in WIND_UNITS:
            raise Exception("unit_wind is not recognized")

        # Check thresholds for validity
        if set(self.thresholds) > THRESHOLDS_NAMES:
            raise Exception("threshold name(s) are not recognized")

        # Copy thresholds if available
        if THRESHOLDS_ALL in self.thresholds:
            for name in THRESHOLDS_NAMES - {THRESHOLDS_ALL}:
                if name not in self.thresholds:
                    self.thresholds[name] = self.thresholds[THRESHOLDS_ALL]

        # Initialize per-format thresholds
        self.thresholds_init = {}
        for name in ("format_humidity",):
            self.thresholds_init[name] = self.py3.get_color_names_list(getattr(self, name))

    def _make_req(self, url, params=None):
        # Make a request expecting a JSON response
        req = self.py3.request(url, params=params)
        if req.status_code != 200:
            data = req.json()
            if data and "message" in data:
                msg = data["message"]
            else:
                msg = "{_error_message} {_status_code}".format(**vars(req))
            self.py3.error(msg)

        return req.json()

    def _jpath(self, data, query, default=None):
        # Take the query expression and drill down into the given dictionary
        parts = query.strip("/").split("/")
        for part in parts:
            try:
                # This represents a key:index expression, representing first
                # selecting a key, then an index
                if ":" in part:
                    (part, index) = tuple(part.split(":"))
                    data = data[part]
                    data = data[int(index)]

                # Select a portion of the dictionary by key in the path
                else:
                    data = data[part]

            # Failed, so return the default
            except (KeyError, IndexError, TypeError):
                return default

        return data

    def _get_loc_tz_info(self):
        # Preference a user-set location
        if all(x is not None for x in (self.location, self.city, self.country)):
            return (self.location, self.city, self.country)

        data = {}
        lat_lng = None
        # Contact the Geo API
        if not (self.location or self.city):
            try:
                data = self._make_req(IP_ENDPOINT)
            except (self.py3.RequestException, self.py3.RequestURLError):
                pass

            # Extract location data
            if self.location is None:
                lat_lng = (
                    self._jpath(data, IP_LAT, "0"),
                    self._jpath(data, IP_LON, "0"),
                )

        if self.location:
            lat_lng = self.location

        # Extract city
        city = self.city
        if self.city is None:
            city = self._jpath(data, IP_CITY, "")

        # Extract country
        country = self.country
        if self.country is None:
            country = self._jpath(data, IP_COUNTRY, "")

        return (lat_lng, city, country)

    def _get_current_weather(self, extras):
        # Get and process the current weather
        params = {"appid": self.api_key, "lang": self.lang}
        extras.update(params)
        return self._make_req(OWM_CURR_ENDPOINT, extras)

    def _get_forecast(self, extras):
        # Get the next few days
        if self.forecast_days == 0:
            return []
        # Get raw data
        params = {
            "appid": self.api_key,
            "lang": self.lang,
            "cnt": self.forecast_days + 1,
        }
        extras.update(params)
        data = self._make_req(OWM_FUTURE_ENDPOINT, extras)
        # Extract forecast
        weathers = data["list"]
        return weathers[:-1] if self.forecast_include_today else weathers[1:]

    def _get_onecall(self, extras):
        # Get and process the current weather
        params = {"appid": self.api_key, "lang": self.lang}
        extras.update(params)
        return self._make_req(OWM_ONECALL_ENDPOINT, extras)

    def _get_icon(self, wthr):
        # Lookup the icon from the weather code (default sunny)
        return self.icons[self._jpath(wthr, OWM_WEATHER_ICON, 800)]

    def _format_clouds(self, wthr):
        # Format the cloud cover (default clear)
        return self.py3.safe_format(
            self.format_clouds,
            {
                "icon": self.icon_cloud,
                "coverage": self._jpath(wthr, OWM_CLOUD_COVER, 0),
            },
        )

    def _format_rain(self, wthr):
        # Format rain fall
        rain = self._jpath(wthr, OWM_RAIN, 0)

        # Data comes as mm
        inches = rain * IN_FROM_MM

        options = {
            "mm": rain,
            "cm": rain / 10,
            "in": inches,
        }

        # Format the rain fall
        return self.py3.safe_format(
            self.format_rain,
            {
                "icon": self.icon_rain,
                "amount": options[self.unit_rain.lower()],
                "unit": self.unit_rain,
            },
        )

    def _format_snow(self, wthr):
        # Format snow fall
        snow = self._jpath(wthr, OWM_SNOW, 0)

        # Data comes as mm
        inches = snow * IN_FROM_MM

        options = {
            "mm": snow,
            "cm": snow / 10,
            "in": inches,
        }

        # Format the snow fall
        return self.py3.safe_format(
            self.format_snow,
            {
                "icon": self.icon_snow,
                "amount": options[self.unit_snow.lower()],
                "unit": self.unit_snow,
            },
        )

    def _format_wind(self, wthr):
        wind = {
            "deg": self._jpath(wthr, OWM_WIND_DEG, self._jpath(wthr, OWN_CURRENT_WIND_DEG, 0)),
            "gust": self._jpath(wthr, OWM_WIND_GUST, self._jpath(wthr, OWN_CURRENT_WIND_GUST, 0)),
            "speed": self._jpath(
                wthr, OWM_WIND_SPEED, self._jpath(wthr, OWN_CURRENT_WIND_SPEED, 0)
            ),
        }

        # Speed and Gust
        msec_speed = wind["speed"] if ("speed" in wind) else 0
        msec_gust = wind["gust"] if ("gust" in wind) else 0

        options = {
            "fsec": {
                "speed": msec_speed * FT_FROM_METER,
                "gust": msec_gust * FT_FROM_METER,
            },
            "msec": {"speed": msec_speed, "gust": msec_gust},
            "mph": {
                "speed": msec_speed * MPH_FROM_MSEC,
                "gust": msec_gust * MPH_FROM_MSEC,
            },
            "kmh": {
                "speed": msec_speed * KMH_FROM_MSEC,
                "gust": msec_gust * KMH_FROM_MSEC,
            },
            "knot": {
                "speed": msec_speed * KNOT_FROM_MSEC,
                "gust": msec_gust * KNOT_FROM_MSEC,
            },
        }

        # Get the choice and add more
        choice = options[self.unit_wind.lower()]
        choice["icon"] = self.icon_wind
        choice["degree"] = wind["deg"] if ("deg" in wind) else 0
        if wind["deg"] >= 20 and wind["deg"] < 65:
            direction = "NE"
        elif wind["deg"] >= 65 and wind["deg"] < 110:
            direction = "E"
        elif wind["deg"] >= 110 and wind["deg"] < 155:
            direction = "SE"
        elif wind["deg"] >= 155 and wind["deg"] < 200:
            direction = "S"
        elif wind["deg"] >= 200 and wind["deg"] < 245:
            direction = "SW"
        elif wind["deg"] >= 245 and wind["deg"] < 290:
            direction = "W"
        elif wind["deg"] >= 290 and wind["deg"] < 335:
            direction = "NW"
        else:
            direction = "N"
        choice["direction"] = direction
        choice["unit"] = self.unit_wind

        # Format the wind speed
        return self.py3.safe_format(self.format_wind, choice)

    def _format_humidity(self, wthr):
        # Format the humidity (default zero humidity)
        humidity_data = {
            "icon": self.icon_humidity,
            "humidity": self._jpath(wthr, OWM_HUMIDITY, self._jpath(wthr, OWM_CURRENT_HUMIDITY, 0)),
        }

        for x in self.thresholds_init["format_humidity"]:
            if x in humidity_data:
                self.py3.threshold_get_color(humidity_data[x], x)

        return self.py3.safe_format(self.format_humidity, humidity_data)

    def _format_pressure(self, wthr):
        # Get data and add the icon
        pressure = {
            "icon": self.icon_pressure,
            "pressure": self._jpath(wthr, OWM_PRESSURE, self._jpath(wthr, OWM_CURRENT_PRESSURE, 0)),
        }

        # Format the barometric pressure
        return self.py3.safe_format(self.format_pressure, pressure)

    def _format_temp(self, wthr):
        # Get Kelvin data (default absolute zero)
        kelvin = {
            "day": self._jpath(wthr, OWM_TEMP_DAY, self._jpath(wthr, OWM_CURRENT_TEMP, "")),
            "max": self._jpath(wthr, OWM_TEMP_MAX, self._jpath(wthr, OWM_CURRENT_TEMP_MAX, "")),
            "min": self._jpath(wthr, OWM_TEMP_MIN, self._jpath(wthr, OWM_CURRENT_TEMP_MIN, "")),
        }

        # Temperature conversion methods
        def kToC(val):
            return val - 273.15

        def kToF(val):
            return val * 9 / 5 - 459.67

        options = {
            "c": {
                "current": kToC(kelvin["day"]),
                "max": kToC(kelvin["max"]),
                "min": kToC(kelvin["min"]),
            },
            "f": {
                "current": kToF(kelvin["day"]),
                "max": kToF(kelvin["max"]),
                "min": kToF(kelvin["min"]),
            },
            "k": {
                "current": kelvin["day"],
                "max": kelvin["max"],
                "min": kelvin["min"],
            },
        }

        # Get the choice and add more
        choice = options[self.unit_temperature.lower()]
        choice["icon"] = self.icon_temperature
        choice["unit"] = self.unit_temperature

        # Calculate thresholds
        for name in THRESHOLDS_NAMES - {THRESHOLDS_ALL}:
            # Try to apply the specific threshold
            if name in self.thresholds:
                self.py3.threshold_get_color(choice[name], name)

        # Format the temperature
        return self.py3.safe_format(self.format_temperature, choice)

    def _format_sunrise(self, wthr):
        # Get the time for sunrise (default is the start of time)
        dt = datetime.datetime.fromtimestamp(self._jpath(wthr, OWM_SUNRISE, 0))

        # Format the sunrise
        replaced = dt.strftime(self.format_sunrise)
        return self.py3.safe_format(replaced, {"icon": self.icon_sunrise})

    def _format_sunset(self, wthr):
        # Get the time for sunset (default is the start of time)
        dt = datetime.datetime.fromtimestamp(self._jpath(wthr, OWM_SUNSET, 0))

        # Format the sunset
        replaced = dt.strftime(self.format_sunset)
        return self.py3.safe_format(replaced, {"icon": self.icon_sunset})

    def _format_dict(self, wthr, city, country):
        data = {
            # Standard options
            "icon": self._get_icon(wthr),
            "clouds": self._format_clouds(wthr),
            "rain": self._format_rain(wthr),
            "snow": self._format_snow(wthr),
            "wind": self._format_wind(wthr),
            "humidity": self._format_humidity(wthr),
            "pressure": self._format_pressure(wthr),
            "temperature": self._format_temp(wthr),
            "sunrise": self._format_sunrise(wthr),
            "sunset": self._format_sunset(wthr),
            # Descriptions (defaults to empty)
            "main": self._jpath(wthr, OWM_DESC, "").lower(),
            "description": self._jpath(wthr, OWM_DESC_LONG, "").lower(),
            # Location information
            "city": city,
            "country": country,
        }

        return data

    def _format(self, current_wthr, fcsts, city, country):
        # Format all sections
        today = self._format_dict(current_wthr, city, country)

        # Insert forecasts
        forecasts = []
        for day in fcsts:
            future = self._format_dict(day, city, country)
            forecasts.append(self.py3.safe_format(self.format_forecast, future))

        # Give the final format
        format_forecast_separator = self.py3.safe_format(self.format_forecast_separator)
        today["forecast"] = self.py3.composite_join(format_forecast_separator, forecasts)

        return self.py3.safe_format(self.format, today)

    def weather_owm(self):
        # Prepare rate limit cache
        cached_day = datetime.datetime.now(datetime.UTC).strftime("%Y%m%d")
        cached_hits = self.cached_hits.get(cached_day, 0)
        # Get weather information
        loc_tz_info = self._get_loc_tz_info()
        text = ""
        if loc_tz_info is not None:
            (coords, city, country) = loc_tz_info
            if coords:
                current_api_params = {"lat": coords[0], "lon": coords[1]}
            elif city:
                current_api_params = {"q": city}

            # try to get a nice city name
            current_wthr = self._get_current_weather(current_api_params)
            owm_city = current_wthr.get("name") or city or "unknown"
            # get the best country we can
            if not country:
                sys = current_wthr.get("sys", {})
                country = sys.get("country", "unknown")
            try:
                lat = current_wthr["coord"]["lat"]
                lon = current_wthr["coord"]["lon"]
            except Exception:
                raise Exception("no latitude/longitude found for your config")

            # onecall = forecasts rate limited
            if cached_hits < 999:
                onecall_api_params = {"lat": lat, "lon": lon}
                onecall = self._get_onecall(onecall_api_params)
                # update and store caches
                self.cached_onecall_response = onecall
                self.cached_hits[cached_day] = cached_hits + 1
                self.py3.storage_set("cached_onecall_response", onecall)
                self.py3.storage_set(
                    "cached_hits", json.dumps({cached_day: self.cached_hits[cached_day]})
                )
            else:
                onecall = self.cached_onecall_response
            onecall_daily = onecall["daily"]

            fcsts_days = self.forecast_days + 1
            text = self._format(
                current_wthr,
                onecall_daily[1:fcsts_days],
                owm_city,
                country,
            )

        return {
            "full_text": text,
            "cached_until": self.py3.time_in(seconds=self.cache_timeout),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from os import getenv

    from py3status.module_test import module_test

    def colorize(names, color="lightgreen", separator=None):
        if separator is None:
            separator = r"[\?color={c}&show  / ]".format(c=color)
        body = r"[\?color={c}&show {n}] [\?color={n} {{{n}}}]"
        return separator.join([body.format(c=color, n=name) for name in names])

    # fmt: off
    weather_placeholders = [
        "icon", "clouds", "description", "humidity", "main", "pressure", "rain",
        "snow", "sunrise", "sunset", "temperature", "wind",
    ]
    format_placeholders = ["city", "country"] + weather_placeholders + ["forecast"]
    # fmt: on

    config = {
        # Miscellaneous
        "api_key": getenv("OWM_API_KEY"),
        "icons": {"200": "☔", "230_232": "🌧"},
        "format_forecast_separator": r"\?color=tomato  separator ",
        "forecast_days": 1,
        # Format
        "format": colorize(format_placeholders, "lightblue"),
        "format_forecast": colorize(weather_placeholders, "pink"),
        # Weather
        "format_clouds": colorize(["icon", "coverage"]),
        "format_humidity": colorize(["icon", "humidity"]),
        "format_pressure": colorize(["icon", "pressure", "sea_level"]),
        "format_rain": colorize(["icon", "amount", "unit"]),
        "format_snow": colorize(["icon", "amount", "unit"]),
        "format_temperature": colorize(["icon", "max", "min", "current", "unit"]),
        "format_wind": colorize(["icon", "degree", "direction", "gust", "speed", "unit"]),
    }

    module_test(Py3status, config)



================================================
FILE: py3status/modules/whatismyip.py
================================================
"""
Display public IP address and online status.

Configuration parameters:
    button_refresh: mouse button to refresh this module (default 2)
    button_toggle: mouse button to toggle between states (default 1)
    cache_timeout: how often we refresh this module in seconds (default 60)
    expected: define expected values for format placeholders,
        and use `color_degraded` to show the output of this module
        if any of them does not match the actual value.
        This should be a dict eg {'country': 'France'}
        (default None)
    format: available placeholders are {ip} and {country},
        as well as any other key in JSON fetched from `url_geo`
        (default '{ip}')
    hide_when_offline: hide the module output when offline (default False)
    icon_off: what to display when offline (default '■')
    icon_on: what to display when online (default '●')
    mode: default mode to display is 'ip' or 'status' (click to toggle)
        (default 'ip')
    url_geo: IP to check for geo location (must output json)
        (default 'https://ifconfig.co/json')

Format placeholders:
    {icon}        eg ●, ■
    {country}     eg France
    {country_iso} eg FR
    {ip}          eg 123.45.67.890
    {ip_decimal}  eg 1234567890
    {city}        eg Paris
    any other key in JSON fetched from `url_geo`

Color options:
    color_bad: Offline
    color_degraded: Output is unexpected (IP/country mismatch, etc.)
    color_good: Online

Examples:
```
# ip choices
whatismyip {
    url_geo = "https://ifconfig.co/json"
    # url_geo = "https://api.ip2location.io"
    # url_geo = "https://ipinfo.io/json"
    # url_geo = "http://ip-api.com/json"
}
```

@author ultrabug, Cyril Levis (@cyrinux)

SAMPLE OUTPUT
{'full_text': '37.48.108.0'}

geo
{'full_text': '37.48.108.0 France'}

mode
{'color': '#00FF00', 'full_text': u'\u25cf'}
"""

import time

URL_GEO_OLD_DEFAULT = "http://ip-api.com/json"
URL_GEO_NEW_DEFAULT = "https://ifconfig.co/json"


class Py3status:
    """ """

    # available configuration parameters
    button_refresh = 2
    button_toggle = 1
    cache_timeout = 60
    expected = None
    format = "{ip}"
    hide_when_offline = False
    icon_off = "■"
    icon_on = "●"
    mode = "ip"
    url_geo = URL_GEO_NEW_DEFAULT

    class Meta:
        deprecated = {
            "remove": [
                {"param": "url", "msg": "obsolete parameter, use `url_geo` instead"},
                {"param": "negative_cache_timeout", "msg": "obsolete parameter"},
            ],
            "rename": [
                {
                    "param": "format_online",
                    "new": "icon_on",
                    "msg": "obsolete parameter, use `icon_on` instead",
                },
                {
                    "param": "format_offline",
                    "new": "icon_off",
                    "msg": "obsolete parameter, use `icon_off` instead",
                },
                {
                    "param": "timeout",
                    "new": "request_timeout",
                    "msg": "obsolete parameter use `request_timeout`",
                },
            ],
        }

    def post_config_hook(self):
        if self.expected is None:
            self.expected = {}

        # Backwards compatibility
        self.substitutions = {}
        if self.url_geo == URL_GEO_NEW_DEFAULT:
            self.substitutions["country_code"] = "country_iso"
        elif self.url_geo == URL_GEO_OLD_DEFAULT:
            self.substitutions["ip"] = "query"

        self.ip_data = {}
        self.toggled = False
        self.idle_time = 0

    def _get_my_ip_info(self):
        try:
            info = self.py3.request(self.url_geo).json()
            for old, new in self.substitutions.items():
                info[old] = info.get(new)
            return info
        except self.py3.RequestException:
            return None

    def whatismyip(self):
        # refresh
        current_time = time.monotonic()
        refresh = current_time >= self.idle_time

        # time
        if refresh:
            self.idle_time = current_time + self.cache_timeout
            cached_until = self.cache_timeout
        else:
            cached_until = self.idle_time - current_time

        # button
        if self.toggled and not refresh:
            self.toggled = False
            info = self.ip_data
        else:
            info = self.ip_data = self._get_my_ip_info()

        response = {"cached_until": self.py3.time_in(cached_until)}

        if info is None and self.hide_when_offline:
            response["full_text"] = ""
        elif info is not None:
            info["icon"] = self.icon_on
            response["color"] = self.py3.COLOR_GOOD
            for key, val in self.expected.items():
                if val != info.get(key):
                    response["color"] = self.py3.COLOR_DEGRADED
                    break
            if self.mode == "ip":
                response["full_text"] = self.py3.safe_format(self.format, info)
            else:
                response["full_text"] = self.icon_on
        else:
            response["full_text"] = self.icon_off
            response["color"] = self.py3.COLOR_BAD

        return response

    def on_click(self, event):
        """
        Toggle between display modes 'ip' and 'status'
        """
        button = event["button"]
        if button == self.button_toggle:
            self.toggled = True
            if self.mode == "ip":
                self.mode = "status"
            else:
                self.mode = "ip"
        elif button == self.button_refresh:
            self.idle_time = 0
        else:
            self.py3.prevent_refresh()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/whoami.py
================================================
"""
Display logged-in username.

Configuration parameters:
    format: display format for this module (default '{username}')

Format placeholders:
    {hostname} display current hostname
    {username} display current username

Inspired by i3 FAQ:
    https://faq.i3wm.org/question/1618/add-user-name-to-status-bar.1.html

@author ultrabug

SAMPLE OUTPUT
{'full_text': u'ultrabug'}
"""

from getpass import getuser
from socket import gethostname


class Py3status:
    """ """

    # available configuration parameters
    format = "{username}"

    class Meta:
        deprecated = {"remove": [{"param": "cache_timeout", "msg": "obsolete parameter"}]}

    def whoami(self):
        return {
            "cached_until": self.py3.CACHE_FOREVER,
            "full_text": self.py3.safe_format(
                self.format, {"username": getuser(), "hostname": gethostname()}
            ),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/wifi.py
================================================
"""
Display WiFi bit rate, quality, signal and SSID using iw.

Configuration parameters:
    bitrate_bad: Bad bit rate in Mbit/s (default 26)
    bitrate_degraded: Degraded bit rate in Mbit/s (default 53)
    blocks: a string, where each character represents quality level
        (default "_▁▂▃▄▅▆▇█")
    cache_timeout: Update interval in seconds (default 10)
    device: specify name or MAC address of device to use, otherwise auto
        (default None)
    down_color: Output color when disconnected, possible values:
        "good", "degraded", "bad" (default "bad")
    format: Display format for this module
        (default 'W: {bitrate} {bitrate_unit} {signal_percent}% {ssid}|W: down')
    signal_bad: Bad signal strength in percent (default 29)
    signal_degraded: Degraded signal strength in percent (default 49)
    thresholds: specify color thresholds to use (default [])

Format placeholders:
    {bitrate} Display bitrate
    {bitrate_unit} Display bitrate unit
    {device} Display device name
    {freq_ghz} Network frequency in Ghz
    {freq_mhz} Network frequency in Mhz
    {icon} Character representing the quality based on bitrate,
        as defined by the 'blocks'
    {ip} Display IP address
    {signal_dbm} Display signal in dBm
    {signal_percent} Display signal in percent
    {ssid} Display SSID

Color options:
    color_bad: Signal strength signal_bad or lower
    color_degraded: Signal strength signal_degraded or lower
    color_good: Signal strength above signal_degraded

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    iw: cli configuration utility for wireless devices
    ip: only for {ip}. may be part of iproute2: ip routing utilities

Notes:
    Some distributions require commands to be run with privileges. You can
    give commands some root rights to run without a password by editing
    sudoers file, i.e., `sudo visudo`, and add a line that requires sudo.
    '<user> ALL=(ALL) NOPASSWD:/sbin/iw dev,/sbin/iw dev [a-z]* link'
    '<user> ALL=(ALL) NOPASSWD:/sbin/ip addr list [a-z]*'

@author Markus Weimar <mail@markusweimar.de>
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'W: 54.0 MBit/s 100% Chicken Remixed'}
"""

import math
import re

DEFAULT_FORMAT = "W: {bitrate} {bitrate_unit} {signal_percent}% {ssid}|W: down"
STRING_NOT_INSTALLED = "iw not installed"
STRING_NO_DEVICE = "no available device"


class Py3status:
    """ """

    # available configuration parameters
    bitrate_bad = 26
    bitrate_degraded = 53
    blocks = "_▁▂▃▄▅▆▇█"
    cache_timeout = 10
    device = None
    down_color = "bad"
    format = DEFAULT_FORMAT
    signal_bad = 29
    signal_degraded = 49
    thresholds = []

    class Meta:
        deprecated = {
            "remove": [
                {"param": "use_sudo", "msg": "obsolete"},
                {"param": "round_bitrate", "msg": "obsolete"},
            ]
        }
        update_config = {
            "update_placeholder_format": [
                {
                    "placeholder_formats": {"signal_percent": ":g", "bitrate": ":g"},
                    "format_strings": ["format"],
                }
            ]
        }

    def post_config_hook(self):
        iw = self.py3.check_commands(["iw", "/sbin/iw"])
        if not iw:
            raise Exception(STRING_NOT_INSTALLED)

        # get wireless interface
        try:
            data = self.py3.command_output([iw, "dev"])
        except self.py3.CommandError as ce:
            raise Exception(ce.error.strip())
        last_device = None
        for line in data.splitlines()[1:]:
            if not line.startswith("\t\t"):
                last_device = None
            if "Interface" in line or ("addr" in line and last_device is not None):
                intf_or_addr = line.split()[-1]
                if "Interface" in line:
                    last_device = intf_or_addr
                if not self.device or intf_or_addr.lower() == self.device.lower():
                    self.device = last_device
                    break
        else:
            device = f" `{self.device}`" if self.device else ""
            raise Exception(STRING_NO_DEVICE + device)

        self._max_bitrate = 0
        self._ssid = ""
        self.color_down = getattr(self.py3, f"COLOR_{self.down_color.upper()}")
        self.commands = set()
        self.ip_addr_list_id = ["ip", "addr", "list", self.device]
        self.iw_dev_id_link = [iw, "dev", self.device, "link"]
        self.signal_dbm_bad = self._percent_to_dbm(self.signal_bad)
        self.signal_dbm_degraded = self._percent_to_dbm(self.signal_degraded)
        self.thresholds_init = self.py3.get_color_names_list(self.format)

        # DEPRECATION WARNING
        format_down = getattr(self, "format_down", None)
        format_up = getattr(self, "format_up", None)

        if self.format != DEFAULT_FORMAT:
            return

        if format_up or format_down:
            self.format = "{}|{}".format(
                format_up or "W: {bitrate} {bitrate_unit} {signal_percent}% {ssid}",
                format_down or "W: down",
            )
            msg = "DEPRECATION WARNING: you are using old style configuration "
            msg += "parameters you should update to use the new format."
            self.py3.log(msg)

    def _dbm_to_percent(self, dbm):
        return 2 * (dbm + 100)

    def _percent_to_dbm(self, percent):
        return (percent / 2) - 100

    def _get_wifi_data(self, command):
        for _ in range(2):
            try:
                return self.py3.command_output(command)
            except self.py3.CommandError as ce:
                if str(command) not in self.commands:
                    command[0:0] = ["sudo", "-n"]
                    continue
                msg = ce.error.strip().replace("sudo", " ".join(command[2:]))
                self.py3.error(msg, self.py3.CACHE_FOREVER)
            finally:
                self.commands.add(str(command))

    def wifi(self):
        iw = self._get_wifi_data(self.iw_dev_id_link)

        bitrate = None
        bitrate_unit = None
        freq_ghz = None
        freq_mhz = None
        icon = None
        ip = None
        signal_dbm = None
        signal_percent = None
        ssid = None
        color = self.color_down
        quality = 0

        # bitrate
        bitrate_out = re.search(r"tx bitrate: ([^\s]+) ([^\s]+)", iw)
        if bitrate_out:
            bitrate = float(bitrate_out.group(1))
            bitrate_unit = bitrate_out.group(2)
            if bitrate_unit == "Gbit/s":
                bitrate *= 1000

        # signal
        signal_out = re.search(r"signal: ([\-0-9]+)", iw)
        if signal_out:
            signal_dbm = int(signal_out.group(1))
            signal_percent = min(self._dbm_to_percent(signal_dbm), 100)

        # ssid
        ssid_out = re.search(r"SSID: (.+)", iw)
        if ssid_out:
            ssid = ssid_out.group(1)
            # `iw` command would prints unicode SSID like `\xe8\x8b\x9f`
            # the `ssid` here would be '\\xe8\\x8b\\x9f' (note the escape)
            # it needs to be decoded using 'unicode_escape', to '苟'
            ssid = ssid.encode("latin-1").decode("unicode_escape")
            ssid = ssid.encode("latin-1").decode("utf-8")

        # frequency
        freq_out = re.search(r"freq: ([\-0-9]+)", iw)
        if freq_out:
            freq_mhz = int(freq_out.group(1))
            freq_ghz = freq_mhz / 1000

        # ip
        if self.py3.format_contains(self.format, "ip"):
            ip_info = self._get_wifi_data(self.ip_addr_list_id)
            ip_match = re.search(r"inet\s+([0-9.]+)", ip_info)
            if ip_match:
                ip = ip_match.group(1)

        # reset _max_bitrate if we have changed network
        if self._ssid != ssid:
            self._ssid = ssid
            self._max_bitrate = self.bitrate_degraded
        if bitrate:
            if bitrate > self._max_bitrate:
                self._max_bitrate = bitrate
            quality = int((bitrate / self._max_bitrate) * 100)

        # wifi
        if ssid is not None:
            icon = self.blocks[math.ceil(quality / 100 * (len(self.blocks) - 1))]
            color = self.py3.COLOR_GOOD
            if bitrate:
                if bitrate <= self.bitrate_bad:
                    color = self.py3.COLOR_BAD
                elif bitrate <= self.bitrate_degraded:
                    color = self.py3.COLOR_DEGRADED
            if signal_dbm:
                if signal_dbm <= self.signal_dbm_bad:
                    color = self.py3.COLOR_BAD
                elif signal_dbm <= self.signal_dbm_degraded:
                    color = self.py3.COLOR_DEGRADED

        wifi_data = {
            "bitrate": bitrate,
            "bitrate_unit": bitrate_unit,
            "device": self.device,
            "freq_ghz": freq_ghz,
            "freq_mhz": freq_mhz,
            "icon": icon,
            "ip": ip,
            "signal_dbm": signal_dbm,
            "signal_percent": signal_percent,
            "ssid": ssid,
        }

        for x in self.thresholds_init:
            if x in wifi_data:
                self.py3.threshold_get_color(wifi_data[x], x)

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, wifi_data),
        }
        if not self.thresholds_init:
            response["color"] = color
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/window.py
================================================
"""
Display window properties (i.e. title, class, instance).

Configuration parameters:
    cache_timeout: refresh interval for i3-msg or swaymsg (default 0.5)
    format: display format for this module (default "{title}")
    hide_title: hide title on containers with window title (default False)
    max_width: specify width to truncate title with ellipsis (default None)

Format placeholders:
    {class} window class
    {instance} window instance
    {title} window title

Requires:
    i3ipc: an improved python library to control i3wm and sway

Examples:
```
# show alternative instead of empty title
window_title {
    format = '{title}|\u2665'
}
```

@author shadowprince (counter), Anon1234 (async)
@license Eclipse Public License (counter), BSD (async)

SAMPLE OUTPUT
{'full_text': u'scary snake movie - mpv'}

ellipsis
{'full_text': u'GitHub - ultrabug/py3sta…'}
"""

STRING_ERROR = "invalid ipc `{}`"


class Ipc:
    """ """

    def __init__(self, parent):
        self.parent = parent
        self.setup(parent)

    def compatibility(self, window_properties):
        # specify width to truncate title with ellipsis
        title = window_properties.get("title", "")
        if title:
            if self.parent.max_width and len(title) > self.parent.max_width:
                window_properties["title"] = title[: self.parent.max_width - 1] + "…"
        else:
            window_properties["title"] = ""

        return window_properties


class I3ipc(Ipc):
    """
    i3ipc - an improved python library to control i3wm and sway
    """

    _focused_workspace = None
    _focused_window = None

    def setup(self, parent):
        from threading import Thread

        self.parent.cache_timeout = self.parent.py3.CACHE_FOREVER
        self.window_properties = {}

        t = Thread(target=self.start)
        t.daemon = True
        t.start()

    # noinspection PyTypeChecker
    def start(self):
        from i3ipc import Connection, Event

        self.i3 = Connection()

        self._update(self.i3.get_tree().find_focused())

        self.i3.on(Event.WORKSPACE_FOCUS, self._on_workplace_focus)
        self.i3.on(Event.WINDOW_CLOSE, self._on_window_close)
        self.i3.on(Event.WINDOW_TITLE, self._on_window_title)
        self.i3.on(Event.WINDOW_FOCUS, self._on_window_focus)
        self.i3.on(Event.BINDING, self._on_binding)
        self.i3.main()

    def _on_workplace_focus(self, i3, event):
        self._focused_workspace = event.current
        self._focused_window = None
        if event.current.nodes or event.current.floating_nodes:
            return
        self._update(event.current)

    def _on_window_close(self, i3, event):
        if event.container.window == self._focused_window:
            self._focused_window = None
            self._update(i3.get_tree().find_focused())

    def _on_binding(self, i3, event):
        self._update(i3.get_tree().find_focused())

    def _on_window_title(self, i3, event):
        if event.container.focused:
            self._update(event.container)

    def _on_window_focus(self, i3, event):
        self._focused_window = event.container.window
        self._update(event.container)

    def _update(self, event_element):
        if not event_element:
            return

        # hide title on containers with window title
        if self.parent.hide_title:
            show_name = True
            if event_element.border == "normal" or event_element.type == "workspace":
                show_name = False
            else:
                event_element_parent = event_element.parent or getattr(
                    self.i3.get_tree().find_by_id(event_element.id), "parent", None
                )
                if (
                    event_element_parent
                    and event_element_parent.layout in ("stacked", "tabbed")
                    and len(event_element_parent.nodes) > 1
                ):
                    show_name = False

            window_properties = {
                "title": event_element.name if show_name else None,
                "class": event_element.window_class,
                "instance": event_element.window_instance,
            }

        else:
            window_properties = {
                "title": event_element.name,
                "class": event_element.window_class,
                "instance": event_element.window_instance,
            }

        window_properties = self.compatibility(window_properties)

        if self.window_properties != window_properties:
            self.window_properties = window_properties
            self.parent.py3.update()

    def get_window_properties(self):
        return self.window_properties


class Msg(Ipc):
    """
    i3-msg - send messages to i3 window manager
    swaymsg - send messages to sway window manager
    """

    def setup(self, parent):
        from json import loads as json_loads

        self.json_loads = json_loads
        wm_msg = {"i3msg": "i3-msg"}.get(parent.ipc, parent.ipc)
        self.tree_command = [wm_msg, "-t", "get_tree"]

    def get_window_properties(self):
        tree = self.json_loads(self.parent.py3.command_output(self.tree_command))
        focused = self.find_needle(tree)
        window_properties = focused.get(
            "window_properties", {"title": None, "class": None, "instance": None}
        )

        # hide title on containers with window title
        if self.parent.hide_title:
            parent = self.find_needle(tree, focused)
            if (
                focused["border"] == "normal"
                or focused["type"] == "workspace"
                or (parent["layout"] in ("stacked", "tabbed") and len(parent["nodes"]) > 1)
            ):
                window_properties["title"] = None
        window_properties = self.compatibility(window_properties)
        return window_properties

    def find_needle(self, tree, focused=None):
        if isinstance(tree, list):
            for el in tree:
                res = self.find_needle(el, focused)
                if res:
                    return res
        elif isinstance(tree, dict):
            nodes = tree.get("nodes", []) + tree.get("floating_nodes", [])
            if focused:
                for node in nodes:
                    if node["id"] == focused["id"]:
                        return tree
            elif tree["focused"]:
                return tree
            return self.find_needle(nodes, focused)
        return {}


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 0.5
    format = "{title}"
    hide_title = False
    max_width = None

    def post_config_hook(self):
        # ipc: specify i3ipc, i3-msg, or swaymsg, otherwise auto
        self.ipc = getattr(self, "ipc", "")
        if self.ipc in ["", "i3ipc"]:
            try:
                from i3ipc import Connection  # noqa f401, auto ipc

                self.ipc = "i3ipc"
            except Exception:
                if self.ipc:
                    raise  # module not found

        self.ipc = (self.ipc or self.py3.get_wm_msg()).replace("-", "")
        if self.ipc in ["i3ipc"]:
            self.backend = I3ipc(self)
        elif self.ipc in ["i3msg", "swaymsg"]:
            self.backend = Msg(self)
        else:
            raise Exception(STRING_ERROR.format(self.ipc))

    def window(self):
        window_properties = self.backend.get_window_properties()

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, window_properties),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    config = {"format": r"\[{ipc}\] [\?color=pink {title}]"}
    module_test(Py3status, config=config)



================================================
FILE: py3status/modules/wwan.py
================================================
r"""
Display WWANs, IP addresses, signals, properties and sms.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 5)
    format: display format for this module
        *(default '\?color=state WW: [\?if=state_name=connected '
        '({signal_quality_0}% at {m3gpp_operator_name}) '
        '[{format_ipv4}[\?soft  ]{format_ipv6}]|{state_name}]'
        '[ SMS {messages} [{format_message}]]')*
    format_ipv4: display format for ipv4 network (default '[{address}]')
    format_ipv6: display format for ipv6 network (default '[{address}]')
    format_message: display format for SMS messages
        (default '\?if=index<2 {number} [\?max_length=10 {text}...]')
    format_message_separator: show separator if more than one (default ' ')
    format_notification: specify notification to use (default None)
    format_stats: display format for statistics (default '{duration_hms}')
    modem: specify a modem device to use, otherwise auto (default None)
    thresholds: specify color thresholds to use
        (default [(0, 'bad'), (11, 'good')])

Format placeholders:
    {access_technologies}           network speed, in bit, eg 192
    {access_technologies_name}      network speed names, eg LTE
    {current_bands}                 modem band, eg 1
    {current_bands_name}            modem band name, eg GSM/GPRS/EDGE 900 MHz
    {format_ipv4}                   format for ipv4 network config
    {format_ipv6}                   format for ipv6 network config
    {format_message}                format for SMS messages
    {format_stats}                  format for network connection statistics
    {interface_name}                network interface name, eg wwp0s20f0u2i12
    {m3gpp_registration_state_name} network registration state name, eg HOME
    {m3gpp_registration_state}      network registration state, eg 1
    {m3gpp_operator_code}           network operator code, eg 496
    {m3gpp_operator_name}           network operator name, eg Py3status Telecom
    {message}                       number of messages, eg 2
    {messages}                      total number of messages, eg 30
    {signal_quality_0}              signal quality percentage, eg 88
    {signal_quality_1}              signal quality refreshed, eg True/False
    {state}                         network state, eg 0, 7, 11
    {state_name}                    network state name, eg searching, connected

format_ipv4 placeholders:
    {address} ip address
    {dns1}    dns1
    {dns2}    dns2
    {gateway} gateway
    {mtu}     mtu
    {prefix}  netmask prefix

format_ipv6 placeholders:
    {address} ip address
    {dns1}    dns1
    {dns2}    dns2
    {gateway} gateway
    {mtu}     mtu
    {prefix}  netmask prefix

format_message placeholders:
    {index}   message index
    {text}    text received, eg: 'hello how are you?'
    {number}  contact number, eg: '+33601020304'

format_stats placeholders:
    {duration}     time since connected, in seconds, eg 171
    {duration_hms} time since connected, in [hh:]mm:ss, eg 02:51
    {tx_bytes}     transmit bytes
    {rx_bytes}     receive bytes

Color thresholds:
    format:
        xxx: print a color based on the value of `xxx` placeholder

Requires:
    modemmanager: mobile broadband modem management service
    networkmanager: network connection manager and user applications
    dbus-python: Python bindings for dbus

Examples:
```
# show state names, eg initializing, searching, registered, connecting.
wwan {
    format = '\?color=state WWAN: {state_name}'
}

# show state names, and when connected, show network information too.
wwan {
    format = 'WWAN:[\?color=state [ {format_ipv4}]'
    format += '[ {format_ipv6}] {state_name}]'
}

# show internet access technologies name with up/down state.
wwan {
    format = 'WWAN: [\?color=state [{access_technologies_name}]'
    format += '[\?soft  ][\?if=state_name=connected up|down]]'
}

# show SMS messages only
wwan {
    format = '[SMS: {format_message}]'
}

# SMS counter
wwan {
    format = 'SMS: {message}/{messages}'
}


# add starter pack thresholds. you do not need to add them all.
wwan {
    thresholds = {
        'access_technologies': [
            (2, 'bad'), (32, 'orange'), (512, 'degraded'), (16384, 'good')
        ],
        'signal_quality_0': [
            (0, 'bad'), (10, 'orange'), (30, 'degraded'), (50, 'good')
        ],
        'signal_quality_1': [
            (False, 'darkgrey'), (True, 'degraded')
        ],
        'state': [
            (-1, 'bad'), (4, 'orange'), (5, 'degraded'), (11, 'good')
        ]
    }
}

# customize WWAN format
wwan {
    format = 'WWAN: [\?color=state {state_name}] '
    format += '[\?if=m3gpp_registration_state_name=HOME {m3gpp_operator_name} ] '
    format += '[\?if=m3gpp_registration_state_name=ROAMING {m3gpp_operator_name} ]'
    format += '[\?color=access_technologies {access_technologies_name} ]'
    format += '[([\?color=signal_quality_0 {signal_quality_0}]]'
    format += '[\?if=!signal_quality_1&color=signal_quality_1 \[!\]|] '
    format += '[\?if=state_name=connected [{format_ipv4}] [{format_stats}]]')
}

# notify users when an event occur... such as new messages, change in state,
# disconnected, etc. you need to specify formatting correctly so it does not
# return anything. otherwise, you always get notifications.
wwan {
    # notify users on low signal percent 25%
    format_notification = '\?if=signal_quality_0<25 Low signal'

    # notify users on connected state
    format_notification = '[\?if=state_name=connected Connected.]'
    format_notification += '[\?if=state_name=disconnected Disconnected.]'

    # message notification
    format_message = '[\?if=index=1 [{number}] [{text}]]'
    format_notification = '[\?if=message>0 {format_message}]'
}
```

@author Cyril Levis (@cyrinux), girst (https://gir.st/)

SAMPLE OUTPUT
{'color': '#00ff00', 'full_text': 'WW: (88% at Py3status Telcom) 12.69.169.32'}

down
{'color': '#ff0000', 'full_text': 'WW: down'}
"""

from datetime import timedelta

from dbus import Interface, SystemBus

STRING_MODEM_ERROR = "MM_MODEM_STATE_FAILED"
STRING_NOT_INSTALLED = "not installed"

DBUS_INTERFACE_PROPERTIES = 'org.freedesktop.DBus.Properties'
MM_DBUS_PATH = '/org/freedesktop/ModemManager1'

MM_DBUS_INTERFACE = "org.freedesktop.ModemManager1"
MM_DBUS_INTERFACE_SMS = MM_DBUS_INTERFACE + '.Sms'
MM_DBUS_INTERFACE_BEARER = MM_DBUS_INTERFACE + '.Bearer'
MM_DBUS_INTERFACE_MODEM = MM_DBUS_INTERFACE + '.Modem'

MM_DBUS_INTERFACE_MODEM_SIMPLE = MM_DBUS_INTERFACE_MODEM + '.Simple'
MM_DBUS_INTERFACE_MODEM_MESSAGING = MM_DBUS_INTERFACE_MODEM + '.Messaging'


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 5
    format = (
        r"\?color=state WW: [\?if=state_name=connected "
        "({signal_quality_0}% at {m3gpp_operator_name}) "
        r"[{format_ipv4}[\?soft  ]{format_ipv6}]"
        "|{state_name}][ SMS {messages} [{format_message}]]"
    )
    format_ipv4 = "[{address}]"
    format_ipv6 = "[{address}]"
    format_message = r"\?if=index<2 {number} [\?max_length=10 {text}...]"
    format_message_separator = " "
    format_notification = None
    format_stats = "{duration_hms}"
    modem = None
    thresholds = [(0, "bad"), (11, "good")]

    def post_config_hook(self):
        modem_manager = ["ModemManager", "/usr/sbin/ModemManager"]
        network_manager = ["NetworkManager", "/usr/sbin/NetworkManager"]
        for command in (modem_manager, network_manager):
            if not self.py3.check_commands(command):
                raise Exception(f"{command[0]} {STRING_NOT_INSTALLED}")

        # search: modemmanager flags and enumerations
        # enum 1: #MMModemState
        # enum 2: #MMModemAccessTechnology
        # enum 3: #MMModem3gppRegistrationState
        # enum 4: #MMModemBand

        # enum 1: network states
        self.network_states = {
            -1: "failed",
            0: "unknown",
            1: "initializing",
            2: "locked",
            3: "disabled",
            4: "disabling",
            5: "enabling",
            6: "enabled",
            7: "searching",
            8: "registered",
            9: "disconnecting",
            10: "connecting",
            11: "connected",
        }
        # enum 2: network speed
        self.network_speed = {
            0: "Unknown",
            1 << 0: "POTS",  # 2
            1 << 1: "GSM",
            1 << 2: "GSM Compact",
            1 << 3: "GPRS",
            1 << 4: "EDGE",
            1 << 5: "UMTS",  # 32
            1 << 6: "HSDPA",
            1 << 7: "HSUPA",
            1 << 8: "HSPA",
            1 << 9: "HSPA+",  # 512
            1 << 10: "1XRTT",
            1 << 11: "EVDO0",
            1 << 12: "EVDOA",
            1 << 13: "EVDOB",
            1 << 14: "LTE",  # 16384
        }
        # enum 3: network registration state
        self.registration_states = {
            0: "IDLE",
            1: "HOME",
            2: "SEARCHING",
            3: "DENIED",
            4: "UNKNOWN",
            5: "ROAMING",
        }
        # enum 4: modem bands
        self.modem_bands = {
            0: "Unknown or invalid band",
            1: "GSM/GPRS/EDGE 900 MHz",
            2: "GSM/GPRS/EDGE 1800 MHz",
            3: "GSM/GPRS/EDGE 1900 MHz",
            4: "GSM/GPRS/EDGE 850 MHz",
            5: "WCDMA 2100 MHz (Class I)",
            6: "WCDMA 3GPP 1800 MHz (Class III)",
            7: "WCDMA 3GPP AWS 1700/2100 MHz (Class IV)",
            8: "WCDMA 3GPP UMTS 800 MHz (Class VI)",
            9: "WCDMA 3GPP UMTS 850 MHz (Class V)",
            10: "WCDMA 3GPP UMTS 900 MHz (Class VIII)",
            11: "WCDMA 3GPP UMTS 1700 MHz (Class IX)",
            12: "WCDMA 3GPP UMTS 1900 MHz (Class II)",
            13: "WCDMA 3GPP UMTS 2600 MHz (Class VII, internal)",
            31: "E-UTRAN band I",
            32: "E-UTRAN band II",
            33: "E-UTRAN band III",
            34: "E-UTRAN band IV",
            35: "E-UTRAN band V",
            36: "E-UTRAN band VI",
            37: "E-UTRAN band VII",
            38: "E-UTRAN band VIII",
            39: "E-UTRAN band IX",
            40: "E-UTRAN band X",
            41: "E-UTRAN band XI",
            42: "E-UTRAN band XII",
            43: "E-UTRAN band XIII",
            44: "E-UTRAN band XIV",
            47: "E-UTRAN band XVII",
            48: "E-UTRAN band XVIII",
            49: "E-UTRAN band XIX",
            50: "E-UTRAN band XX",
            51: "E-UTRAN band XXI",
            52: "E-UTRAN band XXII",
            53: "E-UTRAN band XXIII",
            54: "E-UTRAN band XXIV",
            55: "E-UTRAN band XXV",
            56: "E-UTRAN band XXVI",
            63: "E-UTRAN band XXXIII",
            64: "E-UTRAN band XXXIV",
            65: "E-UTRAN band XXXV",
            66: "E-UTRAN band XXXVI",
            67: "E-UTRAN band XXXVII",
            68: "E-UTRAN band XXXVIII",
            69: "E-UTRAN band XXXIX",
            70: "E-UTRAN band XL",
            71: "E-UTRAN band XLI",
            72: "E-UTRAN band XLII",
            73: "E-UTRAN band XLIII",
            128: "CDMA Band Class 0 (US Cellular 850MHz)",
            129: "CDMA Band Class 1 (US PCS 1900MHz)",
            130: "CDMA Band Class 2 (UK TACS 900MHz)",
            131: "CDMA Band Class 3 (Japanese TACS)",
            132: "CDMA Band Class 4 (Korean PCS)",
            134: "CDMA Band Class 5 (NMT 450MHz)",
            135: "CDMA Band Class 6 (IMT2000 2100MHz)",
            136: "CDMA Band Class 7 (Cellular 700MHz)",
            137: "CDMA Band Class 8 (1800MHz)",
            138: "CDMA Band Class 9 (900MHz)",
            139: "CDMA Band Class 10 (US Secondary 800)",
            140: "CDMA Band Class 11 (European PAMR 400MHz)",
            141: "CDMA Band Class 12 (PAMR 800MHz)",
            142: "CDMA Band Class 13 (IMT2000 2500MHz Expansion)",
            143: "CDMA Band Class 14 (More US PCS 1900MHz)",
            144: "CDMA Band Class 15 (AWS 1700MHz)",
            145: "CDMA Band Class 16 (US 2500MHz)",
            146: "CDMA Band Class 17 (US 2500MHz Forward Link Only)",
            147: "CDMA Band Class 18 (US 700MHz Public Safety)",
            148: "CDMA Band Class 19 (US Lower 700MHz)",
            256: "auto",
        }

        self._dbus = SystemBus()
        self.init = {
            "ip": [],
            "sms_message": [],
            "thresholds": self.py3.get_color_names_list(self.format),
        }
        self.last_messages = 0
        self.last_notification = self.py3.storage_get("notification")

        names = [
            "current_bands_name",
            "access_technologies_name",
            "m3gpp_registration_name",
            "interface_name",
            "ipv4",
            "ipv6",
            "stats",
            "format_message",
            "message",
        ]
        placeholders = [
            "current_bands_name",
            "access_technologies_name",
            "m3gpp_registration_name",
            "interface_name",
            "format_ipv4",
            "format_ipv6",
            "format_stats",
            "format_message",
            "message*",
        ]

        # init methods
        format_strings = [self.format, self.format_notification]
        for name, placeholder in zip(names, placeholders):
            self.init[name] = []
            for format_string in format_strings:
                if format_string:  # fails on None, [], '', etc
                    if self.py3.format_contains(format_string, placeholder):
                        self.init[name].append(format_string)
                        if name in ["ipv4", "ipv6"]:
                            if name not in self.init["ip"]:
                                self.init["ip"].append(name)
                        if name in ["message", "format_message"]:
                            if name not in self.init["sms_message"]:
                                self.init["sms_message"].append(name)

    def _set_modem_proxy(self):
        manager_proxy = self._dbus.get_object(MM_DBUS_INTERFACE, MM_DBUS_PATH)
        manager_iface = Interface(
            manager_proxy, dbus_interface="org.freedesktop.DBus.ObjectManager"
        )
        modems = manager_iface.GetManagedObjects()
        for m in modems:
            _dbus_proxy = self._dbus.get_object(MM_DBUS_INTERFACE, m)
            _dbus_props_iface = Interface(_dbus_proxy, dbus_interface=DBUS_INTERFACE_PROPERTIES)
            eqid = _dbus_props_iface.Get(MM_DBUS_INTERFACE_MODEM, 'EquipmentIdentifier')

            if self.modem is None or self.modem == eqid:
                self._dbus_proxy = _dbus_proxy
                self._dbus_props_iface = _dbus_props_iface
                return

        self._dbus_proxy = None
        self._dbus_props_iface = None

    def _get_modem_status_data(self):
        modem_data = {}
        try:
            modem_data = self._dbus_proxy.get_dbus_method(
                "GetStatus", MM_DBUS_INTERFACE_MODEM_SIMPLE
            )(True)
        except:  # noqa e722
            pass
        return modem_data

    def _get_bearer(self):
        bearer = {}
        try:
            bearer = self._dbus_props_iface.Get(MM_DBUS_INTERFACE_MODEM, 'Bearers')[0]
        except:  # noqa e722
            pass
        return bearer

    def _get_message_data(self):
        message_data = {}
        try:
            message_data = self._dbus_props_iface.Get(MM_DBUS_INTERFACE_MODEM_MESSAGING, 'Messages')
        except:  # noqa e722
            pass
        return message_data

    def _count_messages(self, message_data):
        count_messages = len(message_data)
        count_message = max(0, count_messages - self.last_messages)
        self.last_messages = count_messages
        return count_message, count_messages

    def _manipulate_message(self, data):
        new_message = []
        for index, msg in sorted(enumerate(data, 1), reverse=True):
            try:
                sms_proxy = self._dbus.get_object(MM_DBUS_INTERFACE, msg)
                sms_props_iface = Interface(sms_proxy, dbus_interface=DBUS_INTERFACE_PROPERTIES)
                new_message.append(
                    self.py3.safe_format(
                        self.format_message,
                        {
                            "index": index,
                            "number": sms_props_iface.Get(MM_DBUS_INTERFACE_SMS, 'Number'),
                            "text": sms_props_iface.Get(MM_DBUS_INTERFACE_SMS, 'Text'),
                        },
                    )
                )
            except:  # noqa e722
                break

        format_message_separator = self.py3.safe_format(self.format_message_separator)
        format_message = self.py3.composite_join(format_message_separator, new_message)

        return format_message

    def _get_bearer_network_config(self):
        return {
            "ipv4": self._get_bearer_prop("Ip4Config"),
            "ipv6": self._get_bearer_prop("Ip6Config"),
        }

    def _get_bearer_prop(self, prop):
        result = self._bearer_props_iface.Get(MM_DBUS_INTERFACE_BEARER, prop)
        return result

    def _organize(self, data):
        new_data = {}
        for key, value in data.items():
            key = key.lower().replace("-", "_")
            if isinstance(value, (list, tuple)):
                if len(value) > 1:
                    for i, v in enumerate(value):
                        new_data[f"{key}_{i}"] = v
                elif len(value) == 1:
                    new_data[key] = value[0]
                else:
                    new_data[key] = None
            else:
                new_data[key] = value
        return new_data

    def wwan(self):
        urgent = False
        name = "_name"

        # get wwan data
        self._set_modem_proxy()
        wwan_data = self._get_modem_status_data()
        wwan_data = self._organize(wwan_data)

        # state and name
        key = "state"
        wwan_data[key] = wwan_data.get(key, 0)
        wwan_data[key + name] = self.network_states[wwan_data[key]]

        # if state is -1, modem failed. stop here. report error.
        # if state is less than 8, we are not connected. skip.
        # if state is 8 or more, we are connected. start work.
        if wwan_data[key] == -1:
            self.py3.error(STRING_MODEM_ERROR)
        elif wwan_data[key] < 8:
            pass
        else:
            # access technologies and name
            if self.init["access_technologies_name"]:
                key = "access_technologies"
                if wwan_data[key]:
                    bit = 1 << (wwan_data[key].bit_length() - 1)
                else:
                    bit = 0
                wwan_data[key + name] = self.network_speed[bit]

            # modem band
            if self.init["current_bands_name"]:
                key = "current_bands"
                wwan_data[key + name] = self.modem_bands[wwan_data[key]]

            # registration state and name
            if self.init["m3gpp_registration_name"]:
                key = "m3gpp_registration_state"
                new_key = key + name
                wwan_data[new_key] = self.registration_states[wwan_data[key]]

            # get bearer
            bearer = self._get_bearer()
            self._bearer_props_iface = None

            if bearer:
                self._bearer_props_iface = Interface(
                    self._dbus.get_object(MM_DBUS_INTERFACE, bearer),
                    dbus_interface=DBUS_INTERFACE_PROPERTIES,
                )
                # interface name
                if self.init["interface_name"]:
                    wwan_data["interface_name"] = self._get_bearer_prop("Interface")

                # ipv4 and ipv6 network config
                if self.init["ip"]:
                    network_config = self._get_bearer_network_config()
                    format_ip = {"ipv4": self.format_ipv4, "ipv6": self.format_ipv6}
                    for ip in self.init["ip"]:
                        wwan_data["format_" + ip] = self.py3.safe_format(
                            format_ip[ip], network_config.get(ip, {})
                        )

                # network connection statistics
                if self.init["stats"]:
                    stats = self._organize(self._get_bearer_prop("Stats"))
                    if stats:
                        stats["duration_hms"] = format(timedelta(seconds=stats["duration"]))
                    wwan_data["format_stats"] = self.py3.safe_format(self.format_stats, stats)

        # message and format message
        if self.init["sms_message"]:
            if wwan_data["state"] >= 1:
                message_data = self._get_message_data()
                # count messages
                keys = ["message", "messages"]
                wwan_data.update(zip(keys, self._count_messages(message_data)))
                if wwan_data["message"]:
                    urgent = True

                # format sms messages
                if self.init["format_message"]:
                    wwan_data["format_message"] = self._manipulate_message(message_data)

        # thresholds
        for x in self.init["thresholds"]:
            if x in wwan_data:
                self.py3.threshold_get_color(wwan_data[x], x)

        # notifications
        if self.format_notification:
            # get a notification
            format_notification = self.py3.safe_format(self.format_notification, wwan_data)
            notification = self.py3.get_composite_string(format_notification)

            if notification and notification != self.last_notification:
                self.last_notification = notification
                self.py3.storage_set("notification", notification)
                self.py3.notify_user(notification)

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, wwan_data),
        }
        if urgent:
            response["urgent"] = True
        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/wwan_status.py
================================================
"""
Display network and IP address for newer Huwei modems.

It is tested for Huawei E3276 (usb-id 12d1:1506) aka Telekom Speed
Stick LTE III but may work on other devices too.

Configuration parameters:
    baudrate: There should be no need to configure this, but
        feel free to experiment.
        (default 115200)
    cache_timeout: How often we refresh this module in seconds.
        (default 5)
    consider_3G_degraded: If set to True, only 4G-networks will be
        considered 'good'; 3G connections are shown
        as 'degraded', which is yellow by default. Mostly
        useful if you want to keep track of where there
        is a 4G connection.
        (default False)
    format_down: What to display when the modem is not plugged in
        (default 'WWAN: down')
    format_error: What to display when modem can't be accessed.
        (default 'WWAN: {error}')
    format_no_service: What to display when the modem does not have a
        network connection. This allows to omit the (then
        meaningless) network generation.
        (default 'WWAN: {status} {ip}')
    format_up: What to display upon regular connection
        (default 'WWAN: {status} ({netgen}) {ip}')
    interface: The default interface to obtain the IP address
        from. For wvdial this is most likely ppp0.
        For netctl it can be different.
        (default 'ppp0')
    modem: The device to send commands to. (default '/dev/ttyUSB1')
    modem_timeout: The timespan between querying the modem and
        collecting the response.
        (default 0.4)

Color options:
    color_bad: Error or no connection
    color_degraded: Low generation connection eg 2G
    color_good: Good connection

Requires:
    netifaces: portable module to access network interface information
    pyserial: multiplatform serial port module for python

@author Timo Kohorst timo@kohorst-online.com
PGP: B383 6AE6 6B46 5C45 E594 96AB 89D2 209D DBF3 2BB5

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'WWAN: 4G 37.48.108.0'}

off
{'color': '#FF0000', 'full_text': u'WWAN: down'}
"""

import stat
from pathlib import Path
from time import sleep

import netifaces as ni
import serial


class Py3status:
    """ """

    # available configuration parameters
    baudrate = 115200
    cache_timeout = 5
    consider_3G_degraded = False
    format_down = "WWAN: down"
    format_error = "WWAN: {error}"
    format_no_service = "WWAN: {status} {ip}"
    format_up = "WWAN: {status} ({netgen}) {ip}"
    interface = "ppp0"
    modem = "/dev/ttyUSB1"
    modem_timeout = 0.4

    def wwan_status(self):
        query = "AT^SYSINFOEX"
        target_line = "^SYSINFOEX"

        # Set up the highest network generation to display as degraded
        if self.consider_3G_degraded:
            degraded_netgen = 3
        else:
            degraded_netgen = 2

        response = {}
        response["cached_until"] = self.py3.time_in(self.cache_timeout)

        # Check if path exists and is a character device
        modem_path = Path(self.modem)
        if modem_path.exists() and stat.S_ISCHR(modem_path.stat().st_mode):
            print("Found modem " + self.modem)
            try:
                ser = serial.Serial(
                    port=self.modem,
                    baudrate=self.baudrate,
                    # Values below work for my modem. Not sure if
                    # they necessarily work for all modems
                    parity=serial.PARITY_ODD,
                    stopbits=serial.STOPBITS_ONE,
                    bytesize=serial.EIGHTBITS,
                )
                if ser.isOpen():
                    ser.close()
                ser.open()
                ser.write((query + "\r").encode())
                print("Issued query to " + self.modem)
                sleep(self.modem_timeout)
                n = ser.inWaiting()
                modem_response = ser.read(n)
                ser.close()
            except:  # noqa e722
                # This will happen...
                # 1) in the short timespan between the creation of the device
                # node and udev changing the permissions. If this message
                # persists, double check if you are using the proper device
                # file
                # 2) if/when you unplug the device
                print("Permission error")
                response["full_text"] = self.py3.safe_format(
                    self.format_error, dict(error="no access to " + self.modem)
                )
                response["color"] = self.py3.COLOR_BAD
                return response
            # Dissect response
            for line in modem_response.decode("utf-8").split("\n"):
                print(line)
                if line.startswith(target_line):
                    # Determine IP once the modem responds
                    ip = self._get_ip(self.interface)
                    if not ip:
                        ip = "no ip"
                    modem_answer = line.split(",")
                    netgen = len(modem_answer[-2]) + 1
                    netmode = modem_answer[-1].rstrip()[1:-1]
                    if netmode == "NO SERVICE":
                        response["full_text"] = self.py3.safe_format(
                            self.format_no_service, dict(status=netmode, ip=ip)
                        )
                        response["color"] = self.py3.COLOR_BAD
                    else:
                        response["full_text"] = self.py3.safe_format(
                            self.format_up,
                            dict(status=netmode, netgen=str(netgen) + "G", ip=ip),
                        )
                        if netgen <= degraded_netgen:
                            response["color"] = self.py3.COLOR_DEGRADED
                        else:
                            response["color"] = self.py3.COLOR_GOOD
                elif line.startswith("COMMAND NOT SUPPORT") or line.startswith("ERROR"):
                    response["color"] = self.py3.COLOR_BAD
                    response["full_text"] = self.py3.safe_format(
                        self.format_error, {"error": "unsupported modem"}
                    )
                else:
                    # Outputs can be multiline, so just try the next one
                    pass
        else:
            response["color"] = self.py3.COLOR_BAD
            response["full_text"] = self.format_down
        return response

    def _get_ip(self, interface):
        """
        Returns the interface's IPv4 address if device exists and has a valid
        ip address. Otherwise, returns an empty string
        """
        if interface in ni.interfaces():
            addresses = ni.ifaddresses(interface)
            if ni.AF_INET in addresses:
                return addresses[ni.AF_INET][0]["addr"]
        return ""


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/xkb_input.py
================================================
r"""
Switch inputs.

Configuration parameters:
    button_next: mouse button to cycle next layout (default 4)
    button_prev: mouse button to cycle previous layout (default 5)
    cache_timeout: refresh interval for this module; xkb-switch
        and swaymsg will listen for new updates instead (default 10)
    format: display format for this module (default '{format_input}')
    format_input: display format for inputs
        (default '[{alias}][\?soft  ][\?color=s {s}[ {v}]]')
    format_input_separator: show separator if more than one (default ' ')
    inputs: specify a list of inputs to use in swaymsg (default [])
    switcher: specify xkb-switch, xkblayout-state, xkbgroup,
        or swaymsg to use, otherwise auto (default None)
    thresholds: specify color thresholds to use
        *(default [("fr", "lightgreen"), ("ru", "lightcoral"),
        ("ua", "khaki"),  ("us", "lightskyblue")])*

Format placeholders:
    {format_input} format for inputs
    {input}        number of inputs, eg 1
    {switcher}     eg, xkb-switch, xkblayout-state, xkbgroup, swaymsg

format_input placeholders:
    xkb-switch:
    xkblayout-state:
    xkbgroup:
    swaymsg:
        {c} layout number, eg, 0
        {n} layout name, eg, English (US)
        {s} layout symbol, eg, us
        {v} layout variant, eg, basic
        {e} layout variant, {v} or {s}, eg, dvorak
        {C} layout count, eg, 2
    swaymsg:
        {alias}                   custom string or {name}
        {identifier}              eg, 162:253 USB-HID Keyboard
        {name}                    eg, Trackball, Keyboard, etc
        {vendor}                  eg, 320
        {product}                 eg, 556
        {type}                    eg, pointer, keyboard, touchpad, etc
        {xkb_layout_names}        eg, English (US), French, Russian
        {xkb_active_layout_index} eg, 0, 1, 2, etc
        {xkb_active_layout_name}  eg, English (US)
        {send_events}             eg, True
        {accel_speed}             eg, 0.0
        {accel_profile}           eg, adaptive
        {natural_scroll}          eg, adaptive
        {left_handed}             eg, False
        {middle_emulation}        eg, False
        {scroll_method}           eg, None
        {scroll_button}           eg, 274

        Use `swaymsg -r -t get_inputs` to get a list of current sway inputs
        and for a list of placeholders. Not all of placeholders will be usable.

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

Requires:
    xkb-switch: program that allows to query and change the xkb layout state
    xkblayout-state: a command-line program to get/set the current keyboard layout
    xkbgroup: query and change xkb layout state
    swaymsg: send messages to sway window manager

Examples:
```
# sway users: for best results, add switcher to avoid false positives with `pgrep i3`
# because sway users can be using scripts, tools, et cetera with `i3` in its name.
xkb_input {
    switcher = "swaymsg"
}

# sway users: specify inputs to fnmatch
xkb_input {
    # display logitech identifiers
    inputs = [{"identifier": "*Logitech*"}]

    # display logi* keyboards only
    inputs = [{"name": "Logi*", "type": "keyb*"}]

    # display pointers only
    inputs = [{"type": "pointer"}]
}

# sway users: display inputs, optional aliases, et cetera
xkb_input {
    inputs = [
        {"identifier": "1625:3192:Heng_Yu_Technology_Poker_II", "alias": "Poker 2"},
        {"identifier": "0012:021:USB-HID_Keyboard", "alias": "Race 3"},
        {"identifier": "0123:45678:Logitech_MX_Ergo", "alias": "MX Ergo", "type": "pointer"},
    ]
}

# i3 users: display inputs - see https://wiki.archlinux.org/index.php/X_keyboard_extension
# $ setxkbmap -layout "us,fr,ru"  # install xkb-group to enable a listener thread
```

@author lasers, saengowp, javiertury

SAMPLE OUTPUT
{"color": "#87CEFA", "full_text": "us"}

fr
{"color": "#90EE90", "full_text": "fr"}

ru
{"color": "#F08080", "full_text": "ru"}

au
{"color": "#F0E68C", "full_text": "au"}
"""

from pathlib import Path

STRING_ERROR = "invalid command `{}`"
STRING_NOT_AVAILABLE = "no available binary"
STRING_NOT_INSTALLED = "command `{}` not installed"


class Listener:
    """
    swaymsg -m - monitor for responses until killed
    xkb-switch -W - infinitely waits for group change
    """

    def __init__(self, parent):
        self.parent = parent
        if self.parent.switcher == "swaymsg":
            self.listen_command = ["swaymsg", "-m", "-t", "subscribe", "['input']"]
        elif self.parent.py3.check_commands("xkb-switch"):
            self.listen_command = ["xkb-switch", "-W"]
        else:
            return

        self.setup(parent)

    def setup(self, parent):
        from threading import Thread

        self.parent.cache_timeout = self.parent.py3.CACHE_FOREVER
        self.process = None

        t = Thread(target=self.start)
        t.daemon = True
        t.start()

    def start(self):
        from subprocess import PIPE, Popen

        try:
            self.process = Popen(self.listen_command, stdout=PIPE)
            while True:
                self.process.stdout.readline()
                code = self.process.poll()
                if code is not None:
                    msg = "Command `{}` terminated with returncode {}"
                    raise Exception(msg.format(" ".join(self.listen_command), code))
                self.parent.py3.update()
        except Exception as err:
            self.parent.error = err
            self.parent.py3.update()
        finally:
            self.kill()

    def kill(self):
        try:
            self.process.kill()
        except AttributeError:
            pass


class Xkb:
    """ """

    def __init__(self, parent):
        self.parent = parent
        self.post_config_setup(parent)
        self.setup(parent)

    def py3_command_output(self, *args):
        try:
            return self.parent.py3.command_output(*args)
        except self.parent.py3.CommandError as err:
            self.parent.error = err
            raise err

    def py3_command_run(self, *args):
        try:
            return self.parent.py3.command_run(*args)
        except self.parent.py3.CommandError as err:
            self.parent.error = err
            raise err

    def post_config_setup(self, parent):
        self.name_mapping = {}
        self.reverse_name_mapping = {}
        self.variant_mapping = []

        try:
            with Path("/usr/share/X11/xkb/rules/base.lst").open() as f:
                for chunk in f.read().split("\n\n"):
                    if "! layout" in chunk:
                        for line in chunk.splitlines()[1:]:
                            fields = line.split()
                            symbol, name = (fields[0], " ".join(fields[1:]))
                            self.name_mapping[symbol] = name
                            self.reverse_name_mapping[name] = (symbol, None)
                    if "! variant" in chunk:
                        for line in chunk.splitlines()[1:]:
                            fields = line.split()
                            variant, symbol, name = (
                                fields[0],
                                fields[1][:-1],
                                " ".join(fields[2:]),
                            )
                            self.reverse_name_mapping[name] = (symbol, variant)
                            self.variant_mapping.append((variant, symbol, name))
        except OSError as err:
            self.parent.error = err

    def setup(self, parent):
        pass

    def add_libinput(self, _input):
        pass

    def set_xkb_layout(self, delta):
        pass


class Xkbgroup(Xkb):
    """
    xkbgroup - query and change xkb layout state
    """

    def setup(self, parent):
        from xkbgroup import XKeyboard

        self.xo = XKeyboard
        self.map = {"num": "c", "name": "n", "symbol": "s", "variant": "v"}

    def get_xkb_inputs(self):
        xo = self.xo()
        group_data = xo.group_data._asdict()
        xkb_input = {self.map[k]: v for k, v in group_data.items()}
        xkb_input["e"] = xkb_input["v"] or xkb_input["s"]
        xkb_input["C"] = xo.groups_count

        return [xkb_input]

    def set_xkb_layout(self, delta):
        xo = self.xo()
        xo.group_num = (xo.group_num + delta) % xo.groups_count


class Xkb_Switch(Xkb):
    """
    xkb-switch - program that allows to query and change the xkb layout state
    """

    def setup(self, parent):
        self.init_cC = self.parent.py3.format_contains(self.parent.format_input, "[cC]")

    def get_xkb_inputs(self):
        s = output = self.py3_command_output("xkb-switch -p").strip()
        v = None

        if "(" in s and ")" in s:
            v = s[s.find("(") + 1 : s.find(")")]
            s = s[: s.find("(")]

        for variant, symbol, name in self.variant_mapping:
            if (v, s) == (variant, symbol):
                n = name
                break
        else:
            n = self.name_mapping.get(s)

        xkb_input = {"s": s, "v": v, "e": v or s, "n": n}

        if self.init_cC:
            layouts = self.py3_command_output("xkb-switch -l").splitlines()
            xkb_input["C"] = len(layouts)

            for index, layout in enumerate(layouts):
                if layout == output:
                    xkb_input["c"] = index
                    break

        return [xkb_input]

    def set_xkb_layout(self, delta):
        if delta > 0:
            self.py3_command_run("xkb-switch -n")
        else:
            i = self.py3_command_output("xkb-switch -p").strip()
            s = self.py3_command_output("xkb-switch -l").splitlines()
            self.py3_command_run("xkb-switch -s {}".format(s[s.index(i) - 1]))


class Xkblayout_State(Xkb):
    """
    xkblayout-state - a command-line program to get/set the current keyboard layout
    """

    def setup(self, parent):
        self.placeholders = list("cnsveC")
        self.separator = "|SEPARATOR|"
        self.xkblayout_command = "xkblayout-state print {}".format(
            self.separator.join("%" + x for x in self.placeholders)
        )

    def get_xkb_inputs(self):
        line = self.py3_command_output(self.xkblayout_command)
        xkb_input = dict(zip(self.placeholders, line.split(self.separator)))
        xkb_input["n"] = self.name_mapping.get(xkb_input["s"], xkb_input["n"])

        return [xkb_input]

    def set_xkb_layout(self, delta):
        self.py3_command_run(
            "xkblayout-state set {}{}".format({+1: "+", -1: "-"}[delta], abs(delta))
        )


class Swaymsg(Xkb):
    """
    swaymsg - send messages to sway window manager
    """

    def setup(self, parent):
        from fnmatch import fnmatch
        from json import loads

        self.excluded = ["alias"]
        self.fnmatch, self.loads = (fnmatch, loads)
        self.map = {"enabled": True, "disabled": False, "none": None}
        self.swaymsg_command = ["swaymsg", "--raw", "--type", "get_inputs"]

    def add_libinput(self, _input):
        libinput = _input.pop("libinput", {})
        _input.update({k: self.map.get(v, v) for k, v in libinput.items()})

        return _input

    def update_xkb_input(self, xkb_input, _filter):
        xkb_input["alias"] = _filter.get("alias", xkb_input["name"])

        if "xkb_active_layout_name" in xkb_input:
            c = xkb_input["xkb_active_layout_index"]
            C = len(xkb_input["xkb_layout_names"])
            n = xkb_input["xkb_active_layout_name"]
            s, v = self.reverse_name_mapping.get(n, (None, None))

            if s is None and "(" in n and ")" in n:
                s = n[n.find("(") + 1 : n.find(")")].lower()
                n = n[: n.find("(") - 1]

            xkb_input["xkb_layout_names"] = ", ".join(xkb_input["xkb_layout_names"])
            xkb_input.update({"c": c, "C": C, "s": s, "e": v or s, "n": n, "v": v})

        return xkb_input

    def get_xkb_inputs(self):
        try:
            xkb_data = self.loads(self.py3_command_output(self.swaymsg_command))
        except Exception:
            xkb_data = []

        new_input = []
        for xkb_input in xkb_data:
            if self.parent.inputs:
                for _filter in self.parent.inputs:
                    for key, value in _filter.items():
                        if key in self.excluded or key not in xkb_input:
                            continue
                        if not self.fnmatch(xkb_input[key], value):
                            break
                    else:
                        new_input.append(self.update_xkb_input(xkb_input, _filter))
            else:
                _filter = {}
                new_input.append(self.update_xkb_input(xkb_input, _filter))

        return new_input


class Py3status:
    """ """

    # available configuration parameters
    button_next = 4
    button_prev = 5
    cache_timeout = 10
    format = "{format_input}"
    format_input = r"[{alias}][\?soft  ][\?color=s {s}[ {v}]]"
    format_input_separator = " "
    inputs = []
    switcher = None
    thresholds = [
        ("fr", "lightgreen"),
        ("ru", "lightcoral"),
        ("ua", "khaki"),
        ("us", "lightskyblue"),
    ]

    def post_config_hook(self):
        switchers = ["xkb-switch", "xkblayout-state", "xkbgroup", "swaymsg"]
        if not self.switcher:
            if self.py3.get_wm_msg() == "swaymsg":
                self.switcher = "swaymsg"
            else:
                self.switcher = self.py3.check_commands(switchers)
        elif self.switcher not in switchers:
            raise Exception(STRING_ERROR.format(self.switcher))
        elif not self.py3.check_commands(self.switcher):
            raise Exception(STRING_NOT_INSTALLED.format(self.switcher))
        if not self.switcher:
            raise Exception(STRING_NOT_AVAILABLE)

        self.error = None
        self.input_backend = globals()[self.switcher.replace("-", "_").title()](self)
        if getattr(self, "listener", True):
            self.listener_backend = Listener(self)

        self.thresholds_init = {}
        for name in ["format", "format_input"]:
            self.thresholds_init[name] = self.py3.get_color_names_list(getattr(self, name))

    def _stop_on_errors(self):
        if self.error:
            self.kill()
            self.py3.error(str(self.error), self.py3.CACHE_FOREVER)

    def xkb_input(self):
        xkb_inputs = self.input_backend.get_xkb_inputs()
        self._stop_on_errors()
        new_input = []

        for _input in xkb_inputs:
            _input = self.input_backend.add_libinput(_input) or _input
            for x in self.thresholds_init["format_input"]:
                if x in _input:
                    self.py3.threshold_get_color(_input[x], x)
            new_input.append(self.py3.safe_format(self.format_input, _input))

        format_input_separator = self.py3.safe_format(self.format_input_separator)
        format_input = self.py3.composite_join(format_input_separator, new_input)

        input_data = {
            "format_input": format_input,
            "input": len(xkb_inputs),
            "switcher": self.switcher,
        }

        for x in self.thresholds_init["format"]:
            if x in input_data:
                self.py3.threshold_get_color(input_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, input_data),
        }

    def kill(self):
        try:
            self.listener_backend.kill()
        except AttributeError:
            pass

    def on_click(self, event):
        button = event["button"]
        if button == self.button_next:
            self.input_backend.set_xkb_layout(+1)
        elif button == self.button_prev:
            self.input_backend.set_xkb_layout(-1)


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/xrandr.py
================================================
"""
Control screen layout.

This modules allows you to handle your screens outputs directly from your bar!
    - Detect and propose every possible screen combinations
    - Switch between combinations using click events and mouse scroll
    - Activate the screen or screen combination on a single click
    - It will detect any newly connected or removed screen automatically

For convenience, this module also proposes some added features:
    - Dynamic parameters for POSITION and WORKSPACES assignment (see below)
    - Automatic fallback to a given screen or screen combination when no more
        screen is available (handy for laptops)
    - Automatically apply this screen combination on start: no need for xorg!
    - Automatically move workspaces to screens when they are available
    - Define your own subset of output combinations to use

Configuration parameters:
    cache_timeout: how often to (re)detect the outputs (default 10)
    command: a custom command to be run after display configuration changes
        (default None)
    fallback: when the current output layout is not available anymore,
        fallback to this layout if available. This is very handy if you
        have a laptop and switched to an external screen for presentation
        and want to automatically fallback to your laptop screen when you
        disconnect the external screen. (default True)
    fixed_width: show output as fixed width (default True)
    force_on_change: switch display layout to the leftmost combination mode
        of the given list whenever it is available. The combination modes are
        checked from left (high priority) to right (less priority) until
        one matches.
        Example:
            We have a laptop with internal screen and we are often moving from
            our desk where another screen is available. We want the layout to
            follow our changes so that we do not have to switch manually.
            So whenever we plug at our desk, we want the second monitor to be
            used, and whenever we go away we want everything back on the laptop
            screen automatically:
            ```
            force_on_change = ["eDP1+DP1", "eDP1"]
            ```
        NOTES:
            Click controls will override `force_on_change` until the layout
            changes in the background so you can still manually control your
            layout changes on the bar.
            Use the `force_on_start` to handle initial layout setup on module
            startup along with this feature to benefit from fully dynamic and
            automated changes of screen layouts.
        (default [])
    force_on_start: switch to the given combination mode if available
        when the module starts (saves you from having to configure xorg)
        (default None)
    format: display format for xrandr
        (default '{output}')
    hide_if_single_combination: hide if only one combination is available
        (default False)
    icon_clone: icon used to display a 'clone' combination
        (default '=')
    icon_extend: icon used to display a 'extend' combination
        (default '+')
    on_udev_drm: dynamic variable to watch for `drm` udev subsystem events to
        trigger specified action.
        (default 'refresh_and_freeze')
    output_combinations: string used to define your own subset of output
        combinations to use, instead of generating every possible combination
        automatically. Provide the values in the format that this module uses,
        splitting the combinations using '|' character.
        The combinations will be rotated in the exact order as you listed them.
        When an output layout is not available any more, the configurations
        are automatically filtered out.
        Example:
            Assuming the default values for `icon_clone` and `icon_extend`
            are used, and assuming you have two screens 'eDP1' and 'DP1', the
            following setup will reduce the number of output combinations
            from four (every possible one) down to two.
            ```
            output_combinations = "eDP1|eDP1+DP1"
            ```
        (default None)

Dynamic configuration parameters:
    <OUTPUT>_icon: use this icon instead of OUTPUT name as text
        Example: DP1_icon = "🖵"
    <OUTPUT>_pos: apply the given position to the OUTPUT
        Example: DP1_pos = "-2560x0"
        Example: DP1_pos = "above eDP1"
        Example: DP1_pos = "below eDP1"
        Example: DP1_pos = "left-of LVDS1"
        Example: DP1_pos = "right-of eDP1"
    <OUTPUT>_workspaces: comma separated list of workspaces to move to
        the given OUTPUT when it is activated
        Example: DP1_workspaces = "1,2,3"
    <OUTPUT>_rotate: rotate the output as told
        Example: DP1_rotate = "left"
    <OUTPUT>_mode: define the mode (resolution) for the output
                   if not specified use --auto : preferred mode
        Example: eDP1_mode = "2560x1440"
    <OUTPUT>_primary: apply the primary to the OUTPUT
        Example: DP1_primary = True

Format placeholders:
    {output} xrandr output

Color options:
    color_bad: Displayed layout unavailable
    color_degraded: Using a fallback layout
    color_good: Displayed layout active

Notes:
    Some days are just bad days. Running `xrandr --query` command can
    cause unexplainable brief screen freezes due to an overall combination
    of computer hardware, installed software, your choice of linux distribution,
    and/or some other unknown factors such as recent system updates.

    Configuring `cache_timeout` with a different number, eg `3600` (an hour)
    or `-1` (runs once) can be used to remedy this issue. See issue #580.

Examples:
```
# start with a preferable setup
xrandr {
    force_on_start = "eDP1+DP1"
    DP1_pos = "left-of eDP1"
    VGA_workspaces = "7"
}
```

@author ultrabug

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'LVDS1+DP1'}

mirror
{'full_text': 'LVDS1=DP1'}

single_1
{'full_text': u'LVDS1'}

single_2
{'full_text': 'DP1'}
"""

from collections import OrderedDict, deque
from itertools import combinations
from time import sleep


class Py3status:
    """"""

    # available configuration parameters
    cache_timeout = 10
    command = None
    fallback = True
    fixed_width = True
    force_on_change = []
    force_on_start = None
    format = "{output}"
    hide_if_single_combination = False
    icon_clone = "="
    icon_extend = "+"
    on_udev_drm = "refresh_and_freeze"
    output_combinations = None

    class Meta:
        deprecated = {
            "rename": [
                {
                    "param": "format_clone",
                    "new": "icon_clone",
                    "msg": "obsolete parameter use `icon_clone`",
                },
                {
                    "param": "format_extend",
                    "new": "icon_extend",
                    "msg": "obsolete parameter use `icon_extend`",
                },
            ]
        }

    def post_config_hook(self):
        """
        Initialization
        """
        self._no_force_on_change = True
        self.active_comb = None
        self.active_layout = None
        self.active_mode = "extend"
        self.displayed = None
        self.max_width = 0
        self.layout = None

    def _get_layout(self):
        """
        Get the outputs layout from xrandr and try to detect the
        currently active layout as best as we can on start.
        """
        connected = list()
        active_layout = list()
        disconnected = list()
        layout = OrderedDict({"connected": OrderedDict(), "disconnected": OrderedDict()})
        self.old_layout = self.layout or layout

        current = self.py3.command_output("xrandr")
        for line in current.splitlines():
            try:
                s = line.split(" ")
                infos = line[line.find("(") :]
                if s[1] == "connected":
                    output, state, mode = s[0], s[1], None
                    for index, x in enumerate(s[2:], 2):
                        if "x" in x and "+" in x:
                            mode = x
                            active_layout.append(output)
                            infos = line[line.find(s[index + 1]) :]
                            break
                        elif "(" in x:
                            break
                    connected.append(output)
                elif s[1] == "disconnected":
                    output, state, mode = s[0], s[1], None
                    disconnected.append(output)
                else:
                    continue
            except Exception as err:
                self.py3.log(f'xrandr error="{err}"')
            else:
                layout[state][output] = {"infos": infos, "mode": mode, "state": state}

        # initialize the active layout
        if self.active_layout is None:
            self.active_comb = tuple(active_layout)
            self.active_layout = self._get_string_and_set_width(
                tuple(active_layout), self.active_mode
            )

        return layout

    def _layout_changed(self):
        """
        check if the known monitor setup match current setup
        """
        return (
            self.layout["connected"] != self.old_layout["connected"]
            or self.layout["disconnected"] != self.old_layout["disconnected"]
        )

    def _set_available_combinations(self):
        """
        Generate all connected outputs combinations and
        set the max display width while iterating.
        """
        available = set()
        combinations_map = {}

        whitelist = None
        if self.output_combinations:
            whitelist = self.output_combinations.split("|")

        self.max_width = 0
        for output in range(len(self.layout["connected"])):
            for comb in combinations(self.layout["connected"], output + 1):
                for mode in ["clone", "extend"]:
                    string = self._get_string_and_set_width(comb, mode)
                    if whitelist and string not in whitelist:
                        continue
                    if len(comb) == 1:
                        combinations_map[string] = (comb, None)
                    else:
                        combinations_map[string] = (comb, mode)
                    available.add(string)

        # Preserve the order in which user defined the output combinations
        if whitelist:
            available = reversed([comb for comb in whitelist if comb in available])

        self.available_combinations = deque(available)
        self.combinations_map = combinations_map

    def _get_string_and_set_width(self, combination, mode):
        """
        Construct the string to be displayed and record the max width.
        """
        show = getattr(self, f"icon_{mode}").join(
            tuple(getattr(self, f"{x}_icon", x) for x in combination)
        )
        self.max_width = max(self.max_width, len(show))
        return show

    def _choose_what_to_display(self, force_refresh=False):
        """
        Choose what combination to display on the bar.

        By default we try to display the active layout on the first run, else
        we display the last selected combination.
        """
        for _ in range(len(self.available_combinations)):
            if self.displayed is None and self.available_combinations[0] == self.active_layout:
                self.displayed = self.available_combinations[0]
                break
            else:
                if self.displayed == self.available_combinations[0]:
                    break
                else:
                    self.available_combinations.rotate(1)
        else:
            if force_refresh:
                self.displayed = self.available_combinations[0]
            else:
                self.py3.log('xrandr error="displayed combination is not available"')

    def _center(self, s):
        """
        Center the given string on the detected max width.
        """
        return f"{s:^{self.max_width}}"

    def _apply(self, force=False):
        """
        Call xrandr and apply the selected (displayed) combination mode.
        """
        if self.displayed == self.active_layout and not force:
            # no change, do nothing
            return

        combination, mode = self.combinations_map.get(self.displayed, (None, None))
        if combination is None and mode is None:
            # displayed combination cannot be activated, ignore
            return

        cmd = "xrandr"
        outputs = list(self.layout["connected"])
        outputs += list(self.layout["disconnected"])
        previous_output = None
        primary_added = False
        for output in outputs:
            cmd += f" --output {output}"
            #
            if output in combination:
                pos = getattr(self, f"{output}_pos", "0x0")
                primary = getattr(self, f"{output}_primary", None)
                resolution = getattr(self, f"{output}_mode", None)
                resolution = f"--mode {resolution}" if resolution else "--auto"
                rotation = getattr(self, f"{output}_rotate", "normal")
                if rotation not in ["inverted", "left", "normal", "right"]:
                    self.py3.log(f"configured rotation {rotation} is not valid")
                    rotation = "normal"
                #
                if primary is True and not primary_added:
                    primary_added = True
                    cmd += " --primary"
                if mode == "clone" and previous_output is not None:
                    cmd += f" {resolution} --same-as {previous_output}"
                else:
                    if "above" in pos or "below" in pos or "left-of" in pos or "right-of" in pos:
                        cmd += f" {resolution} --{pos} --rotate {rotation}"
                    else:
                        cmd += " {} --pos {} --rotate {}".format(resolution, pos, rotation)
                previous_output = output
            else:
                cmd += " --off"
        #
        code = self.py3.command_run(cmd)
        if code == 0:
            self.active_comb = combination
            self.active_layout = self.displayed
            self.active_mode = mode
        self.py3.log(f'command "{cmd}" exit code {code}')

        if self.command:
            self.py3.command_run(self.command)

        # move workspaces to outputs as configured
        self._apply_workspaces(combination, mode)

    def _apply_workspaces(self, combination, mode):
        """
        Allows user to force move a comma separated list of workspaces to the
        given output when it's activated.

        Example:
            - DP1_workspaces = "1,2,3"
        """
        if len(combination) > 1 and mode == "extend":
            sleep(3)
            for output in combination:
                workspaces = getattr(self, f"{output}_workspaces", "").split(",")
                for workspace in workspaces:
                    if not workspace:
                        continue
                    # switch to workspace
                    cmd = f'{self.py3.get_wm_msg()} workspace "{workspace}"'
                    self.py3.command_run(cmd)
                    # move it to output
                    cmd = '{} move workspace to output "{}"'.format(self.py3.get_wm_msg(), output)
                    self.py3.command_run(cmd)
                    # log this
                    self.py3.log(f"moved workspace {workspace} to output {output}")

    def _fallback_to_available_output(self):
        """
        Fallback to the first available output when the active layout
        was composed of only one output.

        This allows us to avoid cases where you get stuck with a black sreen
        on your laptop by switching back to the integrated screen
        automatically !
        """
        if len(self.active_comb) == 1:
            self._choose_what_to_display(force_refresh=True)
            self._apply()
            self.py3.update()

    def _force_force_on_start(self):
        """
        Force the user configured mode on start.
        """
        if self.force_on_start in self.available_combinations:
            self.displayed = self.force_on_start
            self._choose_what_to_display(force_refresh=True)
            self._apply(force=True)
            self.py3.update()
        self.force_on_start = None

    def _switch_selection(self, direction):
        self.available_combinations.rotate(direction)
        self.displayed = self.available_combinations[0]

    def _force_on_change(self):
        """
        Handle force_on_change feature.
        """
        for layout in self.force_on_change:
            if layout in self.available_combinations:
                if self.active_layout != layout:
                    self.displayed = layout
                    self._apply(force=True)
                    self.py3.update()
                    break
                else:
                    break

    def on_click(self, event):
        """
        Click events
            - left click & scroll up/down: switch between modes
            - right click: apply selected mode
            - middle click: force refresh of available modes
        """
        self._no_force_on_change = True
        button = event["button"]
        if button == 4:
            self._switch_selection(-1)
        if button in [1, 5]:
            self._switch_selection(1)
        if button == 2:
            self._choose_what_to_display(force_refresh=True)
        if button == 3:
            self._apply()

    def xrandr(self):
        """
        This is the main py3status method, it will orchestrate what's being
        displayed on the bar.
        """
        self.layout = self._get_layout()
        self._set_available_combinations()
        self._choose_what_to_display()

        if len(self.available_combinations) < 2 and self.hide_if_single_combination:
            full_text = self.py3.safe_format(self.format, {"output": ""})
        else:
            if self.fixed_width is True:
                output = self._center(self.displayed)
            else:
                output = self.displayed
            full_text = self.py3.safe_format(self.format, {"output": output})

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": full_text,
        }

        # coloration
        if self.displayed == self.active_layout:
            response["color"] = self.py3.COLOR_GOOD
        elif self.displayed not in self.available_combinations:
            response["color"] = self.py3.COLOR_BAD

        # force default layout setup at module startup
        if self.force_on_start is not None:
            sleep(1)
            self._force_force_on_start()

        # follow on change
        if not self._no_force_on_change and self.force_on_change and self._layout_changed():
            self.py3.log("detected change of monitor setup")
            self._force_on_change()

        # this was a click event triggered update
        if self._no_force_on_change:
            self._no_force_on_change = False

        # fallback detection
        if self.active_layout not in self.available_combinations:
            response["color"] = self.py3.COLOR_DEGRADED
            if self.fallback is True:
                self._fallback_to_available_output()

        return response


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/xrandr_rotate.py
================================================
"""
Control screen rotation.

Configuration parameters:
    cache_timeout: how often to refresh this module.
        (default 10)
    format: a string that formats the output, can include placeholders.
        (default '{icon}')
    hide_if_disconnected: a boolean flag to hide icon when `screen` is
        disconnected.
        It has no effect unless `screen` option is also configured.
        (default False)
    horizontal_icon: a character to represent horizontal rotation.
        (default 'H')
    horizontal_rotation: a horizontal rotation for xrandr to use.
        Available options: 'normal' or 'inverted'.
        (default 'normal')
    screen: display output name to rotate, as detected by xrandr.
        If not provided, all enabled screens will be rotated.
        (default None)
    vertical_icon: a character to represent vertical rotation.
        (default 'V')
    vertical_rotation: a vertical rotation for xrandr to use.
        Available options: 'left' or 'right'.
        (default 'left')

Format placeholders:
    {icon} a rotation icon, specified by `horizontal_icon` or `vertical_icon`.
    {screen} a screen name, specified by `screen` option or detected
        automatically if only one screen is connected, otherwise 'ALL'.

Color options:
    color_degraded: Screen is disconnected
    color_good: Displayed rotation is active

@author Maxim Baz (https://github.com/maximbaz)
@license BSD

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': u'H'}

vertical
{'full_text': u'V'}
"""


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "{icon}"
    hide_if_disconnected = False
    horizontal_icon = "H"
    horizontal_rotation = "normal"
    screen = None
    vertical_icon = "V"
    vertical_rotation = "left"

    def post_config_hook(self):
        self.displayed = ""
        self.scrolling = False

    def _get_active_outputs(self):
        data = self.py3.command_output(["xrandr"]).splitlines()
        connected_outputs = [x.split() for x in data if " connected" in x]
        active_outputs = []
        for output in connected_outputs:
            for x in output[2:]:
                if "x" in x and "+" in x:
                    active_outputs.append(output[0])
                    break
                elif "(" in x:
                    break
        return active_outputs

    def _get_current_rotation_icon(self, all_outputs):
        data = self.py3.command_output(["xrandr"]).splitlines()
        output = self.screen or all_outputs[0]
        output_line = "".join(x for x in data if x.startswith(output))

        for x in output_line.split():
            if "normal" in x or "inverted" in x:
                return self.horizontal_icon
            elif "left" in x or "right" in x:
                return self.vertical_icon

    def _apply(self):
        if self.displayed == self.horizontal_icon:
            rotation = self.horizontal_rotation
        else:
            rotation = self.vertical_rotation
        cmd = "xrandr"
        outputs = [self.screen] if self.screen else self._get_active_outputs()
        for output in outputs:
            cmd += f" --output {output} --rotate {rotation}"
        self.py3.command_run(cmd)

    def _switch_selection(self):
        if self.displayed == self.horizontal_icon:
            self.displayed = self.vertical_icon
        else:
            self.displayed = self.horizontal_icon

    def xrandr_rotate(self):
        all_outputs = self._get_active_outputs()
        selected_screen_disconnected = self.screen is not None and self.screen not in all_outputs
        if selected_screen_disconnected and self.hide_if_disconnected:
            self.displayed = ""
            full_text = ""
        else:
            if not self.scrolling:
                self.displayed = self._get_current_rotation_icon(all_outputs)

            if self.screen or len(all_outputs) == 1:
                screen = self.screen or all_outputs[0]
            else:
                screen = "ALL"
            full_text = self.py3.safe_format(
                self.format, dict(icon=self.displayed or "?", screen=screen)
            )

        response = {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": full_text,
        }

        # coloration
        if selected_screen_disconnected and not self.hide_if_disconnected:
            response["color"] = self.py3.COLOR_DEGRADED
        elif self.displayed == self._get_current_rotation_icon(all_outputs):
            response["color"] = self.py3.COLOR_GOOD

        self.scrolling = False
        return response

    def on_click(self, event):
        """
        Click events
            - left click & scroll up/down: switch between rotations
            - right click: apply selected rotation
        """
        button = event["button"]
        if button in [1, 4, 5]:
            self.scrolling = True
            self._switch_selection()
        elif button == 3:
            self._apply()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/xscreensaver.py
================================================
"""
Control Xscreensaver.

This script is useful for people who let Xscreensaver manage DPMS settings.
Xscreensaver has its own DPMS variables separate from xset. DPMS can be
safely turned off in xset as long as Xscreensaver is running.
Settings can be managed using "xscreensaver-demo".

Configuration parameters:
    button_activate: mouse button to activate Xscreensaver (default 3)
    button_toggle: mouse button to toggle Xscreensaver (default 1)
    cache_timeout: refresh interval for this module (default 15)
    format: display format for this module (default '{icon}')
    icon_off: show when Xscreensaver is not running (default 'XSCR')
    icon_on: show when Xscreensaver is running (default 'XSCR')

Format placeholders:
    {icon} Xscreensaver icon

Color options:
    color_on: Enabled, defaults to color_good
    color_off: Disabled, defaults to color_bad

@author neutronst4r, lasers

SAMPLE OUTPUT
{'color': '#00FF00', 'full_text': 'XSCR'}

off
{'color': '#FF0000', 'full_text': 'XSCR'}
"""

from os import setpgrp
from subprocess import PIPE, Popen

STRING_UNAVAILABLE = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    button_activate = 3
    button_toggle = 1
    cache_timeout = 15
    format = "{icon}"
    icon_off = "XSCR"
    icon_on = "XSCR"

    def post_config_hook(self):
        self.color_on = self.py3.COLOR_ON or self.py3.COLOR_GOOD
        self.color_off = self.py3.COLOR_OFF or self.py3.COLOR_BAD
        if not self.py3.check_commands(["xscreensaver"]):
            raise Exception(STRING_UNAVAILABLE)

    def _is_running(self):
        try:
            self.py3.command_output(["pidof", "xscreensaver"])
            return True
        except self.py3.CommandError:
            return False

    def xscreensaver(self):
        run = self._is_running()
        if run:
            icon = self.icon_on
            color = self.color_on
        else:
            icon = self.icon_off
            color = self.color_off

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"icon": icon}),
            "color": color,
        }

    def on_click(self, event):
        run = self._is_running()
        if event["button"] == self.button_activate:
            self.py3.command_run(["xscreensaver-command", "-activate"])

        if event["button"] == self.button_toggle:
            if run:
                self.py3.command_run(["xscreensaver-command", "-exit"])
            else:
                # Because we want xscreensaver to continue running after
                # exit, we instead use preexec_fn=setpgrp here.
                Popen(
                    ["xscreensaver", "-no-splash", "-no-capture-stderr"],
                    stdout=PIPE,
                    stderr=PIPE,
                    preexec_fn=setpgrp,
                )


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/xsel.py
================================================
"""
Display X selection.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 0.5)
    command: the clipboard command to run (default 'xsel --output')
    format: display format for this module (default '{selection}')
    log_file: specify the clipboard log to use (default None)
    max_size: strip the selection to this value (default 15)
    symmetric: show beginning and end of the selection string
        with respect to configured max_size. (default True)

Format placeholders:
    {selection} output from clipboard command

Requires:
    xsel: a command-line program to retrieve/set the X selection

Examples:
```
xsel {
    max_size = 50
    command = "xsel --clipboard --output"
    on_click 1 = "exec xsel --clear --clipboard"
    log_file = "~/.local/share/xsel/clipboard_log"
}
```

@author Sublim3 umbsublime@gamil.com
@license BSD

SAMPLE OUTPUT
{'full_text': 'selected text'}
"""

import time
from pathlib import Path


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 0.5
    command = "xsel --output"
    format = "{selection}"
    log_file = None
    max_size = 15
    symmetric = True

    def post_config_hook(self):
        self.selection_cache = None
        if self.log_file:
            self.log_file = Path(self.log_file).expanduser()

    def xsel(self):
        selection = self.py3.command_output(self.command).strip()

        if self.log_file and selection and selection != self.selection_cache:
            with self.log_file.open("a") as f:
                datetime = time.strftime("%Y-%m-%d %H:%M:%S")
                f.write(f"{datetime}\n{selection}\n")
            self.selection_cache = selection

        selection = " ".join(selection.split())
        if len(selection) >= self.max_size:
            if self.symmetric is True:
                split = self.max_size // 2 - 1
                selection = selection[:split] + ".." + selection[-split:]
            else:
                selection = selection[: self.max_size]
        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, {"selection": selection}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/yandexdisk_status.py
================================================
"""
Display Yandex.Disk status.

Configuration parameters:
    cache_timeout: refresh interval for this module (default 10)
    format: display format for this module (default 'Yandex.Disk: {status}')
    status_busy: show when Yandex.Disk is busy (default None)
    status_off: show when Yandex.Disk isn't running (default 'Not started')
    status_on: show when Yandex.Disk is idling (default 'Idle')

Format placeholders:
    {status} Yandex.Disk status

Color options:
    color_bad: Not started
    color_degraded: Idle
    color_good: Busy

Requires:
    yandex-disk: command line interface for Yandex.Disk

@author Vladimir Potapev (github:vpotapev)
@license BSD

SAMPLE OUTPUT
{'color': '#FFFF00', 'full_text': 'Yandex.Disk: Busy'}

idle
{'color': '#00FF00', 'full_text': 'Yandex.Disk: Idle'}

off
{'color': '#FF0000', 'full_text': 'Yandex.Disk: Not started'}
"""

STRING_NOT_INSTALLED = "not installed"


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 10
    format = "Yandex.Disk: {status}"
    status_busy = None
    status_off = "Not started"
    status_on = "Idle"

    def post_config_hook(self):
        if not self.py3.check_commands("yandex-disk"):
            raise Exception(STRING_NOT_INSTALLED)

    def yandexdisk_status(self):
        status = self.py3.command_output("yandex-disk status").splitlines()[0]

        if status == "Error: daemon not started":
            color = self.py3.COLOR_BAD
            status = self.status_off
        elif status == "Synchronization core status: idle":
            color = self.py3.COLOR_GOOD
            status = self.status_on
        else:
            color = self.py3.COLOR_DEGRADED
            if self.status_busy is not None:
                status = self.status_busy

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "color": color,
            "full_text": self.py3.safe_format(self.format, {"status": status}),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/yubikey.py
================================================
r"""
Show an indicator when YubiKey is waiting for a touch.

Configuration parameters:
    format: Display format for the module.
        (default '[YubiKey[\?if=is_gpg ][\?if=is_u2f ]]')
    socket_path: A path to the yubikey-touch-detector socket file.
        (default '$XDG_RUNTIME_DIR/yubikey-touch-detector.socket')

Control placeholders:
    {is_gpg} a boolean, True if YubiKey is waiting for a touch due to a gpg operation.
    {is_u2f} a boolean, True if YubiKey is waiting for a touch due to a pam-u2f request.

Requires:
    github.com/maximbaz/yubikey-touch-detector: tool to detect when YubiKey is waiting for a touch

@author Maxim Baz (https://github.com/maximbaz)
@license BSD

SAMPLE OUTPUT
{'full_text': 'YubiKey', 'urgent': True}
"""

import os
import socket
import threading
import time
from pathlib import Path


class YubiKeyTouchDetectorListener(threading.Thread):
    """
    A thread watchng if YubiKey is waiting for a touch
    """

    def __init__(self, parent):
        super().__init__()
        self.parent = parent

    def _connect_socket(self):
        try:
            self.parent.error = None
            self.socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.socket.connect(self.parent.socket_path)
        except:  # noqa e722
            self.socket = None
            self.parent.error = "Cannot connect to yubikey-touch-detector"

    def run(self):
        while not self.parent.killed.is_set():
            self._connect_socket()

            # Refresh once to show or clear error as needed
            self.parent.py3.update()

            if self.socket is None:
                # Socket is not available, try again soon
                time.sleep(60)
                continue

            while not self.parent.killed.is_set():
                data = self.socket.recv(5)
                if not data:
                    # Connection dropped, need to reconnect
                    break
                elif data == b"GPG_1":
                    self.parent.status["is_gpg"] = True
                elif data == b"GPG_0":
                    self.parent.status["is_gpg"] = False
                elif data == b"U2F_1":
                    self.parent.status["is_u2f"] = True
                elif data == b"U2F_0":
                    self.parent.status["is_u2f"] = False
                self.parent.py3.update()


class Py3status:
    """ """

    # available configuration parameters
    format = r"[YubiKey[\?if=is_gpg ][\?if=is_u2f ]]"
    socket_path = "$XDG_RUNTIME_DIR/yubikey-touch-detector.socket"

    def post_config_hook(self):
        self.socket_path = Path(self.socket_path).expanduser()
        self.socket_path = os.path.expandvars(self.socket_path)

        self.status = {"is_gpg": False, "is_u2f": False}
        self.error = None

        self.killed = threading.Event()
        YubiKeyTouchDetectorListener(self).start()

    def yubikey(self):
        if self.error:
            self.py3.error(self.error, self.py3.CACHE_FOREVER)

        response = {
            "cached_until": self.py3.CACHE_FOREVER,
            "full_text": self.py3.safe_format(self.format, self.status),
        }
        if any(self.status.values()):
            response["urgent"] = True
        return response

    def kill(self):
        self.killed.set()


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: py3status/modules/zypper_updates.py
================================================
r"""
Display number of pending updates for OpenSUSE Linux.

Configuration parameters:
    cache_timeout: How often we refresh this module in seconds
        (default 600)
    format: Display format to use
        (default 'zypper: [\?color=update {update}]')
    thresholds: specify color thresholds to use
        (default [(0, 'good'), (50, 'degraded'), (100, 'bad')])

Format placeholders:
    {updates} number of pending zypper updates

Color thresholds:
    xxx: print a color based on the value of `xxx` placeholder

@author Ioannis Bonatakis <ybonatakis@suse.com>
@license BSD

SAMPLE OUTPUT
[{'full_text': 'zypper: '}, {'full_text': '0', 'color': '#00FF00'}]
"""

import re
import subprocess


class Py3status:
    """ """

    # available configuration parameters
    cache_timeout = 600
    format = r"zypper: [\?color=update {update}]"
    thresholds = [(0, "good"), (50, "degraded"), (100, "bad")]

    def post_config_hook(self):
        self.thresholds_init = self.py3.get_color_names_list(self.format)
        self.reg_ex_pkg = re.compile(b"v\\s\\S+", re.M)

    def zypper_updates(self):
        output, error = subprocess.Popen(
            ["zypper", "lu"], stdout=subprocess.PIPE, stderr=subprocess.PIPE
        ).communicate()

        zypper_data = {
            "update": len(self.reg_ex_pkg.findall(output)),
        }

        for x in self.thresholds_init:
            if x in zypper_data:
                self.py3.threshold_get_color(zypper_data[x], x)

        return {
            "cached_until": self.py3.time_in(self.cache_timeout),
            "full_text": self.py3.safe_format(self.format, zypper_data),
        }


if __name__ == "__main__":
    """
    Run module in test mode.
    """
    from py3status.module_test import module_test

    module_test(Py3status)



================================================
FILE: requirements/project.txt
================================================
hatch==1.7.0



================================================
FILE: tests/test_composite.py
================================================
from py3status.composite import Composite


# Composite initialize


def test_Composite_init_1():
    result = Composite("moo").get_content()
    assert result == [{"full_text": "moo"}]


def test_Composite_init_2():
    result = Composite({"full_text": "moo"}).get_content()
    assert result == [{"full_text": "moo"}]


def test_Composite_init_3():
    result = Composite([{"full_text": "moo"}]).get_content()
    assert result == [{"full_text": "moo"}]


def test_Composite_init_4():
    result = Composite(Composite("moo")).get_content()
    assert result == [{"full_text": "moo"}]


# Composite append


def test_Composite_append_1():
    c = Composite("moo")
    c.append("moo")
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]


def test_Composite_append_2():
    c = Composite("moo")
    c.append({"full_text": "moo"})
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]


def test_Composite_append_3():
    c = Composite("moo")
    c.append([{"full_text": "moo"}])
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]


def test_Composite_append_4():
    c = Composite("moo")
    c.append(Composite("moo"))
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]


# Composite __iadd__


def test_Composite_iadd_1():
    c = Composite("moo")
    c += "moo"
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]


def test_Composite_iadd_2():
    c = Composite("moo")
    c += {"full_text": "moo"}
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]


def test_Composite_iadd_3():
    c = Composite("moo")
    c += [{"full_text": "moo"}]
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]


def test_Composite_iadd_4():
    c = Composite("moo")
    c += Composite("moo")
    result = c.get_content()
    assert result == [{"full_text": "moo"}, {"full_text": "moo"}]



================================================
FILE: tests/test_consistency.py
================================================
from pathlib import Path

MODULE_PATH = Path(__file__).resolve().parent.parent / "py3status" / "modules"


def test_method_mismatch():
    line = "def {}(self"
    skip_files = ["__init__.py", "i3pystatus.py"]
    errors = []

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                if f"def {_file.stem}(self" not in f.read():
                    errors.append((_file.stem, _file))
    if errors:
        line = "Method mismatched error(s) detected!\n\n"
        for error in errors:
            line += "Method `{}` is not in module `{}`\n".format(*error)
        print(line[:-1])
        assert False


def test_authors():
    comment = "@author"
    skip_files = ["__init__.py"]
    errors = []

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                if comment not in f.read():
                    errors.append((comment, _file))
    if errors:
        line = "Missing @author error(s) detected!\n\n"
        for error in errors:
            line += "`{}` is not in module `{}`\n".format(*error)
        print(line[:-1])
        assert False


def test_sample_output():
    comment = "SAMPLE OUTPUT"
    skip_files = ["__init__.py"]
    errors = []

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                if comment not in f.read():
                    errors.append((comment, _file))
    if errors:
        line = "Missing sample error(s) detected!\n\n"
        for error in errors:
            line += "`{}` is not in module `{}`\n".format(*error)
        print(line[:-1])
        assert False


# def test_examples():
#     comment = "Examples:"
#     skip_files = ["__init__.py"]
#     errors = []
#
#     for _file in sorted(MODULE_PATH.iterdir()):
#         if _file.suffix == ".py" and _file.name not in skip_files:
#             with _file.open() as f:
#                 if comment not in f.read():
#                     errors.append((comment, _file))
#     if errors:
#         line = "Missing example error(s) detected!\n\n"
#         for error in errors:
#             line += "`{}` is not in module `{}`\n".format(*error)
#         print(line[:-1])
#         assert False


def test_available_configuration_parameters():
    comment = "# available configuration parameters"
    skip_files = ["__init__.py"]
    errors = []

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                if comment not in f.read():
                    errors.append((comment, _file))
    if errors:
        line = "Missing comment error(s) detected!\n\n"
        for error in errors:
            line += "Comment `{}` is not in module `{}`\n".format(*error)
        print(line[:-1])
        assert False


def test_class_meta_before_parameters():
    line = "class Meta:"
    comment = "# available configuration parameters"
    errors = []
    skip_files = ["__init__.py"]

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                for x in f.readlines():
                    if line in x:
                        errors.append((line, _file))
                        break
                    elif comment in x:
                        break
    if errors:
        line = "Class Meta error(s) detected!\n\n"
        for error in errors:
            line += "`{}` is defined early in module `{}`\n".format(*error)
        print(line[:-1])
        assert False


def test_examples_before_requires():
    line = "Examples:"
    comment = "Requires:"
    errors = []
    skip_files = ["__init__.py"]

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                output = f.read()
                if line not in output or comment not in output:
                    continue
                for x in output.splitlines():
                    if x.startswith(line):
                        errors.append((line, _file))
                        break
                    elif x.startswith(comment):
                        break
    if errors:
        line = "Examples error(s) detected!\n\n"
        for error in errors:
            line += "`{}` is defined early in module `{}`\n".format(*error)
        print(line[:-1])
        assert False


def test_authors_before_examples():
    line = "@author "
    comment = "Examples:"
    errors = []
    skip_files = ["__init__.py"]

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                output = f.read()
                if line not in output or comment not in output:
                    continue
                for x in output.splitlines():
                    if x.startswith(line):
                        errors.append((line, _file))
                        break
                    elif x.startswith(comment):
                        break
    if errors:
        line = "Author error(s) detected!\n\n"
        for error in errors:
            line += "`{}` is defined early in module `{}`\n".format(*error)
        print(line[:-1])
        assert False


def test_format_placeholders():
    comment = "ormat placeholders:"
    comment2 = "ontrl placeholders:"
    skip_files = [
        "__init__.py",
        "i3pystatus.py",
        "keyboard_locks.py",
        "screenshot.py",
        "static_string.py",
        "wwan_status.py",
        "yubikey.py",
    ]
    errors = []

    for _file in sorted(MODULE_PATH.iterdir()):
        if _file.suffix == ".py" and _file.name not in skip_files:
            with _file.open() as f:
                output = f.read()
                if comment not in output:
                    if comment2 not in output:
                        errors.append((comment, _file))
    if errors:
        line = f"Missing `{comment}` error(s) detected!\n\n"
        for error in errors:
            line += "`{}` is not in module `{}`\n".format(*error)
        print(line[:-1])
        assert False



================================================
FILE: tests/test_formatter.py
================================================
"""
Run formatter tests
"""

import platform

from pprint import pformat

import pytest

from py3status.composite import Composite
from py3status.formatter import Formatter
from py3status.py3 import NoneColor

is_pypy = platform.python_implementation() == "PyPy"
f = Formatter()

param_dict = {
    "name": "Björk",
    "number": 42,
    "pi": 3.14159265359,
    "yes": True,
    "no": False,
    "empty": "",
    "None": None,
    "?bad name": "evil",
    "☂ Very bad name ": "☂ extremely evil",
    "long_str": "I am a long string though not too long",
    "python2_unicode": "Björk",
    "python2_str": "Björk",
    "zero": 0,
    "zero_str": "0",
    "zero_float": 0.0,
    "zero_almost": 0.0001,
    "str_int": "123",
    "str_float": "123.456",
    "str_nan": "I'm not a number",
    "trailing_zeroes_1": "50.000",
    "trailing_zeroes_2": "5.500",
    "composite_basic": Composite(
        [
            {"full_text": "red ", "color": "#FF0000"},
            {"full_text": "green ", "color": "#00FF00"},
            {"full_text": "blue", "color": "#0000FF"},
        ]
    ),
    "complex": Composite([{"full_text": "LA 09:34"}, {"full_text": "NY 12:34"}]),
    "complex2": Composite(
        [{"full_text": "LA 09:34", "color": "#FF0000"}, {"full_text": "NY 12:34"}]
    ),
    "simple": Composite({"full_text": "NY 12:34"}),
    "empty_composite": Composite(),
    "comp_bad_color": Composite({"full_text": "BAD", "color": NoneColor()}),
    "composite_looks_empty": Composite([{"color": "#FFF", "full_text": ""}]),
}


class Module:
    module_param = "something"
    module_true = True
    module_false = False

    class py3:
        COLOR_BAD = "#FF0000"
        COLOR_DEGRADED = "#FFFF00"
        COLOR_GOOD = "#00FF00"

    def module_method(self):
        return "method"

    @property
    def module_property(self):
        return "property"


def attr_getter_fn(attr):
    """
    test attr_getter function
    """
    return f"*{attr}*"


def run_formatter(test_dict):
    __tracebackhide__ = True

    if not test_dict.get("pypy", True) and is_pypy:
        return
    if test_dict.get("attr_getter"):
        attr_getter = attr_getter_fn
    else:
        attr_getter = None
    try:
        module = Module()
        result = f.format(
            test_dict["format"],
            module,
            param_dict,
            force_composite=test_dict.get("composite"),
            attr_getter=attr_getter,
        )
    except Exception as e:
        if test_dict.get("exception") == str(e):
            return
        print("Format\n{}\n".format(test_dict["format"]))
        raise e

    # simplify the composite and convert to text if possible
    if isinstance(result, Composite):
        result.simplify()
        if not test_dict.get("composite") and len(result) == 1 and len(result[0]) == 1:
            result = result[0]["full_text"]

    if hasattr(result, "get_content"):
        result = result.get_content()

    expected = test_dict.get("expected")
    if result != expected:
        print("Format\n{}\n".format(test_dict["format"]))
        print("Expected\n{}".format(pformat(expected)))
        print("Got\n{}".format(pformat(result)))
    if result != expected:
        pytest.fail("Results not as expected")


def get_placeholders(test_dict):
    __tracebackhide__ = True

    result = f.get_placeholders(test_dict["format"])
    expected = test_dict.get("expected")

    if result != expected:
        print("Format\n{}\n".format(test_dict["format"]))
        print("Expected\n{}".format(pformat(expected)))
        print("Got\n{}".format(pformat(result)))
    if result != expected:
        pytest.fail("Results not as expected")


def update_placeholders(test_dict):
    __tracebackhide__ = True

    result = f.update_placeholders(test_dict["format"], test_dict["updates"])
    expected = test_dict.get("expected")

    if result != expected:
        print("Format\n{}\n".format(test_dict["format"]))
        print("Expected\n{}".format(pformat(expected)))
        print("Got\n{}".format(pformat(result)))
    if result != expected:
        pytest.fail("Results not as expected")


def get_color_names(test_dict):
    __tracebackhide__ = True

    result = f.get_color_names(test_dict["format"])
    expected = test_dict.get("expected")

    if result != expected:
        print("Format\n{}\n".format(test_dict["format"]))
        print("Expected\n{}".format(pformat(expected)))
        print("Got\n{}".format(pformat(result)))
    if result != expected:
        pytest.fail("Results not as expected")


def test_1():
    run_formatter({"format": "hello ☂", "expected": "hello ☂"})


def test_2():
    run_formatter({"format": "hello ☂", "expected": "hello ☂"})


def test_3():
    run_formatter({"format": "[hello]", "expected": ""})


def test_4():
    run_formatter({"format": r"\\ \[ \] \{ \}", "expected": r"\ [ ] { }"})


def test_5():
    run_formatter({"format": "{{hello}}", "expected": "{hello}"})


def test_6():
    run_formatter({"format": "{{hello}", "expected": "{hello}"})


def test_7():
    run_formatter({"format": "{?bad name}", "expected": "evil"})


def test_8():
    run_formatter(
        {
            "format": "{☂ Very bad name }",
            "expected": "☂ extremely evil",
            # unicode.format({<unicode>: ..}) is broken in pypy
            "pypy": False,
        }
    )


def test_9():
    run_formatter(
        {"format": "{missing} {name} {number}", "expected": "{missing} Björk 42"}
    )


def test_10():
    run_formatter({"format": "{missing}|{name}|{number}", "expected": "Björk"})


def test_11():
    run_formatter({"format": "{missing}|empty", "expected": "empty"})


def test_12():
    run_formatter({"format": "[{missing}|empty]", "expected": ""})


def test_13():
    run_formatter({"format": "pre [{missing}|empty] post", "expected": "pre  post"})


def test_14():
    run_formatter({"format": "pre [{missing}|empty] post|After", "expected": "After"})


def test_15():
    run_formatter({"format": "{module_param}", "expected": "something"})


def test_16():
    run_formatter({"format": "{module_method}", "expected": "{module_method}"})


def test_16a():
    run_formatter({"format": "x {module_method}", "expected": "x {module_method}"})


def test_16b():
    run_formatter({"format": "[x {module_method}]", "expected": ""})


def test_17():
    run_formatter({"format": "{module_property}", "expected": "property"})


def test_18():
    run_formatter({"format": "Hello {name}!", "expected": "Hello Björk!"})


def test_19():
    run_formatter({"format": "[Hello {name}!]", "expected": "Hello Björk!"})


def test_20():
    run_formatter({"format": "[Hello {missing}|Anon!]", "expected": ""})


def test_21():
    run_formatter(
        {"format": "zero [one [two [three [no]]]]|Numbers", "expected": "Numbers"}
    )


def test_22():
    run_formatter(
        {
            "format": "zero [one [two [three [{yes}]]]]|Numbers",
            "expected": "zero one two three True",
        }
    )


def test_23():
    run_formatter(
        {"format": "zero [one [two [three [{no}]]]]|Numbers", "expected": "Numbers"}
    )


# zero/False/None etc


def test_24():
    run_formatter({"format": "{zero}", "expected": "0"})


def test_24a():
    run_formatter({"format": "{zero_str}", "expected": "0"})


def test_24b():
    run_formatter({"format": "{zero_float}", "expected": "0.0"})


def test_25():
    run_formatter({"format": "[{zero}] hello", "expected": "0 hello"})


def test_26():
    run_formatter({"format": "[{zero} ping] hello", "expected": "0 ping hello"})


def test_27():
    run_formatter({"format": "{None}", "expected": ""})


def test_28():
    run_formatter({"format": "[{None}] hello", "expected": " hello"})


def test_29():
    run_formatter({"format": "[{None} ping] hello", "expected": " hello"})


def test_30():
    run_formatter({"format": "{no}", "expected": ""})


def test_31():
    run_formatter({"format": "[{no}] hello", "expected": " hello"})


def test_32():
    run_formatter({"format": "[{no} ping] hello", "expected": " hello"})


def test_33():
    run_formatter({"format": "{yes}", "expected": "True"})


def test_34():
    run_formatter({"format": "[{yes}] hello", "expected": "True hello"})


def test_35():
    run_formatter({"format": "[{yes} ping] hello", "expected": "True ping hello"})


def test_36():
    run_formatter({"format": "{empty}", "expected": ""})


def test_37():
    run_formatter({"format": "[{empty}] hello", "expected": " hello"})


def test_38():
    run_formatter({"format": "[{empty} ping] hello", "expected": " hello"})


def test_39():
    run_formatter(
        # python 2 unicode
        {"format": "Hello {python2_unicode}! ☂", "expected": "Hello Björk! ☂"}
    )


def test_40():
    run_formatter(
        {"format": "Hello {python2_unicode}! ☂", "expected": "Hello Björk! ☂"}
    )


def test_41():
    run_formatter({"format": "Hello {python2_str}! ☂", "expected": "Hello Björk! ☂"})


def test_42():
    run_formatter({"format": "Hello {python2_str}! ☂", "expected": "Hello Björk! ☂"})


def test_43():
    run_formatter(
        # formatting
        {"format": "{name}", "expected": "Björk"}
    )


def test_44():
    run_formatter({"format": "{name!s}", "expected": "Björk"})


def test_45():
    # the representation is different in python2 "u'Björk'"
    run_formatter({"format": "{name!r}", "expected": "'Björk'", "py3only": True})


def test_46():
    run_formatter({"format": "{name:7}", "expected": "Björk  "})


def test_47():
    run_formatter({"format": "{name:<7}", "expected": "Björk  "})


def test_48():
    run_formatter({"format": "{name:>7}", "expected": "  Björk"})


def test_49():
    run_formatter({"format": "{name:*^9}", "expected": "**Björk**"})


def test_50():
    run_formatter(
        {"format": "{long_str}", "expected": "I am a long string though not too long"}
    )


def test_51():
    run_formatter({"format": "{long_str:.6}", "expected": "I am a"})


def test_52():
    run_formatter({"format": "{number}", "expected": "42"})


def test_53():
    run_formatter({"format": "{number:04d}", "expected": "0042"})


def test_54():
    run_formatter({"format": "{pi}", "expected": "3.14159265359"})


def test_55():
    run_formatter({"format": "{pi:05.2f}", "expected": "03.14"})


def test_56():
    run_formatter(
        # commands
        {"format": r"{missing}|\?show Anon", "expected": "Anon"}
    )


def test_57():
    run_formatter(
        {"format": r"Hello [{missing}|[\?show Anon]]!", "expected": "Hello Anon!"}
    )


def test_58():
    run_formatter({"format": r"[\?if=yes Hello]", "expected": "Hello"})


def test_58a():
    run_formatter({"format": r"\?if=yes Hello", "expected": "Hello"})


def test_59():
    run_formatter({"format": r"[\?if=no Hello]", "expected": ""})


def test_59a():
    run_formatter({"format": r"\?if=no Hello", "expected": ""})


def test_60():
    run_formatter({"format": r"[\?if=missing Hello]", "expected": ""})


def test_61():
    run_formatter({"format": r"[\?if=!yes Hello]", "expected": ""})


def test_62():
    run_formatter({"format": r"[\?if=!no Hello]", "expected": "Hello"})


def test_63():
    run_formatter({"format": r"[\?if=!missing Hello]", "expected": "Hello"})


def test_64():
    run_formatter({"format": r"[\?if=yes Hello[ {name}]]", "expected": "Hello Björk"})


def test_65():
    run_formatter({"format": r"[\?if=no Hello[ {name}]]", "expected": ""})


def test_66():
    run_formatter(
        {"format": r"[\?max_length=10 Hello {name} {number}]", "expected": "Hello Björ"}
    )


def test_67():
    run_formatter(
        {"format": r"\?max_length=9 Hello {name} {number}", "expected": "Hello Bjö"}
    )


def test_68():
    run_formatter(
        # Errors
        {"format": "hello]", "exception": "Too many `]`"}
    )


def test_69():
    run_formatter({"format": "[hello", "exception": "Block not closed"})


def test_70():
    run_formatter(
        # Composites
        {"format": "{empty_composite}", "expected": [], "composite": True}
    )


def test_70a():
    run_formatter(
        # Composites
        {"format": "[{empty_composite} hello]", "expected": [], "composite": True}
    )


def test_71():
    run_formatter(
        {
            "format": "{simple}",
            "expected": [{"full_text": "NY 12:34"}],
            "composite": True,
        }
    )


def test_72():
    run_formatter(
        {
            "format": "{complex}",
            "expected": [{"full_text": "LA 09:34NY 12:34"}],
            "composite": True,
        }
    )


def test_73():
    run_formatter(
        {
            "format": "TEST {simple}",
            "expected": [{"full_text": "TEST NY 12:34"}],
            "composite": True,
        }
    )


def test_74():
    run_formatter({"format": "[{empty}]", "expected": [], "composite": True})


def test_75():
    run_formatter(
        {
            "format": "[{simple}]",
            "expected": [{"full_text": "NY 12:34"}],
            "composite": True,
        }
    )


def test_76():
    run_formatter(
        {
            "format": "[{complex}]",
            "expected": [{"full_text": "LA 09:34NY 12:34"}],
            "composite": True,
        }
    )


def test_77():
    run_formatter(
        {
            "format": "TEST [{simple}]",
            "expected": [{"full_text": "TEST NY 12:34"}],
            "composite": True,
        }
    )


def test_78():
    run_formatter(
        {
            "format": "{simple} TEST [{name}[ {number}]]",
            "expected": [{"full_text": "NY 12:34 TEST Björk 42"}],
            "composite": True,
        }
    )


def test_else_true():
    run_formatter({"format": r"[\?if=yes Hello|Goodbye]", "expected": "Hello"})


def test_else_false():
    run_formatter(
        {"format": r"[\?if=no Hello|Goodbye|Something else]", "expected": "Goodbye"}
    )


def test_composite_looks_empty():
    run_formatter({"format": "[ {composite_looks_empty}]", "expected": ""})


# block colors


def test_color_name_1():
    run_formatter(
        {
            "format": r"\?color=bad color",
            "expected": [{"full_text": "color", "color": "#FF0000"}],
        }
    )


def test_color_name_2():
    run_formatter({"format": r"\?color=no_name color", "expected": "color"})


def test_color_name_3():
    run_formatter(
        {
            "format": r"\?color=#FF00FF color",
            "expected": [{"full_text": "color", "color": "#FF00FF"}],
        }
    )


def test_color_name_4():
    run_formatter(
        {
            "format": r"\?color=#ff00ff color",
            "expected": [{"full_text": "color", "color": "#FF00FF"}],
        }
    )


def test_color_name_4a():
    run_formatter(
        {
            "format": r"[\?color=#ff00ff&show color]",
            "expected": [{"full_text": "color", "color": "#FF00FF"}],
        }
    )


def test_color_name_5():
    run_formatter(
        {
            "format": r"\?color=#F0F color",
            "expected": [{"full_text": "color", "color": "#FF00FF"}],
        }
    )


def test_color_name_5a():
    run_formatter(
        {
            "format": r"[\?color=#F0F&show color]",
            "expected": [{"full_text": "color", "color": "#FF00FF"}],
        }
    )


def test_color_name_6():
    run_formatter(
        {
            "format": r"\?color=#f0f color",
            "expected": [{"full_text": "color", "color": "#FF00FF"}],
        }
    )


def test_color_name_7():
    run_formatter({"format": r"\?color=#BADHEX color", "expected": "color"})


def test_color_name_7a():
    run_formatter({"format": r"[\?color=#BADHEX&show color]", "expected": "color"})


def test_color_1():
    run_formatter(
        {
            "format": r"[\?color=bad {name}]",
            "expected": [{"full_text": "Björk", "color": "#FF0000"}],
        }
    )


def test_color_1a():
    run_formatter(
        {
            "format": r"\?color=bad {name}",
            "expected": [{"full_text": "Björk", "color": "#FF0000"}],
        }
    )


def test_color_2():
    run_formatter(
        {
            "format": r"[\?color=good Name [\?color=bad {name}] hello]",
            "expected": [
                {"full_text": "Name ", "color": "#00FF00"},
                {"full_text": "Björk", "color": "#FF0000"},
                {"full_text": " hello", "color": "#00FF00"},
            ],
        }
    )


def test_color_3():
    run_formatter(
        {
            "format": r"[\?max_length=20&color=good Name [\?color=bad {name}] hello]",
            "expected": [
                {"full_text": "Name ", "color": "#00FF00"},
                {"full_text": "Björk", "color": "#FF0000"},
                {"full_text": " hello", "color": "#00FF00"},
            ],
        }
    )


def test_color_4():
    run_formatter(
        {
            "format": r"[\?max_length=8&color=good Name [\?color=bad {name}] hello]",
            "expected": [
                {"full_text": "Name ", "color": "#00FF00"},
                {"full_text": "Bjö", "color": "#FF0000"},
            ],
        }
    )


def test_color_5():
    run_formatter(
        {
            "format": r"[\?color=bad {name}][\?color=good {name}]",
            "expected": [
                {"full_text": "Björk", "color": "#FF0000"},
                {"full_text": "Björk", "color": "#00FF00"},
            ],
        }
    )


def test_color_6():
    run_formatter(
        {
            "format": r"[\?color=bad {name}] [\?color=good {name}]",
            "expected": [
                {"full_text": "Björk ", "color": "#FF0000"},
                {"full_text": "Björk", "color": "#00FF00"},
            ],
        }
    )


def test_color_7():
    run_formatter(
        {
            "format": r"\?color=bad {simple}",
            "expected": [{"full_text": "NY 12:34", "color": "#FF0000"}],
        }
    )


def test_color_7a():
    run_formatter(
        {
            "format": r"[\?color=bad {simple}]",
            "expected": [{"full_text": "NY 12:34", "color": "#FF0000"}],
        }
    )


def test_color_8():
    run_formatter(
        {
            "format": r"\?color=bad {complex}",
            "expected": [{"full_text": "LA 09:34NY 12:34", "color": "#FF0000"}],
        }
    )


def test_color_8a():
    run_formatter(
        {
            "format": r"[\?color=#FF00FF {complex}]",
            "expected": [{"full_text": "LA 09:34NY 12:34", "color": "#FF00FF"}],
        }
    )


def test_color_9():
    run_formatter(
        {
            "format": r"\?color=good {complex2}",
            "expected": [
                {"color": "#FF0000", "full_text": "LA 09:34"},
                {"color": "#00FF00", "full_text": "NY 12:34"},
            ],
        }
    )


def test_color_9a():
    run_formatter(
        {
            "format": r"[\?color=good {complex2}]",
            "expected": [
                {"color": "#FF0000", "full_text": "LA 09:34"},
                {"color": "#00FF00", "full_text": "NY 12:34"},
            ],
        }
    )


def test_color_10():
    # correct, but code is py3 instead of composite/formatter. same w/ color=hidden.
    run_formatter(
        {
            "format": r"[\?color=None&show None][\?color=degraded&show degraded]",
            "expected": [
                {"full_text": "None"},
                {"full_text": "degraded", "color": "#FFFF00"},
            ],
        }
    )


def test_color_11():
    # one would say it's right, but maybe one would say it's wrong too.
    run_formatter(
        {
            "format": r"[\?color=ORANGE&show orange] [\?color=bLuE&show blue]",
            "expected": "orange blue",  # wrong imho
            # "expected": [
            #     {"full_text": "orange", "color": "#FFA500"},
            #     {"full_text": "blue", "color": "#0000FF"},
            # ],
        }
    )


def test_color_12():
    run_formatter(
        {
            "color_test": "#FFA500",
            "format": r"\?color=test test",
            "expected": "test",  # wrong
            # "expected": [{"full_text": "test", "color": "#FFA500"}]
        }
    )


# Composite tests


def test_composite_1():
    run_formatter(
        {
            "format": "{composite_basic}",
            "expected": [
                {"color": "#FF0000", "full_text": "red "},
                {"color": "#00FF00", "full_text": "green "},
                {"color": "#0000FF", "full_text": "blue"},
            ],
        }
    )


def test_composite_2():
    run_formatter(
        {
            "format": "{composite_basic}",
            "expected": [
                {"color": "#FF0000", "full_text": "red "},
                {"color": "#00FF00", "full_text": "green "},
                {"color": "#0000FF", "full_text": "blue"},
            ],
            "composite": True,
        }
    )


def test_composite_3():
    run_formatter(
        {
            "format": "RGB: {composite_basic}",
            "expected": [
                {"full_text": "RGB: "},
                {"color": "#FF0000", "full_text": "red "},
                {"color": "#00FF00", "full_text": "green "},
                {"color": "#0000FF", "full_text": "blue"},
            ],
        }
    )


def test_composite_4():
    run_formatter(
        {
            "format": r"\?color=good {simple} {composite_basic} {complex}",
            "expected": [
                {"full_text": "NY 12:34 ", "color": "#00FF00"},
                {"color": "#FF0000", "full_text": "red "},
                {"color": "#00FF00", "full_text": "green "},
                {"color": "#0000FF", "full_text": "blue "},
                {"full_text": "LA 09:34NY 12:34", "color": "#00FF00"},
            ],
            "composite": True,
        }
    )


def test_composite_5():
    run_formatter(
        {
            "format": r"[\?color=#FF00FF {simple} {composite_basic} {complex2}]",
            "expected": [
                {"full_text": "NY 12:34 ", "color": "#FF00FF"},
                {"color": "#FF0000", "full_text": "red "},
                {"color": "#00FF00", "full_text": "green "},
                {"color": "#0000FF", "full_text": "blue "},
                {"color": "#FF0000", "full_text": "LA 09:34"},
                {"color": "#FF00FF", "full_text": "NY 12:34"},
            ],
            "composite": True,
        }
    )


def test_composite_6():
    run_formatter(
        {"format": "hello", "expected": [{"full_text": "hello"}], "composite": True}
    )


def test_attr_getter():
    run_formatter(
        {
            "format": "{test_attr_getter}",
            "expected": "*test_attr_getter*",
            "attr_getter": True,
        }
    )


def test_min_length_1():
    run_formatter({"format": r"\?min_length=9 Hello", "expected": "    Hello"})


def test_min_length_2():
    run_formatter({"format": r"[\?min_length=9&show Hello]", "expected": "    Hello"})


def test_min_length_3():
    run_formatter({"format": r"[\?min_length=9 [{name}]]", "expected": "    Björk"})


def test_min_length_4():
    run_formatter(
        {
            "format": r"[\?min_length=9 [\?color=good {name}]]",
            "expected": [{"color": "#00FF00", "full_text": "    Björk"}],
        }
    )


def test_min_length_5():
    run_formatter(
        {
            "format": r"\?min_length=9 [\?color=bad {number}][\?color=good {name}]",
            "expected": [
                {"full_text": "  42", "color": "#FF0000"},
                {"full_text": "Björk", "color": "#00FF00"},
            ],
        }
    )


def test_min_length_6():
    run_formatter(
        {
            "format": r"[\?min_length=9 [\?color=bad {number}][\?color=good {name}]]",
            "expected": [
                {"full_text": "  42", "color": "#FF0000"},
                {"full_text": "Björk", "color": "#00FF00"},
            ],
        }
    )


def test_numeric_strings_1():
    run_formatter({"format": "{str_int: d}", "expected": " 123"})


def test_numeric_strings_2():
    run_formatter({"format": "{str_int:.2f}", "expected": "123.00"})


def test_numeric_strings_3():
    run_formatter({"format": "{str_float: d}", "expected": " 123"})


def test_numeric_strings_4():
    run_formatter({"format": "{str_float:.1f}", "expected": "123.5"})


def test_numeric_strings_5():
    run_formatter({"format": "{str_nan: d}", "expected": "I'm not a number"})


def test_numeric_strings_6():
    run_formatter({"format": "{str_nan:.1f}", "expected": "I'm not a number"})


def test_not_zero_1():
    run_formatter({"format": r"[\?not_zero {zero}]", "expected": ""})


def test_not_zero_2():
    run_formatter({"format": r"[\?not_zero {zero_str}]", "expected": ""})


def test_not_zero_3():
    run_formatter({"format": r"[\?not_zero {zero_float}]", "expected": ""})


def test_not_zero_4():
    run_formatter({"format": r"[\?not_zero {yes}]", "expected": "True"})


def test_not_zero_5():
    run_formatter({"format": r"[\?not_zero {no}]", "expected": ""})


def test_not_zero_6():
    run_formatter({"format": r"[\?not_zero {number}]", "expected": "42"})


def test_not_zero_7():
    run_formatter({"format": r"[\?not_zero {pi}]", "expected": "3.14159265359"})


def test_not_zero_8():
    run_formatter({"format": r"[\?not_zero {name}]", "expected": "Björk"})


def test_not_zero_9():
    run_formatter({"format": r"[\?not_zero {str_nan}]", "expected": "I'm not a number"})


def test_not_zero_10():
    run_formatter(
        {"format": r"[\?not_zero {zero} {str_nan}]", "expected": "0 I'm not a number"}
    )


def test_not_zero_11():
    run_formatter({"format": r"[\?not_zero {zero_str} {zero}]", "expected": ""})


def test_bad_composite_color():
    run_formatter({"format": "{comp_bad_color}", "expected": "BAD"})


def test_soft_1():
    run_formatter({"format": r"{name}[\?soft  ]{name}", "expected": "Björk Björk"})


def test_soft_2():
    run_formatter({"format": r"{name}[\?soft  ]{empty}", "expected": "Björk"})


def test_soft_3():
    run_formatter({"format": r"{empty}[\?soft  ]{empty}", "expected": ""})


def test_soft_4():
    run_formatter({"format": r"[\?soft  ]", "expected": ""})


def test_soft_5():
    run_formatter(
        {"format": r"{number}[\?soft  {name} ]{number}", "expected": "42 Björk 42"}
    )


def test_soft_6():
    run_formatter({"format": r"{number}[\?soft  {name} ]{empty}", "expected": "42"})


def test_soft_7():
    run_formatter({"format": r"\?soft {number}", "expected": "42"})


def test_module_true():
    run_formatter({"format": r"[\?if=module_true something]", "expected": "something"})


def test_module_false():
    run_formatter({"format": r"[\?if=module_false something]", "expected": ""})


def test_module_true_value():
    run_formatter({"format": "{module_true}", "expected": "True"})


def test_module_false_value():
    run_formatter({"format": "{module_false}", "expected": ""})


def test_zero_format_1():
    run_formatter({"format": r"[\?not_zero {zero_almost}]", "expected": "0.0001"})


def test_zero_format_2():
    run_formatter({"format": r"[\?not_zero {zero_almost:d}]", "expected": ""})


def test_zero_format_3():
    run_formatter({"format": r"[\?not_zero {zero_almost:.3f}]", "expected": ""})


def test_zero_format_4():
    run_formatter({"format": r"[\?not_zero {zero_almost:.4f}]", "expected": "0.0001"})


def test_inherit_not_zero_1():
    run_formatter({"format": r"\?not_zero [{zero}]", "expected": ""})


def test_inherit_not_zero_2():
    run_formatter({"format": r"[\?not_zero [{zero}]]", "expected": ""})


def test_inherit_not_zero_3():
    run_formatter({"format": r"[\?not_zero [[[{zero}]]]]", "expected": ""})


def test_inherit_show_1():
    run_formatter({"format": r"\?show [[[hello]]]", "expected": "hello"})


def test_inherit_color_1():
    run_formatter(
        {
            "format": r"\?color=#F0F [[[{number}]]]",
            "expected": [{"color": "#FF00FF", "full_text": "42"}],
        }
    )


def test_inherit_color_2():
    run_formatter(
        {
            "format": r"\?color=#F0F [[\?color=good [{number}]]]",
            "expected": [{"color": "#00FF00", "full_text": "42"}],
        }
    )


def test_conditions_1():
    run_formatter({"format": r"\?if=number=42 cool beans", "expected": "cool beans"})


def test_conditions_2():
    run_formatter({"format": r"\?if=number=4 cool beans", "expected": ""})


def test_conditions_3():
    run_formatter({"format": r"\?if=!number=42 cool beans", "expected": ""})


def test_conditions_4():
    run_formatter({"format": r"\?if=!number=4 cool beans", "expected": "cool beans"})


def test_conditions_5():
    run_formatter({"format": r"\?if=missing=4 cool beans", "expected": ""})


def test_conditions_6():
    run_formatter({"format": r"\?if=name=Björk cool beans", "expected": "cool beans"})


def test_conditions_7():
    run_formatter({"format": r"\?if=name=Jimmy cool beans", "expected": ""})


def test_conditions_8():
    run_formatter({"format": r"\?if=name= cool beans", "expected": ""})


def test_conditions_9():
    run_formatter({"format": r"\?if=number= cool beans", "expected": ""})


def test_conditions_10():
    run_formatter(
        {"format": r"\?if=pi=3.14159265359 cool beans", "expected": "cool beans"}
    )


def test_conditions_11():
    run_formatter({"format": r"\?if=pi=3 cool beans", "expected": ""})


def test_conditions_12():
    run_formatter({"format": r"\?if=yes=3 cool beans", "expected": "cool beans"})


def test_conditions_13():
    run_formatter({"format": r"\?if=no=3 cool beans", "expected": ""})


def test_conditions_14():
    run_formatter({"format": r"\?if=number>3 cool beans", "expected": "cool beans"})


def test_conditions_15():
    run_formatter({"format": r"\?if=number<50 cool beans", "expected": "cool beans"})


def test_conditions_16():
    run_formatter({"format": r"\?if=number>50 cool beans", "expected": ""})


def test_conditions_17():
    run_formatter({"format": r"\?if=number<3 cool beans", "expected": ""})


def test_conditions_18():
    run_formatter({"format": r"\?if=name<Andrew cool beans", "expected": ""})


def test_conditions_19():
    run_formatter({"format": r"\?if=name>Andrew cool beans", "expected": "cool beans"})


def test_conditions_20():
    run_formatter({"format": r"\?if=name<John cool beans", "expected": "cool beans"})


def test_conditions_21():
    run_formatter({"format": r"\?if=name>John cool beans", "expected": ""})


def test_conditions_22():
    run_formatter({"format": r"\?if=missing>John cool beans", "expected": ""})


def test_conditions_23():
    run_formatter({"format": r"[\?if=None=None cool] beans", "expected": " beans"})


def test_trailing_zeroes_1():
    run_formatter(
        {
            "format": "{trailing_zeroes_1} becomes {trailing_zeroes_1:g}",
            "expected": "50.000 becomes 50",
        }
    )


def test_trailing_zeroes_2():
    run_formatter(
        {
            "format": "{trailing_zeroes_2} becomes {trailing_zeroes_2:g}",
            "expected": "5.500 becomes 5.5",
        }
    )


def test_ceiling_numbers_1():
    run_formatter(
        {"format": "{pi} becomes {pi:ceil}", "expected": "3.14159265359 becomes 4"}
    )


def test_ceiling_numbers_2():
    run_formatter(
        {
            "format": "{zero_almost} becomes {zero_almost:ceil}",
            "expected": "0.0001 becomes 1",
        }
    )


# get placeholder tests


def test_placeholders_1():
    get_placeholders({"format": "{placeholder}", "expected": {"placeholder"}})


def test_placeholders_2():
    get_placeholders(
        {
            "format": "[{placeholder}]{placeholder2:%d}",
            "expected": {"placeholder", "placeholder2"},
        }
    )


def test_placeholders_3():
    get_placeholders(
        {
            "format": r"{placeholder}[\?if=test something]",
            "expected": {"placeholder", "test"},
        }
    )


def test_placeholders_4():
    get_placeholders(
        {
            "format": r"{placeholder}[\?if=!test=42&color=red something]",
            "expected": {"placeholder", "test"},
        }
    )


def test_placeholders_5():
    get_placeholders(
        {
            "format": r"\{placeholder\}[\?if=test&color=red something]",
            "expected": {"test"},
        }
    )


# Placeholder update tests


def test_update_placeholders_1():
    update_placeholders(
        {"format": "{placeholder}", "updates": {}, "expected": "{placeholder}"}
    )


def test_update_placeholders_2():
    update_placeholders(
        {
            "format": "[{placeholder}]{placeholder2:%d}",
            "updates": {
                "placeholder": "new_placeholder",
                "placeholder2": "new_placeholder2",
            },
            "expected": "[{new_placeholder}]{new_placeholder2:%d}",
        }
    )


def test_update_placeholders_3():
    update_placeholders(
        {
            "format": r"{placeholder}[\?if=test something]",
            "updates": {"test": "new_test"},
            "expected": r"{placeholder}[\?if=new_test something]",
        }
    )


def test_update_placeholders_4():
    update_placeholders(
        {
            "format": r"{placeholder}[\?if=!test=42&color=red something]",
            "updates": {"red": "blue"},
            "expected": r"{placeholder}[\?if=!test=42&color=red something]",
        }
    )


def test_update_placeholders_5():
    update_placeholders(
        {
            "format": r"\{placeholder\}{placeholder}[\?if=placeholder&color=red something]",
            "updates": {"placeholder": "new_placeholder"},
            "expected": r"\{placeholder\}{new_placeholder}[\?if=new_placeholder&color=red something]",
        }
    )


def test_get_color_names_1():
    get_color_names(
        {
            "format": r"\?color=red \?color=#0f0 green \?color=#0000ff blue",
            "expected": set(),
        }
    )


def test_get_color_names_2():
    get_color_names(
        {
            "format": r"[\?color=tobias funke|\?color=bluemangroup troupe]",
            "expected": {"tobias", "bluemangroup"},
        }
    )


def test_get_color_names_3():
    get_color_names(
        {
            "format": r"[\?color=good bonsai tree][\?color=None Saibot]",
            "expected": set(),
        }
    )


def test_get_color_names_4():
    get_color_names(
        {
            "format": r"\?color=rebeccapurple \?color=rebecca \?color=purple",
            "expected": {"rebecca"},
        }
    )


if __name__ == "__main__":
    # run tests
    import sys

    this_module = sys.modules[__name__]
    for _ in range(10):
        for name in dir(this_module):
            if not name.startswith("test_"):
                continue
            getattr(this_module, name)()



================================================
FILE: tests/test_module_doc.py
================================================
"""
This tests module docstrings to ensure

* all the config options are documented

* correct default values are given

* config parameters listed in alphabetical order

Specific modules/config parameters are excluded but this should be discouraged.
"""

import ast
import re

from collections import OrderedDict
from pathlib import Path

from py3status.docstrings import core_module_docstrings

IGNORE_MODULE = []

ILLEGAL_CONFIG_OPTIONS = ["min_width", "separator", "separator_block_width", "align"]

IGNORE_ILLEGAL_CONFIG_OPTIONS = [("group", "align")]

# Ignored items will not have their default values checked or be included for
# alphabetical order purposes
IGNORE_ITEM = []

# Obsolete parameters will not have alphabetical order checked
OBSOLETE_PARAM = []

RE_PARAM = re.compile(r"^\n- `(?P<name>[^`]*)`.*?(\*\(default (?P<value>(.*))\)\*)?$")

AST_LITERAL_TYPES = {
    "Num": "n",
    "Str": "s",
    "NameConstant": "value",
    "Constant": "value",
}

MODULE_PATH = Path(__file__).resolve().parent.parent / "py3status" / "modules"


def docstring_params(docstring):
    """
    Crudely parse the docstring and get parameters and their defaults
    """

    def find_line(text):
        for index, line in enumerate(docstring):
            if line == text:
                return index + 1

    def find_params(start):
        """
        find documented parameters and add them to params dict
        """
        params = OrderedDict()
        if start is None:
            return params
        lines = []
        for part in docstring[start:]:
            if part == "\n":
                break
            if part.startswith("\n- "):
                lines.append(part[:-1])
                continue
            lines[-1] += part[:-1]

        for line in lines:
            match = RE_PARAM.match(line)
            if match:
                if match.group("value"):
                    try:
                        value = eval(match.group("value"))
                        try:
                            value = value.replace("&amp;", "&")
                            value = value.replace("&lt;", "<")
                            value = value.replace("&gt;", ">")
                        except AttributeError:
                            pass
                        # wrap in tuple to distinguish None from missing
                        value = (value,)
                    except (SyntaxError, NameError):
                        value = "?Unknown?"
                else:
                    value = None
                params[match.group("name")] = value
        return params

    params = find_params(find_line("Configuration parameters:\n"))
    obsolete = find_params(find_line("Obsolete configuration parameters:\n"))
    return params, obsolete


def get_module_attributes(path):
    """
    Get the attributes from the module from the ast.  We use ast because this
    way we can examine modules even if we do not have their required python
    modules installed.
    """
    names = {}
    attributes = OrderedDict()
    python2_names = {"True": True, "False": False, "None": None}

    def get_values(source, dest, extra=None):
        """
        Get a list of the configuration parameters and their defaults.
        """

        def get_value(value):
            """
            Get the actual value from the ast allowing recursion
            """
            class_name = value.__class__.__name__
            # if this is a literal then get its value
            value_type = AST_LITERAL_TYPES.get(class_name)
            if value_type:
                attr_value = getattr(value, value_type)
            else:
                if class_name == "Dict":
                    attr_value = {
                        get_value(k): get_value(v)
                        for k, v in zip(value.keys, value.values)
                    }
                elif class_name == "List":
                    attr_value = [get_value(e) for e in value.elts]
                elif class_name == "Name":
                    # in python 2 True, False, None are Names rather than
                    # NameConstant so we use them for the default
                    default = python2_names.get(value.id)
                    attr_value = extra.get(value.id, default)
                elif class_name == "Tuple":
                    attr_value = tuple(get_value(e) for e in value.elts)
                elif class_name == "UnaryOp":
                    op = value.op.__class__.__name__
                    attr_value = get_value(value.operand)
                    # we only understand negation
                    if op == "USub":
                        attr_value = -attr_value
                    else:
                        attr_value = f"UNKNOWN {class_name} UnaryOp {op}"
                elif class_name == "BinOp":
                    left = get_value(value.left)
                    right = get_value(value.right)
                    op = value.op.__class__.__name__
                    try:
                        if op == "Add":
                            attr_value = left + right
                        elif op == "Mult":
                            attr_value = left * right
                        else:
                            attr_value = f"UNKNOWN {class_name} BinOp {op}"
                    except Exception:
                        attr_value = f"UNKNOWN {class_name} BinOp error"
                else:
                    attr_value = f"UNKNOWN {class_name}"
            return attr_value

        if extra is None:
            extra = {}

        for line in source:
            if isinstance(line, ast.Assign):
                if len(line.targets) == 1 and isinstance(line.targets[0], ast.Name):
                    attr = line.targets[0].id
                    value = line.value
                    dest[attr] = get_value(value)

    with path.open() as f:
        tree = ast.parse(f.read(), "")
        # some modules have constants defined we need to find these
        get_values(tree.body, names)
        for statement in tree.body:
            # look for the Py3status class and find it's attributes
            if isinstance(statement, ast.ClassDef) and statement.name == "Py3status":
                get_values(statement.body, attributes, names)
    return attributes


def _gen_diff(source, target, source_label="Source", target_label="Target"):
    # Create a unique object for determining if the list is missing an entry
    blank = object()

    # Make both lists the same length
    max_len = max(len(source), len(target))
    for lst in (source, target):
        lst.extend([blank] * (max_len - len(lst)))

    # Determine the length of the longest item in the list
    max_elem_len = max(len(str(elem)) for elem in source)
    padding = "    "
    format_str = padding + f"{{:{max_elem_len}}} {{}} {{}}"

    # Set up initial output contents
    middle_orig = "  "
    out = [
        format_str.format(source_label, middle_orig, target_label),
        # Length of dashes is enough for the longest element on both sides,
        # plus the size of the middle symbol(s), plus two spaces for separation
        padding + ("-" * (2 * max_elem_len + len(middle_orig) + 2)),
    ]

    for (have, want) in zip(source, target):
        # Determine the mark
        middle = middle_orig

        # The current version is missing this line
        if have == blank:
            middle = "<<"
            have = ""

        # The target version is missing this line
        elif want == blank:
            middle = ">>"
            want = ""

        # Both lines exist, but are different
        elif have != want:
            middle = "!!"

        # Place the diff into the output
        out.append(format_str.format(str(have), middle, str(want)))

    return "\n".join(out) + "\n"


def check_docstrings():
    all_errors = []
    docstrings = core_module_docstrings()
    for module_name in sorted(docstrings):
        errors = []
        if module_name in IGNORE_MODULE:
            continue

        path = MODULE_PATH / f"{module_name}.py"
        mod_config = get_module_attributes(path)

        params, obsolete = docstring_params(docstrings[module_name])

        if list(params) != sorted(params):
            keys = list(params)
            msg = "config params not in alphabetical order should be\n{keys}"
            errors.append(msg.format(keys=_gen_diff(keys, sorted(keys))))
        if list(obsolete) != sorted(obsolete):
            keys = list(obsolete)
            msg = "obsolete params not in alphabetical order should be\n{keys}"
            errors.append(msg.format(keys=_gen_diff(keys, sorted(keys))))

        # combine docstring parameters
        params.update(obsolete)

        # bad config params - these have reserved usage
        allowed_bad_config_params = [
            x[1] for x in IGNORE_ILLEGAL_CONFIG_OPTIONS if x[0] == module_name
        ]
        bad_config_params = set(ILLEGAL_CONFIG_OPTIONS) & set(params)
        bad_config_params -= set(allowed_bad_config_params)

        if bad_config_params:
            msg = "The following config parameters are reserved and"
            msg += "should not be used by modules:\n    {}"
            errors.append(msg.format(", ".join(bad_config_params)))

        # check attributes are in alphabetical order
        keys = list(mod_config)
        for item in IGNORE_ITEM:
            if item[0] == module_name and item[1] in keys:
                keys.remove(item[1])
        for item in OBSOLETE_PARAM:
            if item[0] == module_name and item[1] in keys:
                keys.remove(item[1])
        if keys != sorted(keys):
            errors.append("Attributes not in alphabetical order, should be")
            errors.append(_gen_diff(keys, sorted(keys)))

        for param in sorted(mod_config):
            if (module_name, param) in IGNORE_ITEM:
                continue
            default = mod_config[param]
            if param not in params:
                msg = "{}: (default {!r}) not in module docstring"
                errors.append(msg.format(param, default))
                continue
            default_doc = params[param]
            if default_doc is None:
                msg = "`{}` default not in docstring add (default {!r})"
                errors.append(msg.format(param, default))
                del params[param]
                continue
            if default_doc[0] != default:
                msg = "`{}` (default {!r}) does not match docstring {!r}"
                errors.append(msg.format(param, default, default_doc[0]))
                del params[param]
                continue
            del params[param]

        for param in params:
            if (module_name, param) in IGNORE_ITEM:
                continue
            errors.append(f"{param} in module docstring but not module")
        if errors:
            all_errors += ["=" * 30, module_name, "=" * 30] + errors + ["\n"]
    return all_errors


def test_docstrings():
    errors = check_docstrings()
    if errors:
        print("Docstring error(s) detected!\n\n")
        print(
            "The tests may give incorrect errors for some configuration "
            "parameters that the tests do not understand. "
            "Such parameters can be excluded from the test by adding them "
            "to the IGNORE_ITEM list in tests/test_module_doc.py\n\n"
        )
        for error in errors:
            print(error)
        assert False



================================================
FILE: tests/test_module_load.py
================================================
from py3status.module_test import MockPy3statusWrapper
from py3status.module import Module


class TestModule:
    static_variable = 123

    @classmethod
    def setup_class(cls):
        cls.instance_variable = 321

    def post_config_hook(self):
        pass

    @staticmethod
    def static_method(self):
        raise Exception("I don't want to be called!")

    @property
    def property(self):
        raise Exception("I don't want to be called!")

    def instance_method(self):
        raise Exception("I don't want to be called!")

    def _private_instance_method(self):
        raise Exception("I don't want to be called!")

    def on_click(self, event):
        raise Exception("I don't want to be called!")


def test_module_load():
    mock = MockPy3statusWrapper(
        {
            "general": {},
            "py3status": {},
            ".module_groups": {},
            "test_module": {},
        }
    )

    module = TestModule()
    m = Module("test_module", {}, mock, module)
    m.prepare_module()
    assert list(m.methods) == ["instance_method"]



================================================
FILE: tests/test_py3.py
================================================
from pprint import pformat

from py3status.py3 import Py3


py3 = Py3()


def test_format_units():

    tests = [
        # basic unit guessing
        (dict(value=100), (100, "B")),
        (dict(value=999), (999, "B")),
        (dict(value=1000), (0.977, "KiB")),
        (dict(value=1024), (1.0, "KiB")),
        (dict(value=pow(1024, 2)), (1.0, "MiB")),
        (dict(value=pow(1024, 3)), (1.0, "GiB")),
        (dict(value=pow(1024, 4)), (1.0, "TiB")),
        (dict(value=pow(1024, 5)), (1.0, "PiB")),
        # no guessing
        (dict(value=pow(1024, 2), auto=False), (pow(1024, 2), "B")),
        (dict(value=pow(1024, 2), auto=False, unit="B"), (pow(1024, 2), "B")),
        (dict(value=pow(1024, 2), auto=False, unit="KiB"), (1024, "KiB")),
        # guess with si units
        (dict(value=100, si=True), (100, "B")),
        (dict(value=1000, si=True), (1.0, "kB")),
        (dict(value=pow(1000, 2), si=True), (1.0, "MB")),
        (dict(value=pow(1000, 3), si=True), (1.0, "GB")),
        (dict(value=pow(1000, 4), si=True), (1.0, "TB")),
        (dict(value=pow(1000, 5), si=True), (1.0, "PB")),
        # forced MiB
        (dict(value=pow(1024, 1), unit="MiB"), (0.000977, "MiB")),
        (dict(value=pow(1024, 2), unit="MiB"), (1.0, "MiB")),
        (dict(value=pow(1024, 3), unit="MiB"), (1024, "MiB")),
        (dict(value=pow(1024, 4), unit="MiB"), (pow(1024, 2), "MiB")),
        (dict(value=pow(1024, 5), unit="MiB"), (pow(1024, 3), "MiB")),
        # endings
        (dict(value=100, unit="b/s"), (100, "b/s")),
        (dict(value=1024, unit="b/s"), (1.0, "Kib/s")),
        (dict(value=pow(1024, 2), unit="b/s"), (1.0, "Mib/s")),
        (dict(value=pow(1000, 2), si=True, unit="b/s"), (1.0, "Mb/s")),
        (dict(value=pow(1024, 3), unit="Mib/sec"), (1024, "Mib/sec")),
        # optimal
        (dict(value=1234567890), (1.15, "GiB")),
        (dict(value=1234567890, optimal=None), (1.1497809458523989, "GiB")),
        (dict(value=1234567890, optimal=1), (1, "GiB")),
        (dict(value=1234567890, optimal=2), (1, "GiB")),
        (dict(value=1234567890, optimal=3), (1.1, "GiB")),
        (dict(value=1234567890, optimal=5), (1.15, "GiB")),
        (dict(value=1234567890, unit="MiB"), (1177, "MiB")),
        (dict(value=1234567890, unit="MiB", optimal=None), (1177.3756885528564, "MiB")),
        (dict(value=1234567890, unit="MiB", optimal=2), (1177, "MiB")),
        (dict(value=1234567890, unit="MiB", optimal=6), (1177.4, "MiB")),
        (dict(value=1234567890, unit="MiB", optimal=9), (1177.3757, "MiB")),
    ]

    for test in tests:
        print(test)
        # we use repr in the assert to ensure 1 and 1.0 are not treated the
        # same
        assert repr(py3.format_units(**test[0])) == repr(test[1])


def test_flatten_dict():
    data = {
        "fish_facts": {
            "sharks": "Most will drown if they stop moving",
            "skates": "More than 200 species",
        },
        "fruits": ["apple", "peach", "watermelon"],
        "number": 52,
    }
    expected = {
        "fish_facts-sharks": "Most will drown if they stop moving",
        "fish_facts-skates": "More than 200 species",
        "fruits-0": "apple",
        "fruits-1": "peach",
        "fruits-2": "watermelon",
        "number": 52,
    }

    returned = py3.flatten_dict(data, delimiter="-")
    print("returned data")
    print(pformat(returned))
    assert returned == expected


def test_flatten_dict_intermediates():
    data = {
        "fish_facts": {
            "sharks": "Most will drown if they stop moving",
            "skates": "More than 200 species",
        },
        "fruits": ["apple", "peach", "watermelon"],
        "number": 52,
    }
    expected = {
        "fish_facts": {
            "sharks": "Most will drown if they stop moving",
            "skates": "More than 200 species",
        },
        "fish_facts-sharks": "Most will drown if they stop moving",
        "fish_facts-skates": "More than 200 species",
        "fruits": ["apple", "peach", "watermelon"],
        "fruits-0": "apple",
        "fruits-1": "peach",
        "fruits-2": "watermelon",
        "number": 52,
    }

    returned = py3.flatten_dict(data, delimiter="-", intermediates=True)
    print("returned data")
    print(pformat(returned))
    assert returned == expected


def test_flatten_dict_deep():
    data = {
        "hash": {
            "dict": {"array": [1, 2, [1, 2, {"#": 123}]]},
            "list": [1, 2, [1, 2, {"mapping": 123}]],
        },
        "list": [1, 2, [1, 2, {"mapping": 123}]],
    }

    expected = {
        "hash-dict-array-0": 1,
        "hash-dict-array-1": 2,
        "hash-dict-array-2-0": 1,
        "hash-dict-array-2-1": 2,
        "hash-dict-array-2-2-#": 123,
        "hash-list-0": 1,
        "hash-list-1": 2,
        "hash-list-2-0": 1,
        "hash-list-2-1": 2,
        "hash-list-2-2-mapping": 123,
        "list-0": 1,
        "list-1": 2,
        "list-2-0": 1,
        "list-2-1": 2,
        "list-2-2-mapping": 123,
    }

    assert py3.flatten_dict(data, delimiter="-") == expected
    returned = py3.flatten_dict(data, delimiter="-")
    print("returned data")
    print(pformat(returned))
    assert returned == expected


def test_flatten_dict_deep_intermediates():
    data = {
        "hash": {
            "dict": {"array": [1, 2, [1, 2, {"#": 123}]]},
            "list": [1, 2, [1, 2, {"mapping": 123}]],
        },
        "list": [1, 2, [1, 2, {"mapping": 123}]],
    }

    expected = {
        "hash": {
            "dict": {"array": [1, 2, [1, 2, {"#": 123}]]},
            "list": [1, 2, [1, 2, {"mapping": 123}]],
        },
        "hash-dict": {"array": [1, 2, [1, 2, {"#": 123}]]},
        "hash-dict-array": [1, 2, [1, 2, {"#": 123}]],
        "hash-dict-array-0": 1,
        "hash-dict-array-1": 2,
        "hash-dict-array-2": [1, 2, {"#": 123}],
        "hash-dict-array-2-0": 1,
        "hash-dict-array-2-1": 2,
        "hash-dict-array-2-2": {"#": 123},
        "hash-dict-array-2-2-#": 123,
        "hash-list": [1, 2, [1, 2, {"mapping": 123}]],
        "hash-list-0": 1,
        "hash-list-1": 2,
        "hash-list-2": [1, 2, {"mapping": 123}],
        "hash-list-2-0": 1,
        "hash-list-2-1": 2,
        "hash-list-2-2": {"mapping": 123},
        "hash-list-2-2-mapping": 123,
        "list": [1, 2, [1, 2, {"mapping": 123}]],
        "list-0": 1,
        "list-1": 2,
        "list-2": [1, 2, {"mapping": 123}],
        "list-2-0": 1,
        "list-2-1": 2,
        "list-2-2": {"mapping": 123},
        "list-2-2-mapping": 123,
    }

    returned = py3.flatten_dict(data, delimiter="-", intermediates=True)
    print("returned data")
    print(pformat(returned))
    assert returned == expected


def test_flatten_dict_parent_key():
    data = {
        "fish_facts": {
            "sharks": "Most will drown if they stop moving",
            "skates": "More than 200 species",
        },
        "fruits": ["apple", "peach", "watermelon"],
        "number": 52,
    }
    expected = {
        "purple-fish_facts-sharks": "Most will drown if they stop moving",
        "purple-fish_facts-skates": "More than 200 species",
        "purple-fruits-0": "apple",
        "purple-fruits-1": "peach",
        "purple-fruits-2": "watermelon",
        "purple-number": 52,
    }

    returned = py3.flatten_dict(data, delimiter="-", parent_key="purple")
    print("returned data")
    print(pformat(returned))
    assert returned == expected



================================================
FILE: tests/test_user_modules.py
================================================
import argparse
import sys
from pathlib import Path

import importlib.metadata
import pytest

import py3status
from py3status.core import Py3statusWrapper, ENTRY_POINT_KEY


@pytest.fixture(name="status_wrapper")
def make_status_wrapper():
    args = argparse.Namespace()
    status_wrapper = Py3statusWrapper(args)
    return status_wrapper


def test__get_path_based_modules(status_wrapper):
    """Use the list of inbuilt modules as reference to check against."""
    included_modules_path = Path(py3status.__file__).resolve().parent / "modules"
    status_wrapper.options.__dict__["include_paths"] = [included_modules_path]
    assert included_modules_path.exists()
    expected_keys = [
        n.stem for n in included_modules_path.iterdir() if n.suffix == ".py"
    ]
    modules = status_wrapper._get_path_based_modules()
    assert sorted(modules) == sorted(expected_keys)


def test__get_entry_point_based_modules(status_wrapper, monkeypatch):
    def return_fake_entry_points(*args, **kwargs):
        class FakePy3status:
            Py3status = "I am a fake class"

            def __init__(self, name):
                self.name = name
                self.module_name = "module_name_" + self.name

            @staticmethod
            def load():
                from py3status.modules import air_quality

                return air_quality

        # TODO: drop on 3.9 EOL
        if sys.version_info.minor < 10:
            return {"py3status": [FakePy3status("spam"), FakePy3status("eggs")]}
        else:
            return [FakePy3status("spam"), FakePy3status("eggs")]

    monkeypatch.setattr(importlib.metadata, "entry_points", return_fake_entry_points)

    user_modules = status_wrapper._get_entry_point_based_modules()
    assert len(user_modules) == 2
    for name, info in user_modules.items():
        assert any(n in name for n in ["spam", "eggs"])
        kind, klass = info
        assert kind == ENTRY_POINT_KEY
        assert klass.__name__ == "Py3status"



================================================
FILE: .git-hooks/pre-push
================================================
#!/usr/bin/env bash

# run all tests first before pushing

# $ git config core.hooksPath .git-hooks  # (in dir) to add hooks
# $ git config --unset core.hooksPath  # (in dir) to remove hooks

if command -v hatch &>/dev/null; then
    hatch run all
else
    echo 'hooks/pre-push: command "hatch" not found, skipping hatch tests'
fi



================================================
FILE: .github/FUNDING.yml
================================================
github: ultrabug
custom: https://paypal.me/alexysjacob1



================================================
FILE: .github/ISSUE_TEMPLATE/ask-a-question.md
================================================
---
name: Ask a question
about: Ask the py3status community about anything
title: ''
labels: ''
assignees: ''

---

**How can we help you today?**
What's your question? Describe it here.

**Your py3status version**
Please run `py3status -v` and place the output here.

**Share your configuration**
Place your py3status configuration here (filter out any private values) if you feel it can help us understand what you're trying to do:

**Additional context**
Add any other context or screenshots about the feature request here.



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea to improve py3status
title: ''
labels: 'feature request :pray:'
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Your py3status version**
Please run `py3status -v` and place the output here.

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



================================================
FILE: .github/ISSUE_TEMPLATE/report-a-bug-or-a-problem.md
================================================
---
name: Report a bug or a problem
about: Create a report to help us improve py3status
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**Your py3status version**
Please run `py3status -v` and place the output here.

**To Reproduce**
Steps to reproduce the behavior along with your py3status configuration (filter out any private values):
1. Add module '...'
2. Configure module like this '....'
3. Run py3status '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Additional context**
Add any other context about the problem here.



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 5
      matrix:
        python-version: [3.9, "3.10", "3.11", "3.12", "3.13"]

    steps:
    - uses: actions/checkout@v1
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements/project.txt
    - name: Test with hatch
      run: hatch run all


================================================
FILE: .github/workflows/codeql.yml
================================================
name: "CodeQL"

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]
  schedule:
    - cron: "11 1 * * 0"

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: [ python ]

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: ${{ matrix.language }}
          queries: +security-and-quality

      - name: Autobuild
        uses: github/codeql-action/autobuild@v2

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
        with:
          category: "/language:${{ matrix.language }}"



================================================
FILE: .github/workflows/deploy-docs.yml
================================================
name: Deploy docs

on:
  push:
    branches:
      - master

jobs:
  build:
    name: Deploy docs
    runs-on: ubuntu-latest
    steps:
      - name: Download source
        uses: actions/checkout@v3
      - name: Install Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade hatch
      - name: Build site
        run: hatch -e docs run mkdocs build
      - name: Deploy to gh-pages
        if: github.event_name == 'push' && github.ref == 'refs/heads/master'
        uses: oprypin/push-to-gh-pages@v3
        with:
          publish_dir: site
          commit_message: 'Generate docs: '

