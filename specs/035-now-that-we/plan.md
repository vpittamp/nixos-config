# Implementation Plan: Registry-Centric Project & Workspace Management

**Branch**: `035-now-that-we` | **Date**: 2025-10-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/035-now-that-we/spec.md`

## Summary

Replace tag-based application filtering with environment variable injection for deterministic window-to-project association. Applications launched via app-launcher-wrapper.sh receive I3PM_* environment variables (project name, directory, unique application instance ID). The daemon filters windows on project switch by reading /proc/<pid>/environ to determine window ownership. This eliminates complex tag configuration, enables applications to access project context, and provides exact window identification for layout restore.

**Key Innovation**: Application instance IDs (I3PM_APP_ID) injected at launch enable deterministic window matching even with multiple instances of the same application (e.g., multiple VS Code windows across different projects).

## Technical Context

**Language/Version**:
- TypeScript/Deno 1.40+ (CLI tools)
- Python 3.11+ (daemon, i3 event handling)
- Nix/NixOS (declarative configuration)
- Bash (app launcher wrapper)

**Primary Dependencies**:
- Deno: `@std/cli/parse-args` (CLI argument parsing)
- Python: i3ipc.aio (async i3 IPC), Rich (terminal UI)
- System: xprop or wmctrl (window PID retrieval), /proc filesystem (environment reading)
- Existing: app-registry.nix (Feature 034), i3pm daemon (Feature 015)

**Storage**:
- Application Registry: `~/.config/i3/application-registry.json` (generated from app-registry.nix)
- Projects: `~/.config/i3/projects/<name>.json` (JSON files)
- Active Project: `~/.config/i3/active-project.json` (current project state)
- Layouts: `~/.config/i3/layouts/<name>.json` (window positions + app IDs)

**Testing**:
- Python: pytest with pytest-asyncio (daemon unit tests, integration tests)
- Deno: Deno.test() (CLI unit tests)
- Bash: Shell script validation (launcher wrapper)
- Manual: Quickstart workflows, layout restore validation

**Target Platform**:
- NixOS on Linux (Hetzner, WSL, M1 Mac via Asahi)
- i3 window manager with X11
- xrdp multi-session support

**Project Type**: System integration - extends existing i3 window manager configuration

**Performance Goals**:
- Application launch with environment injection: <100ms overhead
- Window filtering on project switch (20 windows): <2 seconds total
- /proc/<pid>/environ read: <5ms per process
- xprop PID lookup: <20ms per window
- Layout restore (10 applications): <30 seconds total

**Constraints**:
- Must maintain <1% CPU usage for daemon during idle
- Must work within i3 tiling window manager framework
- Must be compatible with xrdp multi-session
- Must survive NixOS rebuilds (declarative configuration)
- No external dependencies beyond Nix packages

**Scale/Scope**:
- Support 50+ registered applications
- Support 10+ concurrent projects
- Handle 30+ open windows per project
- Support 5+ layouts per project
- Work with multiple terminal instances (5-10 per project)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Principle I (Modular Composition)**: ✅ PASS
- Environment injection in app-launcher-wrapper.sh (single responsibility)
- Window filtering in daemon window_filter.py service (isolated module)
- Registry remains single source of truth in app-registry.nix
- Clear separation: launcher injects → daemon reads → window filtering

**Principle VI (Declarative Configuration)**: ✅ PASS
- app-registry.nix remains declarative (Nix expressions)
- Projects stored as JSON (generated by CLI, survives rebuilds)
- Layouts stored as JSON with application instance IDs
- Environment variables injected at runtime (not imperative scripts)
- All configuration version-controlled

**Principle XII (Forward-Only Development)**: ✅ PASS
- **Completely replaces tag-based filtering** (no dual support)
- Removes XDG isolation from walker.nix (no longer needed)
- Removes application tags from registry schema
- No backward compatibility with tag system
- Clean break: environment-based is THE approach

**Principle XIII (Deno CLI Development Standards)**: ✅ PASS
- All CLI commands use Deno 1.40+ with TypeScript
- Uses `@std/cli/parse-args` for argument parsing
- Compiled to standalone executables via `deno compile`
- Type-safe interfaces for all data models
- JSON-RPC client for daemon communication

**Principle X (Python Development & Testing Standards)**: ✅ PASS
- Daemon uses Python 3.11+ with async/await (i3ipc.aio)
- pytest with pytest-asyncio for automated tests
- Type hints for function signatures
- Rich library for terminal UI (monitoring tools)
- Clear module separation (window_filter.py service)

**Principle XI (i3 IPC Alignment & State Authority)**: ✅ PASS
- Uses xprop to get window PIDs (i3ipc doesn't expose reliably)
- Reads /proc/<pid>/environ for authoritative environment state
- i3 window::new events trigger environment reading
- Falls back to i3 window class if /proc read fails
- i3 IPC used for window commands (move scratchpad, mark)

## Architecture Overview

### Environment Variable Injection Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│ Application Launch Flow                                          │
└─────────────────────────────────────────────────────────────────┘

User Action (Walker/Keybind)
  ↓
app-launcher-wrapper.sh
  ↓
1. Load registry (app metadata)
2. Query daemon for active project
3. Generate unique application instance ID
4. Inject environment variables:
   - I3PM_APP_ID="vscode-nixos-12345-1730000000"
   - I3PM_APP_NAME="vscode"
   - I3PM_PROJECT_NAME="nixos"
   - I3PM_PROJECT_DIR="/etc/nixos"
   - I3PM_SCOPE="scoped"
   - I3PM_ACTIVE="true"
   - I3PM_LAUNCH_TIME="1730000000"
5. Substitute $PROJECT_DIR variables
  ↓
exec application (inherits environment)
  ↓
Application Process (PID 12345)
  ├─ /proc/12345/environ contains I3PM_* variables
  └─ Application can read $I3PM_PROJECT_DIR if needed
```

### Window Filtering on Project Switch

```
┌─────────────────────────────────────────────────────────────────┐
│ Project Switch Flow                                              │
└─────────────────────────────────────────────────────────────────┘

User: i3pm project switch stacks
  ↓
CLI updates active-project.json
  ↓
CLI sends i3 tick event: "project:switch:stacks"
  ↓
Daemon receives tick event
  ↓
Daemon queries i3 for all windows
  ↓
For each window:
  1. Get window ID from i3
  2. Get PID via xprop (xprop -id <window_id> _NET_WM_PID)
  3. Read /proc/<PID>/environ
  4. Extract I3PM_PROJECT_NAME
  5. Compare to active project "stacks"
  6. If match → keep visible
  7. If no match → move to scratchpad (hide)
  8. If no I3PM_PROJECT_NAME → global (keep visible)
  ↓
Update i3bar status with new project
```

### Window Matching with Application Instance IDs

```
┌─────────────────────────────────────────────────────────────────┐
│ Window Identification                                            │
└─────────────────────────────────────────────────────────────────┘

Traditional (Ambiguous):
  Window 1: class="Code" → Which project? 🤷
  Window 2: class="Code" → Which project? 🤷
  Window 3: class="Code" → Which project? 🤷

Environment-Based (Deterministic):
  Window 1: PID 1001 → /proc/1001/environ → I3PM_APP_ID="vscode-nixos-12345"
  Window 2: PID 1002 → /proc/1002/environ → I3PM_APP_ID="vscode-stacks-67890"
  Window 3: PID 1003 → /proc/1003/environ → I3PM_APP_ID="vscode-personal-11111"

Layout Restore:
  1. Launch app with expected I3PM_APP_ID
  2. Wait for window::new event
  3. Read /proc/<pid>/environ → get I3PM_APP_ID
  4. Match to expected ID → exact window identification!
  5. Apply geometry from layout
```

## Project Structure

### Documentation (this feature)

```
specs/035-now-that-we/
├── plan.md                       # This file
├── research.md                   # Deno i3 IPC research, registry patterns
├── research-env-vars.md          # Environment variable approach analysis
├── research-proc-filtering.md    # /proc-based filtering validation (RECOMMENDED)
├── data-model.md                 # JSON schemas (projects, layouts, environment)
├── quickstart.md                 # User workflows and examples
├── contracts/
│   ├── cli-commands.md           # CLI API contract
│   └── ipc-protocol.md           # Daemon JSON-RPC + i3 IPC patterns
└── tasks.md                      # Implementation tasks (87 tasks, 8 phases)
```

### Source Code (repository root)

```
home-modules/
├── desktop/
│   ├── app-registry.nix          # Extended: remove tags field (no longer needed)
│   ├── i3-window-rules.nix       # NEW: Auto-generate for_window rules (global apps only)
│   ├── walker.nix                # Simplified: remove XDG isolation (no longer needed)
│   └── i3-project-event-daemon/
│       ├── handlers.py           # Updated: on_window_new reads /proc environment
│       ├── services/
│       │   ├── window_filter.py  # NEW: /proc reading, PID lookup, filtering logic
│       │   └── registry_loader.py # NEW: Load and validate registry on startup
│       └── models.py             # Updated: Add environment variable models
│
└── tools/
    ├── i3pm/                     # Deno CLI tool (existing from Feature 034)
    │   ├── src/
    │   │   ├── commands/
    │   │   │   ├── apps.ts       # List/show registry applications
    │   │   │   ├── project.ts    # Create/list/show/update/delete/switch/clear projects
    │   │   │   ├── layout.ts     # NEW: Save/restore/delete layouts
    │   │   │   └── daemon.ts     # Status/events monitoring
    │   │   ├── models/
    │   │   │   ├── registry.ts   # TypeScript interfaces for registry
    │   │   │   ├── project.ts    # Project schema (no tags)
    │   │   │   ├── layout.ts     # Layout schema with app instance IDs
    │   │   │   └── environment.ts # NEW: I3PM_* environment variable types
    │   │   ├── services/
    │   │   │   ├── registry.ts   # Load/parse registry JSON
    │   │   │   ├── project-manager.ts # CRUD for projects
    │   │   │   ├── launcher.ts   # Application launching logic
    │   │   │   ├── layout-engine.ts # NEW: Capture/restore layouts
    │   │   │   └── daemon-client.ts # JSON-RPC to daemon
    │   │   └── ui/
    │   │       └── formatters.ts # Table/JSON formatters
    │   ├── main.ts               # CLI entry point
    │   └── deno.json             # Deno configuration
    │
    └── app-launcher.nix          # Packaging for launcher

scripts/
└── app-launcher-wrapper.sh       # UPDATED: Inject I3PM_* environment variables
```

**Structure Decision**:
- **Extend existing Feature 034 registry infrastructure** (app-launcher-wrapper.sh, app-registry.nix)
- **Extend existing Feature 015 daemon** (add window_filter.py service)
- **Use Feature 034 Deno CLI patterns** (TypeScript, @std/cli, JSON-RPC)
- **No new top-level directories** - all changes integrate into existing structure

## Implementation Strategy

### Phase 1: Environment Injection (Backward Compatible)

**Goal**: Inject I3PM_* environment variables without changing behavior

**Changes**:
1. Update app-launcher-wrapper.sh to export I3PM_* variables
2. Generate unique application instance IDs
3. Keep existing tag-based filtering working
4. Applications gain access to project context

**Validation**: Launch application → check /proc/<pid>/environ → see I3PM_* variables

### Phase 2: /proc Reading in Daemon (Backward Compatible)

**Goal**: Add capability to read window environments without using it yet

**Changes**:
1. Create window_filter.py service with /proc reading functions
2. Add xprop PID lookup (i3ipc doesn't expose PIDs reliably)
3. Log environment variables for debugging
4. Don't change window filtering behavior yet

**Validation**: Window opens → daemon logs I3PM_* variables from /proc

### Phase 3: Switch to Environment-Based Filtering (Breaking Change)

**Goal**: Replace tag-based filtering with environment-based approach

**Changes**:
1. Update on_tick_event to filter by I3PM_PROJECT_NAME from /proc
2. Remove XDG isolation from walker.nix
3. Remove tags field from app-registry.nix
4. Remove application_tags from project schema
5. Update CLI commands to remove tag references

**Validation**: Switch projects → windows filter by environment → no tags needed

### Phase 4: Layout Restore with Instance IDs

**Goal**: Enable exact window identification for layout restore

**Changes**:
1. Capture layouts with I3PM_APP_ID values
2. Launch applications with expected instance IDs
3. Match windows by comparing I3PM_APP_ID
4. Apply geometry only after exact match

**Validation**: Restore layout → all windows appear in correct positions with exact apps

### Phase 5: Cleanup and Documentation

**Goal**: Remove all legacy code and update documentation

**Changes**:
1. Remove tag validation logic
2. Remove tag-related CLI commands
3. Update CLAUDE.md with new workflow
4. Update quickstart.md with environment-based examples

## Technical Decisions

### Decision 1: Environment Variables vs Tags

**Chosen**: Environment variable injection with /proc reading

**Alternatives Considered**:
1. **Tag-based filtering** (original plan)
   - Complex: 3-layer indirection (tags → registry → window class)
   - Manual: Users must configure tags per project
   - Limited: Applications can't access project context

2. **XDG directory isolation** (Feature 034 approach)
   - Inflexible: Requires desktop file regeneration
   - Complex: Cache invalidation for Walker/Elephant
   - Static: Can't change at runtime

**Rationale**: Environment variables are simpler, more powerful, and enable applications to access project context. /proc reading enables deterministic window-to-project association without configuration.

### Decision 2: Application Instance IDs

**Chosen**: Generate unique I3PM_APP_ID at launch time

**Format**: `${APP_NAME}-${PROJECT_NAME}-${PID}-${TIMESTAMP}`

**Rationale**: Eliminates window matching ambiguity. Multiple VS Code windows across projects are distinguishable by their instance IDs. Critical for accurate layout restore.

### Decision 3: PID Retrieval Method

**Chosen**: xprop with fallback to window class

**Alternatives Considered**:
1. **i3ipc library node.pid** - Returns None for most windows (unreliable)
2. **wmctrl -l -p** - Works but requires parsing full window list
3. **xprop -id <window_id> _NET_WM_PID** - Direct, reliable, per-window

**Rationale**: xprop provides direct window → PID mapping with ~10-20ms latency. Acceptable overhead for project switching operations.

### Decision 4: Window Filtering Strategy

**Chosen**: Read /proc/<pid>/environ on project switch

**Performance**: 20 windows × 22ms = 440ms (well under 2-second requirement)

**Optimization Opportunities**:
1. Cache PIDs on window::new (avoid xprop on switch)
2. Parallel xprop calls (async subprocess)
3. Only query scoped windows (skip globals)

**Rationale**: Slight performance cost (vs instant tag filtering) but eliminates all tag configuration complexity.

## Risks and Mitigations

### Risk 1: PID Not Available

**Scenario**: xprop fails to get PID for a window

**Mitigation**: Fallback to window class matching (existing behavior)

**Impact**: Low - rare occurrence, graceful degradation

### Risk 2: Permission Errors Reading /proc

**Scenario**: Process owned by different user (multi-user system)

**Mitigation**: Assume global scope if /proc read fails

**Impact**: Low - single-user systems (current deployment)

### Risk 3: Performance Degradation

**Scenario**: /proc reading adds latency to project switching

**Mitigation**:
1. Optimize with caching
2. Parallel queries
3. Profile and optimize if needed

**Impact**: Medium - but acceptable (440ms < 2s requirement)

### Risk 4: Application Crashes Before Environment Read

**Scenario**: Application crashes immediately after launch

**Mitigation**: Window::close event cleanup, timeout handling

**Impact**: Low - rare occurrence, user can retry

## Success Criteria

All criteria from spec.md plus:

- **SC-011**: Environment variables successfully injected in 100% of launched applications (verified via /proc)
- **SC-012**: Application instance IDs uniquely identify windows even with 10+ instances of same application
- **SC-013**: Window filtering completes in <2 seconds for 20 windows (measured end-to-end)
- **SC-014**: Layout restore matches 100% of windows by I3PM_APP_ID (no ambiguity)
- **SC-015**: All tag-based filtering code removed (verified by grep for "tags" in codebase)

## Next Steps

1. **Phase 0**: Research complete (environment validation, /proc testing)
2. **Phase 1**: Update data-model.md with environment schemas
3. **Phase 1**: Update contracts/ with environment-based CLI commands
4. **Phase 1**: Generate quickstart.md with new workflows
5. **Phase 2**: Run /speckit.tasks to generate implementation tasks

## Notes

- **See research-proc-filtering.md** for complete technical validation
- **See research-env-vars.md** for environment variable approach analysis
- **See research.md** for Deno i3 IPC integration patterns
- **Application tags completely removed** - environment-based approach is simpler and more powerful
- **Backward compatibility intentionally broken** (Principle XII) - no dual support for tags
