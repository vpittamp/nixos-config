# Web Applications Declarative Launcher Module
# Based on activity-aware-apps-native.nix pattern
# Implements FR-007 through FR-016, FR-018
{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.webApps;

  # Filter enabled applications
  enabledApps = filterAttrs (id: app: app.enabled or true) cfg.applications;

  # Determine browser package based on configuration
  browserPkg = {
    "ungoogled-chromium" = pkgs.ungoogled-chromium;
    "chromium" = pkgs.chromium;
    "google-chrome" = pkgs.google-chrome;
  }.${cfg.browser};

  # 1Password extension ID
  onePasswordExtensionId = "aeblfdkhhhdcdjpifhhbdiojplfjncoa";

  # Generate launcher script for each web app
  makeLauncher = id: app: pkgs.writeScriptBin "webapp-${id}" ''
    #!/bin/sh
    # Web application launcher for ${app.name}
    # Generated by web-apps-declarative.nix

    PROFILE_DIR="$HOME/.local/share/webapps/${app.wmClass}"
    MAIN_CHROMIUM_PROFILE="$HOME/.config/chromium/Default"

    # Create profile directory if it doesn't exist (FR-045)
    mkdir -p "$PROFILE_DIR"
    mkdir -p "$PROFILE_DIR/Default"

    # Install 1Password extension via External Extensions mechanism
    # This is how home-manager installs extensions - Chromium will download it from Chrome Web Store
    mkdir -p "$PROFILE_DIR/External Extensions"
    cat > "$PROFILE_DIR/External Extensions/${onePasswordExtensionId}.json" <<'EOF'
{"external_update_url":"https://clients2.google.com/service/update2/crx"}
EOF

    # Create native messaging hosts directory for 1Password
    mkdir -p "$PROFILE_DIR/NativeMessagingHosts"

    # Link 1Password native messaging host configuration
    # This allows 1Password extension to communicate with the desktop app
    ln -sf "$HOME/.config/chromium/NativeMessagingHosts/com.1password.1password.json" \
      "$PROFILE_DIR/NativeMessagingHosts/com.1password.1password.json" 2>/dev/null || true
    ln -sf "$HOME/.config/chromium/NativeMessagingHosts/com.1password.browser_support.json" \
      "$PROFILE_DIR/NativeMessagingHosts/com.1password.browser_support.json" 2>/dev/null || true

    # Share 1Password extension data from main Chromium profile
    # This allows authentication to persist across all web apps
    if [ -d "$MAIN_CHROMIUM_PROFILE/Local Extension Settings/${onePasswordExtensionId}" ]; then
      mkdir -p "$PROFILE_DIR/Default/Local Extension Settings"
      rm -rf "$PROFILE_DIR/Default/Local Extension Settings/${onePasswordExtensionId}" 2>/dev/null
      ln -sf "$MAIN_CHROMIUM_PROFILE/Local Extension Settings/${onePasswordExtensionId}" \
        "$PROFILE_DIR/Default/Local Extension Settings/${onePasswordExtensionId}"
    fi

    # Share extension state and sync data for seamless authentication
    if [ -d "$MAIN_CHROMIUM_PROFILE/Extension State" ]; then
      rm -rf "$PROFILE_DIR/Default/Extension State" 2>/dev/null
      ln -sf "$MAIN_CHROMIUM_PROFILE/Extension State" "$PROFILE_DIR/Default/Extension State"
    fi

    # Share extension cookies for authentication
    if [ -f "$MAIN_CHROMIUM_PROFILE/Extension Cookies" ]; then
      ln -sf "$MAIN_CHROMIUM_PROFILE/Extension Cookies" "$PROFILE_DIR/Default/Extension Cookies" 2>/dev/null
    fi

    # Launch Chromium in app mode with custom WM_CLASS for i3wm targeting
    exec ${browserPkg}/bin/chromium \
      --user-data-dir="$PROFILE_DIR" \
      --class="${app.wmClass}" \
      --app="${app.url}" \
      --enable-native-messaging \
      ${concatStringsSep " " (app.extraBrowserArgs or [])}
  '';

  # Generate i3wm window rules for workspace assignment
  makeI3WindowRule = id: app: optionalString (app.workspace != null && cfg.i3Integration.autoAssignWorkspace) ''
    # Assign ${app.name} to workspace ${app.workspace}
    for_window [class="^${app.wmClass}$"] move to workspace ${app.workspace}
    assign [class="^${app.wmClass}$"] workspace ${app.workspace}
  '';

  # Generate cleanup script for removed web apps (FR-046)
  cleanupScript = pkgs.writeScriptBin "webapp-cleanup" ''
    #!/bin/sh
    # Web Application Profile Cleanup Script
    # Removes profile directories for web applications no longer in configuration

    PROFILE_BASE="${cfg.baseProfileDir}"
    ACTIVE_PROFILES="${concatStringsSep " " (mapAttrsToList (id: app: app.wmClass) enabledApps)}"

    echo "Web Application Profile Cleanup"
    echo "================================"
    echo "Profile directory: $PROFILE_BASE"
    echo "Active applications: $(echo $ACTIVE_PROFILES | wc -w)"
    echo

    if [ ! -d "$PROFILE_BASE" ]; then
      echo "No profiles directory found. Nothing to clean up."
      exit 0
    fi

    # Find all profile directories
    for profile_dir in "$PROFILE_BASE"/*; do
      if [ ! -d "$profile_dir" ]; then
        continue
      fi

      profile_name=$(basename "$profile_dir")

      # Check if this profile is still active
      if echo "$ACTIVE_PROFILES" | grep -qw "$profile_name"; then
        echo "✓ Keeping: $profile_name (active)"
      else
        echo "✗ Removing: $profile_name (no longer configured)"
        rm -rf "$profile_dir"
      fi
    done

    echo
    echo "Cleanup complete."
  '';

in {
  # Import site definitions
  imports = [ ./web-apps-sites.nix ];

  options.programs.webApps = {
    enable = mkEnableOption "declarative web application launcher";

    browser = mkOption {
      type = types.enum [ "ungoogled-chromium" "chromium" "google-chrome" ];
      default = "ungoogled-chromium";
      description = "Browser to use for web applications";
    };

    baseProfileDir = mkOption {
      type = types.str;
      default = "$HOME/.local/share/webapps";
      description = "Base directory for web application browser profiles";
    };

    applications = mkOption {
      type = types.attrsOf (types.submodule {
        options = {
          name = mkOption {
            type = types.str;
            description = "Display name for the web application";
          };

          url = mkOption {
            type = types.str;
            description = "URL of the web application";
          };

          wmClass = mkOption {
            type = types.str;
            description = "Window manager class for i3wm targeting (must start with 'webapp-')";
          };

          icon = mkOption {
            type = types.nullOr types.path;
            default = null;
            description = "Path to custom icon file";
          };

          workspace = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = "Preferred i3wm workspace";
          };

          lifecycle = mkOption {
            type = types.enum [ "persistent" "fresh" ];
            default = "persistent";
            description = "Lifecycle management (persistent or fresh launch)";
          };

          keywords = mkOption {
            type = types.listOf types.str;
            default = [];
            description = "Search keywords for rofi";
          };

          enabled = mkOption {
            type = types.bool;
            default = true;
            description = "Whether this web application is enabled";
          };

          extraBrowserArgs = mkOption {
            type = types.listOf types.str;
            default = [];
            description = "Additional browser command-line arguments";
          };
        };
      });
      default = {};
      description = "Web application definitions";
    };

    rofi = {
      showIcons = mkOption {
        type = types.bool;
        default = true;
        description = "Show icons in rofi launcher";
      };
    };

    i3Integration = {
      autoAssignWorkspace = mkOption {
        type = types.bool;
        default = true;
        description = "Automatically assign web apps to workspaces";
      };

      floatingMode = mkOption {
        type = types.bool;
        default = false;
        description = "Launch web apps in floating mode";
      };
    };
  };

  config = mkIf cfg.enable {
    # Validation assertions (FR-042, FR-043, FR-044)
    assertions = [
      {
        assertion = all (app: app.wmClass != null && hasPrefix "webapp-" app.wmClass) (attrValues enabledApps);
        message = "All web applications must have wmClass starting with 'webapp-'";
      }
      {
        assertion =
          let wmClasses = mapAttrsToList (id: app: app.wmClass) enabledApps;
          in (length wmClasses) == (length (unique wmClasses));
        message = "Web application wmClass values must be unique";
      }
      {
        assertion = all (app: app.icon == null || pathExists app.icon) (attrValues enabledApps);
        message = "Web application icon paths must exist if specified";
      }
      {
        assertion = all (app: hasPrefix "https://" app.url || hasPrefix "http://localhost" app.url) (attrValues enabledApps);
        message = "Web application URLs must start with https:// or http://localhost";
      }
    ];

    # Install launcher scripts and cleanup helper (FR-007, FR-008, FR-046)
    # Note: Browser (chromium) is already installed via chromium.nix
    home.packages = [ cleanupScript ] ++ mapAttrsToList makeLauncher enabledApps;

    # Create desktop entries for rofi integration (FR-009)
    xdg.desktopEntries = mapAttrs (id: app: {
      name = app.name;
      exec = "webapp-${id}";
      icon = if app.icon != null then toString app.icon else "web-browser";
      categories = [ "Network" "WebBrowser" ];
      terminal = false;
      comment = "Web application: ${app.url}";
    }) enabledApps;

    # Generate i3wm configuration snippet (FR-010)
    # Always generate if web apps are enabled (works with both xsession and XRDP i3)
    home.file.".config/i3/web-apps.conf" = {
      text = ''
        # Web Applications Configuration
        # Generated by web-apps-declarative.nix
        # DO NOT EDIT - Changes will be overwritten on rebuild

        ${concatStringsSep "\n" (mapAttrsToList makeI3WindowRule enabledApps)}

        ${optionalString cfg.i3Integration.floatingMode ''
        # Launch all web apps in floating mode
        ${concatMapStringsSep "\n" (id:
          "for_window [class=\"^${(enabledApps.${id}).wmClass}$\"] floating enable"
        ) (attrNames enabledApps)}
        ''}
      '';
    };
  };
}
