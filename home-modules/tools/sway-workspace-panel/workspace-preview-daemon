#!/usr/bin/env python3
"""Workspace preview daemon for Feature 057: User Story 2.

Subscribes to i3pm workspace_mode events and outputs workspace preview JSON
to stdout for Eww deflisten.

Protocol:
- Outputs line-delimited JSON to stdout
- Each line is a complete WorkspacePreview JSON object
- Eww deflisten workspace_preview variable consumes this stream
- Uses eww open/close commands to control window visibility (not :visible property)
"""
from __future__ import annotations

import asyncio
import json
import signal
import socket
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional

import i3ipc  # Feature 059: For Sway IPC navigation commands

from models import WorkspaceModeEvent, PendingWorkspaceState
from selection_models.selection_state import SelectionState, NavigableItem, PreviewListModel
from preview_renderer import PreviewRenderer

# Socket path matches systemd socket unit configuration
DAEMON_IPC_SOCKET = Path("/run/i3-project-daemon/ipc.sock")

# Eww configuration directory (workspace bar)
EWW_CONFIG_DIR = Path.home() / ".config" / "eww-workspace-bar"


def eww_open_window(window_name: str = "workspace-preview") -> None:
    """Open an Eww window using the eww CLI.

    Args:
        window_name: Name of the Eww window to open (default: workspace-preview)
    """
    try:
        subprocess.run(
            ["eww", "--config", str(EWW_CONFIG_DIR), "open", window_name],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=1.0,
        )
        print(f"DEBUG: Opened Eww window: {window_name}", file=sys.stderr, flush=True)
    except subprocess.TimeoutExpired:
        print(f"WARNING: eww open {window_name} timed out after 1s", file=sys.stderr, flush=True)
    except subprocess.CalledProcessError as e:
        print(f"ERROR: Failed to open Eww window {window_name}: {e}", file=sys.stderr, flush=True)
    except FileNotFoundError:
        print("ERROR: eww command not found. Is Eww installed?", file=sys.stderr, flush=True)


def eww_close_window(window_name: str = "workspace-preview") -> None:
    """Close an Eww window using the eww CLI.

    Args:
        window_name: Name of the Eww window to close (default: workspace-preview)
    """
    try:
        subprocess.run(
            ["eww", "--config", str(EWW_CONFIG_DIR), "close", window_name],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=1.0,
        )
        print(f"DEBUG: Closed Eww window: {window_name}", file=sys.stderr, flush=True)
    except subprocess.TimeoutExpired:
        print(f"WARNING: eww close {window_name} timed out after 1s", file=sys.stderr, flush=True)
    except subprocess.CalledProcessError as e:
        # Window might already be closed, which is fine
        print(f"DEBUG: eww close {window_name} returned non-zero (might already be closed): {e}", file=sys.stderr, flush=True)
    except FileNotFoundError:
        print("ERROR: eww command not found. Is Eww installed?", file=sys.stderr, flush=True)


def parse_workspace_and_monitor(accumulated_digits: str) -> tuple[Optional[int], Optional[str]]:
    """Parse accumulated digits into workspace number and optional monitor.

    Feature 057: Workspace-to-Monitor Move (User Story 3)

    Parsing rules:
    - 1 digit: workspace only (e.g., "7" = workspace 7)
    - 2 digits: workspace only (e.g., "23" = workspace 23)
    - 3 digits: workspace + monitor (e.g., "231" = workspace 23, monitor 1 = HEADLESS-1)

    Returns:
        (workspace_number, monitor_name) tuple
    """
    if not accumulated_digits:
        return (None, None)

    # 1-2 digits: workspace only
    if len(accumulated_digits) <= 2:
        try:
            workspace = int(accumulated_digits)
            if 1 <= workspace <= 70:
                return (workspace, None)
        except ValueError:
            pass
        return (None, None)

    # 3 digits: workspace + monitor
    if len(accumulated_digits) == 3:
        try:
            workspace_str = accumulated_digits[:2]
            monitor_digit = accumulated_digits[2]

            workspace = int(workspace_str)
            monitor = int(monitor_digit)

            # Validate workspace (1-70) and monitor (1-3)
            if 1 <= workspace <= 70 and 1 <= monitor <= 3:
                monitor_name = f"HEADLESS-{monitor}"
                return (workspace, monitor_name)
        except ValueError:
            pass
        return (None, None)

    # More than 3 digits: invalid
    return (None, None)


class SelectionManager:
    """Manage selection state for interactive workspace menu navigation (Feature 059).

    Owns the PreviewListModel and SelectionState, exposes navigation methods for
    arrow key handling.
    """

    def __init__(self):
        """Initialize SelectionManager with empty state."""
        self.list_model: Optional[PreviewListModel] = None
        self.selection_state: Optional[SelectionState] = None

    def initialize_from_workspace_groups(self, workspace_groups: list) -> None:
        """Initialize selection from workspace groups data.

        Args:
            workspace_groups: List of workspace group dicts from PreviewRenderer
        """
        # Build flattened list model from workspace groups
        self.list_model = PreviewListModel.from_workspace_groups(workspace_groups)

        # Initialize selection state to first item (if non-empty)
        if self.list_model and not self.list_model.is_empty:
            first_item = self.list_model.items[0]
            self.selection_state = SelectionState(
                selected_index=0,
                item_type=first_item.item_type,
                workspace_num=first_item.workspace_num,
                window_id=first_item.window_id,
                visible=True
            )
        else:
            self.selection_state = None

    def navigate_down(self) -> None:
        """Navigate selection down (circular wrap to first if at last)."""
        if not self.list_model or self.list_model.is_empty:
            return

        self.list_model.navigate_down()
        self._update_selection_state_from_model()

    def navigate_up(self) -> None:
        """Navigate selection up (circular wrap to last if at first)."""
        if not self.list_model or self.list_model.is_empty:
            return

        self.list_model.navigate_up()
        self._update_selection_state_from_model()

    def reset_selection(self) -> None:
        """Reset selection to first item (or None if empty)."""
        if not self.list_model:
            self.selection_state = None
            return

        self.list_model.reset_selection()
        self._update_selection_state_from_model()

    def get_selection_state(self) -> Optional[SelectionState]:
        """Get current selection state for JSON output."""
        return self.selection_state

    def get_selected_item(self) -> Optional[NavigableItem]:
        """Get currently selected navigable item."""
        if not self.list_model:
            return None
        return self.list_model.get_selected_item()

    def clear(self) -> None:
        """Clear all selection state (mode exit)."""
        self.list_model = None
        self.selection_state = None

    def remove_item(self, item: NavigableItem) -> bool:
        """Remove item from preview list (Feature 059: T045).

        Args:
            item: NavigableItem to remove

        Returns:
            True if item was found and removed, False otherwise
        """
        if not self.list_model:
            return False
        removed = self.list_model.remove_item(item)
        if removed:
            self._update_selection_state_from_model()
        return removed

    def clamp_selection(self) -> None:
        """Clamp selection index after list modification (Feature 059: T046)."""
        if not self.list_model:
            return
        self.list_model.clamp_selection()
        self._update_selection_state_from_model()

    def _update_selection_state_from_model(self) -> None:
        """Update SelectionState from current PreviewListModel selection."""
        if not self.list_model or not self.list_model.has_selection:
            self.selection_state = None
            return

        selected_item = self.list_model.get_selected_item()
        if selected_item:
            print(f"DEBUG: _update_selection_state_from_model: index={self.list_model.current_selection_index}, item_type={selected_item.item_type}, window_id={selected_item.window_id}, ws={selected_item.workspace_num}", file=sys.stderr, flush=True)
            self.selection_state = SelectionState(
                selected_index=self.list_model.current_selection_index,
                item_type=selected_item.item_type,
                workspace_num=selected_item.workspace_num,
                window_id=selected_item.window_id,
                visible=True
            )


class NavigationHandler:
    """Handle keyboard navigation events for interactive workspace menu (Feature 059).

    Processes arrow key, Enter, and Delete key events from i3pm daemon IPC.
    """

    def __init__(self, selection_manager: SelectionManager):
        """Initialize NavigationHandler with SelectionManager reference.

        Args:
            selection_manager: SelectionManager instance to manipulate selection
        """
        self.selection_manager = selection_manager
        self.last_preview_data = None  # Cache last preview for re-emission
        self.current_mode = "goto"  # Feature 059: T024 - Track current mode (goto/move) for move-mode styling

    def handle_arrow_key_event(self, direction: str, mode: str) -> None:
        """Handle arrow key navigation event.

        Args:
            direction: "up" or "down"
            mode: Preview mode when key was pressed ("all_windows", etc.)
        """
        # T056: Performance benchmarking - measure arrow key latency (target: <10ms)
        start_time = time.time()

        # Only handle navigation in all_windows mode for Feature 059
        if mode != "all_windows":
            return

        if direction == "down":
            self.selection_manager.navigate_down()
        elif direction == "up":
            self.selection_manager.navigate_up()
        else:
            print(f"Warning: Unknown navigation direction: {direction}", file=sys.stderr)
            return

        # Re-emit preview with updated selection
        self._emit_preview_with_selection()

        # T056: Log performance if exceeds target
        elapsed_ms = (time.time() - start_time) * 1000
        if elapsed_ms > 10:
            print(f"WARNING: Arrow navigation took {elapsed_ms:.1f}ms (target: <10ms)", file=sys.stderr)
        else:
            print(f"DEBUG: Arrow navigation latency: {elapsed_ms:.1f}ms", file=sys.stderr)

    def handle_enter_key_event(self, mode: str, accumulated_digits: str) -> None:
        """Handle Enter key selection event (Feature 059: T028).

        Navigates to selected workspace/window, or falls back to digit navigation.

        Args:
            mode: Preview mode when Enter was pressed ("all_windows", "filtered_workspace", etc.)
            accumulated_digits: Digits typed before Enter (for fallback)
        """
        # Only handle selection-based navigation in all_windows mode
        if mode != "all_windows":
            # Delegate to existing Feature 072 digit navigation handler (i3pm daemon handles it)
            print(f"DEBUG: Delegating to digit navigation (mode={mode})", file=sys.stderr)
            return

        # Get selected item from SelectionManager (T032, T033)
        selected_item = self.selection_manager.get_selected_item()

        # T034: Fallback logic - if no selection, check for digit navigation
        if selected_item is None:
            if accumulated_digits:
                # Fall back to digit-based navigation
                try:
                    workspace_num = int(accumulated_digits)
                    sway_conn = i3ipc.Connection()
                    result = navigate_to_workspace(sway_conn, workspace_num)
                    if result["success"]:
                        # T037: Clear selection and hide preview on success
                        self.selection_manager.clear()
                        emit_preview(visible=False)
                    return
                except ValueError:
                    print(f"ERROR: Invalid workspace number: {accumulated_digits}", file=sys.stderr)
                    return
            else:
                # No selection and no digits - nothing to do
                print("DEBUG: No selection and no digits, exiting mode without action", file=sys.stderr)
                return

        # Selection exists - navigate based on item type
        sway_conn = i3ipc.Connection()

        if selected_item.is_workspace_heading():
            # T032: Navigate to workspace heading
            print(f"DEBUG: Navigating to workspace {selected_item.workspace_num}", file=sys.stderr)
            result = navigate_to_workspace(sway_conn, selected_item.workspace_num)
        elif selected_item.is_window():
            # T033: Focus window (auto-switches to workspace)
            print(f"DEBUG: Focusing window {selected_item.window_id} on workspace {selected_item.workspace_num}", file=sys.stderr)
            result = focus_window(sway_conn, selected_item.window_id)
        else:
            print(f"ERROR: Unknown selected item type: {selected_item.item_type}", file=sys.stderr)
            return

        # T037: Clear selection and hide preview on successful navigation
        if result.get("success"):
            self.selection_manager.clear()
            emit_preview(visible=False)
            print(f"DEBUG: Navigation successful, cleared selection and hid preview", file=sys.stderr)
        else:
            print(f"ERROR: Navigation failed: {result.get('error')}", file=sys.stderr)

    def handle_delete_key_event(self, mode: str) -> None:
        """Handle Delete key window close event (Feature 059: T039).

        Closes selected window if it's a window (not workspace heading).
        Updates preview list and maintains workspace mode.

        Args:
            mode: Preview mode when Delete was pressed ("all_windows", etc.)
        """
        # Only handle deletion in all_windows mode
        if mode != "all_windows":
            return

        # Get selected item
        selected_item = self.selection_manager.get_selected_item()

        if selected_item is None:
            print("DEBUG: No selection, cannot delete", file=sys.stderr)
            return

        # T044: Validate that selection is a window (not workspace heading)
        if selected_item.is_workspace_heading():
            print(f"WARNING: Cannot close workspace heading {selected_item.workspace_num}", file=sys.stderr)
            # No notification needed - silent no-op per contract
            return

        # Close window with verification (T043)
        print(f"DEBUG: Closing window {selected_item.window_id} on workspace {selected_item.workspace_num}", file=sys.stderr)
        sway_conn = i3ipc.Connection()
        result = close_window_with_verification(sway_conn, selected_item.window_id, timeout_ms=500)

        if result["success"]:
            # T045: Remove closed window from preview list
            self.selection_manager.remove_item(selected_item)

            # T046: Adjust selection index after removal
            self.selection_manager.clamp_selection()

            # T047: Re-emit preview with updated list
            self._emit_preview_with_selection()

            print(f"DEBUG: Window {selected_item.window_id} closed successfully in {result['close_duration_ms']:.1f}ms", file=sys.stderr)
        else:
            # T048: Error handling for close timeout or failure
            error_msg = result.get("error", "Unknown error")
            warning_msg = result.get("warning")

            # T049: Log timeout as WARNING (not ERROR) - expected for unsaved changes
            if "timeout" in error_msg.lower():
                log_msg = f"Window {selected_item.window_id} close timeout: {warning_msg or error_msg}"
                print(f"WARNING: {log_msg}", file=sys.stderr)
            else:
                print(f"ERROR: Failed to close window {selected_item.window_id}: {error_msg}", file=sys.stderr)

            # Show notification for blocked close (using swaynag for now - can be replaced with SwayNC)
            notification_msg = warning_msg or error_msg
            try:
                sway_conn.command(f'exec swaynag -t warning -m "Window Close Blocked" -b "Dismiss" "swaymsg mode default"')
                print(f"DEBUG: Showed notification: {notification_msg}", file=sys.stderr)
            except Exception as e:
                print(f"ERROR: Failed to show notification: {e}", file=sys.stderr)

        # T050: Maintain workspace mode active (do NOT exit mode, allow multiple deletions)
        # No mode exit command needed - user can press Escape or Enter to exit

    def handle_home_key_event(self, mode: str) -> None:
        """Handle Home key to jump to first item (Feature 059: T059).

        Args:
            mode: Preview mode when Home was pressed ("all_windows", etc.)
        """
        # Only handle navigation in all_windows mode
        if mode != "all_windows":
            return

        if not self.selection_manager.list_model or self.selection_manager.list_model.is_empty:
            print("DEBUG: No items to navigate to", file=sys.stderr)
            return

        # Jump to first item
        self.selection_manager.list_model.current_selection_index = 0
        self.selection_manager._update_selection_state_from_model()

        # Re-emit preview with updated selection
        self._emit_preview_with_selection()
        print("DEBUG: Jumped to first item (Home key)", file=sys.stderr)

    def handle_end_key_event(self, mode: str) -> None:
        """Handle End key to jump to last item (Feature 059: T059).

        Args:
            mode: Preview mode when End was pressed ("all_windows", etc.)
        """
        # Only handle navigation in all_windows mode
        if mode != "all_windows":
            return

        if not self.selection_manager.list_model or self.selection_manager.list_model.is_empty:
            print("DEBUG: No items to navigate to", file=sys.stderr)
            return

        # Jump to last item
        last_index = len(self.selection_manager.list_model.items) - 1
        self.selection_manager.list_model.current_selection_index = last_index
        self.selection_manager._update_selection_state_from_model()

        # Re-emit preview with updated selection
        self._emit_preview_with_selection()
        print("DEBUG: Jumped to last item (End key)", file=sys.stderr)

    def cache_preview_data(self, preview_data: dict, mode: str = "goto") -> None:
        """Cache preview data for re-emission with updated selection.

        Args:
            preview_data: The workspace_groups list and metadata from renderer
            mode: Navigation mode ("goto" or "move") for move-mode styling (Feature 059: T024)
        """
        self.last_preview_data = preview_data
        self.current_mode = mode  # Feature 059: T024 - Store mode for move-mode styling

    def _emit_preview_with_selection(self) -> None:
        """Re-emit cached preview data with updated selection state."""
        if not self.last_preview_data:
            print("Warning: No cached preview data to re-emit", file=sys.stderr)
            return

        # Get current selection state
        selection_state = self.selection_manager.get_selection_state()
        selection_dict = {
            "selected_index": selection_state.selected_index if selection_state else None,
            "item_type": selection_state.item_type if selection_state else "workspace_heading",
            "workspace_num": selection_state.workspace_num if selection_state else None,
            "window_id": selection_state.window_id if selection_state else None,
            "visible": selection_state.visible if selection_state else False,
            "move_mode": self.current_mode == "move",  # Feature 059: T024 - Add move_mode boolean for CSS styling
        }

        # Update selection_state in cached data and re-emit
        output = {**self.last_preview_data, "selection_state": selection_dict}
        print(json.dumps(output), flush=True)

        # Also update Eww variable directly (deflisten isn't reliable)
        try:
            json_str = json.dumps(output)
            result = subprocess.run(
                ["eww", "--config", str(EWW_CONFIG_DIR), "update", f"workspace_preview_data={json_str}"],
                check=False,
                capture_output=True,
                timeout=0.5,
                text=True,
            )
            if result.returncode != 0:
                print(f"WARNING: eww update failed with code {result.returncode}: {result.stderr}", file=sys.stderr, flush=True)
            else:
                print(f"DEBUG: Updated Eww variable with {len(json_str)} chars", file=sys.stderr, flush=True)
        except Exception as e:
            print(f"WARNING: Failed to update Eww variable: {e}", file=sys.stderr, flush=True)

        print(f"DEBUG: Re-emitted preview with selection_index={selection_dict['selected_index']}", file=sys.stderr, flush=True)


def emit_preview(visible: bool, renderer: Optional[PreviewRenderer] = None, **kwargs) -> None:
    """Emit workspace preview JSON to stdout and control Eww window visibility.

    Feature 072: T036 - Added <50ms performance timing validation for workspace filtering.
    Eww Best Practice: Use eww open/close commands instead of :visible widget property
    to ensure GTK creates window surface that Sway can see in its tree.

    Args:
        visible: Whether preview card should be shown
        renderer: PreviewRenderer instance for querying workspace contents
        **kwargs: Additional fields (workspace_num, monitor, mode, accumulated_digits, etc.)
    """
    # T036: Start timing for performance validation (<50ms target)
    start_time = time.time()

    if not visible:
        # Close Eww window (GTK destroys window surface, removes from Sway tree)
        eww_close_window("workspace-preview")
        # Still emit JSON for deflisten (Eww needs stream to remain active)
        output = {}  # Empty JSON (no data needed when window closed)
        print(json.dumps(output), flush=True)
        return

    # Open Eww window (GTK creates window surface, appears in Sway tree)
    # This MUST happen before emitting JSON to ensure window exists
    eww_open_window("workspace-preview")

    # Render workspace preview with full contents
    if renderer is None:
        print("Error: renderer is None but visible=True", file=sys.stderr)
        return

    workspace_num = kwargs.get("workspace_num")
    monitor_output = kwargs.get("monitor_output", "HEADLESS-1")
    mode = kwargs.get("mode", "goto")
    accumulated_digits = kwargs.get("accumulated_digits", "")

    if workspace_num is None:
        print("Error: workspace_num is None but visible=True", file=sys.stderr)
        return

    # Special case: workspace_num=0 means instructional state (mode entered, no digits yet)
    if workspace_num == 0:
        output = {
            "monitor": monitor_output,
            "workspace_num": 0,
            "workspace_name": None,
            "mode": mode,
            "accumulated_digits": "",
            "apps": [],
            "window_count": 0,
            "empty": True,
            "invalid": False,
            "instructional": True,
            "icon_path": None,
        }
        print(json.dumps(output), flush=True)
        return

    # Validate workspace number range
    if workspace_num < 1 or workspace_num > 70:
        # Invalid workspace - show error card
        output = {
            "monitor": monitor_output,
            "workspace_num": workspace_num,
            "workspace_name": None,
            "mode": mode,
            "accumulated_digits": accumulated_digits,
            "apps": [],
            "window_count": 0,
            "empty": True,
            "invalid": True,
            "instructional": False,
            "icon_path": None,
        }
        print(json.dumps(output), flush=True)
        return

    # Query workspace contents via Sway IPC
    preview = renderer.render_workspace_preview(
        workspace_num=workspace_num,
        monitor_output=monitor_output,
        mode=mode,
    )

    # Feature 057: Parse target monitor from accumulated digits (for move mode)
    _, target_monitor = parse_workspace_and_monitor(accumulated_digits)

    # Convert to dict for JSON output (matches contract schema)
    output = {
        "monitor": preview.monitor_output,
        "workspace_num": preview.workspace_num,
        "workspace_name": preview.workspace_name,
        "mode": preview.mode,
        "accumulated_digits": accumulated_digits,
        "target_monitor": target_monitor or "",  # Feature 057: Target monitor for move mode (empty string if not set, not null)
        "apps": [
            {
                "name": app.name,
                "icon_path": app.icon or "",
                "app_id": app.app_id,
                "window_class": app.window_class,
                "focused": app.focused,
            }
            for app in preview.apps
        ],
        "window_count": preview.window_count,
        "empty": preview.empty,
        "invalid": False,
        "instructional": False,
        "icon_path": preview.apps[0].icon if preview.apps else None,
    }

    print(json.dumps(output), flush=True)

    # Also update Eww variable directly (deflisten isn't reliable)
    try:
        json_str = json.dumps(output)
        result = subprocess.run(
            ["eww", "--config", str(EWW_CONFIG_DIR), "update", f"workspace_preview_data={json_str}"],
            check=False,
            capture_output=True,
            timeout=0.5,
            text=True,
        )
        if result.returncode != 0:
            print(f"WARNING: eww update failed with code {result.returncode}: {result.stderr}", file=sys.stderr, flush=True)
    except Exception as e:
        print(f"WARNING: Failed to update Eww variable: {e}", file=sys.stderr, flush=True)

    # T036: Log performance timing if >50ms (User Story 2 target)
    elapsed_ms = (time.time() - start_time) * 1000
    if elapsed_ms > 50:
        print(f"WARNING: Preview update took {elapsed_ms:.1f}ms (target: <50ms) for workspace {workspace_num}", file=sys.stderr)


def emit_project_preview(visible: bool, **kwargs) -> None:
    """Emit project preview JSON to stdout.

    Option A: Unified Smart Detection - Show project search results.

    Args:
        visible: Whether preview card should be shown
        **kwargs: Additional fields (accumulated_chars, matched_project, project_icon)
    """
    if not visible:
        # Close Eww window (GTK destroys window surface, removes from Sway tree)
        eww_close_window("workspace-preview")
        # Hide preview card
        output = {"visible": False}
        print(json.dumps(output), flush=True)

        # Also update Eww variable directly (deflisten isn't reliable)
        try:
            json_str = json.dumps(output)
            result = subprocess.run(
                ["eww", "--config", str(EWW_CONFIG_DIR), "update", f"workspace_preview_data={json_str}"],
                check=False,
                capture_output=True,
                timeout=0.5,
                text=True,
            )
            if result.returncode != 0:
                print(f"WARNING: eww update failed with code {result.returncode}: {result.stderr}", file=sys.stderr, flush=True)
        except Exception as e:
            print(f"WARNING: Failed to update Eww variable: {e}", file=sys.stderr, flush=True)
        return

    accumulated_chars = kwargs.get("accumulated_chars", "")
    matched_project = kwargs.get("matched_project")
    project_icon = kwargs.get("project_icon", "ðŸ“")

    # Show project search preview
    output = {
        "visible": True,
        "type": "project",
        "accumulated_chars": accumulated_chars,
        "matched_project": matched_project,
        "project_icon": project_icon,
        "no_match": matched_project is None and len(accumulated_chars) > 0,
    }

    print(json.dumps(output), flush=True)

    # Also update Eww variable directly (deflisten isn't reliable)
    try:
        json_str = json.dumps(output)
        result = subprocess.run(
            ["eww", "--config", str(EWW_CONFIG_DIR), "update", f"workspace_preview_data={json_str}"],
            check=False,
            capture_output=True,
            timeout=0.5,
            text=True,
        )
        if result.returncode != 0:
            print(f"WARNING: eww update failed with code {result.returncode}: {result.stderr}", file=sys.stderr, flush=True)
    except Exception as e:
        print(f"WARNING: Failed to update Eww variable: {e}", file=sys.stderr, flush=True)


# Feature 059: Sway IPC navigation functions for Enter key selection (T030-T031)

def navigate_to_workspace(sway_conn: i3ipc.Connection, workspace_num: int) -> dict:
    """Navigate to workspace using Sway IPC (Feature 059: T030).

    Args:
        sway_conn: Sway IPC connection
        workspace_num: Target workspace number (1-70)

    Returns:
        Dict with success status and error message if failed
    """
    # T035: Validate workspace number range
    if workspace_num < 1 or workspace_num > 70:
        error_msg = f"Invalid workspace number: {workspace_num} (must be 1-70)"
        print(f"ERROR: {error_msg}", file=sys.stderr)
        return {"success": False, "error": error_msg}

    try:
        # Send Sway IPC command to switch workspace
        sway_conn.command(f"workspace number {workspace_num}")
        # Exit workspace mode
        sway_conn.command("mode default")
        print(f"Navigated to workspace {workspace_num}", file=sys.stderr)
        return {"success": True, "workspace": workspace_num}
    except Exception as e:
        error_msg = f"Failed to navigate to workspace {workspace_num}: {e}"
        print(f"ERROR: {error_msg}", file=sys.stderr)
        return {"success": False, "error": error_msg}


def focus_window(sway_conn: i3ipc.Connection, window_id: int) -> dict:
    """Focus window using Sway IPC (Feature 059: T031).

    Args:
        sway_conn: Sway IPC connection
        window_id: Sway container ID of window to focus

    Returns:
        Dict with success status and error message if failed
    """
    try:
        # Send Sway IPC command to focus window by container ID
        # This automatically switches to the workspace containing the window
        sway_conn.command(f"[con_id={window_id}] focus")
        # Exit workspace mode
        sway_conn.command("mode default")
        print(f"Focused window {window_id}", file=sys.stderr)
        return {"success": True, "window_id": window_id}
    except Exception as e:
        # T036: Handle window not found error
        error_msg = f"Failed to focus window {window_id}: {e}"
        print(f"ERROR: {error_msg}", file=sys.stderr)
        return {"success": False, "error": error_msg}


def send_kill_command(sway_conn: i3ipc.Connection, container_id: int) -> dict:
    """Send kill command to Sway for window close (Feature 059: T041).

    Args:
        sway_conn: Sway IPC connection
        container_id: Sway container ID of window to close

    Returns:
        Dict with success status and error message if failed
    """
    try:
        results = sway_conn.command(f'[con_id={container_id}] kill')

        for reply in results:
            if not reply.success:
                error_msg = reply.error if hasattr(reply, 'error') else "Unknown error"
                return {"success": False, "error": f"Kill failed: {error_msg}"}

        return {"success": True, "message": "Kill command sent"}

    except Exception as e:
        return {"success": False, "error": f"Exception: {str(e)}"}


def wait_for_window_close(sway_conn: i3ipc.Connection, container_id: int, timeout_ms: int = 500, poll_interval_ms: int = 50) -> tuple:
    """Poll Sway tree to verify window closed within timeout (Feature 059: T042).

    Args:
        sway_conn: Sway IPC connection
        container_id: Container ID of window to verify closure
        timeout_ms: Maximum time to wait for close (default: 500ms)
        poll_interval_ms: Time between polls (default: 50ms)

    Returns:
        Tuple of (closed: bool, duration_ms: int)
    """
    start_time = time.time()
    timeout_sec = timeout_ms / 1000.0
    poll_interval_sec = poll_interval_ms / 1000.0

    while (time.time() - start_time) < timeout_sec:
        tree = sway_conn.get_tree()
        window = tree.find_by_id(container_id)

        if window is None:
            # Window closed
            duration_ms = (time.time() - start_time) * 1000
            return True, duration_ms

        # Still exists, wait before next poll
        time.sleep(poll_interval_sec)

    # Timeout - window still exists
    return False, timeout_ms


def close_window_with_verification(sway_conn: i3ipc.Connection, container_id: int, timeout_ms: int = 500) -> dict:
    """Close window and verify it closed successfully (Feature 059: T043).

    Combines send_kill_command + wait_for_window_close for full verification workflow.

    Args:
        sway_conn: Sway IPC connection
        container_id: Container ID of window to close
        timeout_ms: Maximum time to wait for close verification (default: 500ms)

    Returns:
        Dict with keys:
            - success (bool): Whether window closed successfully
            - message (str): Success message
            - error (str | None): Error message if failed
            - warning (str | None): Warning message for timeout
            - close_duration_ms (int): Time taken to close
    """
    start_time = time.time()

    # Step 1: Validate window exists
    tree = sway_conn.get_tree()
    window = tree.find_by_id(container_id)

    if not window:
        return {
            "success": True,
            "message": "Window already closed",
            "close_duration_ms": 0
        }

    # Step 2: Send kill command
    kill_result = send_kill_command(sway_conn, container_id)
    if not kill_result["success"]:
        return {
            "success": False,
            "error": kill_result["error"],
            "close_duration_ms": 0
        }

    # Step 3: Wait for window to close
    remaining_timeout = timeout_ms - ((time.time() - start_time) * 1000)
    closed, duration_ms = wait_for_window_close(
        sway_conn,
        container_id,
        timeout_ms=int(remaining_timeout),
        poll_interval_ms=50
    )

    total_duration_ms = (time.time() - start_time) * 1000

    if closed:
        return {
            "success": True,
            "message": "Window closed successfully",
            "close_duration_ms": total_duration_ms
        }
    else:
        return {
            "success": False,
            "error": "Window did not close within timeout",
            "warning": "Application may have unsaved changes or be unresponsive",
            "close_duration_ms": total_duration_ms
        }


# Global selection manager and navigation handler for interactive workspace menu (Feature 059)
# Initialized after class definitions to avoid NameError
selection_manager = SelectionManager()
navigation_handler = NavigationHandler(selection_manager)


def subscribe_to_workspace_mode_events(renderer: PreviewRenderer) -> None:
    """Subscribe to i3pm workspace_mode events via IPC socket.

    Args:
        renderer: PreviewRenderer instance for querying workspace contents
    """
    if not DAEMON_IPC_SOCKET.exists():
        print(f"Error: i3pm daemon socket not found: {DAEMON_IPC_SOCKET}", file=sys.stderr)
        sys.exit(1)

    try:
        # Connect to i3pm daemon IPC socket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(str(DAEMON_IPC_SOCKET))

        # Subscribe to workspace_mode and project_mode events (JSON-RPC 2.0)
        # Option A: Unified Smart Detection - Subscribe to both event types
        subscribe_request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "subscribe",
            "params": {"event_types": ["workspace_mode", "project_mode"]},
        }
        sock.sendall((json.dumps(subscribe_request) + "\n").encode())

        # Read subscription response
        response = sock.recv(4096).decode().strip()
        response_data = json.loads(response)
        if "error" in response_data:
            print(f"Error: Failed to subscribe to events: {response_data['error']}", file=sys.stderr)
            sys.exit(1)

        print("DEBUG: Successfully subscribed to workspace_mode and project_mode events", file=sys.stderr, flush=True)

        # Event loop: read incoming workspace_mode events
        buffer = ""
        while True:
            chunk = sock.recv(4096).decode()
            if not chunk:
                print("DEBUG: Connection closed by daemon", file=sys.stderr)
                break

            buffer += chunk
            while "\n" in buffer:
                line, buffer = buffer.split("\n", 1)
                line = line.strip()
                if not line:
                    continue

                try:
                    event = json.loads(line)

                    # Check if this is a workspace_mode event
                    if event.get("method") == "event" and event.get("params", {}).get("type") == "workspace_mode":
                        payload = event.get("params", {}).get("payload", {})

                        # Parse event payload (raw dict, not Pydantic model)
                        event_type = payload.get("event_type")
                        pending = payload.get("pending_workspace")

                        print(f"DEBUG: Received workspace_mode event: type={event_type}, pending={pending}", file=sys.stderr, flush=True)

                        if event_type == "cancel":
                            # Feature 059: Clear selection state on mode exit
                            selection_manager.clear()
                            # Hide preview card
                            emit_preview(visible=False)
                        elif event_type == "execute":
                            # Feature 059: T028 - Execute selected item (workspace heading or window)
                            print(f"DEBUG: Execute event received, delegating to NavigationHandler", file=sys.stderr, flush=True)
                            # Call NavigationHandler to execute selection (with fallback to digit navigation)
                            navigation_handler.handle_enter_key_event(
                                mode="all_windows",
                                accumulated_digits=pending.get("accumulated_digits", "") if pending else ""
                            )
                        elif event_type == "enter":
                            # Feature 072: T016 - Show all windows preview on mode entry (User Story 1)
                            # T049: Performance logging for all_windows preview
                            start_time = time.time()

                            # Open Eww window (GTK creates window surface, appears in Sway tree)
                            eww_open_window("workspace-preview")

                            # Feature 059: T024 - Extract mode for move-mode styling
                            mode_type = payload.get("mode_type", "goto")  # Mode passed directly in enter event
                            if mode_type not in ("goto", "move"):
                                mode_type = "goto"  # Default to goto if invalid

                            # Call render_all_windows() to show complete window list grouped by workspace
                            all_windows_preview = renderer.render_all_windows()

                            # Feature 059: Initialize selection manager with workspace groups
                            workspace_groups = [
                                {
                                    "workspace_num": group.workspace_num,
                                    "workspace_name": group.workspace_name,
                                    "window_count": group.window_count,
                                    "monitor_output": group.monitor_output,
                                    "windows": [
                                        {
                                            "name": window.name,
                                            "icon_path": window.icon_path,
                                            "app_id": window.app_id,
                                            "window_class": window.window_class,
                                            "focused": window.focused,
                                            "workspace_num": window.workspace_num,
                                            "window_id": window.window_id,  # Sway container ID (Feature 059: now always present)
                                        }
                                        for window in group.windows
                                    ],
                                }
                                for group in all_windows_preview.workspace_groups
                            ]
                            selection_manager.initialize_from_workspace_groups(workspace_groups)

                            # Get selection state for JSON output
                            selection_state = selection_manager.get_selection_state()
                            selection_dict = {
                                "selected_index": selection_state.selected_index if selection_state else None,
                                "item_type": selection_state.item_type if selection_state else "workspace_heading",
                                "workspace_num": selection_state.workspace_num if selection_state else None,
                                "window_id": selection_state.window_id if selection_state else None,
                                "visible": selection_state.visible if selection_state else False,
                                "move_mode": mode_type == "move",  # Feature 059: T024 - Add move_mode boolean for CSS styling
                            }

                            # Convert AllWindowsPreview Pydantic model to dict for JSON output
                            output = {
                                "type": all_windows_preview.type,  # "all_windows"
                                "workspace_groups": workspace_groups,
                                "total_window_count": all_windows_preview.total_window_count,
                                "total_workspace_count": all_windows_preview.total_workspace_count,
                                "instructional": all_windows_preview.instructional,
                                "empty": all_windows_preview.empty,
                                "selection_state": selection_dict,  # Feature 059: Add selection state
                            }

                            # Feature 059: Cache preview data for arrow key navigation re-emission (T024: pass mode for move-mode styling)
                            navigation_handler.cache_preview_data(output, mode=mode_type)

                            print(json.dumps(output), flush=True)

                            # Also update Eww variable directly (deflisten isn't reliable)
                            try:
                                json_str = json.dumps(output)
                                result = subprocess.run(
                                    ["eww", "--config", str(EWW_CONFIG_DIR), "update", f"workspace_preview_data={json_str}"],
                                    check=False,
                                    capture_output=True,
                                    timeout=0.5,
                                    text=True,
                                )
                                if result.returncode != 0:
                                    print(f"WARNING: eww update failed with code {result.returncode}: {result.stderr}", file=sys.stderr, flush=True)
                                else:
                                    print(f"DEBUG: Updated Eww variable with {len(json_str)} chars", file=sys.stderr, flush=True)
                            except Exception as e:
                                print(f"WARNING: Failed to update Eww variable: {e}", file=sys.stderr, flush=True)

                            # DEBUG: Log the JSON being emitted for troubleshooting
                            print(f"DEBUG: Emitted all_windows JSON: groups={len(output['workspace_groups'])}, total_windows={output['total_window_count']}, empty={output['empty']}, instructional={output['instructional']}", file=sys.stderr, flush=True)
                            # DEBUG: Log workspace groups details
                            for i, group in enumerate(output['workspace_groups']):
                                print(f"DEBUG: Group {i}: WS {group['workspace_num']}, windows={len(group['windows'])}, names={[w['name'] for w in group['windows']]}", file=sys.stderr, flush=True)

                            # T049: Log performance timing if >150ms (User Story 1 target)
                            elapsed_ms = (time.time() - start_time) * 1000
                            if elapsed_ms > 150:
                                print(f"WARNING: All-windows preview took {elapsed_ms:.1f}ms (target: <150ms) with {all_windows_preview.total_window_count} windows", file=sys.stderr)
                        elif event_type == "nav":
                            # Feature 059: Handle arrow key navigation for interactive workspace menu
                            direction = payload.get("direction")
                            print(f"DEBUG: Received nav event: direction={direction}", file=sys.stderr, flush=True)

                            # Handle navigation using NavigationHandler (emits updated preview internally)
                            navigation_handler.handle_arrow_key_event(direction, mode="all_windows")

                        elif event_type == "delete":
                            # Feature 059: Handle Delete key to close selected window
                            print(f"DEBUG: Received delete event", file=sys.stderr, flush=True)

                            # Handle delete using NavigationHandler
                            navigation_handler.handle_delete_key_event(mode="all_windows")

                        elif event_type == "digit" and pending is not None:
                            # Feature 059: Reset selection when digits are typed (switches to filtered view)
                            selection_manager.reset_selection()

                            # Show/update preview card
                            emit_preview(
                                visible=True,
                                renderer=renderer,
                                workspace_num=pending.get("workspace_number"),
                                monitor_output=pending.get("target_output") or "eDP-1",
                                mode=pending.get("mode_type", "goto"),
                                accumulated_digits=pending.get("accumulated_digits", ""),
                            )
                        elif event_type == "digit" and pending is None:
                            # No pending state on digit event - hide preview
                            emit_preview(visible=False)

                    # Option A: Unified Smart Detection - Handle project_mode events
                    elif event.get("method") == "event" and event.get("params", {}).get("type") == "project_mode":
                        payload = event.get("params", {}).get("payload", {})

                        # Parse event payload
                        event_type = payload.get("event_type")
                        accumulated_chars = payload.get("accumulated_chars", "")
                        matched_project = payload.get("matched_project")
                        project_icon = payload.get("project_icon", "ðŸ“")

                        print(f"DEBUG: Received project_mode event: type={event_type}, chars={accumulated_chars}, match={matched_project}, icon={project_icon}", file=sys.stderr, flush=True)

                        if event_type == "cancel" or event_type == "execute":
                            # Hide preview card
                            emit_project_preview(visible=False)
                        elif event_type == "char":
                            # Show/update project preview
                            emit_project_preview(
                                visible=True,
                                accumulated_chars=accumulated_chars,
                                matched_project=matched_project,
                                project_icon=project_icon,
                            )
                        else:
                            # Unknown event type - hide preview
                            emit_project_preview(visible=False)

                    # Feature 059: Handle arrow_key_nav events for interactive workspace menu
                    elif event.get("method") == "event" and event.get("params", {}).get("type") == "arrow_key_nav":
                        payload = event.get("params", {}).get("payload", {})

                        # Parse event payload
                        direction = payload.get("direction")
                        mode = payload.get("mode", "all_windows")

                        print(f"DEBUG: Received arrow_key_nav event: direction={direction}, mode={mode}", file=sys.stderr, flush=True)

                        # Handle arrow key navigation
                        navigation_handler.handle_arrow_key_event(direction, mode)

                    # Feature 059: T029 - Handle enter_key_select events for workspace/window navigation
                    elif event.get("method") == "event" and event.get("params", {}).get("type") == "enter_key_select":
                        payload = event.get("params", {}).get("payload", {})

                        # Parse event payload
                        mode = payload.get("mode", "all_windows")
                        accumulated_digits = payload.get("accumulated_digits", "")

                        print(f"DEBUG: Received enter_key_select event: mode={mode}, digits={accumulated_digits}", file=sys.stderr, flush=True)

                        # Handle Enter key selection
                        navigation_handler.handle_enter_key_event(mode, accumulated_digits)

                    # Feature 059: T040 - Handle delete_key_close events for window close
                    elif event.get("method") == "event" and event.get("params", {}).get("type") == "delete_key_close":
                        payload = event.get("params", {}).get("payload", {})

                        # Parse event payload
                        mode = payload.get("mode", "all_windows")

                        print(f"DEBUG: Received delete_key_close event: mode={mode}", file=sys.stderr, flush=True)

                        # Handle Delete key window close
                        navigation_handler.handle_delete_key_event(mode)

                    # Feature 059: T059 - Handle home_key_nav events for jump to first item
                    elif event.get("method") == "event" and event.get("params", {}).get("type") == "home_key_nav":
                        payload = event.get("params", {}).get("payload", {})

                        # Parse event payload
                        mode = payload.get("mode", "all_windows")

                        print(f"DEBUG: Received home_key_nav event: mode={mode}", file=sys.stderr, flush=True)

                        # Handle Home key jump to first item
                        navigation_handler.handle_home_key_event(mode)

                    # Feature 059: T059 - Handle end_key_nav events for jump to last item
                    elif event.get("method") == "event" and event.get("params", {}).get("type") == "end_key_nav":
                        payload = event.get("params", {}).get("payload", {})

                        # Parse event payload
                        mode = payload.get("mode", "all_windows")

                        print(f"DEBUG: Received end_key_nav event: mode={mode}", file=sys.stderr, flush=True)

                        # Handle End key jump to last item
                        navigation_handler.handle_end_key_event(mode)

                except json.JSONDecodeError as e:
                    print(f"Warning: Failed to parse IPC message: {e}", file=sys.stderr)
                except Exception as e:
                    print(f"Warning: Failed to process workspace_mode event: {e}", file=sys.stderr)

    except Exception as e:
        print(f"Error in workspace_mode event subscription: {e}", file=sys.stderr)
        sys.exit(1)


def main() -> None:
    """Main entry point for workspace-preview-daemon."""
    # Set up signal handlers for clean shutdown
    def signal_handler(sig, frame):
        print("DEBUG: Received shutdown signal", file=sys.stderr)
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Initialize preview renderer
    renderer = PreviewRenderer()

    # Emit initial state (hidden)
    emit_preview(visible=False)

    # Subscribe to workspace_mode events
    print("DEBUG: Starting workspace-preview-daemon", file=sys.stderr, flush=True)
    subscribe_to_workspace_mode_events(renderer)


if __name__ == "__main__":
    main()
